Why does passing an unnamed function as transform to array add one to iteration count in playground in furthest abstractions
<p>I'm in the process of getting comfortable passing unnamed functions as arguments and I am using this to practice with, based off of the examples in <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/GuidedTour.html#//apple_ref/doc/uid/TP40014097-CH2-XID_1" rel="nofollow noreferrer">the Swift Programming Guide.</a></p> <p>So we have an array of <code>Int</code>s:</p> <pre><code>var numbers: Int[] = [1, 2, 3, 4, 5, 6, 7] </code></pre> <p>And I apply a transform like so: (7)</p> <pre><code>func transformNumber(number: Int) -&gt; Int { let result = number * 3 return result } numbers = numbers.map(transformNumber) </code></pre> <p>Which is equal to: (7)</p> <pre><code>numbers = numbers.map({(number: Int) -&gt; Int in let result = number * 3 return result; }) </code></pre> <p>Which is equal to: (8)</p> <pre><code>numbers = numbers.map({number in number * 3}) </code></pre> <p>Which is equal to: (8)</p> <pre><code>numbers = numbers.map({$0 * 3}) </code></pre> <p>Which is equal to: (8)</p> <pre><code>numbers = numbers.map() {$0 * 3} </code></pre> <p>As you can see in the following graphic, the iteration count in the playground sidebar shows that in the furthest abstraction of a function declaration, it has an 8 count. </p> <p><img src="https://i.stack.imgur.com/nc5Q0.png" alt="enter image description here"></p> <h3> Question </h3> <p>Why is it showing as 8 iterations for the last two examples? </p>
<p>It's not showing 8 iterations, really. It's showing that 8 things executed on that line. There were 7 executions as part of the <code>map</code> function, and an 8th to do the assignment back into the <code>numbers</code> variable.</p> <p>It looks like this could probably provide more helpful diagnostics. I would highly encourage you to provide feedback via <a href="https://bugreport.apple.com" rel="nofollow">https://bugreport.apple.com</a>.</p>
<p>Slightly rewriting your experiment to use only closures, the call counts still differ by one:</p> <p>Case 1: Explicitly specifying argument types (visit count is 7)</p> <pre><code>var f1 = {(number: Int) -&gt; Int in let result = number * 3 return result } numbers.map(f1) </code></pre> <p>Case 2: Implicit argument types (visit count is 8)</p> <pre><code>var f2 = {$0 * 3} numbers.map(f2) </code></pre> <p>If the (<code>x</code> times) count reported by the REPL does indeed represent a count of visits to that code location, and noting that the count is greater by one in cases where the closure type arguments are not explicitly specified (e.g. <code>f2</code>), my guess is that at least in the playground REPL, the extra visit is to establish actual parameter types and fill that gap in the underlying AST. </p>