What is the swift equivalent of respondsToSelector?
<p>I've googled but not been able to find out what the swift equivalent to respondsToSelector: is.</p> <p>This is the only thing I could find (<a href="http://stackoverflow.com/questions/24142906/swift-alternative-to-respondstoselector">Swift alternative to respondsToSelector:</a>) but isn't too relevant in my case as its checking the existence of the delegate, I don't have a delegate I just want to check if a new API exists or not when running on the device and if not fall back to a previous version of the api.</p>
<p>There is no real Swift replacement.</p> <p>You can check in the following way:</p> <pre><code>someObject.someMethod?() </code></pre> <p>This calls the method <code>someMethod</code> only if it's defined on object <code>someObject</code> but you can use it only for <code>@objc</code> protocols which have declared the method as <code>optional</code>.</p> <p>Swift is inherently a safe language so everytime you call a method Swift has to know the method is there. No runtime checking is possible. You can't just call random methods on random objects.</p> <p>Even in Obj-C you should avoid such things when possible because it doesn't play well with ARC (ARC then triggers warnings for <code>performSelector:</code>).</p> <p>However, when checking for available APIs, you can still use <code>respondsToSelector:</code>, even if Swift, if you are dealing with <code>NSObject</code> instances:</p> <pre><code>@interface TestA : NSObject - (void)someMethod; @end @implementation TestA //this triggers a warning @end </code></pre> <p><br></p> <pre><code>var a = TestA() if a.respondsToSelector("someMethod") { a.someMethod() } </code></pre>
<p>The equivalent is the ? operator:</p> <pre><code>var value: NSNumber? = myQuestionableObject?.importantMethod() </code></pre> <p>importantMethod will only be called if myQuestionableObject exists and implements it.</p>
<p>As mentioned, in Swift <strong>most of the time you can achieve what you need with the <code>?</code> optional unwrapper operator</strong>. This allows you to call a method on an object if and only if the object exists (not <code>nil</code>) and the method is implemented.</p> <p>In the case where you still need <code>respondsToSelector:</code>, it is still there as part of the <code>NSObject</code> protocol.</p> <p>If you are calling <code>respondsToSelector:</code> on an Obj-C type in Swift, then it works the same as you would expect. If you are using it on your own Swift class, you will need to ensure your class derives from <code>NSObject</code>.</p> <p>Here's an example of a Swift class that you can check if it responds to a selector:</p> <pre><code>class Worker : NSObject { func work() { } func eat(food: AnyObject) { } func sleep(hours: Int, minutes: Int) { } } let worker = Worker() let canWork = worker.respondsToSelector(Selector("work")) // true let canEat = worker.respondsToSelector(Selector("eat:")) // true let canSleep = worker.respondsToSelector(Selector("sleep:minutes:")) // true let canQuit = worker.respondsToSelector(Selector("quit")) // false </code></pre> <p>It is important that you do not leave out the parameter names. In this example, <code>Selector("sleep::")</code> is <strong>not</strong> the same as <code>Selector("sleep:minutes:")</code>.</p>
<p>If the method you are testing for is defined as an <em>optional method</em> in a <em>@objc</em> protocol (which sounds like your case), then use the <em>optional chaining</em> pattern as:</p> <pre><code>if let result = object.method?(args) { /* method exists, result assigned, use result */ } else { ... } </code></pre> <p>When the method is declare as returning <code>Void</code>, simply use:</p> <pre><code>if object.method?(args) { ... } </code></pre> <p>See:</p> <blockquote> <p>“Calling Methods Through Optional Chaining”<br> Excerpt From: Apple Inc. “The Swift Programming Language.”<br> iBooks. <a href="https://itun.es/us/jEUH0.l" rel="nofollow">https://itun.es/us/jEUH0.l</a></p> </blockquote>
<p>It seems you need to define your protocol as as subprotocol of NSObjectProtocol ... then you'll get respondsToSelector method</p> <pre><code>@objc protocol YourDelegate : NSObjectProtocol { func yourDelegateMethod(passObject: SomeObject) } </code></pre> <p>note that only specifying @objc was not enough. You should be also careful that the actual delegate is a subclass of NSObject - which in Swift might not be.</p>
<p>You can use the "if let" approach to test an optional protocol like this:</p> <pre><code>weak var delegate: SomeDelegateWithOptionals? func someMethod() { if let delegate = delegate { if let theMethod = delegate.theOptionalProtocolMethod? { theMethod() return } } // Reaching here means the delegate doesn't exist or doesn't respond to the optional method alternativeMethod() } </code></pre>
<p>Functions are first-class types in Swift, so you can check whether an optional function defined in a protocol has been implemented by comparing it to nil:</p> <pre><code>if (someObject.someMethod != nil) { someObject.someMethod!(someArgument) } else { // do something else } </code></pre>
<p>It seems that this issues is mainly about protocol's optional method.</p> <pre><code>@objc protocol MyClassDelegate { optional func optionalFunc() -&gt; Int } weak var deleagate: MyClassDelegate? // Call the method without Runtime Error // if delegate was nil or optionalFunc was note implemented. delegate?.optionalFunc?() // Call the method and get a returned value without Runetime Error. if let value = delegate?.optionalFunc?() { // Do something. } // Just check the method is implemented. if delegate?.optionalFunc != nil { // Do something. } </code></pre>
<p>I just implement this myself in a project, see code below. As mentions by @Christopher Pickslay it is important to remember that functions are first class citizens and can therefore be treated like optional variables.</p> <pre><code>@objc protocol ContactDetailsDelegate: class { optional func deleteContact(contact: Contact) -&gt; NSError? } ... weak var delegate:ContactDetailsDelegate! if let deleteContact = delegate.deleteContact { deleteContact(contact) } </code></pre>
<p>In Swift 2,Apple introduced a new feature called <code>API availability checking</code>, which might be a replacement for <code>respondsToSelector:</code> method.The following code snippet comparison is copied from the WWDC2015 Session 106 <a href="https://developer.apple.com/videos/wwdc/2015/?id=106">What's New in Swift</a> which I thought might help you,please check it out if you need to know more.</p> <blockquote> <p>The Old Approach:</p> </blockquote> <pre><code>@IBOutlet var dropButton: NSButton! override func awakeFromNib() { if dropButton.respondsToSelector("setSpringLoaded:") { dropButton.springLoaded = true } } </code></pre> <blockquote> <p>The Better Approach:</p> </blockquote> <pre><code>@IBOutlet var dropButton: NSButton! override func awakeFromNib() { if #available(OSX 10.10.3, *) { dropButton.springLoaded = true } } </code></pre>
<p>another possible syntax by swift..</p> <pre><code> if let delegate = self.delegate, method = delegate.somemethod{ method() } </code></pre>
<p>Currently (Swift 2.1) you can check it using 3 ways:</p> <ol> <li>Using <a href="http://stackoverflow.com/a/24168825/4260691">respondsToSelector</a> answered by @Erik_at_Digit</li> <li><p>Using <a href="http://stackoverflow.com/a/24167936/4260691">'?'</a> answered by @Sulthan</p></li> <li><p>And using <code>as?</code> operator:</p> <pre><code>if let delegateMe = self.delegate as? YourCustomViewController { delegateMe.onSuccess() } </code></pre></li> </ol> <p>Basically it depends on what you are trying to achieve:</p> <ul> <li>If for example your app logic need to perform some action and the delegate isn't set or the pointed delegate didn't implement the onSuccess() method (protocol method) so option 1 and 3 are the best choice, though I'd use option 3 which is Swift way.</li> <li>If you don't want to do anything when delegate is nil or method isn't implemented then use option 2.</li> </ul>
<p>I use <code>guard let else</code>, so that can do some default stuff if the delegate func is not implemented.</p> <pre><code>@objc protocol ViewController2Delegate: NSObjectProtocol { optional func viewController2(controller: ViewController2, didSomethingWithStringAndReturnVoid string: String) optional func viewController2(controller: ViewController2, didSomethingWithStringAndReturnString string: String) -&gt; String } class ViewController2: UIViewController { weak var delegate: ViewController2Delegate? @IBAction func onVoidButtonClicked(sender: AnyObject){ if (delegate != nil &amp;&amp; delegate!.respondsToSelector(Selector("viewController2:didSomethingWithStringAndReturnVoid:"))) { NSLog("ReturnVoid is implemented") delegate!.viewController2!(self, didSomethingWithStringAndReturnVoid: "dummy") } else{ NSLog("ReturnVoid is not implemented") // Do something by default } } @IBAction func onStringButtonClicked(sender: AnyObject){ guard let result = delegate?.viewController2?(self, didSomethingWithStringAndReturnString: "dummy") else { NSLog("ReturnString is not implemented") // Do something by default return } NSLog("ReturnString is implemented with result: \(result)") } } </code></pre>
<p>For swift 3.0</p> <pre><code>import UIKit @objc protocol ADelegate : NSObjectProtocol { @objc optional func hi1() @objc optional func hi2(message1:String, message2:String) } class SomeObject : NSObject { weak var delegate:ADelegate? func run() { // single method if delegate != nil &amp;&amp; delegate!.responds(to: #selector(ADelegate.hi1)) { delegate?.hi1!() } else { print("fail h1") } // multiple parameters if delegate != nil &amp;&amp; delegate!.responds(to: #selector(ADelegate.hi2(message1:message2:))) { delegate?.hi2!(message1: "superman", message2: "batman") } else { print("fail h2") } } } class ViewController: UIViewController, ADelegate { let someObject = SomeObject() override func viewDidLoad() { super.viewDidLoad() someObject.delegate = self someObject.run() } // MARK: ADelegate func hi1() { print("Hi") } func hi2(message1: String, message2: String) { print("Hi \(message1) \(message2)") } } </code></pre>