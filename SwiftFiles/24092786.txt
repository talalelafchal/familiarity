Using dispatch_async with self
<p>I have run into this problem a few times while porting Objective-C code to Swift. Say I have the following code:</p> <pre><code>dispatch_async(dispatch_get_main_queue()) { self.hostViewController?.view.addSubview(self.commandField) } </code></pre> <p>This will result in an error, underlining the entire <code>dispatch_async</code> call, offering:</p> <pre><code>Could not find member 'addSubview' </code></pre> <p>I assume this is an error that has not yet been properly implemented because if I put the <code>addSubview</code> call outside the <code>dispatch_async</code> block, the project builds fine. Initially I assumed it may have something to do with capturing <code>self</code> in the block. However, inserting <code>[unowned self] in</code> results in the same error, as does <code>[weak self] in</code> (after the appropriate <code>!</code> unwrap operators have been inserted).</p> <p>How can I get <code>dispatch_async</code> blocks to work in Swift that need to capture <code>self</code>?</p>
<p>You should condition spinning off this action on the non-nullity, not test for it after you've already initiated it:</p> <pre><code>if let hostView = self.hostViewController?.view { dispatch_async(dispatch_get_main_queue()) { hostView.addSubview(self.commandField) } } else { // handle nil hostView } </code></pre> <p>You should never unwrap an optional outside of an <code>if let</code>, or testing it first. Doing this should also resolve yer weak self issue.</p>
<p>The <code>dispatch_async</code> syntax has changed with Swift 3:</p> <pre><code>DispatchQueue.main.async { hostView.addSubview(self.commandField) } </code></pre>