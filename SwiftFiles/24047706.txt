Why is forwarding variadic parameters invalid?
<p>Consider the variadic function parameter:</p> <pre><code>func foo(bar:Int...) -&gt; () { } </code></pre> <p>Here <code>foo</code> can accept multiple arguments, eg <code>foo(5,4)</code>. I am curious about the type of <code>Int...</code> and its supported operations. For example, why is this invalid?</p> <pre><code>func foo2(bar2:Int...) -&gt; () { foo(bar2); } </code></pre> <p>Gives a error:</p> <blockquote> <p>Could not find an overload for '_conversion' that accepts the supplied arguments</p> </blockquote> <p>Why is forwarding variadic parameters invalid?</p> <p>What is the "conversion" the compiler is complaining about?</p>
<p>When you call <code>foo</code>, the compiler expects a series of arguments, each of which must be an <code>Int</code>.</p> <p>In the body of <code>foo2</code>, <code>bar2</code> summarises all the passed arguments and actually has the type <code>Int[]</code> for all practical purposes. Thus, you cannot pass it directly to <code>foo</code> â€” as <code>foo</code> wants <code>Int</code> arguments, and not an <code>Int[]</code>.</p> <p>As for a solution to this: see my answer to <a href="http://stackoverflow.com/questions/24046142/how-to-forward-functions-with-variadic-parameters">this question</a>.</p>
<p>You can forward a variadic argument but the function you forward it to has to be defined with a parameter that is an array, not a variadic. So write your foo function as </p> <pre><code>func foo(bar:[Int]) -&gt; () { } </code></pre> <p>and it works.</p>