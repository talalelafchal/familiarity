Why can't Swift initializers call convenience initializers on their superclass?
<p>Consider the two classes:</p> <pre><code>class A { var x: Int init(x: Int) { self.x = x } convenience init() { self.init(x: 0) } } class B: A { init() { super.init() // Error: Must call a designated initializer of the superclass 'A' } } </code></pre> <p>I don't see why this isn't allowed. Ultimately, each class's designated initializer is called with any values they need, so why do I need to repeat myself in <code>B</code>'s <code>init</code> by specifying a default value for <code>x</code> again, when the convenience <code>init</code> in <code>A</code> will do just fine?</p>
<p>This is Rule 1 of the "Initializer Chaining" rules as specified in the Swift Programming Guide, which reads:</p> <blockquote> <p>Rule 1: <strong>Designated</strong> initializers must call a <strong>designated</strong> initializer from their immediate superclass.</p> </blockquote> <p><a href="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Initialization.html" rel="nofollow noreferrer">https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Initialization.html</a></p> <p>Emphasis mine. Designated initializers cannot call convenience initializers.</p> <p>There is a diagram that goes along with the rules to demonstrate what initializer "directions" are allowed:</p> <p><img src="https://i.stack.imgur.com/fPmUU.png" alt="Initializer Chaining"></p>
<p>Look at the WWDC-video "403 intermediate Swift" at 18:30 for an in depth explanation of initializers and their inheritance. As I understood it, consider the following:</p> <pre><code>class Dragon { var legs: Int var isFlying: Bool init(legs: Int, isFlying: Bool) { self.legs = legs self.isFlying = isFlying } convenience initWyvern() { self.init(legs: 2, isFlying: true) } } </code></pre> <p>But now consider a Wyrm-subclass: A Wyrm is a Dragon with no legs and no wings. So the Initializer for a Wyvern (2 legs, 2 wings) is wrong for it! That error can be avoided if the convenience Wyvern-Initializer simply can't be called but only the full designated Initializer:</p> <pre><code>class Wyrm: Dragon { init() { super.init(legs: 0, isFlying: false) } } </code></pre>
<p>Consider</p> <pre><code>class A { var a: Int var b: Int init (a: Int, b: Int) { print("Entering A.init(a,b)") self.a = a; self.b = b } convenience init(a: Int) { print("Entering A.init(a)") self.init(a: a, b: 0) } convenience init() { print("Entering A.init()") self.init(a:0) } } class B : A { var c: Int override init(a: Int, b: Int) { print("Entering B.init(a,b)") self.c = 0; super.init(a: a, b: b) } } var b = B() </code></pre> <p>Because all designated initializers of class A are overridden, class B will inherit all convenience initializers of A. So executing this will output</p> <pre><code>Entering A.init() Entering A.init(a:) Entering B.init(a:,b:) Entering A.init(a:,b:) </code></pre> <p>Now, if the designated initializer B.init(a:b:) would be allowed to call the base class convenience initializer A.init(a:), this would result in a recursive call to B.init(a:,b:).</p>
<p>I found a work around for this. It's not super pretty, but it solves the problem of not knowing a superclass's values or wanting to set default values. <br><br> All you have to do is create an instance of the superclass, using the convenience <code>init</code>, right in the <code>init</code> of the subclass. Then you call the designated <code>init</code> of the super using the instance you just created.</p> <pre><code>class A { var x: Int init(x: Int) { self.x = x } convenience init() { self.init(x: 0) } } class B: A { init() { // calls A's convenience init, gets instance of A with default x value let intermediate = A() super.init(x: intermediate.x) } } </code></pre>
<p>Why don't you just have two initializers - one with a default value? </p> <pre><code>class A { var x: Int init(x: Int) { self.x = x } init() { self.x = 0 } } class B: A { override init() { super.init() // Do something else } } let s = B() s.x // 0 </code></pre>