Class conforming to protocol as function parameter in Swift
<p>In Objective-C, it's possible to specify a class conforming to a protocol as a method parameter. For example, I could have a method that only allows a <code>UIViewController</code> that conforms to <code>UITableViewDataSource</code>:</p> <pre><code>- (void)foo:(UIViewController&lt;UITableViewDataSource&gt; *)vc; </code></pre> <p>I can't find a way to do this in Swift (perhaps it's not possible yet). You can specify multiple protocols using <code>func foo(obj: protocol&lt;P1, P2&gt;)</code>, but how do you require that the object is of a particular class as well?</p>
<p>You can define <code>foo</code> as a generic function and use type constraints to require both a class and a protocol.</p> <pre><code>func foo&lt;T: UIViewController where T: UITableViewDataSource&gt;(vc: T) { // access UIViewController property let view = vc.view // call UITableViewDataSource method let sections = vc.numberOfSectionsInTableView?(tableView) } </code></pre>
<p>The Swift book documentation suggests that you use type constraints with a where clause:</p> <pre><code>func someFunction&lt;C1: SomeClass where C1:SomeProtocol&gt;(inParam: C1) {} </code></pre> <p>This guarantees that "inParam" is of type "SomeClass" with a condition that it also adheres to "SomeProtocol". You even have the power to specify multiple where clauses delimited by a comma:</p> <pre><code>func itemsMatch&lt;C1: SomeProtocol, C2: SomeProtocol where C1.ItemType == C2.ItemType, C1.ItemType: SomeOtherProtocol&gt;(foo: C1, bar: C2) -&gt; Bool { return true } </code></pre>
<p><strong>Note in September 2015</strong>: This was an observation in the early days of Swift.</p> <p>It seems to be impossible. Apple has this annoyance in some of their APIs as well. Here is one example from a newly introduced class in iOS 8 (as of beta 5):</p> <p><code>UIInputViewController</code>'s <code>textDocumentProxy</code> property:</p> <p>Defined in Objective-C as follows:</p> <pre><code>@property(nonatomic, readonly) NSObject&lt;UITextDocumentProxy&gt; *textDocumentProxy; </code></pre> <p>and in Swift:</p> <pre><code>var textDocumentProxy: NSObject! { get } </code></pre> <p>Link to Apple' documentation: <a href="https://developer.apple.com/library/prerelease/iOS/documentation/UIKit/Reference/UIInputViewController_Class/index.html#//apple_ref/occ/instp/UIInputViewController/textDocumentProxy" rel="nofollow">https://developer.apple.com/library/prerelease/iOS/documentation/UIKit/Reference/UIInputViewController_Class/index.html#//apple_ref/occ/instp/UIInputViewController/textDocumentProxy</a></p>
<p>With Swift 3, you can do the following:</p> <pre><code>func foo(_ dataSource: UITableViewDataSource) { self.tableView.dataSource = dataSource } func foo(_ delegateAndDataSource: UITableViewDelegate &amp; UITableViewDataSource) { //Whatever } </code></pre>