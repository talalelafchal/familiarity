Why does a function call require the parameter name in Swift?
<p>I have this Function in a class:</p> <pre><code>func multiply(factor1:Int, factor2:Int) -&gt; Int{ return factor1 * factor2 } </code></pre> <p>I try to call the function using this:</p> <pre><code>var multResult = calculator.multiply(9834, 2321) </code></pre> <p>The problem is that the compiler wants it to look more like this:</p> <pre><code>var multResult = calculator.multiply(9834, factor2: 2321) </code></pre> <p>Why does the first one cause an error? </p>
<p><strong>Update for Swift 2.0</strong>: Now functions behave identically to methods, and for both, by default:</p> <ul> <li>the first parameter has no external name; and</li> <li>the other parameters have an external name identical to the internal name.</li> </ul> <p>Other than that, the rules below still apply, except that the <code>#</code> shorthand syntax is now gone.</p> <hr> <p>Here's a more general answer: functions behave differently when defined as true functions outside a class, and when defined as methods. Moreover, init methods have a special rule.</p> <hr> <h2>Functions</h2> <p>Suppose you define this:</p> <pre><code>func multiply1(f1: Double, f2: Double) -&gt; Double { return f1 * f2 } </code></pre> <p>Parameter names are here only <strong>local</strong> to the function, and cannot be used when calling the function:</p> <pre><code>multiply1(10.0, 10.0) </code></pre> <p>If you want to force using named parameters when calling the function, you can. Prefix each parameter declaration with its <strong>external</strong> name. Here, the external name of <code>f1</code> is <code>f1param</code>, and for <code>f2</code>, we use the shorthand where we prefix it by <code>#</code> to indicate that the local name is to be used as the external name as well:</p> <pre><code>func multiply2(f1param f1: Double, #f2: Double) -&gt; Double { return f1 * f2 } </code></pre> <p>Then, named parameters must be used:</p> <pre><code>multiply2(f1param: 10.0, f2: 10.0) </code></pre> <hr> <h2>Methods</h2> <p>Things are different for methods. By default, all but the first parameter are named, as you've discovered. Suppose we have this, and consider the <code>multiply1</code> method:</p> <pre><code>class Calc { func multiply1(f1: Double, f2: Double) -&gt; Double { return f1 * f2 } func multiply2(f1param f1: Double, f2: Double) -&gt; Double { return f1 * f2 } func multiply3(f1: Double, _ f2: Double) -&gt; Double { return f1 * f2 } } </code></pre> <p>Then, you have to use the name of the second (and following, if any) parameters:</p> <pre><code>let calc = Calc() calc.multiply1(1.0, f2: 10.0) </code></pre> <p>You can force to use a named param for the first argument by providing an external name for it, like for functions (or prefixing its local name with <code>#</code> if you want to use the same external name as its local name). Then, you have to use it:</p> <pre><code>calc.multiply2(f1param: 10.0, f2: 10.0) </code></pre> <p>Finally, you can declare an external name of <code>_</code> for the other following arguments, indicating that you want to call your method without using named parameters, like this:</p> <pre><code>calc.multiply3(10.0, 10.0) </code></pre> <p><strong><em>Interoperability note:</strong> If you prefix <code>class Calc</code> with the <code>@objc</code> annotation, then you can use it from Objective-C code, and it is equivalent to this declaration (look at parameter names):</em></p> <pre><code>@interface Calc - (double)multiply1:(double)f1 f2:(double)f2; - (double)multiply2WithF1param:(double)f1 f2:(double)f2; - (double)multiply3:(double)f1 :(double)f2; @end </code></pre> <hr> <h3>Init Methods</h3> <p>The rule differs a bit for <code>init</code> methods, where all parameters have an external name by default. For instance, this works:</p> <pre><code>class Calc { init(start: Int) {} init(_ start: String) {} } let c1 = Calc(start: 6) let c2 = Calc("6") </code></pre> <p>Here, you have to specify <code>start:</code> for the overload that accepts an <code>Int</code>, but you must omit it for the overload that accepts a <code>String</code>.</p> <p><strong><em>Interoperability note:</strong> this class would get exported to Objective-C like this:</em></p> <pre><code>@interface Calc - (instancetype)initWithStart:(NSInteger)start __attribute__((objc_designated_initializer)); - (instancetype)init:(NSString *)start __attribute__((objc_designated_initializer)); @end </code></pre> <hr> <h2>Closures</h2> <p>Assume you define a closure type like this:</p> <pre><code>typealias FancyFunction = (f1: Double, f2: Double) -&gt; Double </code></pre> <p>The parameter names will behave very similar to those in a method. You will have to provide the names to the parameters when calling the closure unless you explicitly set the external name to _.</p> <p>For example, executing the closure:</p> <pre><code>fund doSomethingInteresting(withFunction: FancyFunction) { withFunction(f1: 1.0, f2: 3.0) } </code></pre> <hr> <p>As a rule of thumb: even if you dislike them, you should probably try to keep using named parameters at least whenever two parameters have the same type, in order to disambiguate them. I'd also argue that it's good to also name at least all <code>Int</code> and <code>Boolean</code> parameters.</p>
<p>Because your "multiply" function is a method, and like Objective-c, the parameters in methods are part of the name.</p> <p>For example you can do this.</p> <pre><code>class Calculator { func multiply(factor1:Int, factor2:Int) -&gt; Int{ return factor1 * factor2 } func multiply(factor1:Int, factor2:Int, factor3:Int) -&gt; Int{ return factor1 * factor2 * factor3 } } </code></pre> <p>Here there are two different methods, with different names, multiply(factor2) and multiply(factor2 factor3).</p> <p>This rule only apply to methods, if you declare this like a functions outside of a class, then the function call don't require parameter name.</p>
<p>since you used <code>calculator.multiply()</code> in the example code I'm assuming this function is a method of the <code>calculator</code> object.</p> <p>Swift inherits a lot of things from objective-c and this is one of them:</p> <p>When in objective-c you would do (hypothetically):</p> <pre><code>[calculator multiply:@9834 factor2:@2321]; </code></pre> <p>the <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Methods.html" rel="nofollow">equivalent in Swift</a> is:</p> <pre><code>calculator.multiply(9834, factor2:2321); </code></pre>
<p>The reason is historical. This is how it worked in Smalltalk and it survived into its descendants. Squeak, <a href="https://scratch.mit.edu/" rel="nofollow noreferrer">Scratch</a>, <a href="https://developers.google.com/blockly/" rel="nofollow noreferrer">Blockly</a>, Objective C and Swift.</p> <p>The kiddy languages (Squeak, Scratch and Blockly) held to it, because beginning programmers tend to struggle with the arity and parameter order. That was the original reason why Smalltalk did it that way. I do not know why ObjC and Swift decided to adopt the convention, but they did.</p> <p><a href="https://i.stack.imgur.com/8v32d.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/8v32d.png" alt="Scratch example program"></a></p>
<p>The parameter names in the function call are called keyword names, and they are trace their roots back to the Smalltalk language.</p> <p>Classes and objects are often re-used from somewhere else, or form part of very large complex systems, and will not have active maintenance attention for long periods at a time.</p> <p>Improving the clarity and legibility of the code is very important in these situations, as code often ends up as the only documentation, when developers are under deadline pressure.</p> <p>Giving each parameter a descriptive keyword name allows maintainers to quickly see what the purpose of a function call by glancing at the function call, as opposed to delving deeper into the function code itself. It makes the implied meaning of the parameters explicit.</p> <p>The latest language to adopt keyword names for parameters in function calls is <a href="https://www.rust-lang.org/" rel="nofollow">Rust (link)</a> - described as "a systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety."</p> <p>High uptime systems require greater code quality. Keyword names allow development and maintenance teams much more opportunity to avoid <em>and</em> to catch errors from sending the wrong parameter, or calling parameters out of order.</p> <p>They can be wordy or terse, but Smalltalkers prefer wordy and descriptive to terse and meaningless. They can afford to be, because their IDE will do the bulk of such typing for them.</p>
<p>A note about passing in a method as an argument that returns no value: </p> <pre><code>func refresh(obj:Obj, _ method: (Obj)-&gt;Void = setValue) { method(element) } func setValue(obj:Obj){ obj.value = "someValue" } refresh(someObj,setValue) </code></pre>