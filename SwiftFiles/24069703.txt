How to define category bit mask enumeration for SpriteKit in Swift?
<p>To define a category bit mask enum in Objective-C I used to type:</p> <pre><code>typedef NS_OPTIONS(NSUInteger, CollisionCategory) { CollisionCategoryPlayerSpaceship = 0, CollisionCategoryEnemySpaceship = 1 &lt;&lt; 0, CollisionCategoryChickenSpaceship = 1 &lt;&lt; 1, }; </code></pre> <p>How can I achieve the same using <code>Swift</code>? I experimented with enumerations but can't get it working. Here is what I tried so far.</p> <p><img src="https://i.stack.imgur.com/6cMHI.png" alt="error screenshot"></p>
<p>Try casting your cases as UInt. </p> <pre><code>enum CollisionCategory: UInt{ case PlayerSpaceship = 0 case EnemySpaceship = UInt(1 &lt;&lt; 0) case PlayerMissile = UInt(1 &lt;&lt; 1) case EnemyMissile = UInt(1 &lt;&lt; 2) } </code></pre> <p>This gets rid of the errors for me.</p>
<p>What you could do is use the binary literals: <code>0b1</code>, <code>0b10</code>, <code>0b100</code>, etc.</p> <p>However, in Swift you cannot bitwise-OR enums, so there is really no point in using bitmasks in enums. Check out <a href="http://stackoverflow.com/questions/24066170/swift-ns-options-style-bitmask-enumerations/24066171">this question</a> for a replacement for NS_OPTION.</p>
<p>There is a bit of a bug with UInt, but given I think only 32 bits are used anyway this would work. I would also suggest submitting a radar, you should be able to use any constant value (1 &lt;&lt; 2 will always be the same)</p> <p>Anyway, here's once they've got rid of the bugs with UInts, this would work</p> <p>enum CollisionCategory: Int{ case PlayerSpaceship = 0, EnemySpaceShip, PlayerMissile, EnemyMissile</p> <pre><code>func collisionMask()-&gt;Int{ switch self{ case .PlayerSpaceship: return 0; default: return 1 &lt;&lt; (self.toRaw()-1) } } } CollisionCategory.PlayerMissle.collisionMask() </code></pre>
<p>Take a look at the AdvertureBuilding SpriteKit game. They rebuilt it in Swift and you can download the source on the iOS8 dev site. </p> <p>They are using the following method of creating an enum:</p> <pre><code>enum ColliderType: UInt32 { case Hero = 1 case GoblinOrBoss = 2 case Projectile = 4 case Wall = 8 case Cave = 16 } </code></pre> <p>And the setup is like this</p> <pre><code> physicsBody.categoryBitMask = ColliderType.Cave.toRaw() physicsBody.collisionBitMask = ColliderType.Projectile.toRaw() | ColliderType.Hero.toRaw() physicsBody.contactTestBitMask = ColliderType.Projectile.toRaw() </code></pre> <p>And check like this:</p> <pre><code> func didBeginContact(contact: SKPhysicsContact) { // Check for Projectile if contact.bodyA.categoryBitMask &amp; 4 &gt; 0 || contact.bodyB.categoryBitMask &amp; 4 &gt; 0 { let projectile = (contact.bodyA.categoryBitMask &amp; 4) &gt; 0 ? contact.bodyA.node : contact.bodyB.node } } </code></pre>
<p>An easy way to handle the bitmasks in swift is to create an enum of type UInt32 containing all your different collision types. That is</p> <pre><code>enum ColliderType: UInt32 { case Player = 1 case Attacker = 2 } </code></pre> <p>And then in your <strong>Player Class</strong> add a physics body and setup the collision detection</p> <pre><code>physicsBody = SKPhysicsBody(rectangleOfSize: CGSizeMake(size.width, size.height)) physicsBody.categoryBitMask = ColliderType.Player.toRaw() physicsBody.contactTestBitMask = ColliderType.Attacker.toRaw() physicsBody.collisionBitMask = ColliderType.Attacker.toRaw() </code></pre> <p>And for your <strong>Attacker Class</strong> (or projectile, bird, meteor, etc.) setup its physics body as</p> <pre><code>physicsBody = SKPhysicsBody(circleOfRadius: size.width / 2) physicsBody.categoryBitMask = ColliderType.Attacker.toRaw() physicsBody.contactTestBitMask = ColliderType.Player.toRaw() physicsBody.collisionBitMask = ColliderType.Player.toRaw() </code></pre> <p>(Note that you can setup the physics body to be whatever shape you want)</p> <p>Then make sure you have a <code>SKPhysicsContactDelegate</code> setup (e.g. you can let your scene be the delegate) and then implement the <em>optional</em> protocol method <code>didBeginContact</code></p> <pre><code>class GameScene: SKScene, SKPhysicsContactDelegate { override func didMoveToView(view: SKView) { physicsWorld.contactDelegate = self // Additional setup... } func didBeginContact(contact: SKPhysicsContact!) { println("A collision was detected!") if (contact.bodyA.categoryBitMask == ColliderType.Player.toRaw() &amp;&amp; contact.bodyB.categoryBitMask == ColliderType.Attacker.toRaw()) { println("The collision was between the Player and the Attacker") } } } </code></pre> <p>By adding more ColliderTypes you can detect more collisions in your game.</p>
<p>As noted by, user949350 you can use literal values instead. But what he forgot to point out is that your raw value should be in "squares". Notice how the sample of code of Apple enumerates the categories. They are 1, 2, 4, 8 and 16, instead of the usual 1, 2, 3, 4 , 5 etc.</p> <p>So in your code it should be something like this:</p> <pre><code>enum CollisionCategory:UInt32 { case PlayerSpaceShip = 1, case EnemySpaceShip = 2, case ChickenSpaceShip = 4, </code></pre> <p>}</p> <p>And if you want your player node to collide with either enemy or chicken spaceship, for example, you can do something like this:</p> <pre><code>playerNode.physicsBody.collisionBitMask = CollisionCategory.EnemySpaceShip.toRaw() | CollisionCategory.ChickenSpaceShip.toRaw() </code></pre>
<p>If you look at <a href="http://www.raywenderlich.com/84434/sprite-kit-swift-tutorial-beginners">this swift tutorial</a>, you can avoid the whole toRaw() or rawValue conversion by using:</p> <pre><code>struct PhysicsCategory { static let None : UInt32 = 0 static let All : UInt32 = UInt32.max static let Monster : UInt32 = 0b1 // 1 static let Projectile: UInt32 = 0b10 // 2 } monster.physicsBody?.categoryBitMask = PhysicsCategory.Monster monster.physicsBody?.contactTestBitMask = PhysicsCategory.Projectile monster.physicsBody?.collisionBitMask = PhysicsCategory.None </code></pre>