Programatically get path to Application Support folder
<p>I'm trying to get an NSString for the user's Application Support folder.</p> <p>I know I can do <code>NSString *path = @"~/Library/Application Support";</code> but this doesn't seem very elegant. I've played around with using <code>NSSearchPathForDirectoriesInDomains</code> but it seems to be quite long-winded and creates several unnecessary objects (at least, my implementation of it does).</p> <p>Is there a simple way to do this?</p>
<p>Best practice is to use <code>NSSearchPathForDirectoriesInDomains</code> with <code>NSApplicationSupportDirectory</code> as "long winded" as it may be.</p> <p>Example:</p> <pre><code>NSArray *paths = NSSearchPathForDirectoriesInDomains(NSApplicationSupportDirectory, NSUserDomainMask, YES); NSString *applicationSupportDirectory = [paths firstObject]; NSLog(@"applicationSupportDirectory: '%@'", applicationSupportDirectory); </code></pre> <p>NSLog output:</p> <pre><code>applicationSupportDirectory: '/Volumes/User/me/Library/Application Support' </code></pre>
<p>This is what I use to get the database. Got it from the Stanford class. It might help somebody.</p> <pre><code>NSURL *url = [[[NSFileManager URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask] lastObject]; url = [url URLByAppendingPathComponent:@"database_name"]; NSLog(@"Database URL: %@",url); </code></pre>
<p>Just to be sure people will start using the recommended way of doing this:</p> <pre><code>- (NSArray&lt;NSURL *&gt; * _Nonnull)URLsForDirectory:(NSSearchPathDirectory)directory inDomains:(NSSearchPathDomainMask)domainMask </code></pre> <p>Expanded example from documentation:</p> <pre><code>- (NSURL*)applicationDataDirectory { NSFileManager* sharedFM = [NSFileManager defaultManager]; NSArray* possibleURLs = [sharedFM URLsForDirectory:NSApplicationSupportDirectory inDomains:NSUserDomainMask]; NSURL* appSupportDir = nil; NSURL* appDirectory = nil; if ([possibleURLs count] &gt;= 1) { // Use the first directory (if multiple are returned) appSupportDir = [possibleURLs objectAtIndex:0]; } // If a valid app support directory exists, add the // app's bundle ID to it to specify the final directory. if (appSupportDir) { NSString* appBundleID = [[NSBundle mainBundle] bundleIdentifier]; appDirectory = [appSupportDir URLByAppendingPathComponent:appBundleID]; } return appDirectory; } </code></pre> <p>Proof link: <a href="https://developer.apple.com/library/ios/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/AccessingFilesandDirectories/AccessingFilesandDirectories.html#//apple_ref/doc/uid/TP40010672-CH3-SW3">https://developer.apple.com/library/ios/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/AccessingFilesandDirectories/AccessingFilesandDirectories.html#//apple_ref/doc/uid/TP40010672-CH3-SW3</a></p>
<p><strong>Swift:</strong></p> <pre><code>print(NSHomeDirectory()) </code></pre> <p>or</p> <pre><code>print(NSFileManager.defaultManager().URLsForDirectory(.ApplicationSupportDirectory, inDomains: .UserDomainMask)[0]) </code></pre> <p>and</p> <pre><code>let yourString = String(NSFileManager.defaultManager().URLsForDirectory(.ApplicationSupportDirectory, inDomains: .UserDomainMask)[0]) </code></pre>
<p>This works for me:</p> <pre><code>NSError *error; NSURL* appSupportDir = [[NSFileManager defaultManager] URLForDirectory:NSApplicationSupportDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:YES error:&amp;error]; </code></pre>
<p>Create separate objective C class for reading and writing into documents directory. I will avoid code re-writing. Below is my version of it.</p> <pre><code>//Directory.h #import &lt;Foundation/Foundation.h&gt; #import &lt;UIKit/UIKit.h&gt; #define PATH (NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)) #define BASEPATH (([PATH count] &gt; 0)? [PATH objectAtIndex:0] : nil) @interface DocumentsDirectory : NSObject //Here you can also use URL path as return type and file path. +(void)removeFilesfromDocumentsDirectory:(NSString*)filename; +(NSString*)writeFiletoDocumentsDirectory:(NSString*)filename; @end #import "Directory.h" @implementation DocumentsDirectory UIAlertView *updateAlert; +(void)removeFilesfromDocumentsDirectory:(NSString*)filename { NSFileManager *fileManager = [NSFileManager defaultManager]; NSString *filePath = [BASEPATH stringByAppendingPathComponent:filename]; NSError *error; BOOL success = [fileManager removeItemAtPath:filePath error:&amp;error]; //Remove or delete file from documents directory. if (success) { updateAlert= [[UIAlertView alloc] initWithTitle:@"Congratulations:" message:@"File is updated successfully" delegate:self cancelButtonTitle:@"OK" otherButtonTitles:nil]; [updateAlert show]; } else { NSLog(@"Could not delete file -:%@ ",[error localizedDescription]); updateAlert= [[UIAlertView alloc] initWithTitle:@"Try again:" message:[error localizedDescription] delegate:self cancelButtonTitle:@"OK" otherButtonTitles:nil]; [updateAlert show]; } } +(NSString*)writeFiletoDocumentsDirectory:(NSString*)filename { NSString *foldDestination = BASEPATH; NSString *filePath = [foldDestination stringByAppendingPathComponent:filename]; return filePath; } @end </code></pre>
<p><strong>Swift 3:</strong></p> <pre><code>FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask).first </code></pre>