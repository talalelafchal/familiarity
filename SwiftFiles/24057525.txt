Swift native base class or NSObject
<p>I tested out some <a href="http://stackoverflow.com/q/24050500/404201">isa swizzling</a> with Swift, and found that it only works when NSObject is a super-class (directly or further up), or by using the '@objc' decoration. Otherwise it will follow a static- and vtable-dispatch style, like C++. </p> <p>Is it normal to define a Swift class without a Cocoa/NSObject base class? If it is I'm concerned this means foregoing much of the dynamism of Objective-C, such as method interception and run-time introspection. </p> <p>Dynamic run-time behavior sits at the heart of features like property observers, Core Data, <a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">Aspect Oriented Programming</a>, <a href="http://en.wikipedia.org/wiki/Higher_order_message">Higher Order Messaging</a>, analytical &amp; logging frameworks and so on. </p> <p>Using Objective-C's style of method invocation adds around 20 machine code operands to a method call, so in certain situations (<em>many tight calls to methods with small bodies</em>) C++ style static and vtable dispatch can perform better. </p> <p>But given the general 95-5 rule (<em>95% of performance gains come from tuning 5% of the code</em>), doesn't it makes sense to start with the powerful dynamic features and harden where necessary? </p>
<p>According to the language reference, there is no requirement for classes to subclass any standard root class, so you can include or omit a superclass as needed.</p> <p>Note that omitting a superclass from the class declaration, doesn't assign a implicit base superclass of any kind. It defines a base class, which will effectively become the root for an independent class hierarchy.</p> <p>From the language reference:</p> <blockquote> <p>Swift classes do not inherit from a universal base class. Classes you define without specifying a superclass automatically become base classes for you to build upon.</p> </blockquote> <p>Trying to reference <code>super</code> from a class without a super class (i.e. a base class) will result in a compile time error</p> <pre><code>'super' members cannot be referenced in a root class </code></pre>
<p>It is normal. Look at the design goals of Swift: The goal is to make huge classes of programming problems disappear. Method swizzling is probably not one of the things that you want to do with Swift. </p>
<p>I believe that the vast majority of Swift data will not be <code>objc</code>. Only those parts that do need to communicate with te Objective C infrastructure will be explicitly marked as such.</p> <p>To which extent runtime introspection will be added to the language, I do not know. Method interception will likely become only possible if the method explicitly allows it. This is my guess, but only the language designers within Apple really know where they are really heading.</p>
<p>The following is copied from Apple's Swift-eBook and gives an appropriate answer to your question:</p> <h2>Defining a Base-Class</h2> <p>Any class that does not inherit from another class is known as a base class.</p> <p>Swift classes do not inherit from a universal base class. Classes you define without specifying a superclass automatically become base classes for you to build upon.</p> <p><br> <h3>Reference</h3> <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Inheritance.html#//apple_ref/doc/uid/TP40014097-CH17-XID_251" rel="nofollow">https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Inheritance.html#//apple_ref/doc/uid/TP40014097-CH17-XID_251</a></p>
<p>Swift classes that are subclasses of NSObject:</p> <ul> <li>are Objective-C classes themselves</li> <li>use <code>objc_msgSend()</code> for calls to (most of) their methods</li> <li>provide Objective-C runtime metadata for (most of) their method implementations</li> </ul> <p>Swift classes that are not subclasses of NSObject:</p> <ul> <li>are Objective-C classes, but implement only a handful of methods for NSObject compatibility</li> <li>do not use <code>objc_msgSend()</code> for calls to their methods (by default)</li> <li>do not provide Objective-C runtime metadata for their method implementations (by default)</li> </ul> <p>Subclassing NSObject in Swift gets you Objective-C runtime flexibility but also Objective-C performance. Avoiding NSObject can improve performance if you don't need Objective-C's flexibility.</p> <p><strong>Edit:</strong></p> <p>With Xcode 6 beta 6, the dynamic attribute appears. This allows us to instruct Swift that a method should use dynamic dispatch, and will therefore support interception. </p> <pre><code>public dynamic func foobar() -&gt; AnyObject { } </code></pre>
<p>I also found that if basing a Swift class on NSObject, I saw some unexpected run-time behaviour that could hide coding bugs. Here is an example.</p> <p>In this example, where we <strong>don't</strong> base on NSObject, the compiler correctly spots the error in testIncorrect_CompilerShouldSpot, reporting "... 'MyClass' is not convertible to 'MirrorDisposition'"</p> <pre><code>class MyClass { let mString = "Test" func getAsString() -&gt; String { return mString } func testIncorrect_CompilerShouldSpot() { var myString = "Compare to me" var myObject = MyClass() if (myObject == myString) { // Do something } } func testCorrect_CorrectlyWritten() { var myString = "Compare to me" var myObject = MyClass() if (myObject.getAsString() == myString) { // Do something } } } </code></pre> <p>In this example, where we base on <strong>NSObject</strong>, the compiler <strong>doesn't</strong> spot the error in testIncorrect_CompilerShouldSpot:</p> <pre><code>class myClass : NSObject { let mString = "Test" func getAsString() -&gt; String { return mString } func testIncorrect_CompilerShouldSpot() { var myString = "Compare to me" var myObject = MyClass() if (myObject == myString) { // Do something } } func testCorrect_CorrectlyWritten() { var myString = "Compare to me" var myObject = MyClass() if (myObject.getAsString() == myString) { // Do something } } } </code></pre> <p>I guess the moral is, only base on NSObject where you really have to!</p>