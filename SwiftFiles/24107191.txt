Curry Function in Swift
<p>I want to make a function that return a curry function like below</p> <pre><code>func addTwoNumbers(a: Int)(b: Int) -&gt; Int { return a + b } addTwoNumbers(4)(b: 6) // Result: 10 var add4 = addTwoNumbers(4) add4(b: 10) // returns 14 </code></pre> <p>What is the return type of such function and how can I generate a function like this using a function that take Variadic parameters.</p> <pre><code>func generateCurry(.../*Variadic parameters*/) -&gt; .../*curry function type*/ { return ...//curry function } </code></pre> <p>I want a generic solution and not take only Int as arguments in the parmeter of the generateCurry function</p> <pre><code>let curried = curry(func(a, b, c) { print(a + b + c) }) curried(1)(2)(3) //prints 6 </code></pre>
<p>I'm not sure this is actually going to be possible in the same way it is inside of languages like Python.</p> <p>The core problem I see to having a single generic solution is the strong typing of the closures/funcs you want to accept.</p> <p>You could fairly easily create a curry function that worked on a specific or common function signature, but as far as a general purpose curry I don't see a way for it to work. The issue is more than about the types of the arguments (as mentioned in comments) but also with the number of them.</p> <p>I've written up a simple example of how you could implement a curry function. It works, but I don't see a sane way to have a truly generic one like you can in more loosely typed languages.</p> <pre><code>func add(a1: Int, a2: Int) -&gt; Int { return a1 + a2 } func curry(argument: Int, block: (Int, Int) -&gt; Int) -&gt; Int -&gt; Int{ func curried(arg: Int) -&gt; Int { return block(argument, arg) } return curried } curry(5, add)(6) </code></pre>
<p>To return a curry function just do this :</p> <blockquote> <p>func test() -> (data : T) -> () {</p> <pre><code> func onSuccess (data : T) { } return onSuccess } </code></pre> </blockquote>
<p>You can achieve this pretty easily with closures:</p> <pre><code>/// Takes a binary function and returns a curried version func curry&lt;A,B,C&gt;(f: (A, B) -&gt; C) -&gt; A -&gt; B -&gt; C { return { a in { b in f(a, b) } } } curry(+)(5)(6) // =&gt; 11 let add: Int -&gt; Int -&gt; Int = curry(+) add(5)(6) // =&gt; 11 </code></pre> <p>It would be really nice to be able to do the same thing for functions that take 3, 4 or more arguments, but without duplicating the implementation. The signature of such a function might start something like:</p> <pre><code>/// Take a function accepting N arguments and return a curried version func curry&lt;T&gt;(args: T...) -&gt; /* ? */ </code></pre> <p>What would the return type be? It would change based on the input to the function. This definitely isn't possible in Swift at the moment, and I don't think it would be possible at all without some kind of macro system. But even with macros I don't think the compiler would be satisfied unless it knew the length of the list at compile-time.</p> <p>Having said that, it's really straight-forward to manually overload the currying function with a version that accepts 3, 4, 5 or more parameters:</p> <pre><code>func curry&lt;A,B,C,D&gt;(f: (A, B, C) -&gt; D) -&gt; A -&gt; B -&gt; C -&gt; D { return { a in { b in { c in f(a,b,c) } } } } func curry&lt;A,B,C,D,E&gt;(f: (A, B, C, D) -&gt; E) -&gt; A -&gt; B -&gt; C -&gt; D -&gt; E { return { a in { b in { c in { d in f(a,b,c,d) } } } } } // etc. </code></pre>