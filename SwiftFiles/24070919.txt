swift: what is the forced type modifier (!) for
<p>The swift documentation explains the purpose of the ! unboxing operator on optional types, </p> <pre><code>var optionalString : String? = "optional" var regularString: String = optionalString! </code></pre> <p>but they have used it on type definitions themselves (String!), without an explicit explanation that I can find.</p> <p>Example:</p> <pre><code>func takesBang(value:String!) -&gt; String { if !value { return "nil value, without the safe syntax" } return "This works" } var unsafe:String! takesBang(unsafe) // yields "nil value, without the safe syntax" </code></pre> <p>The String! type does not force an unboxing of the optional type, but only seems to remove the need for optional syntax (?.). Apple uses this in their own examples, but it seems to only negate the optional safety (pointer) mechanisms.</p> <p>Can anybody explain the purpose / motivation? This seems generally unsafe as the caller won't have to check or at least think about their value.</p>
<p>It turns out that this was just an oversight on Apple's part, they have been auditing classes and updating the return types since Beta 5.</p> <p>From the Beta 6 release notes:</p> <blockquote> <p>"A large number of Foundation APIs have been audited for optional conformance, removing a significant number of implicitly unwrapped optionals from their interfaces. This clarifies the nullability of their properties and arguments / return values of their methods. This is an ongoing effort since beta 5."</p> </blockquote>
<p>It is generally unsafe, but is used for imported Objective-C APIs, which are already unsafe in that way and don't expose enough information to decide whether they should be Optional or non-Optional.</p> <p>In non-imported APIs, I wouldn't expect it to be used much.</p>
<p>The <em>Language Reference</em> states that both, <code>?</code> as also <code>!</code>, when used on <code>var</code> declarations are only syntactic sugar (meaning they are replaced by the compiler during parsing). They map to <code>Optional&lt;T&gt;</code> (?) and <code>ImplicitlyUnwrappedOptional&lt;T&gt;</code> (!) respectively.</p> <p>While you have to use the <code>if let maybeNil = someVar? { ... }</code> syntax for variables of type <code>Optional&lt;T&gt;</code>, you don't have to do so with the implicitly unwrapped optionals (as the name already implies). As the poster in <a href="http://stackoverflow.com/a/24071003/1599345">http://stackoverflow.com/a/24071003/1599345</a> already mentioned, implicitly unwrapped optionals are meant to be used with <em>legacy Objective-C</em> APIs, since those don't provide enough information for Swift.</p> <p>So as a short recap:</p> <pre><code>var foo : SomeType? // should be read as var foo : Optional&lt;SomeType&gt; var bar : SomeType! // should be read as var bar : ImplicitlyUnwrappedOptional&lt;SomeType&gt; </code></pre> <p>The usage of <code>?</code> and <code>!</code> when working with actual values in variables is actually a mapping that can be read in this way, analogous to the declarations above:</p> <pre><code>foo?.somemethod() // if let maybeFoo = foo { maybeFoo.somemethod() } foo!.somemethod() /* # Yeah I know for sure, that this is NOT nil ever everâ€¦ just call `somemethod` and kill me at runtime if it doesn't work out. </code></pre>