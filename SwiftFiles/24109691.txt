Add a method to Card that creates a full deck of cards, with one card of each combination of rank and suit
<p>So I have been doing the experiments that are in the Apple Swift Book.</p> <p>I have been able to do all of them, except for this one so far. Below is what I have tried, but I can't figure out how to get it working.</p> <blockquote> <p>Add a method to <em>Card</em> that creates a full deck of cards, with one card of each combination of rank and suit.</p> </blockquote> <pre><code>// Playground - noun: a place where people can play enum Rank: Int { case Ace = 1 case Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten case Jack, Queen, King func simpleDescription() -&gt; String { switch self { case .Ace: return "ace" case .Jack: return "jack" case .Queen: return "queen" case .King: return "king" default: return String(self.toRaw()) } } } enum Suit { case Spades, Hearts, Diamonds, Clubs func simpleDescription() -&gt; String { switch self { case .Spades: return "spades" case .Hearts: return "hearts" case .Diamonds: return "diamonds" case .Clubs: return "clubs" } } } struct Card { var rank: Rank var suit: Suit func simpleDescription() -&gt; String { return "The \(rank.simpleDescription()) of \(suit.simpleDescription())" } func createFullDeck() -&gt; Array{ var FullDeck: Array FullDeck = Card(rank: .Ace, suit: .Spades) FullDeck = Card(rank: .Two, suit: .Spades) return FullDeck } } let threeOfSpades = Card(rank: .Three, suit: .Spades) let threeOfSpadesDescription = threeOfSpades.simpleDescription() threeOfSpades.createFullDeck() </code></pre> <ul> <li>I don't know what I am supposed to return for that method, an Array?</li> <li>Should I use a for loop to create this? or is there a proper/easier way to do this with enum</li> <li>Why would I create this method inside of <em>Card</em>, calling <code>threeOfSpades.createFullDeck()</code> seems incorrect.</li> </ul>
<p>A for loop is the way to go. I made a few adjustments in your base code. First, I added a type to your Suit enum.</p> <pre><code>enum Suit : Int </code></pre> <p>Then I added a class called Deck which is responsible for a deck of cards.</p> <pre><code>class Deck { var cards:Card[] init() { self.cards = Array&lt;Card&gt;() } func createDeck() { for suit in 0...Suit.Clubs.toRaw() { for rank in 1...Rank.King.toRaw() { self.cards += Card(rank: Rank.fromRaw(rank)!, suit: Suit.fromRaw(suit)!) } } } } </code></pre> <p><code>func createDeck()</code> loops through all possible playing cards and adds them to your deck.</p>
<p>First I'll tackle the easiest question: Where you put the code that creates the full deck is up to you, but I would advise you <em>not</em> to put it in <code>Card</code>, but rather create a <code>Deck</code> class and provide a <a href="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-XID_284" rel="nofollow"><strong>convenience initializer</strong></a> to do it there.</p> <p>That said, let's continue with the plan of adding it to the <code>Card</code> class. Unfortunately there is no way to just loop over all possible values of an Enum in the way you'd hope (though I'd love to be wrong about this!), but you <em>can</em> do this:</p> <pre><code>let first_card = Rank.Ace.toRaw() // == 1 let last_card = Rank.King.toRaw() // == 13 for raw_rank in first_card...last_card { let rank = Rank.fromRaw(raw_rank)! } </code></pre> <p>Let's walk through this. An Enum assigns an underlying value to each case, and by writing <code>case Ace = 1</code> you're setting it up to start counting from 1 (rather than 0, the default). The API provided by an Enum for accessing the underlying value is a <code>toRaw()</code> method on each Enum case (The Enum itself also provides it in the form of <code>Rank.toRaw(Rank.Ace)</code>.</p> <p>You can convert back from the raw value using the aptly named <code>fromRaw()</code> method (so <code>Rank.fromRaw(1)</code> would give us Ace) but there is a caveat: It returns an optional. The return type is <code>Rank?</code>, <strong><em>not</em></strong> <code>Rank</code>. In order to access the value you need to <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-XID_428" rel="nofollow">either check for nil, or force unwrap it</a>.</p> <p>Checking for nil:</p> <pre><code>if let rank = Rank.fromRaw(1) { // Do stuff with rank, which is now a plain old Rank } else { // handle nil } </code></pre> <p>Force unwrap:</p> <pre><code>var rank: Rank = Rank.fromRaw(1)! </code></pre> <p>So to answer your question about the loops: Yes, that's the way to do it =P, and yes again about the array, though that's a design decision. It makes just as much sense to create a <code>Deck</code> class and return that instead.</p> <p>Let's add the method using <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Extensions.html#//apple_ref/doc/uid/TP40014097-CH24-XID_191" rel="nofollow">an extension</a>. Extensions let you add functionality to an existing type. You can create an extension on a class, enum, or even a primitive type. pretty much anything.</p> <pre><code>extension Card { func createFullDeck() -&gt; Card[] { var deck: Array&lt;Card&gt; = [] for raw_rank in Rank.Ace.toRaw()...Rank.King.toRaw() { deck += [ Card(rank:Rank.fromRaw(raw_rank)!, suit:.Spades), Card(rank:Rank.fromRaw(raw_rank)!, suit:.Hearts), Card(rank:Rank.fromRaw(raw_rank)!, suit:.Diamonds), Card(rank:Rank.fromRaw(raw_rank)!, suit:.Clubs), ] } return deck } } </code></pre>
<p>Here's another way of doing it, this time only using techniques you would have learned up to that point*</p> <p>First we define the possible ranks and suits, using the respective <code>Rank</code> and <code>Suit</code> enums defined previously.</p> <p>Next we have the function iterate over each rank within each suit, creating a card for each, and finally returning an array of the cards.</p> <pre><code>struct Card { var rank: Rank var suit: Suit func simpleDescription() -&gt; String { return "The \(rank.simpleDescription()) of \(suit.simpleDescription())" } func createDeck() -&gt; Card[] { let ranks = [Rank.Ace, Rank.Two, Rank.Three, Rank.Four, Rank.Five, Rank.Six, Rank.Seven, Rank.Eight, Rank.Nine, Rank.Ten, Rank.Jack, Rank.Queen, Rank.King] let suits = [Suit.Spades, Suit.Hearts, Suit.Diamonds, Suit.Clubs] var deck = Card[]() for suit in suits { for rank in ranks { deck.append(Card(rank: rank, suit: suit)) } } return deck } } </code></pre> <p>(* with the notable exception that the tour hadn't explicitly explained how to append to arrays at that point)</p>
<p>I read the answers above, but then I couldn't use the method ... unless it is a class method. So I added "static" before the 2 methods I added, and here is my proposal:</p> <pre><code>struct Card { var rank: Rank var suit: Suit func simpleDescription() -&gt; String { return "The \(rank.simpleDescription()) of \(suit.simpleDescription())" } static func createDeck() -&gt; Card[] { var deck = Card[]() for suit in [Suit.Spades, Suit.Clubs, Suit.Hearts, Suit.Diamonds] { for rankRawValue in 1...13 { let rank = Rank.fromRaw(rankRawValue) let card = Card(rank: rank!, suit: suit) deck += card } } return deck } static func printDeck(deck:Card[]) { for card in deck { println(card.simpleDescription()) } } } let threeOfSpades = Card(rank: .Three, suit: .Spades) let threeOfSpadesDescription = threeOfSpades.simpleDescription() let deck = Card.createDeck() Card.printDeck(deck) </code></pre> <p>But I agree, a "Deck" class would be a better option ...</p>
<p>Surprisingly, no one has yet had a stab at a functional implementation. Here goes:</p> <pre><code>extension Array { func flatten&lt;T&gt;() -&gt; T[] { let xs = (self as Any) as Array&lt;Array&lt;T&gt;&gt; return xs.reduce(T[]()) { (x, acc) in x + acc } } } extension Card { static func fullDeck() -&gt; Card[] { let rawRanks = Array(Rank.Ace.toRaw()...Rank.King.toRaw()) let suits: Suit[] = [.Spades, .Hearts, .Diamonds, .Clubs] return (rawRanks.map { rawRank in suits.map { suit in Card(rank: Rank.fromRaw(rawRank)!, suit: suit) } }).flatten() } } </code></pre>
<p>The experiment asks for a method to Card. So I I declared the method as being static so that it acts on the struct and not an instance of it:</p> <pre><code>struct Card { var rank: Rank var suit: Suit func simpleDescription() -&gt; String { return "The \(rank.simpleDescription()) of \(suit.simpleDescription())" } static func deck() -&gt; [Card] { var deck: [Card] = [] for suit in [Suit.Spades, Suit.Hearts, Suit.Diamonds, Suit.Clubs] { for rank in 0...13 { if let unwrappedRank = Rank.fromRaw(rank) { deck.append(Card(rank: unwrappedRank, suit: suit)) } } } return deck } } </code></pre> <p>To make use of it:</p> <pre><code>let deck = Card.deck() </code></pre> <p>Hope that helps.</p>
<p>Trying to avoid knowledge of the enum definition... It seems clumsy (I'm a beginner), and still needs the starting index: 0 for Suit, 1 for Rank.</p> <pre><code>struct Card { var rank: Rank var suit: Suit func simpleDescription() -&gt; String { return "The \(rank.simpleDescription()) of \(suit.simpleDescription())" } static func deck() -&gt; [Card] { var deck = [Card]() var suitCount = 0 while (Suit(rawValue: suitCount) != nil) { var rankCount = 1 while (Rank(rawValue: rankCount) != nil) { deck.append(Card(rank: Rank(rawValue: rankCount)!, suit: Suit(rawValue: suitCount)!)) rankCount++ } suitCount++ } return deck } } let deck = Card.deck() </code></pre>
<p>A robust code answer will not to the use actual values (i.e., .Spades) from the enumerations when generating the deck, e.g., if a "Joker" is added later to the Rank enumeration (anywhere in the enumeration), the deck generation function should still work without change.</p> <p>The design questions (what to return?, should the deck generation be a function of card?) are not really relevant to this tutorial, but it is likely that a Deck class would be preferable if any serious functionality is going to be built out further (e.g., shuffle). So for now, returning an Array from a function in the Card structure is all that is required.</p> <p>The following code (as far as possible only using what has been described up to this point in the tutorial) defines a function in the Card Structure that loops through the Suit and Rank enumerations without needing to know any of the enumeration values and returns an Array:</p> <pre><code>static func deck() -&gt; [Card] { var deck = [Card]() var suitCount = 1 while let suit = Suit(rawValue: suitCount) { var rankCount = 1 while let rank = Rank(rawValue: rankCount) { deck.append(Card(rank: rank, suit: suit)) rankCount += 1 } suitCount += 1 } return deck } </code></pre> <p>Invoke this with:</p> <pre><code>let deck = Card.deck() var card3 = deck[3].simpleDescription() </code></pre> <p>Copy the function into the Card structure and try adding values to enums. Note the following:</p> <ul> <li>how the number of times the loops are executed changes when adding to the enums</li> <li>that both enum counters start at 1 (if not otherwise specified in the enumeration the first raw value is one)</li> <li>unspecified array indexes start at 0 (e.g., deck[3] is actually the 4 of Spades)</li> </ul>
<p>I just started learning Swift also, and had this same problem. I too thought it was rather odd that the experiment was to create a method inside the Card structure to create a full deck of cards.</p> <p>After looking at these answers, and reading the official Apple "The Swift Programming Language (Swift 2.1)" tour, I solved it like this:</p> <pre><code>struct Card { var rank: Rank var suit: Suit func simpleDescription() -&gt; String { return "The \(rank.simpleDescription()) of \(suit.simpleDescription())" } func createDeck() -&gt; [Card] { let suits = [Suit.Spades, Suit.Hearts, Suit.Clubs, Suit.Diamonds] var deck = [Card]() for theSuit in suits { for theRank in Rank.Ace.rawValue...Rank.King.rawValue { deck.append(Card(rank: Rank(rawValue: theRank)!, suit: theSuit)) } } return deck } } let aceOfHearts = Card(rank: .Ace, suit: .Hearts) let deck = aceOfHearts.createDeck() for card in deck { print("\(card.rank) of \(card.suit)") } </code></pre>