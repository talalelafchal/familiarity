How to determine the type of a variable in Swift
<p>Is there a function to determine the variable type in Swift? I presume there might be something like like <code>type()</code> in Python.</p> <p>I'd like a way to judge if a variable is a Foundation object or C variable in Swift. Like NSString vs String, or NSArray vs array. So that I can log it out in console and see clearly what it is.</p> <p>For example, I would like to know the type inferred for the the first <code>array</code> below:</p> <pre><code>var array = [1,2,3] // by default NSArray or array? var array:[Int] = [1,2,3] var array:NSArray = [1,2,3] var array:Array&lt;Any&gt; = [1,2,3] </code></pre> <p>I have seen answers for judging if a <em>given</em> variable is a kind of <em>given</em> type in <a href="http://stackoverflow.com/q/24091882/1114">this question</a>, but I'll say it's quite different from what I want to ask.</p>
<p>I use breakpoints during debuging but if you need to check if they match a certain type during runtime then drewag is right</p> <p>another thing you can do is test datatype with assertion this would only work in debugging but with assertion you can set conditions which if met app crashes</p> <p>maybe something like <code>assert(let tArray == oldArray as? NSArray[] //if not NSArray app crashes)</code></p>
<p>It is possible to do so, though it's not necessarily that easy nor useful:</p> <pre><code>func getClassName(obj : AnyObject) -&gt; String { let objectClass : AnyClass! = object_getClass(obj) let className = objectClass.description() return className } let swiftArray = [1, 2, 3] let swiftDictionary = ["Name": "John Doe"] let cocoaArray : NSArray = [10, 20, 30] var mutableCocoaArray = NSMutableArray() println(getClassName(swiftArray)) println(getClassName(swiftDictionary)) println(getClassName(cocoaArray)) println(getClassName(mutableCocoaArray)) </code></pre> <p>Output:</p> <pre><code>_TtCSs22ContiguousArrayStorage00007F88D052EF58 __NSDictionaryM __NSArrayI __NSArrayM </code></pre> <p>You are better of using the <code>is</code> and <code>as</code> keywords in Swift. Many foundation classes use class clusters (as you can see with <code>__NSArrayI</code> (immutable) and <code>__NSArrayM</code> (mutable).</p> <p>Notice the interesting behavior. The <code>swiftArray</code> defaults to using a Swift <code>Array&lt;Int&gt;</code> while the <code>swiftDictionary</code> defaulted to <code>NSMutableDictionary</code>. With this kind of behavior I would not really rely on anything being a certain type (check first).</p>
<p>option+click the variable you'd like to examine.</p> <p><img src="https://i.stack.imgur.com/NY3Sb.png" alt="enter image description here"></p>
<p>You can get a reference to the type object of a value by using the <code>.dynamicType</code> property. This is equivalent to Python's <code>type()</code> function, and is mentioned <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/doc/uid/TP40014097-CH31-XID_1022">in the Swift documentation under Language Reference: Types: Metatype Type</a>.</p> <pre><code>var intArray = [1, 2, 3] let typeOfArray = intArray.dynamicType </code></pre> <p>With this type object, we are able to create a new instance of the same array type.</p> <pre><code>var newArray = typeOfArray() newArray.append(5) newArray.append(6) println(newArray) </code></pre> <pre class="lang-none prettyprint-override"><code>[5, 6] </code></pre> <p>We can see that this new value is of the same type (<code>[Int]</code>) by attempting to append a float:</p> <pre><code>newArray.append(1.5) </code></pre> <pre class="lang-none prettyprint-override"><code>error: type 'Int' does not conform to protocol 'FloatLiteralConvertible' </code></pre> <p>If we import Cocoa and use an array literal with mixed types, we can see that an <code>NSArray</code> is created:</p> <pre><code>import Cocoa var mixedArray = [1, "2"] let mixedArrayType = mixedArray.dynamicType var newArray = mixedArrayType() var mutableArray = newArray.mutableCopy() as NSMutableArray mutableArray.addObject(1) mutableArray.addObject(1.5) mutableArray.addObject("2") println(mutableArray) </code></pre> <pre class="lang-none prettyprint-override"><code>(1, "1.5", 2) </code></pre> <p>However, at this point there does not seem to be any general way to generate a string description of a type object, so this may not serve the debugging role that you were asking about.</p> <p>Types derived from <code>NSObject</code> do have a <code>.description()</code> method, as is used <a href="http://stackoverflow.com/a/24093709/1114">in SiLo's answer</a>,</p> <pre><code>println(mixedArrayType.description()) </code></pre> <pre class="lang-none prettyprint-override"><code>__NSArrayI </code></pre> <p>However this is not present on types such as Swift's built-in arrays.</p> <pre><code>println(typeOfArray.description()) </code></pre> <pre class="lang-none prettyprint-override"><code>error: '[Int].Type' does not have a member named 'description' </code></pre>