NSNotificationCenter vs delegation - which is faster?
<p>I have read a lot about the pros and cons of each , and i know delegates are usually for one listener, and notifications are for many. The question is about performance.</p> <p>I have read this : <a href="http://stackoverflow.com/questions/1927965/nsnotificationcenter-vs-delegation-using-protocols">NSNotificationCenter vs delegation( using protocols )?</a></p> <p>I am sending audio signals from mic, to another class by notification . i know that here i should use the delegate BUT my question is : does delegates will be faster ? because i can see i have some frame rate issue(decreased), and i would like to know if the cause could be the using of notification <strong>instead</strong> of delegate, or there is no relation ?</p>
<blockquote> <p>i know that here i should use the delegate BUT my question is : does delegates will be faster ?</p> </blockquote> <p>It is easy: try and share the results!</p> <p>The delegate when 1:1, point to point relationship can be faster than the 1:m publish and subscribe in any system.</p> <p>Is it faster hard to answer, because it depends on environment. When aren't a lot of listeners and the publisher not need to search a lot for listeners, then should be similar performance, but when are a million of subscribers and need to search it, then can be a delay, frame rate decrease.</p>
<p>Delegates come with less overhead and will therefore be executed much faster. </p> <p>However, in general you should look on performance topics only there where they are likely to be an issue at all. For once-off tasks like sending a notification vs calling a delegate this should never be an issue. But when you plan to perform these in a loop with a variable (depending on data) number of intarations or for a number of data objects where you have fetched or received the data an cannot predict how many there will be - those are the situations where I would consider performance optimization. </p>
<p>Calling the delegate is just a method invocation but when notifications are used there some more stuff should be done behind the scenes to deliver your notification. Considering this - delegate is a bit faster.</p> <p>Realtime audio processing is a complex task and I tend to think that delegate's method call or sending a notification produces much more less overhead than your audio-processing code.</p> <p><strong>UPDATE</strong></p> <p>Considering performance issues you always should do measurements while trying different approaches.</p>
<p>Delegates are faster.</p> <p>Your frame rate issue while recording is not due to delegates or notifications. It is because your are doing all your tasks on the main thread, which also renders the UI.</p>
<p>A delegate will be faster than a notification but neither is necessarily what you need. For audio you should probably measure first. If you need something executed faster before updating the UI then you should look at moving some processing task to another thread via GCD dispatch or NSOperation. </p>
<p>For those interested in performance I ran a simple test in swift using the XCTest framework's <code>measureBlock</code> API. The short answer is that if calling in a loop, the difference will be significant.</p> <p>Here is the code used to test:</p> <pre><code>public protocol MyTestClassDelegate: class { func myTestDelegateCallback() } public let TestClassValueChangedNotification = "TestClassNotification" public class MyViewModel { public weak var delegate: MyTestClassDelegate? public init() { } public func doNotification() { NSNotificationCenter.defaultCenter().postNotificationName(TestClassValueChangedNotification, object: nil) } public func doDelegation(value: Int) { delegate?.myTestClassDelegateCallback() } } </code></pre> <p>And the Test Cases:</p> <pre><code>func testPerformanceNotifiction() { measureBlock { () -&gt; Void in let testClass = MyTestClass() for i in 0...100000 { testClass.doNotification(i) } } } func testPerformanceDelegation() { measureBlock { () -&gt; Void in let testClass = MyTestClass() testClass.delegate = self for i in 0...100000 { testClass.doDelegation(i) } } } </code></pre> <blockquote> <p>Results: <br> - Delegation:- - - - - - 0.957 seconds <br> - Notification Center: - 3.882 seconds</p> </blockquote> <h2>A Crappy Alternative I Tried</h2> <p>Other considerations are that the performance of NSNotificationCenter obviously may vary based on how many listeners there are for a given event, and the performance of the code executed by those listeners. Its also worth noting that NSNotificationCenter calls the notification listeners synchronously, and on the same thread on which <code>postNotification</code> was invoked, which can be a gotcha when first approaching NSNotificationCenter.</p> <p>If you find yourself in a scenario, (as I have) where you need one to many communication, and high performance, you might consider simply implementing an array of delegates. But you need not bother, because the performance of this is actually the worst option.</p> <pre><code>public func doMultipleDelegatation() { for i in 0..&lt;delegates.count { delegates[i].myTestDelegateCallback() }) } func testPerformanceMultipleDelegation() { measureBlock { () -&gt; Void in let testClass = MyTestClass() testClass.delegates = [self] for i in 0...100000 { testClass.doMultipleDelegation(i) } } } </code></pre> <blockquote> <p>Final Results: <br> - Delegation:- - - - - - 0.957 seconds <br> - Notification Center: - 3.882 seconds <br> - Multiple Delegation: - 6.488 seconds</p> </blockquote>