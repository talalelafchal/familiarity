Array without function in Swift
<p>Following the guides on generics and type constraints, I attempted to create an Array.without function as follows:</p> <pre><code>extension Array { func without&lt;T: Equatable&gt;(item:T) -&gt; T[] { return self.map { $0 != item } } } </code></pre> <p>Testing this in a playground, I can't get it to work as the != value triggers a compiler error, "Could not find an overload for != that accepts the supplied arguments".</p> <p>I believe the <code>&lt;T: Equatable&gt;</code> should be enough to allow the use of <code>!=</code> but obviously it didn't work. What's missing here?</p>
<p>The problem is that the <code>T</code> you define in the method has nothing to do with the <code>T</code> defined in the actual struct. Your local <code>T</code> is constrained to be <code>Equatable</code>, but the <code>Array</code> version of <code>T</code> is still not constrained and that is what <code>self.map</code> is providing to the closure. The closure is getting an <code>Array</code> type <code>T</code> and you are trying to compare that to your local <code>T</code> which isn't necessarily the same type.</p> <p>I think the best you can do is something like this:</p> <pre><code>extension Array { func without&lt;U : Equatable&gt;(item : U) -&gt; [T] { return self.filter { $0 as? U != item } } } </code></pre> <p>Unfortunately, this will still work if you call it with an instance of a different type as is stored in the array. If you do, it will simply return the original Array. It will not let you call it with an instance that is not equatable though.</p> <p><strong>Notes:</strong></p> <ol> <li>I used <code>filter</code> instead of <code>map</code> because that is the method that allows you to filter out contents of an array. <code>map</code> is for changing contents</li> <li>I changed <code>without</code> to return an array. <code>filter</code> and <code>map</code> do not modify the array, instead they return a new version of the array that is altered according to the closure.</li> </ol>