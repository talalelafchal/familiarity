How to share a Dictionary instance in Swift?
<p>According to the Swift Programming Language reference, Dictionary instances are copied whenever they are passed to a function/method or assigned to a constant or variable. This seems inefficient. Is there a way to efficiently share the contents of a dictionary between two methods without copying?</p>
<p>You always have the option to define a custom, generic class with a <code>Dictionary</code> attribute:</p> <pre><code>class SharedDictionary&lt;K, V&gt; { var dict : Dictionary&lt;K, V&gt; // add the methods you need, including overloading operators } </code></pre> <p>Instances of your <code>SharedDictionary</code> will be passed-by-reference (not copied).</p>
<p>It's true the documentation says that but there are also various notes saying it won't affect the performance. The copying will be performed lazily - only when needed.</p> <blockquote> <p>The descriptions below refer to the “copying” of arrays, dictionaries, strings, and other values. Where copying is mentioned, the behavior you see in your code will always be as if a copy took place. However, Swift only performs an actual copy behind the scenes when it is absolutely necessary to do so. Swift manages all value copying to ensure optimal performance, and you should not avoid assignment to try to preempt this optimization.</p> </blockquote> <p>Source: <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13-XID_109" rel="nofollow">Classes &amp; Collections</a></p> <p>Meaning - don't try to optimize before you actually encounter performance problems!</p> <p>Also, don't forget that dictionaries are structures. When you pass them into a function, they are implicitly immutable, so no need for copying. To actually pass a mutable dictionary into a function, you can use an <code>inout</code> parameter and the dictionary won't be copied (passed by reference). <strike>The only case when a mutable dictionary passed as a parameter will be copied is when you declare the parameter as <code>var</code>.</strike></p>
<p>Trust the language designers: the compiler is usually smarter than you think in optimizing copies.</p> <p>You can hack around this, but I don't frankly see a need before proving it's inefficient.</p>
<p>I actually talked to someone on the Swift team today about "pass by reference" in Swift. Here is what I got:</p> <ol> <li>As we all know, struct are pass by copy, classes are pass by reference</li> <li>I quote "It is extremely easy to wrap a <code>struct</code> in a <code>class</code>. Pointing to GoZoner's answer.</li> <li>Even though though a <code>struct</code> is copied, any <code>classes</code> defined in the struct will still be passed by reference.</li> <li>If you want to do traditional pass by reference on a struct, use <code>inout</code>. However he specifically mentioned to "consider adding in another return value instead of using <code>inout</code>" when saying this.</li> </ol> <p>Since <code>Dictionary</code> defines <code>KeyType</code> and <code>ValueType</code> as generics:</p> <pre><code>struct Dictionary&lt;KeyType : Hashable, ValueType&gt; </code></pre> <p>I believe this means that if your <code>KeyType</code> and <code>ValueType</code> are class objects they will not be copied when the <code>Dictionary</code> itself is copied, and you shouldn't need to worry about it too much.</p> <p>Also, the <code>NSDictionary</code> class is still available to use!</p>
<p>As other said "Swift only performs an actual copy behind the scenes when it is absolutely necessary to do so." so performance should not be a big problem here. However you might still want to have a dictionary passed by reference for some other reasons. In that case you can create a custom class like below and use it just like you would use a normal dictionary object:</p> <pre><code>class SharedDictionary&lt;K : Hashable, V&gt; { var dict : Dictionary&lt;K, V&gt; = Dictionary() subscript(key : K) -&gt; V? { get { return dict[key] } set(newValue) { dict[key] = newValue } } } </code></pre>