Delete a particular local notification
<p>I am developing an iPhone alarm app based on local notifications.</p> <p>On deleting an alarm, the related local notification should get cancelled. But how can I determine exactly which object from the array of local notifications is to be cancelled?</p> <p>I am aware of <code>[[UIApplication sharedApplication] cancelLocalNotification:notification]</code> method but how can I get this 'notification' to cancel it?</p>
<p>You can save a unique value for key in your local notification's userinfo. Get all local notification, loop through the array and delete the particular notification.</p> <p>Code as follows,</p> <p><strong>OBJ-C:</strong></p> <pre><code>UIApplication *app = [UIApplication sharedApplication]; NSArray *eventArray = [app scheduledLocalNotifications]; for (int i=0; i&lt;[eventArray count]; i++) { UILocalNotification* oneEvent = [eventArray objectAtIndex:i]; NSDictionary *userInfoCurrent = oneEvent.userInfo; NSString *uid=[NSString stringWithFormat:@"%@",[userInfoCurrent valueForKey:@"uid"]]; if ([uid isEqualToString:uidtodelete]) { //Cancelling local notification [app cancelLocalNotification:oneEvent]; break; } } </code></pre> <p><strong>SWIFT:</strong></p> <pre><code>var app:UIApplication = UIApplication.sharedApplication() for oneEvent in app.scheduledLocalNotifications { var notification = oneEvent as UILocalNotification let userInfoCurrent = notification.userInfo! as [String:AnyObject] let uid = userInfoCurrent["uid"]! as String if uid == uidtodelete { //Cancelling local notification app.cancelLocalNotification(notification) break; } } </code></pre> <p><strong>UserNotification:</strong></p> <p>If you use <a href="https://developer.apple.com/reference/usernotifications" rel="nofollow">UserNotification</a> (iOS 10+), just follow this steps:</p> <ol> <li><p>When creating the UserNotification content, add an unique <a href="https://developer.apple.com/reference/usernotifications/unnotificationrequest/1649634-identifier" rel="nofollow" title="identifier">identifier</a></p></li> <li><p>Remove specific pending notification using <a href="https://developer.apple.com/reference/usernotifications/unusernotificationcenter/1649517-removependingnotificationrequest" rel="nofollow" title="removePendingNotificationRequests&#40;withIdentifiers:&#41;">removePendingNotificationRequests(withIdentifiers:)</a></p></li> <li><p>Remove specific delivered notification using <a href="https://developer.apple.com/reference/usernotifications/unusernotificationcenter/1649500-removedeliverednotifications" rel="nofollow">removeDeliveredNotifications(withIdentifiers:)</a></p></li> </ol> <p>For more info, <a href="https://developer.apple.com/reference/usernotifications/unusernotificationcenter#symbols" rel="nofollow">UNUserNotificationCenter</a></p>
<p>Other Option:</p> <p>First of All, when you create local notification, you can store it in user defaults for future use, Local notification object can not be stored directly in user defaults, This object needs to be converted into NSData object first, and then <code>NSData</code> can be stored into <code>User defaults</code>. Below is code for that:</p> <pre><code>NSData *data = [NSKeyedArchiver archivedDataWithRootObject:localNotif]; [[NSUserDefaults standardUserDefaults] setObject:data forKey:[NSString stringWithFormat:@"%d",indexPath.row]]; </code></pre> <p>After you have stored and scheduled local notification, In future, requirement may arise that you need to cancel any of notification that you created earlier, So you can retrieve it from User defaults.</p> <pre><code>NSData *data= [[NSUserDefaults standardUserDefaults] objectForKey:[NSString stringWithFormat:@"%d",UniqueKey]]; UILocalNotification *localNotif = [NSKeyedUnarchiver unarchiveObjectWithData:data]; NSLog(@"Remove localnotification are %@", localNotif); [[UIApplication sharedApplication] cancelLocalNotification:localNotif]; [[NSUserDefaults standardUserDefaults] removeObjectForKey:[NSString stringWithFormat:@"%d",UniqueKey]]; </code></pre> <p>Hope This helps</p>
<p>Here is what i do.</p> <p>When creating your notification do this:</p> <pre><code> // Create the notification UILocalNotification *notification = [[UILocalNotification alloc] init] ; notification.fireDate = alertDate; notification.timeZone = [NSTimeZone localTimeZone] ; notification.alertAction = NSLocalizedString(@"Start", @"Start"); notification.alertBody = **notificationTitle**; notification.repeatInterval= NSMinuteCalendarUnit; notification.soundName=UILocalNotificationDefaultSoundName; notification.applicationIconBadgeNumber = 1; [[UIApplication sharedApplication] scheduleLocalNotification:notification] ; </code></pre> <p>when trying to delete it do this:</p> <pre><code> NSArray *arrayOfLocalNotifications = [[UIApplication sharedApplication] scheduledLocalNotifications] ; for (UILocalNotification *localNotification in arrayOfLocalNotifications) { if ([localNotification.alertBody isEqualToString:savedTitle]) { NSLog(@"the notification this is canceld is %@", localNotification.alertBody); [[UIApplication sharedApplication] cancelLocalNotification:localNotification] ; // delete the notification from the system } } </code></pre> <p>This solution should work for multiple notifications, and your not managing any arrays or dictionaries or user defaults. Your simply using the data you've already saved to the systems notification database.</p> <p>Hope this helps future designers and developers.</p> <p>Happy coding guys! :D</p>
<p>For Repeated Reminders ( For example you want your alarm to fire on Sun, Sat and Wed at 4 PM , Then you have to make 3 alarms and set repeatInterval to NSWeekCalendarUnit ).</p> <p>For making Once Only Reminder :</p> <pre><code>UILocalNotification *aNotification = [[UILocalNotification alloc] init]; aNotification.timeZone = [NSTimeZone defaultTimeZone]; aNotification.alertBody = _reminderTitle.text; aNotification.alertAction = @"Show me!"; aNotification.soundName = UILocalNotificationDefaultSoundName; aNotification.applicationIconBadgeNumber += 1; NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar]; NSDateComponents *componentsForFireDate = [calendar components:(NSYearCalendarUnit | NSWeekCalendarUnit| NSHourCalendarUnit | NSMinuteCalendarUnit| NSSecondCalendarUnit | NSWeekdayCalendarUnit) fromDate: _reminderDate]; [componentsForFireDate setHour: [componentsForFireDate hour]] ; //for fixing 8PM hour [componentsForFireDate setMinute:[componentsForFireDate minute]]; [componentsForFireDate setSecond:0] ; NSDate *fireDateOfNotification = [calendar dateFromComponents: componentsForFireDate]; aNotification.fireDate = fireDateOfNotification; NSDictionary *infoDict = [NSDictionary dictionaryWithObject:_reminderTitle.text forKey:kRemindMeNotificationDataKey]; aNotification.userInfo = infoDict; [[UIApplication sharedApplication] scheduleLocalNotification:aNotification]; </code></pre> <p>For Making Repeated Reminder :</p> <pre><code>for (int i = 0 ; i &lt;reminderDaysArr.count; i++) { UILocalNotification *aNotification = [[UILocalNotification alloc] init]; aNotification.timeZone = [NSTimeZone defaultTimeZone]; aNotification.alertBody = _reminderTitle.text; aNotification.alertAction = @"Show me!"; aNotification.soundName = UILocalNotificationDefaultSoundName; aNotification.applicationIconBadgeNumber += 1; NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar]; NSDateComponents *componentsForFireDate = [calendar components:(NSYearCalendarUnit | NSWeekCalendarUnit| NSHourCalendarUnit | NSMinuteCalendarUnit| NSSecondCalendarUnit | NSWeekdayCalendarUnit) fromDate: _reminderDate]; [componentsForFireDate setWeekday: [[reminderDaysArr objectAtIndex:i]integerValue]]; [componentsForFireDate setHour: [componentsForFireDate hour]] ; // Setup Your Own Time. [componentsForFireDate setMinute:[componentsForFireDate minute]]; [componentsForFireDate setSecond:0] ; NSDate *fireDateOfNotification = [calendar dateFromComponents: componentsForFireDate]; aNotification.fireDate = fireDateOfNotification; aNotification.repeatInterval = NSWeekCalendarUnit; NSDictionary *infoDict = [NSDictionary dictionaryWithObject:_reminderTitle.text forKey:kRemindMeNotificationDataKey]; aNotification.userInfo = infoDict; [[UIApplication sharedApplication] scheduleLocalNotification:aNotification]; } } </code></pre> <p>For Filtering you array to display it.</p> <pre><code>-(void)filterNotficationsArray:(NSMutableArray*) notificationArray{ _dataArray = [[NSMutableArray alloc]initWithArray:[[UIApplication sharedApplication] scheduledLocalNotifications]]; NSMutableArray *uniqueArray = [NSMutableArray array]; NSMutableSet *names = [NSMutableSet set]; for (int i = 0 ; i&lt;_dataArray.count; i++) { UILocalNotification *localNotification = [_dataArray objectAtIndex:i]; NSString * infoDict = [localNotification.userInfo objectForKey:@"kRemindMeNotificationDataKey"]; if (![names containsObject:infoDict]) { [uniqueArray addObject:localNotification]; [names addObject:infoDict]; } } _dataArray = uniqueArray; } </code></pre> <p>To remove Reminder even it was Once Only or Repeated :</p> <pre><code>- (void) removereminder:(UILocalNotification*)notification { _dataArray = [[NSMutableArray alloc]initWithArray:[[UIApplication sharedApplication]scheduledLocalNotifications]]; NSString * idToDelete = [notification.userInfo objectForKey:@"kRemindMeNotificationDataKey"]; for (int i = 0 ; i&lt;_dataArray.count; i++) { UILocalNotification *currentLocalNotification = [_dataArray objectAtIndex:i]; NSString * notificationId = [currentLocalNotification.userInfo objectForKey:@"kRemindMeNotificationDataKey"]; if ([notificationId isEqualToString:idToDelete]) [[UIApplication sharedApplication]cancelLocalNotification:currentLocalNotification]; } _dataArray = [[NSMutableArray alloc]initWithArray:[[UIApplication sharedApplication]scheduledLocalNotifications]]; [self filterNotficationsArray:_dataArray]; [_remindersTV reloadData]; } </code></pre>
<p>The UILocalNotification object you pass to <code>cancelLocalNotification:</code> will match any existing UILocalNotification object with matching properties.</p> <p>So:</p> <pre><code>UILocalNotification *notification = [[UILocalNotification alloc] init]; notification.alertBody = @"foo"; [[UIApplication sharedApplication] presentLocalNotificationNow:notification]; </code></pre> <p>will present a local notification that can later be cancelled with:</p> <pre><code>UILocalNotification *notification = [[UILocalNotification alloc] init]; notification.alertBody = @"foo"; [[UIApplication sharedApplication] cancelLocalNotification:notification]; </code></pre>
<p>Scheduling and removeNotification in swift:</p> <pre><code> static func scheduleNotification(notificationTitle:String, objectId:String) { var localNotification = UILocalNotification() localNotification.fireDate = NSDate(timeIntervalSinceNow: 24*60*60) localNotification.alertBody = notificationTitle localNotification.timeZone = NSTimeZone.defaultTimeZone() localNotification.applicationIconBadgeNumber = 1 //play a sound localNotification.soundName = UILocalNotificationDefaultSoundName; localNotification.alertAction = "View" var infoDict : Dictionary&lt;String,String!&gt; = ["objectId" : objectId] localNotification.userInfo = infoDict; UIApplication.sharedApplication().scheduleLocalNotification(localNotification) } static func removeNotification(objectId:String) { var app:UIApplication = UIApplication.sharedApplication() for event in app.scheduledLocalNotifications { var notification = event as! UILocalNotification var userInfo:Dictionary&lt;String,String!&gt; = notification.userInfo as! Dictionary&lt;String,String!&gt; var infoDict : Dictionary = notification.userInfo as! Dictionary&lt;String,String!&gt; var notifcationObjectId : String = infoDict["objectId"]! if notifcationObjectId == objectId { app.cancelLocalNotification(notification) } } } </code></pre>
<p>Swift Version, if need:</p> <pre><code>func cancelLocalNotification(UNIQUE_ID: String){ var notifyCancel = UILocalNotification() var notifyArray = UIApplication.sharedApplication().scheduledLocalNotifications for notifyCancel in notifyArray as! [UILocalNotification]{ let info: [String: String] = notifyCancel.userInfo as! [String: String] if info[uniqueId] == uniqueId{ UIApplication.sharedApplication().cancelLocalNotification(notifyCancel) }else{ println("No Local Notification Found!") } } } </code></pre>
<p>iMOBDEV's <a href="http://stackoverflow.com/a/6495321/2829102">solution</a> works perfectly to remove a specific notification (e.g. after deleting the alarm) but it's specially useful when you need to selectively remove any notification that has already fired and is still on the notification center. </p> <p>A possible scenario would be: the notification for an alarm fires, but the user opens the app without tapping on that notification and schedules that alarm again. If you want to make sure only one notification can be on the notification center for a given item/alarm, it's a good approach. It also allows you not having to clear all notifications every time the app is opened, shall that fit the app better.</p> <ul> <li>Upon creating a local notification, use NSKeyedArchiver to store it as NSData in NSUserDefaults. You can create a key equal to what you're saving in the notification's userInfo dictionary. If it's associated with a Core Data object, you could use its unique objectID property. </li> <li>Retrieve it with NSKeyedUnarchiver. Now you're able to delete it using the cancelLocalNotification method.</li> <li>Update the key on NSUserDefaults accordingly.</li> </ul> <p>Here's a Swift version of that solution (for targets below iOS 10):</p> <p><strong>Store</strong></p> <pre><code>// localNotification is the UILocalNotification you've just set up UIApplication.sharedApplication().scheduleLocalNotification(localNotification) let notificationData = NSKeyedArchiver.archivedDataWithRootObject(localNotification) NSUserDefaults.standardUserDefaults().setObject(notificationData, forKey: "someKeyChosenByYou") </code></pre> <p><strong>Retrieve and delete</strong></p> <pre><code>let userDefaults = NSUserDefaults.standardUserDefaults() if let existingNotificationData = userDefaults.objectForKey("someKeyChosenByYou") as? NSData, existingNotification = NSKeyedUnarchiver.unarchiveObjectWithData(existingNotificationData) as? UILocalNotification { // Cancel notification if scheduled, delete it from notification center if already delivered UIApplication.sharedApplication().cancelLocalNotification(existingNotification) // Clean up userDefaults.removeObjectForKey("someKeyChosenByYou") } </code></pre>
<p>I use this function in Swift 2.0:</p> <pre><code> static func DeleteNotificationByUUID(uidToDelete: String) -&gt; Bool { let app:UIApplication = UIApplication.sharedApplication() // loop on all the current schedualed notifications for schedualedNotif in app.scheduledLocalNotifications! { let notification = schedualedNotif as UILocalNotification let urrentUi = notification.userInfo! as! [String:AnyObject] let currentUid = urrentUi["uid"]! as! String if currentUid == uidToDelete { app.cancelLocalNotification(notification) return true } } return false } </code></pre> <p>Inspired from @KingofBliss's Answer</p>
<p>I expanded on KingofBliss's answer a little, written this a little more Swift2-like, removed some unnecessary code, and added in some crash guards.</p> <p>To start, when creating the notification, you need to make sure you set the uid (or any custom property really) of the notification's <code>userInfo</code>:</p> <pre><code>notification.userInfo = ["uid": uniqueid] </code></pre> <p>Then, when deleting it, you can do:</p> <pre><code>guard let app: UIApplication = UIApplication.sharedApplication(), let notifications = app.scheduledLocalNotifications else { return } for notification in notifications { if let userInfo = notification.userInfo, let uid: String = userInfo["uid"] as? String where uid == uidtodelete { app.cancelLocalNotification(notification) print("Deleted local notification for '\(uidtodelete)'") } } </code></pre>
<p>You can keep a string with the category identifier when scheduling the notification like so</p> <pre><code> localNotification.category = NotificationHelper.categoryIdentifier </code></pre> <p>and search for it and cancel when needed like so</p> <pre><code>let app = UIApplication.sharedApplication() for notification in app.scheduledLocalNotifications! { if let cat = notification.category{ if cat==NotificationHelper.categoryIdentifier { app.cancelLocalNotification(notification) break } } } </code></pre>