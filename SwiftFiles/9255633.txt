Front facing camera in UIImagePickerController
<p>I am developing the front facing camera app in iPad2 by using the <code>UIImagePickerController</code>.</p> <p>When I capture the image it's shows as flipped from left to right.</p> <p>How do I correct this?</p> <pre><code>if ([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera]) { UIImagePickerController *imgPkr = [[UIImagePickerController alloc] init]; imgPkr.delegate = self; imgPkr.sourceType = UIImagePickerControllerSourceTypeCamera; imgPkr.cameraDevice=UIImagePickerControllerCameraDeviceFront; UIImageView *anImageView=[[UIImageView alloc] initWithImage:[UIImage imageNamed:[NSString stringWithFormat:@"select%d.png",val]]]; anImageView.frame = CGRectMake(0, 0, anImageView.image.size.width, anImageView.image.size.height); imgPkr.cameraOverlayView = anImageView; [theApp.TabViewControllerObject presentModalViewController:imgPkr animated:YES]; [imgPkr release]; } </code></pre>
<p>You can flip the image from the source image use this</p> <pre><code>UIImage *flippedImage = [UIImage imageWithCGImage:picture.CGImage scale:picture.scale orientation:UIImageOrientationLeftMirrored]; </code></pre> <hr> <p><strong>Edit:</strong> Added swift code</p> <pre><code>let flippedImage = UIImage(CGImage: picture.CGImage, scale: picture.scale, orientation:.LeftMirrored) </code></pre>
<p>I had the same problem - and the solution above only got me half the answer, because the user had to approve the mirrored image before getting to the next page of my app - where I use the captured image after flipping it.</p> <p>To solve this I had to flip the camera view whenever I switch to the front facing camera:</p> <pre><code>- (IBAction)flipCamera:(id)sender { if(cameraUI.cameraDevice == UIImagePickerControllerCameraDeviceFront) { cameraUI.cameraDevice = UIImagePickerControllerCameraDeviceRear; } else { cameraUI.cameraDevice = UIImagePickerControllerCameraDeviceFront; } cameraUI.cameraViewTransform = CGAffineTransformScale(cameraUI.cameraViewTransform, -1, 1); } </code></pre> <hr> <p>Just to expand on this great answer, some typical complete code, Dec2013, iOS7 / Xcode5. Does everything. You just need an icon (cameraToggle.PNG in the example).</p> <pre><code>-(void)showTheDeviceCamera { if ( ! [UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera] ) return; // self.cameraController is a UIImagePickerController self.cameraController = [[UIImagePickerController alloc] init]; self.cameraController.delegate = (id)self; self.cameraController.mediaTypes = @[(NSString *)kUTTypeImage]; self.cameraController.allowsEditing = YES; self.cameraController.sourceType = UIImagePickerControllerSourceTypeCamera; [self presentViewController:self.cameraController animated:YES completion:NULL]; // Add front-rear toggle button MANUALLY, IF NECESSARY // (You seem to usually get it for free, on iPhone, but // need to add manually on an iPad.) UIView *buttonView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"cameraToggle"]]; [buttonView sizeToFit]; buttonView.userInteractionEnabled = YES; [self.cameraController.view addSubview:buttonView]; UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(_frontRearButtonClicked) ]; tap.numberOfTapsRequired = 1; [buttonView addGestureRecognizer:tap]; // we'll add it at the top right .. could be anywhere you want buttonView.center = CGPointMake( self.cameraController.view.frame.size.width-buttonView.frame.size.width, 3.0 * buttonView.frame.size.height ); } -(void)_frontRearButtonClicked { [UIView transitionWithView:self.cameraController.view duration:1.0 options:UIViewAnimationOptionAllowAnimatedContent | UIViewAnimationOptionTransitionFlipFromLeft animations:^{ if ( self.cameraController.cameraDevice == UIImagePickerControllerCameraDeviceRear ) self.cameraController.cameraDevice = UIImagePickerControllerCameraDeviceFront; else self.cameraController.cameraDevice = UIImagePickerControllerCameraDeviceRear; } completion:NULL]; } </code></pre>
<p>As the other answers, I had the same problem. As Yonatan Betzer mentioned, just flip the final image is only half the answer, because the preview image, displayed by the UIPickerController when you take a picture with the front camera, it's still inverted (mirrored).</p> <p>Yonatan Betzer's anwser works great, but he did not mentioned how or where to put the action to change the camera device.</p> <p>Based in some codes from internet, I created a Pod to get this wanted behavior: </p> <p><a href="https://github.com/lucasecf/LEMirroredImagePicker">https://github.com/lucasecf/LEMirroredImagePicker</a></p> <p>After installed, you just have to call this two lines of code together with your <code>UIImagePickerController</code>:</p> <pre><code>self.mirrorFrontPicker = [[LEMirroredImagePicker alloc] initWithImagePicker:pickerController]; [self.mirrorFrontPicker mirrorFrontCamera]; </code></pre> <p>And thats it, simply as that. You can check for more informations in the README of the github link.</p>
<p>Just to add how I have just achieved this without subclassing UIImagePickerController and without adding extra buttons to the camera view.</p> <p>Simply listen for this notification which is fired several times whenever the camera is changed:</p> <pre><code>[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(cameraChanged:) name:@"AVCaptureDeviceDidStartRunningNotification" object:nil]; </code></pre> <p>Then use this method to flip the camera view:</p> <pre><code>- (void)cameraChanged:(NSNotification *)notification { if(imagePicker.cameraDevice == UIImagePickerControllerCameraDeviceFront) { imagePicker.cameraViewTransform = CGAffineTransformIdentity; imagePicker.cameraViewTransform = CGAffineTransformScale(imagePicker.cameraViewTransform, -1, 1); } else { imagePicker.cameraViewTransform = CGAffineTransformIdentity; } } </code></pre>
<p>I know this question is really old but it seems like this is a still a common problem. Just set a <code>CGAffineTransform</code> on the <code>cameraViewTransform</code> property on a <code>UIImagePickerController</code> object. </p> <pre><code>let picker = UIImagePickerController() picker.cameraViewTransform = CGAffineTransformScale(picker.cameraViewTransform, -1, 1) </code></pre>
<p>Full Working Example in <strong>Swift</strong>, which answers to the initial question of this post (tested on an iPhone 5c using iOS 8.2):</p> <pre><code> import UIKit class ViewController: UIViewController, UIImagePickerControllerDelegate, UINavigationControllerDelegate, UIActionSheetDelegate { @IBOutlet var myUIImageView: UIImageView! var myUIImagePickerController: UIImagePickerController! override func viewDidLoad() { super.viewDidLoad() } override func viewWillAppear(animated: Bool) { println("viewWillAppear(animated: Bool) method called.") super.viewWillAppear(animated) NSNotificationCenter.defaultCenter().removeObserver(self) } override func viewWillDisappear(animated: Bool) { println("viewWillDisappear(animated: Bool) method called.") super.viewWillDisappear(animated) NSNotificationCenter.defaultCenter().addObserver(self, selector: "cameraChanged:", name: "AVCaptureDeviceDidStartRunningNotification", object: nil) } /* UIImagePickerControllerDelegate Section */ func imagePickerController(picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [NSObject : AnyObject]) { if(self.myUIImagePickerController.sourceType == UIImagePickerControllerSourceType.Camera) { self.myUIImageView.image = info[UIImagePickerControllerEditedImage] as? UIImage } else { self.myUIImageView.image = info[UIImagePickerControllerOriginalImage] as? UIImage } self.dismissViewControllerAnimated(true, completion: nil) } func imagePickerControllerDidCancel(picker: UIImagePickerController) { self.dismissViewControllerAnimated(true, completion: nil) } /* You can choose to use one of the UIResponder methods: touchesBegan, touchesMoved, touchesEnded etc, in order to detect the touch on the UIImageView. */ override func touchesEnded(touches: NSSet, withEvent event: UIEvent) { let touch: UITouch? = touches.anyObject() as? UITouch if (touch?.view == myUIImageView) { println("myUIImageView has been tapped by the user.") self.takingAPictureUsingTheCamera() } } func takingAPictureUsingTheCamera() { self.myUIImagePickerController = UIImagePickerController() self.myUIImagePickerController.delegate = self // Set the delegate self.myUIImagePickerController.sourceType = UIImagePickerControllerSourceType.Camera self.myUIImagePickerController.cameraDevice = UIImagePickerControllerCameraDevice.Front // self.myUIImagePickerController.editing = true self.myUIImagePickerController.allowsEditing = true self.presentViewController(self.myUIImagePickerController, animated: true, completion: nil) } func cameraChanged(notification: NSNotification) { println("cameraChanged(notification: NSNotification) method called.") self.myUIImagePickerController.cameraViewTransform = CGAffineTransformIdentity if(self.myUIImagePickerController.cameraDevice == UIImagePickerControllerCameraDevice.Front){ self.myUIImagePickerController.cameraViewTransform = CGAffineTransformScale(self.myUIImagePickerController.cameraViewTransform, -1, 1) } } }// End class </code></pre>
<p>I tried all answers described here, but none of them offered the result I was looking for. Eiter the whole <code>UIImagePickerViewController</code> was transformed, so the camera was unintuitive, not like looking into a mirror, or only the image was transformed afterwards, what was working fine but you have a wrong preview of the image in-between. So I ended up with this hack, it's definitely not best-practice but works on iOS8 and 9 and gives me the result I need.</p> <p>Make sure you add a observer to get notified when the capture image button was pressed:</p> <pre><code>NSNotificationCenter.defaultCenter().addObserver(self, selector: "photoTaken", name: "_UIImagePickerControllerUserDidCaptureItem", object: nil) </code></pre> <p>In the <code>potoTaken</code> method you can do something like this to find the preview image and transform it to look like you expect it:</p> <pre><code>func photoTaken() { for subview in self.imagePicker.view.subviews { for subsubview in subview.subviews { for subsubsubview in subsubview.subviews { for subsubsubsubview in subsubsubview.subviews { for subsubsubsubsubview in subsubsubsubview.subviews { for subsubsubsubsubsubview in subsubsubsubsubview.subviews { for subsubsubsubsubsubsubview in subsubsubsubsubsubview.subviews { if subsubsubsubsubsubsubview.isKindOfClass(UIImageView) { subsubsubsubsubsubsubview.transform = CGAffineTransformScale(self.imagePicker.cameraViewTransform, -1, 1) } } } } } } } } } </code></pre> <p>And in your <code>didFinishPickingMediaWithInfo</code> delegate flip the image again before saving or displaying it.</p> <pre><code>func imagePickerController(picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : AnyObject]) { if let pickedImage = info[UIImagePickerControllerOriginalImage] as? UIImage { let flippedImage = UIImage(CGImage: pickedImage.CGImage!, scale: pickedImage.scale, orientation: .LeftMirrored) myCustomPhotoAlbum.sharedInstance.saveImage(flippedImage) self.imageView.image = flippedImage } self.dismissViewControllerAnimated(true, completion: nil) } </code></pre>
<p>It looks like <code>AVCaptureDeviceDidStartRunningNotification</code> is no longer available as a means of detecting camera device changes. Also, the <code>cameraDevice</code> property on <code>UIImagePickerController</code> doesn't work with KVO. However, it's still possible to detect camera device changes, as shown below (though long-term support for this solution isn't guaranteed as we're using KVO on a property that isn't explicitly marked as KVO-compliant).</p> <pre><code>import AVFoundation var context = 0 override func viewDidLoad() { super.viewDidLoad() // Register for notifications let notificationCenter = NSNotificationCenter.defaultCenter() notificationCenter.addObserver(self, selector: #selector(handleCaptureSessionDidStartRunning(_:)), name: AVCaptureSessionDidStartRunningNotification, object: nil) notificationCenter.addObserver(self, selector: #selector(handleCaptureSessionDidStopRunning(_:)), name: AVCaptureSessionDidStopRunningNotification, object: nil) } deinit { NSNotificationCenter.defaultCenter().removeObserver(self) } func handleCaptureSessionDidStartRunning(notification: NSNotification) { guard let session = notification.object as? AVCaptureSession else { return } session.addObserver(self, forKeyPath: "inputs", options: [ .Old, .New ], context: &amp;context) } func handleCaptureSessionDidStopRunning(notification: NSNotification) { guard let session = notification.object as? AVCaptureSession else { return } session.removeObserver(self, forKeyPath: "inputs") } override func observeValueForKeyPath(keyPath: String?, ofObject object: AnyObject?, change: [String : AnyObject]?, context: UnsafeMutablePointer&lt;Void&gt;) { if context == &amp;self.context { if let inputs = change?[NSKeyValueChangeNewKey] as? [AnyObject], captureDevice = (inputs.first as? AVCaptureDeviceInput)?.device { switch captureDevice.position { case .Back: print("Switched to back camera") case .Front: print("Switched to front camera") case .Unspecified: break } } } else { super.observeValueForKeyPath(keyPath, ofObject: object, change: change, context: context) } } </code></pre>