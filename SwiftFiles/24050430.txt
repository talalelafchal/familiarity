Calling a global function which has the same name as a member function
<p>The <code>Array</code> type in Swift has a member function called <code>sort</code>, with its signature being <code>sort(isOrderedBefore: (T, T) -&gt; Bool)</code>. This function differs from the global version of <code>sort</code>, which has the signature <code>sort(array: T[], pred: (T, T) -&gt; Bool)</code>.</p> <p>If one extends an <code>Array</code> (see <a href="http://stackoverflow.com/q/24050102/1371070">Why does the same method fail when inside an Array extension in Swift?</a>), calling <code>sort</code> from inside the scope of the <code>Array</code> extension will naturally result in the local version being used.</p> <p>Is it possible to explicitly call a function from an outer scope, or specifically from the global scope, even if its name coincides with that of a function from an inner scope?</p> <p>This would be similar to the C++ scoping resolution operator, <code>::</code></p>
<p>Wrap the global <code>sort</code>, for example,</p> <pre><code>func my_sort&lt;T&gt;(arr: T[], pred: (T, T) -&gt; Bool) -&gt; T[] { return sort(arr, pred) } </code></pre>
<p><a href="https://twitter.com/clattner_llvm/status/474772713739792384">Chris Lattner suggests</a> qualifying the name of the global function with Swift's default namespace, <code>Swift</code>. So you should be able to access the global version using: <code>Swift.sort</code>.</p>