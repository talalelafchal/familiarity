Swift performSelector: withObject: afterDelay:
<p>I have an app in Objective C that I'm transitioning to Swift. In Objective C, I have this method:</p> <p><code>[self.view performSelector:@selector(someSelector) withObject:self afterDelay:0.1f];</code></p> <p>I'm working with Swift and I can't figure out how to do this. I've tried:</p> <p><code>self.view.performSelector(Selector("someSelector"), withObject: self, afterDelay: 0.1)</code></p> <p>Here's the error that I get: <code>'performSelector' is unavailable: 'performSelector' methods are unavailable</code></p> <p>What call would I use to call a method <code>afterDelay</code>?</p> <p><strong>UPDATE</strong></p> <p>Here's what I ended up with:</p> <pre><code>extension NSObject { func callSelectorAsync(selector: Selector, object: AnyObject?, delay: NSTimeInterval) -&gt; NSTimer { let timer = NSTimer.scheduledTimerWithTimeInterval(delay, target: self, selector: selector, userInfo: object, repeats: false) return timer } func callSelector(selector: Selector, object: AnyObject?, delay: NSTimeInterval) { let delay = delay * Double(NSEC_PER_SEC) let time = dispatch_time(DISPATCH_TIME_NOW, Int64(delay)) dispatch_after(time, dispatch_get_main_queue(), { NSThread.detachNewThreadSelector(selector, toTarget:self, withObject: object) }) } } </code></pre>
<p>Swift is statically typed so the <code>performSelector:</code> methods are to fall by the wayside.</p> <p>Instead, use GCD to dispatch a suitable block to the relevant queue â€” in this case it'll presumably be the main queue since it looks like you're doing UIKit work.</p> <p>EDIT: the relevant <code>performSelector:</code> is also notably missing from <a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html">the Swift version of the <code>NSRunLoop</code> documentation</a> ("1 Objective-C symbol hidden") so you can't jump straight in with that. With that and its absence from the Swiftified <code>NSObject</code> I'd argue it's pretty clear what Apple is thinking here.</p>
<p>As you did with Objective-C, use simply:</p> <p><strong>Swift 3</strong></p> <pre><code>let dispatchTime = DispatchTime.now() + .seconds(0.1) DispatchQueue.main.asyncAfter(deadline: dispatchTime) { // your function here } </code></pre> <p><strong>Swift 2</strong></p> <pre><code>let dispatchTime: dispatch_time_t = dispatch_time(DISPATCH_TIME_NOW, Int64(0.1 * Double(NSEC_PER_SEC))) dispatch_after(dispatchTime, dispatch_get_main_queue(), { // your function here }) </code></pre> <p>There's no need to add unnecessary overhead instantiating an <code>NSTimer</code>.</p> <p>The one caveat (and frustration) that you'll notice is that Xcode's auto-complete doesn't populate these in Swift like it does in Objective-C.</p> <p>Here's a collection of github gists that expand on it: <a href="https://gist.github.com/calebd/3ec29b084f31e41dbc76" rel="nofollow">https://gist.github.com/calebd/3ec29b084f31e41dbc76</a></p> <p>And finally, a <strong>massive</strong> shout-out to <a href="http://stackoverflow.com/a/24318861/1214800">@matt's answer here</a> which wraps the entire block in a neat global function that can be used anywhere in your app, so that instead of <em>that</em> complicated code, you can do:</p> <pre><code>delay(n) { // stuff! } </code></pre>
<p>You could do this: </p> <pre><code>var timer = NSTimer.scheduledTimerWithTimeInterval(0.1, target: self, selector: Selector("someSelector"), userInfo: nil, repeats: false) func someSelector() { // Something after a delay } </code></pre>