NSTableView: detecting a mouse click together with the row and column
<p>I'm trying to detect when a mouse click occurs in an NSTableView, and when it does, to determine the row and column of the cell that was clicked.</p> <p>So far I've tried to use NSTableViewSelectionDidChangeNotification, but there are two problems: </p> <ol> <li>It only triggers when the selection changes, whereas I want every mouse click, even if it is on the currently selected row.</li> <li>The clickedRow and clickedColumn properties of NSTableView are both -1 when my delegate is called.</li> </ol> <p>Is there a better (and correct) way of doing this?</p>
<p>I would prefer doing as follows.</p> <p>Override</p> <pre><code>-(BOOL)tableView:(NSTableView *)tableView shouldSelectRow:(NSInteger)row; </code></pre> <p>Provide super implementation;</p> <pre><code>RequiredRow = row; RequiredColumn = [tableView clickedColumn]; </code></pre> <p>Hope this helps.</p>
<p>To catch the user clicking a row (only, when the user clicks a row, not when it is selected programmatically) :</p> <p><strong>Subclass your NSTableView and declare an protocol</strong></p> <p><em>MyTableView.h</em></p> <pre><code>@protocol ExtendedTableViewDelegate &lt;NSObject&gt; - (void)tableView:(NSTableView *)tableView didClickedRow:(NSInteger)row; @end @interface MyTableView : NSTableView @property (nonatomic, weak) id&lt;ExtendedTableViewDelegate&gt; extendedDelegate; @end </code></pre> <p><em>MyTableView.m</em></p> <p><strong>Handle the mouse down event</strong> (note, the delegate callback is not called when the user clicks outside, maybe you want to handle that too, in that case, just comment out the condition "<code>if (clickedRow != -1)</code>")</p> <pre><code>- (void)mouseDown:(NSEvent *)theEvent { NSPoint globalLocation = [theEvent locationInWindow]; NSPoint localLocation = [self convertPoint:globalLocation fromView:nil]; NSInteger clickedRow = [self rowAtPoint:localLocation]; [super mouseDown:theEvent]; if (clickedRow != -1) { [self.extendedDelegate tableView:self didClickedRow:clickedRow]; } } </code></pre> <p><strong>Make your WC, VC conform to ExtendedTableViewDelegate</strong>. </p> <pre><code>@interface MyViewController : DocumentBaseViewController&lt;ExtendedTableViewDelegate, NSTableViewDelegate, NSTableViewDataSource&gt; </code></pre> <p><strong>set the extendedDelegate of the MyTableView to your WC, VC (MyViewController)</strong></p> <p>somewhere in <em>MyTableView.m</em></p> <pre><code>self.myTableView.extendedDelegate = self </code></pre> <p><strong>Implement the callback in delegate (MyViewController.m)</strong></p> <pre><code>- (void)tableView:(NSTableView *)tableView didClickedRow:(NSInteger)row { // have fun } </code></pre>
<p>see the <strong>tableViewSelectionIsChanging</strong> notification, here are the the comments from NSTableView.h</p> <p>/* Optional - Called when the selection is about to be changed, but note, tableViewSelectionIsChanging: is only called when mouse events are changing the selection and not keyboard events. */</p> <p>I concede that this might not be the surest way to correlate your mouse clicks, but it is another area to investigate, seeing that you are interested in mouse clicks.</p>
<p>Just in case someone was looking for it in <strong>SWIFT</strong> and / or for <strong>NSOutlineView</strong>.</p> <p>Based on @Peter Lapisu instructions.</p> <pre><code>class MYOutlineViewDelegate: NSOutlineView, NSOutlineViewDelegate,NSOutlineViewDataSource{ //.... } extension MYOutlineViewDelegate{ func outlineView(outlineView: NSOutlineView, didClickTableRow item: AnyObject?) { //Click stuff } override func mouseDown(theEvent: NSEvent) { let globalLocation:NSPoint = theEvent.locationInWindow let localLocation:NSPoint = self.convertPoint(globalLocation, fromView: nil) let clickedRow:Int = self.rowAtPoint(localLocation) super.mouseDown(theEvent) if (clickedRow != -1) { self.outlineView(self, didClickTableRow: self.itemAtRow(clickedRow)) } }} </code></pre>