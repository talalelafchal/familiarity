Swift function swizzling / runtime
<p>Before Swift, in Objective-C I would swizzle or hook methods in a class using <code>&lt;objc/runtime.h&gt;</code>.</p> <p>If anyone has any info on the topic of modifying Swift's runtime and hooking functions like CydiaSubstrate and other libraries that helped in this area, please inform me.</p>
<p>You would likely be able to swizzle swift-generated classes that inherit from Objective-C classes with no problem, since they appear to use dynamic method dispatch all the time. You may be able to swizzle methods of swift-defined classes that exist in the Objective-C runtime by virtue of being passed across the bridge, but the Objective-C side methods are likely to just be proxies back across the bridge to the swift-side runtime, so it's not clear that it'd be particularly helpful to swizzle them.</p> <p>"Pure" swift method calls do not appear to be dispatched dynamically via anything like <code>objc_msgSend</code> and it appears (from brief experimentation) that the type safety of swift is implemented at compile time, and that much of the actual type information is absent (i.e. gone) at runtime for non-class types (both of which likely contribute to the purported speed advantages of swift.) </p> <p>For these reasons, I expect that meaningfully swizzling swift-only methods will be significantly harder than swizzling Objective-C methods, and will probably look a lot more like <code>mach_override</code> than Objective-C method swizzling.</p>
<p>I've succeed with method swizzling in Swift. This example shows how to hook description method on NSDictionary</p> <p>My implementation:</p> <pre><code>extension NSDictionary { func myDescription() -&gt; String!{ println("Description hooked") return "Hooooked " + myDescription(); } } </code></pre> <p>Swizzling code: </p> <pre><code>func swizzleEmAll() { var dict:NSDictionary = ["SuperSecret": kSecValueRef] var method: Method = class_getInstanceMethod(object_getClass(dict), Selector.convertFromStringLiteral("description")) println(dict.description) // Check original description var swizzledMethod: Method = class_getInstanceMethod(object_getClass(dict), Selector.convertFromStringLiteral("myDescription")) method_exchangeImplementations(method, swizzledMethod) println(dict.description) //Check that swizzling works } </code></pre> <p><strong>Edited:</strong> This code will work for any custom Swift class that inherits from <strong>NSObject</strong> (but will not work for classes that don't.) More examples - <a href="https://github.com/mbazaliy/MBSwizzler">https://github.com/mbazaliy/MBSwizzler</a></p>
<p>I wouldn't do it that way, I think closures provide the answers (as they give you a chance to intercept, evaluate, and forward the invocation of the function, additionally it will be easy to extend when and if we have reflection. </p> <p><a href="http://www.swift-studies.com/blog/2014/7/13/method-swizzling-in-swift" rel="nofollow">http://www.swift-studies.com/blog/2014/7/13/method-swizzling-in-swift</a></p>
<p>After spending some time on it... Wake up this morning.... beta 6 is out and Problem Fixed in beta6! From release notes "Dynamic dispatch can now call overrides of methods and properties introduced in class extensions, fixing a regression introduced in Xcode 6 beta 5. (17985819)!"</p>
<p>I would like to extend the great answer provided by <strong>mbazaliy</strong>.</p> <p>Another way of doing swizzling in Swift is by providing an implementation using an Objective-C block.</p> <p>e.g. to replace <code>description</code>method on class <code>NSString</code> we can write:</p> <pre><code>let originalMethod = class_getInstanceMethod(NSString.self, "description") let impBlock : @objc_block () -&gt; NSString = { () in return "Bit of a hack job!" } let newMethodImp = imp_implementationWithBlock(unsafeBitCast(impBlock, AnyObject.self)) method_setImplementation(originalMethod, newMethodImp) </code></pre> <p>This works as of Swift 1.1.</p>
<p>I'm answering this question more than one year later because none of the other answers provide the definitive set of requirements for method swizzling for every kind of class.</p> <p>What is described by other, while it will work flawlessly for extensions to foundation/uikit classes (like NSDictionary), will simply <strong>never</strong> work for your own Swift classes.</p> <p>As described <a href="https://stackoverflow.com/questions/33096873/method-swizzling-does-not-work/33097636#comment54010803_33097636">here</a>, there is an additional requirement for method swizzling other than extending NSObject in your custom class. </p> <p>The swift method you want to swizzle <strong>must be marked</strong> <code>dynamic</code>.</p> <p>If you don't mark it, the runtime will simply continue to call the original method instead of the swizzled one, even if the method pointers appear to have been swapped correctly.</p> <h2>Update:</h2> <p>I've expanded this answer <a href="https://www.uraimo.com/2015/10/23/effective-method-swizzling-with-swift/" rel="nofollow">in a blog post</a>.</p>
<p>I had a Xcode 7 iOS project written in Swift 2, using Cocoapods. In a specific Cocoapod, with Objective-C source, I wanted to override a short method, without forking the pod. Writing a Swift extension wouldn't work in my case.</p> <p>For using method swizzling, I created a new Objective-C class in my main bundle with the method I wanted to replace/inject into the cocoapod. (Also added the bridging header) </p> <p>Using mbazaliy 's <a href="http://stackoverflow.com/a/24048694/396429">solution on stackflow</a>, I put my code similar to this into the <code>didFinishLaunchingWithOptions</code> in my Appdelegate:</p> <pre><code> let mySelector: Selector = "nameOfMethodToReplace" let method: Method = class_getInstanceMethod(SomeClassInAPod.self, mySelector) let swizzledMethod: Method = class_getInstanceMethod(SomeOtherClass.self, mySelector) method_exchangeImplementations(method, swizzledMethod) </code></pre> <p>This worked perfectly. The difference between @mbazaliy 's code is that I didn't need to create an instance of the <code>SomeClassInAPod</code> class first, which in my case would have been impossible.</p> <p>Note: I put the code in the Appdelegate because every other time the code runs, it exchanges the method for the original - it should only run one time.</p> <p>I also needed to copy some assets that were referenced in the Pod's bundle to the main bundle.</p>