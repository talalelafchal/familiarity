Literal String vs. `String` in swift
<p>Playing with swift I found this surprising:</p> <pre><code>"123".integerValue // &lt;= returns 123 var x = "123" x.integerValue // &lt;= Error: String does not have a member named integerValue </code></pre> <p>Can someone explain?</p>
<p>My guess is that in the first example the compiler uses the call to <code>integerValue</code> as additional information to infer the type (choosing between NSString and a Swift String).</p> <p>In the second example it probably defaults to a Swift String because it doesn't evaluate multiple lines.</p>
<p>I believe this is an example of type inference in action. When you do: <code>"123".integerValue</code> the compiler detects that in this case you want to use an <code>NSString</code> (which it also does when you use string literals as arguments to objective-c functions.</p> <p>A similar example is:</p> <pre><code>// x is an Int let x = 12 // here we tell the compiler that y is a Double explicitly let y: Double = 12 // z is a Double because 2.5 is a literal Double and so "12" is also // parsed as a literal Double let z = 12 * 2.5 </code></pre>
<p>If you do:</p> <pre><code>var x = "123" as NSString x.integerValue var x : NSString = "123" // or this as Sulthan suggests </code></pre> <p>it won't show that error. </p> <p>I think your first example is automatically picking up that you want to use a NSString as NSString only has this .integerValue call.</p> <p>The second example is probably failing because it's not being told what it is and deciding to use a swift string instead.</p>
<p>Use <code>.toInt()</code></p> <pre><code>var x = "123" var num: Int = x.toInt() </code></pre>