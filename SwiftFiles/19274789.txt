How can I change image tintColor in iOS and WatchKit
<p>I have an UIImageView called "theImageView", with UIImage in a single color (transparent background) just like the left black heart below. How can I change the tint color of this image programmatically in iOS 7 or above, as per the tint method used in the iOS 7+ Navigation Bar icons?</p> <p>Can this method also work in WatchKit for an Apple Watch app?</p> <p><img src="https://i.stack.imgur.com/6GiCO.jpg" alt="enter image description here"></p>
<p>Here's a category that should do the trick</p> <pre><code>@interface UIImage(Overlay) @end @implementation UIImage(Overlay) - (UIImage *)imageWithColor:(UIColor *)color1 { UIGraphicsBeginImageContextWithOptions(self.size, NO, self.scale); CGContextRef context = UIGraphicsGetCurrentContext(); CGContextTranslateCTM(context, 0, self.size.height); CGContextScaleCTM(context, 1.0, -1.0); CGContextSetBlendMode(context, kCGBlendModeNormal); CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height); CGContextClipToMask(context, rect, self.CGImage); [color1 setFill]; CGContextFillRect(context, rect); UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return newImage; } @end </code></pre> <p>so you would do:</p> <pre><code>theImageView.image = [theImageView.image imageWithColor:[UIColor redColor]]; </code></pre>
<p>I had to do this in Swift using an <code>extension</code>.</p> <p>I thought I'd share how I did it:</p> <pre><code>extension UIImage { func imageWithColor(color1: UIColor) -&gt; UIImage { UIGraphicsBeginImageContextWithOptions(self.size, false, self.scale) color1.setFill() let context = UIGraphicsGetCurrentContext() as CGContextRef CGContextTranslateCTM(context, 0, self.size.height) CGContextScaleCTM(context, 1.0, -1.0); CGContextSetBlendMode(context, CGBlendMode.Normal) let rect = CGRectMake(0, 0, self.size.width, self.size.height) as CGRect CGContextClipToMask(context, rect, self.CGImage) CGContextFillRect(context, rect) let newImage = UIGraphicsGetImageFromCurrentImageContext() as UIImage UIGraphicsEndImageContext() return newImage } } </code></pre> <p>Usage:</p> <p><code>theImageView.image = theImageView.image.imageWithColor(UIColor.redColor())</code></p>
<p>Try this</p> <p><a href="http://robots.thoughtbot.com/designing-for-ios-blending-modes" rel="nofollow">http://robots.thoughtbot.com/designing-for-ios-blending-modes</a></p> <p>or</p> <pre><code>- (void)viewDidLoad { [super viewDidLoad]; UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(10, 30, 300, 50)]; label.numberOfLines = 0; label.font = [UIFont systemFontOfSize:13]; label.text = @"These checkmarks use the same gray checkmark image with a tintColor applied to the image view"; [self.view addSubview:label]; [self _createImageViewAtY:100 color:[UIColor purpleColor]]; } - (void)_createImageViewAtY:(int)y color:(UIColor *)color { UIImage *image = [[UIImage imageNamed:@"gray checkmark.png"] imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate]; UIImageView *imageView = [[UIImageView alloc] initWithImage:image]; CGRect frame = imageView.frame; frame.origin.x = 100; frame.origin.y = y; imageView.frame = frame; if (color) imageView.tintColor = color; [self.view addSubview:imageView]; } </code></pre>
<p><strong>iOS</strong><br> For an iOS app, in Swift 3:</p> <pre><code>theImageView.image = theImageView.image!.withRenderingMode(.alwaysTemplate) theImageView.tintColor = UIColor.red </code></pre> <p>Swift 2:</p> <pre><code>theImageView.image = theImageView.image!.imageWithRenderingMode(UIImageRenderingMode.AlwaysTemplate) theImageView.tintColor = UIColor.redColor() </code></pre> <p>Meanwhile, the modern Objective-C solution is:</p> <pre><code>theImageView.image = [theImageView.image imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate]; [theImageView setTintColor:[UIColor redColor]]; </code></pre> <hr> <p><strong>Watchkit</strong><br> In WatchKit for Apple Watch apps, you can set the <a href="https://developer.apple.com/library/prerelease/ios/documentation/WatchKit/Reference/WKInterfaceImage_class/index.html#//apple_ref/occ/instm/WKInterfaceImage/setTintColor:">tint color for a template image</a>. </p> <ol> <li>You must add your image to an Asset Catalog in your WatchKit App, and set the image set to be rendered as a Template Image in the Attributes Inspector. Unlike for an iPhone app, you cannot set the template rendering in code in the WatchKit Extension at present.</li> <li>Set that image to be used in your WKInterfaceImage in interface builder for your app</li> <li>Create an IBOutlet in your WKInterfaceController for the WKInterfaceImage called 'theImage'...</li> </ol> <p>To then set the tint color in Swift 3:</p> <pre><code>theImage.setTintColor(UIColor.red) </code></pre> <p>Swift 2:</p> <pre><code>theImage.setTintColor(UIColor.redColor()) </code></pre> <p>To then set the tint color in Objective-C:</p> <pre><code>[self.theImage setTintColor:[UIColor redColor]]; </code></pre> <p>If you use a template image and do not apply a tint colour, the Global Tint for your WatchKit app will be applied. If you have not set a Global Tint, <code>theImage</code> will be tinted light blue by default when used as a template image.</p>
<p>With Swift</p> <pre><code>let commentImageView = UIImageView(frame: CGRectMake(100, 100, 100, 100)) commentImageView.image = UIImage(named: "myimage.png")!.imageWithRenderingMode(UIImageRenderingMode.AlwaysTemplate) commentImageView.tintColor = UIColor.blackColor() addSubview(commentImageView) </code></pre>
<p>In storyboard and image Assets. you can change this two also:</p> <p>Update the Render Mode to Template Image</p> <p><a href="https://i.stack.imgur.com/Ar2xi.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/Ar2xi.png" alt="Update the Render Mode to Template Image in Image Assets"></a></p> <p>Update the tint Color in Views.</p> <p><a href="https://i.stack.imgur.com/sODBs.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/sODBs.png" alt="Update the tint Color in Views in Views"></a></p>
<p>For change tint of image (<strong>pick</strong>, <strong>classical image</strong>, <strong>photo</strong>) use that :</p> <p><strong>Example image :</strong> <a href="https://i.stack.imgur.com/AESfq.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/AESfq.png" alt="enter image description here"></a> <a href="https://i.stack.imgur.com/LlrqV.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/LlrqV.png" alt="enter image description here"></a></p> <p><strong>Swift 2</strong></p> <pre><code>public extension UIImage { /** Tint, Colorize image with given tint color&lt;br&gt;&lt;br&gt; This is similar to Photoshop's "Color" layer blend mode&lt;br&gt;&lt;br&gt; This is perfect for non-greyscale source images, and images that have both highlights and shadows that should be preserved&lt;br&gt;&lt;br&gt; white will stay white and black will stay black as the lightness of the image is preserved&lt;br&gt;&lt;br&gt; &lt;img src="http://yannickstephan.com/easyhelper/tint1.png" height="70" width="120"/&gt; **To** &lt;img src="http://yannickstephan.com/easyhelper/tint2.png" height="70" width="120"/&gt; - parameter tintColor: UIColor - returns: UIImage */ public func tintPhoto(tintColor: UIColor) -&gt; UIImage { return modifiedImage { context, rect in // draw black background - workaround to preserve color of partially transparent pixels CGContextSetBlendMode(context, .Normal) UIColor.blackColor().setFill() CGContextFillRect(context, rect) // draw original image CGContextSetBlendMode(context, .Normal) CGContextDrawImage(context, rect, self.CGImage) // tint image (loosing alpha) - the luminosity of the original image is preserved CGContextSetBlendMode(context, .Color) tintColor.setFill() CGContextFillRect(context, rect) // mask by alpha values of original image CGContextSetBlendMode(context, .DestinationIn) CGContextDrawImage(context, rect, self.CGImage) } } /** Tint Picto to color - parameter fillColor: UIColor - returns: UIImage */ public func tintPicto(fillColor: UIColor) -&gt; UIImage { return modifiedImage { context, rect in // draw tint color CGContextSetBlendMode(context, .Normal) fillColor.setFill() CGContextFillRect(context, rect) // mask by alpha values of original image CGContextSetBlendMode(context, .DestinationIn) CGContextDrawImage(context, rect, self.CGImage) } } /** Modified Image Context, apply modification on image - parameter draw: (CGContext, CGRect) -&gt; ()) - returns: UIImage */ private func modifiedImage(@noescape draw: (CGContext, CGRect) -&gt; ()) -&gt; UIImage { // using scale correctly preserves retina images UIGraphicsBeginImageContextWithOptions(size, false, scale) let context: CGContext! = UIGraphicsGetCurrentContext() assert(context != nil) // correctly rotate image CGContextTranslateCTM(context, 0, size.height); CGContextScaleCTM(context, 1.0, -1.0); let rect = CGRectMake(0.0, 0.0, size.width, size.height) draw(context, rect) let image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return image } } </code></pre> <p><strong>UPD</strong></p> <p><strong>Swift 3</strong></p> <pre><code>extension UIImage { /** Tint, Colorize image with given tint color&lt;br&gt;&lt;br&gt; This is similar to Photoshop's "Color" layer blend mode&lt;br&gt;&lt;br&gt; This is perfect for non-greyscale source images, and images that have both highlights and shadows that should be preserved&lt;br&gt;&lt;br&gt; white will stay white and black will stay black as the lightness of the image is preserved&lt;br&gt;&lt;br&gt; &lt;img src="http://yannickstephan.com/easyhelper/tint1.png" height="70" width="120"/&gt; **To** &lt;img src="http://yannickstephan.com/easyhelper/tint2.png" height="70" width="120"/&gt; - parameter tintColor: UIColor - returns: UIImage */ func tintPhoto(_ tintColor: UIColor) -&gt; UIImage { return modifiedImage { context, rect in // draw black background - workaround to preserve color of partially transparent pixels context.setBlendMode(.normal) UIColor.black.setFill() context.fill(rect) // draw original image context.setBlendMode(.normal) context.draw(cgImage!, in: rect) // tint image (loosing alpha) - the luminosity of the original image is preserved context.setBlendMode(.color) tintColor.setFill() context.fill(rect) // mask by alpha values of original image context.setBlendMode(.destinationIn) context.draw(context.makeImage()!, in: rect) } } /** Tint Picto to color - parameter fillColor: UIColor - returns: UIImage */ func tintPicto(_ fillColor: UIColor) -&gt; UIImage { return modifiedImage { context, rect in // draw tint color context.setBlendMode(.normal) fillColor.setFill() context.fill(rect) // mask by alpha values of original image context.setBlendMode(.destinationIn) context.draw(cgImage!, in: rect) } } /** Modified Image Context, apply modification on image - parameter draw: (CGContext, CGRect) -&gt; ()) - returns: UIImage */ fileprivate func modifiedImage(_ draw: (CGContext, CGRect) -&gt; ()) -&gt; UIImage { // using scale correctly preserves retina images UIGraphicsBeginImageContextWithOptions(size, false, scale) let context: CGContext! = UIGraphicsGetCurrentContext() assert(context != nil) // correctly rotate image context.translateBy(x: 0, y: size.height) context.scaleBy(x: 1.0, y: -1.0) let rect = CGRect(x: 0.0, y: 0.0, width: size.width, height: size.height) draw(context, rect) let image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return image! } } </code></pre>
<p>Now i use this method based in Duncan Babbage response:</p> <pre><code>+ (UIImageView *) tintImageView: (UIImageView *)imageView withColor: (UIColor*) color{ imageView.image = [imageView.image imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate]; [imageView setTintColor:color]; return imageView; } </code></pre>
<p>For swift 3 purposes</p> <p><code>theImageView.image = theImageView.image!.withRenderingMode(.alwaysTemplate) theImageView.tintColor = UIColor.red</code></p>
<blockquote> <p>You can use this in Swift 3 if you have an image to replace the clear button</p> </blockquote> <pre><code>func addTextfieldRightView(){ let rightViewWidth:CGFloat = 30 let viewMax = self.searchTxt.frame.height let buttonMax = self.searchTxt.frame.height - 16 let buttonView = UIView(frame: CGRect( x: self.searchTxt.frame.width - rightViewWidth, y: 0, width: viewMax, height: viewMax)) let myButton = UIButton(frame: CGRect( x: (viewMax - buttonMax) / 2, y: (viewMax - buttonMax) / 2, width: buttonMax, height: buttonMax)) myButton.setImage(UIImage(named: "BlueClear")!, for: .normal) buttonView.addSubview(myButton) let clearPressed = UITapGestureRecognizer(target: self, action: #selector(SearchVC.clearPressed(sender:))) buttonView.isUserInteractionEnabled = true buttonView.addGestureRecognizer(clearPressed) myButton.addTarget(self, action: #selector(SearchVC.clearPressed(sender:)), for: .touchUpInside) self.searchTxt.rightView = buttonView self.searchTxt.rightViewMode = .whileEditing } </code></pre>