How can I extend typed Arrays in Swift?
<p>How can I extend Swift's <code>Array&lt;T&gt;</code> or <code>T[]</code> type with custom functional utils? </p> <p>Browsing around Swift's API docs shows that Array methods are an extension of the <code>T[]</code>, e.g:</p> <pre><code>extension T[] : ArrayType { //... init() var count: Int { get } var capacity: Int { get } var isEmpty: Bool { get } func copy() -&gt; T[] } </code></pre> <p>When copying and pasting the same source and trying any variations like:</p> <pre><code>extension T[] : ArrayType { func foo(){} } extension T[] { func foo(){} } </code></pre> <p>It fails to build with the error:</p> <blockquote> <p>Nominal type <code>T[]</code> can't be extended</p> </blockquote> <p>Using the full type definition fails with <code>Use of undefined type 'T'</code>, i.e:</p> <pre><code>extension Array&lt;T&gt; { func foo(){} } </code></pre> <p>And it also fails with <code>Array&lt;T : Any&gt;</code> and <code>Array&lt;String&gt;</code>.</p> <p>Curiously Swift lets me extend an untyped array with:</p> <pre><code>extension Array { func each(fn: (Any) -&gt; ()) { for i in self { fn(i) } } } </code></pre> <p>Which it lets me call with:</p> <pre><code>[1,2,3].each(println) </code></pre> <p>But I can't create a proper generic type extension as the type seems to be lost when it flows through the method, e.g trying to <a href="http://stackoverflow.com/q/24025633/85785">replace Swift's built-in filter with</a>:</p> <pre><code>extension Array { func find&lt;T&gt;(fn: (T) -&gt; Bool) -&gt; T[] { var to = T[]() for x in self { let t = x as T if fn(t) { to += t } } return to } } </code></pre> <p>But the compiler treats it as untyped where it still allows calling the extension with: </p> <pre><code>["A","B","C"].find { $0 &gt; "A" } </code></pre> <p>And when stepped-thru with a debugger indicates the type is <code>Swift.String</code> but it's a build error to try access it like a String without casting it to <code>String</code> first, i.e:</p> <pre><code>["A","B","C"].find { ($0 as String).compare("A") &gt; 0 } </code></pre> <p>Does anyone know what's the proper way to create a typed extension method that acts like the built-in extensions?</p>
<p>After a while trying different things the solution seems to remove the <code>&lt;T&gt;</code> from the signature like:</p> <pre><code>extension Array { func find(fn: (T) -&gt; Bool) -&gt; [T] { var to = [T]() for x in self { let t = x as T; if fn(t) { to += t } } return to } } </code></pre> <p>Which now works as intended without build errors:</p> <pre><code>["A","B","C"].find { $0.compare("A") &gt; 0 } </code></pre>
<p>If you want to learn about extending Arrays and other types of build in classes checkout code in this github repo <a href="https://github.com/ankurp/Dollar.swift/tree/master/Cent/Cent" rel="nofollow">https://github.com/ankurp/Dollar.swift/tree/master/Cent/Cent</a></p> <p>As of Xcode 6.1 the syntax to extend arrays is as follows</p> <pre><code>extension Array { func at(indexes: Int...) -&gt; [Element] { ... // You code goes herer } } </code></pre>
<p>I had a look at the Swift 2 standard library headers, and here is the prototype for the filter function, which makes it quite obvious how to roll your own. </p> <pre><code>extension CollectionType { func filter(@noescape includeElement: (Self.Generator.Element) -&gt; Bool) -&gt; [Self.Generator.Element] } </code></pre> <p>It's not an extension to Array, but to CollectionType, so the same method applies to other collection types. @noescape means that the block passed in will not leave the scope of the filter function, which enables some optimisations. Self with a capital S is the class we are extending. Self.Generator is an iterator that iterates through the objects in the collection and Self.Generator.Element is the type of the objects, for example for an array [Int?] Self.Generator.Element would be Int?. </p> <p>All in all this filter method can be applied to any CollectionType, it needs a filter block which takes an element of the collection and returns a Bool, and it returns an array of the original type. So putting this together, here's a method that I find useful: It combines map and filter, by taking a block that maps a collection element to an optional value, and returns an array of those optional values that are not nil. </p> <pre><code>extension CollectionType { func mapfilter&lt;T&gt;(@noescape transform: (Self.Generator.Element) -&gt; T?) -&gt; [T] { var result: [T] = [] for x in self { if let t = transform (x) { result.append (t) } } return result } } </code></pre>
<pre><code>import Foundation extension Array { func calculateMean() -&gt; Double { // is this an array of Doubles? if self.first is Double { // cast from "generic" array to typed array of Doubles let doubleArray = self.map { $0 as! Double } // use Swift "reduce" function to add all values together let total = doubleArray.reduce(0.0, combine: {$0 + $1}) let meanAvg = total / Double(self.count) return meanAvg } else { return Double.NaN } } func calculateMedian() -&gt; Double { // is this an array of Doubles? if self.first is Double { // cast from "generic" array to typed array of Doubles var doubleArray = self.map { $0 as! Double } // sort the array doubleArray.sort( {$0 &lt; $1} ) var medianAvg : Double if doubleArray.count % 2 == 0 { // if even number of elements - then mean average the middle two elements var halfway = doubleArray.count / 2 medianAvg = (doubleArray[halfway] + doubleArray[halfway - 1]) / 2 } else { // odd number of elements - then just use the middle element medianAvg = doubleArray[doubleArray.count / 2 ] } return medianAvg } else { return Double.NaN } } } </code></pre>
<p>For extending typed arrays with <strong>classes</strong>, the below works for me (Swift <strong>2.2</strong>). For example, sorting a typed array:</p> <pre><code>class HighScoreEntry { let score:Int } extension Array where Element:HighScoreEntry { func sort() -&gt; [HighScoreEntry] { return sort { $0.score &lt; $1.score } } } </code></pre> <p>Trying to do this with a <strong>struct</strong> or <strong>typealias</strong> will give an error:</p> <pre><code>Type 'Element' constrained to a non-protocol type 'HighScoreEntry' </code></pre> <p><strong>Update</strong>: </p> <p>To extend typed arrays with <strong>non-classes</strong> use the following approach:</p> <pre><code>typealias HighScoreEntry = (Int) extension SequenceType where Generator.Element == HighScoreEntry { func sort() -&gt; [HighScoreEntry] { return sort { $0 &lt; $1 } } } </code></pre> <p>In <strong>Swift 3</strong> some types have been renamed:</p> <pre><code>extension Sequence where Iterator.Element == HighScoreEntry { // ... } </code></pre>
<p>I had a similar problem - wanted to extend the general Array with a swap() method, which was supposed to take an argument of the same type as the array. But how do you specify the generic type? I found by trial and error that the below worked:</p> <pre><code>extension Array { mutating func swap(x:[Element]) { self.removeAll() self.appendContentsOf(x) } } </code></pre> <p>The key to it was the word 'Element'. Note that I didn't define this type anywhere, it seems automatically exist within the context of the array extension, and refer to whatever the type of the array's elements is.</p> <p>I am not 100% sure what's going on there, but I think it is probably because 'Element' is an associated type of the Array (see 'Associated Types' here <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-ID189" rel="nofollow">https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-ID189</a>)</p> <p>However, I can't see any reference of this in the Array structure reference (<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Reference/Swift_Array_Structure/index.html#//apple_ref/swift/struct/s:Sa" rel="nofollow">https://developer.apple.com/library/prerelease/ios/documentation/Swift/Reference/Swift_Array_Structure/index.html#//apple_ref/swift/struct/s:Sa</a>)... so I'm still a little unsure.</p>
<p>(<em><strong>Swift 2.x</strong></em>)</p> <p>You can also extend the array to conform to a protocol containing blue-rpints for generic type methods, e.g., a protocol containing your custom functional utils for all generic array elements conforming to some type constraint, say protocol <code>MyTypes</code>. The bonus using this approach is that you can write functions taking generic array arguments, with a constraint that these array arguments must conform to your custom function utilities protocol, say protocol <code>MyFunctionalUtils</code>. </p> <p>You can get this behaviour either implicitly, by type constraining the array elements to <code>MyTypes</code>, or---as I will show in the method I describe below---, quite neatly, explicitly, letting your generic array functions header directly show that input arrays conforms to <code>MyFunctionalUtils</code>.</p> <hr> <p>We begin with Protocols <code>MyTypes</code> for use as type constraint; extend the types you want to fit in your generics by this protocol (example below extends fundamental types <code>Int</code> and <code>Double</code> as well as a custom type <code>MyCustomType</code>)</p> <pre><code>/* Used as type constraint for Generator.Element */ protocol MyTypes { var intValue: Int { get } init(_ value: Int) func *(lhs: Self, rhs: Self) -&gt; Self func +=(inout lhs: Self, rhs: Self) } extension Int : MyTypes { var intValue: Int { return self } } extension Double : MyTypes { var intValue: Int { return Int(self) } } // ... /* Custom type conforming to MyTypes type constraint */ struct MyCustomType : MyTypes { var myInt : Int? = 0 var intValue: Int { return myInt ?? 0 } init(_ value: Int) { myInt = value } } func *(lhs: MyCustomType, rhs: MyCustomType) -&gt; MyCustomType { return MyCustomType(lhs.intValue * rhs.intValue) } func +=(inout lhs: MyCustomType, rhs: MyCustomType) { lhs.myInt = (lhs.myInt ?? 0) + (rhs.myInt ?? 0) } </code></pre> <p>Protocol <code>MyFunctionalUtils</code> (holding blueprints our additional generic array functions utilities) and thereafter, the extension of Array by <code>MyFunctionalUtils</code>; implementation of blue-printed method(s):</p> <pre><code>/* Protocol holding our function utilities, to be used as extension o Array: blueprints for utility methods where Generator.Element is constrained to MyTypes */ protocol MyFunctionalUtils { func foo&lt;T: MyTypes&gt;(a: [T]) -&gt; Int? // ... } /* Extend array by protocol MyFunctionalUtils and implement blue-prints therein for conformance */ extension Array : MyFunctionalUtils { func foo&lt;T: MyTypes&gt;(a: [T]) -&gt; Int? { /* [T] is Self? proceed, otherwise return nil */ if let b = self.first { if b is T &amp;&amp; self.count == a.count { var myMultSum: T = T(0) for (i, sElem) in self.enumerate() { myMultSum += (sElem as! T) * a[i] } return myMultSum.intValue } } return nil } } </code></pre> <p>Finally, tests and two examples showing a function taking generic arrays, with the following cases, respectively</p> <ol> <li><p>Showing <em>implicit</em> assertion that the array parameters conform to protocol 'MyFunctionalUtils', via type constraining the arrays elements to 'MyTypes' (function <code>bar1</code>).</p></li> <li><p>Showing <em>explicitly</em> that the array parameters conform to protocol 'MyFunctionalUtils' (function <code>bar2</code>).</p></li> </ol> <p>The test and examples follows:</p> <pre><code>/* Tests &amp; examples */ let arr1d : [Double] = [1.0, 2.0, 3.0] let arr2d : [Double] = [-3.0, -2.0, 1.0] let arr1my : [MyCustomType] = [MyCustomType(1), MyCustomType(2), MyCustomType(3)] let arr2my : [MyCustomType] = [MyCustomType(-3), MyCustomType(-2), MyCustomType(1)] /* constrain array elements to MyTypes, hence _implicitly_ constraining array parameters to protocol MyFunctionalUtils. However, this conformance is not apparent just by looking at the function signature... */ func bar1&lt;U: MyTypes&gt; (arr1: [U], _ arr2: [U]) -&gt; Int? { return arr1.foo(arr2) } let myInt1d = bar1(arr1d, arr2d) // -4, OK let myInt1my = bar1(arr1my, arr2my) // -4, OK /* constrain the array itself to protocol MyFunctionalUtils; here, we see directly in the function signature that conformance to MyFunctionalUtils is given for valid array parameters */ func bar2&lt;T: MyTypes, U: protocol&lt;MyFunctionalUtils, _ArrayType&gt; where U.Generator.Element == T&gt; (arr1: U, _ arr2: U) -&gt; Int? { // OK, type U behaves as array type with elements T (=MyTypes) var a = arr1 var b = arr2 a.append(T(2)) // add 2*7 to multsum b.append(T(7)) return a.foo(Array(b)) /* Ok! */ } let myInt2d = bar2(arr1d, arr2d) // 10, OK let myInt2my = bar2(arr1my, arr2my) // 10, OK </code></pre>
<pre><code>import Foundation extension Array { var randomItem: Element? { let idx = Int(arc4random_uniform(UInt32(self.count))) return self.isEmpty ? nil : self[idx] } } </code></pre>
<p><strong>Using Swift 2.2</strong>: I ran into a similar issue when trying to remove duplicates from an array of strings. I was able to add an extension on the Array class that does just what I was looking to do.</p> <pre><code>extension Array where Element: Hashable { /** * Remove duplicate elements from an array * * - returns: A new array without duplicates */ func removeDuplicates() -&gt; [Element] { var result: [Element] = [] for value in self { if !result.contains(value) { result.append(value) } } return result } /** * Remove duplicate elements from an array */ mutating func removeDuplicatesInPlace() { var result: [Element] = [] for value in self { if !result.contains(value) { result.append(value) } } self = result } } </code></pre> <p>Adding these two methods to the Array class allows me to call one of the two methods on an array and successfully remove duplicates. Note that the elements in the array must conform to the Hashable protocol. Now I can do this:</p> <pre><code> var dupes = ["one", "two", "two", "three"] let deDuped = dupes.removeDuplicates() dupes.removeDuplicatesInPlace() // result: ["one", "two", "three"] </code></pre>