How do you access command line arguments in Swift?
<p>How do you access command line arguments for a command line application in Swift?</p>
<p>Use the top level constants <code>C_ARGC</code> and <code>C_ARGV</code>.</p> <pre><code>for i in 1..C_ARGC { let index = Int(i); let arg = String.fromCString(C_ARGV[index]) switch arg { case "this": println("this yo"); case "that": println("that yo") default: println("dunno bro") } } </code></pre> <p>Note that I'm using the range of <code>1..C_ARGC</code> because the first element of the <code>C_ARGV</code> "array" is the application's path.</p> <p>The <code>C_ARGV</code> variable is not actually an array but is sub-scriptable like an array.</p>
<p><strong>Update 09/30/2015:</strong> Updated the example to work in Swift 2.</p> <hr> <p>It's actually possible to do this without Foundation <em>or</em> <code>C_ARGV</code> and <code>C_ARGC</code>.</p> <p>The Swift standard library contains a struct <code>Process</code> which has a collection of <code>String</code>s called <code>arguments</code>. So you could switch on arguments like this:</p> <pre><code>for argument in Process.arguments { switch argument { case "arg1": print("first argument"); case "arg2": print("second argument"); default: print("an argument"); } } </code></pre>
<p>Anyone who wants to use the old "getopt" (which is available in Swift) can use this as reference. I made a Swift port of the GNU example in C one can find at:</p> <p><a href="http://www.gnu.org/software/libc/manual/html_node/Example-of-Getopt.html">http://www.gnu.org/software/libc/manual/html_node/Example-of-Getopt.html</a></p> <p>with a full description. It's tested and fully functional. It doesn't require Foundation either.</p> <pre><code>var aFlag = 0 var bFlag = 0 var cValue = String() let pattern = "abc:" var buffer = Array(pattern.utf8).map { Int8($0) } while true { let option = Int(getopt(C_ARGC, C_ARGV, buffer)) if option == -1 { break } switch "\(UnicodeScalar(option))" { case "a": aFlag = 1 println("Option -a") case "b": bFlag = 1 println("Option -b") case "c": cValue = String.fromCString(optarg)! println("Option -c \(cValue)") case "?": let charOption = "\(UnicodeScalar(Int(optopt)))" if charOption == "c" { println("Option '\(charOption)' requires an argument.") } else { println("Unknown option '\(charOption)'.") } exit(1) default: abort() } } println("aflag ='\(aFlag)', bflag = '\(bFlag)' cvalue = '\(cValue)'") for index in optind..&lt;C_ARGC { println("Non-option argument '\(String.fromCString(C_ARGV[Int(index)])!)'") } </code></pre>
<p>In Swift 3 use <a href="https://developer.apple.com/reference/swift/commandline"><code>CommandLine</code></a> enum instead of <code>Process</code></p> <p>So:</p> <pre><code>let arguments = CommandLine.arguments </code></pre>