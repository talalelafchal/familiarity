Swift class introspection &amp; generics
<p>I am trying to dynamically create a <code>class</code> instance based type using generics, however I am encountering difficulty with class introspection.</p> <p>Here are the questions:</p> <ul> <li>Is there a Swift-equivalent to Obj-C's <code>self.class</code>?</li> <li>Is there a way to instantiate a class using the <code>AnyClass</code> result from <code>NSClassFromString</code>?</li> <li>Is there a way to get <code>AnyClass</code> or otherwise type information strictly from a generic parameter <code>T</code>? (Similar to C#'s <code>typeof(T)</code> syntax)</li> </ul>
<p>Well, for one, the Swift equivalent of <code>[NSString class]</code> is <code>.self</code> (see <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/doc/uid/TP40014097-CH31-XID_1022">Metatype docs</a>, though they're pretty thin).</p> <p>In fact, <code>NSString.class</code> doesn't even work! You have to use <code>NSString.self</code>.</p> <pre><code>let s = NSString.self var str = s() str = "asdf" </code></pre> <p>Similarly, with a swift class I tried...</p> <pre><code>class MyClass { } let MyClassRef = MyClass.self // ERROR :( let my_obj = MyClassRef() </code></pre> <p>Hmm… the error says:</p> <blockquote> <p>Playground execution failed: error: :16:1: error: constructing an object of class type 'X' with a metatype value requires an '@required' initializer</p> <pre><code> Y().me() ^ &lt;REPL&gt;:3:7: note: selected implicit initializer with type '()' class X { ^ </code></pre> </blockquote> <p>It took me a while to figure out what this means… turns out it wants the class to have a <code>@required init()</code></p> <pre><code>class X { func me() { println("asdf") } required init () { } } let Y = X.self // prints "asdf" Y().me() </code></pre> <p>Some of the docs refer to this as <code>.Type</code>, but <code>MyClass.Type</code> gives me an error in the playground.</p>
<p>If I'm reading the documentation right, if you deal with instances and e.g. want to return a new instance of the same Type than the object you have been given and the Type can be constructed with an init() you can do:</p> <pre><code>let typeOfObject = aGivenObject.dynamicType var freshInstance = typeOfObject() </code></pre> <p>I quickly tested it with String:</p> <pre><code>let someType = "Fooo".dynamicType let emptyString = someType() let threeString = someType("Three") </code></pre> <p>which worked fine.</p>
<p>Finally got something to work. Its a bit lazy but even the NSClassFromString() route did not work for me...</p> <pre><code>import Foundation var classMap = Dictionary&lt;String, AnyObject&gt;() func mapClass(name: String, constructor: AnyObject) -&gt; () { classMap[name] = constructor; } class Factory { class func create(className: String) -&gt; AnyObject? { var something : AnyObject? var template : FactoryObject? = classMap[className] as? FactoryObject if (template) { let somethingElse : FactoryObject = template!.dynamicType() return somethingElse } return nil } } import ObjectiveC class FactoryObject : NSObject { @required init() {} //... } class Foo : FactoryObject { class override func initialize() { mapClass("LocalData", LocalData()) } init () { super.init() } } var makeFoo : AnyObject? = Factory.create("Foo") </code></pre> <p>and bingo, "makeFoo" contains a Foo instance.</p> <p>The downside is your classes must derrive from FactoryObject and they MUST have the Obj-C +initialize method so your class gets automagically inserted in the class map by global function "mapClass".</p>
<p>Here's how to use <code>NSClassFromString</code>. You have to know the superclass of what you're going to end up with. Here are a superclass-subclass pair that know how to describe themselves for <code>println</code>:</p> <pre><code>@objc(Zilk) class Zilk : NSObject { override var description : String {return "I am a Zilk"} } @objc(Zork) class Zork : Zilk { override var description : String {return "I am a Zork"} } </code></pre> <p>Notice the use of the special <code>@obj</code> syntax to dictate the Objective-C munged name of these classes; that's crucial, because otherwise we don't know the munged string that designates each class.</p> <p>Now we can use <code>NSClassFromString</code> to make the Zork class or the Zilk class, because we know we can type it as an NSObject and not crash later:</p> <pre><code>let aClass = NSClassFromString("Zork") as NSObject.Type let anObject = aClass() println(anObject) // "I am a Zork" </code></pre> <p>And it's reversible; <code>println(NSStringFromClass(anObject.dynamicType))</code> also works.</p>
<p>Here is another example showing class hierarchy implementation, similar to accepted answer, updated for the first release of Swift. </p> <pre><code>class NamedItem : NSObject { func display() { println("display") } required override init() { super.init() println("base") } } class File : NamedItem { required init() { super.init() println("folder") } } class Folder : NamedItem { required init() { super.init() println("file") } } let y = Folder.self y().display() let z = File.self z().display() </code></pre> <p>Prints this result:</p> <pre><code>base file display base folder display </code></pre>
<h2><strong>Swift implementation of comparing types</strong></h2> <pre><code>protocol Decoratable{} class A:Decoratable{} class B:Decoratable{} let object:AnyObject = A() object.dynamicType is A.Type//true object.dynamicType is B.Type//false object.dynamicType is Decoratable.Type//true </code></pre> <p><strong>NOTE:</strong> Notice that it also works with protocols the object may or may not extend</p>