Swift and method prototype - forward declaration
<p>Exploring Swift headers I'm seeing this pattern used by Apple, in particular the init declaration of the following struct HAS NO IMPLEMENTATION. Obviously the init() implementation is hidden somehow, since it's Apple stuff, but I was trying to understand how. This is only an example, but it seems a common behavior in the headers</p> <pre><code>struct AutoreleasingUnsafePointer&lt;T&gt; : Equatable, LogicValue { let value: Builtin.RawPointer init(_ value: Builtin.RawPointer) // &lt;---- how is it possible? where is the implementation? func getLogicValue() -&gt; Bool /// Access the underlying raw memory, getting and /// setting values. var memory: T } </code></pre> <p>I know that it is possible to declare a protocol plus a class extension, doing this it's possible to "hide" the implementation from the class declaration and moving it elsewhere</p> <pre><code>class TestClass :TestClassProtocol { // nothing here } protocol TestClassProtocol { func someMethod() // here is the method declaration } extension TestClass { func someMethod() // here is the method implementation { println("extended method") } } </code></pre> <p>But it's different from what I have seen in the Apple Headers, since the method "declaration" is inside the "class", not inside the "protocol". if I try to put the method declaration inside the class TestClass, however, I have two errors (function without body on the class, and invalid redeclaration on the extension)</p> <p>In Objective C this was "implicit", since the method declaration was in the .h and the implementation in the .m How to do the same in Swift?</p>
<p>I think the explanation is very simple. What you see in Xcode is not actually a valid Swift code.</p> <p>It's a result from an automatic conversion of an Obj-C header into Swift-like code but it's not compilable Swift.</p>