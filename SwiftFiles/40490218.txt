Method overloading by return type issue
I have unexpected behaviour while overloading methods using generics: func wrapper<T>() -> T? { print(T.self) let result: T? = internalFunc() return result } func internalFunc<T>() -> T? { print("generic") return nil } func internalFunc() -> Int? { print("non generic") return nil } let s: Int = internalFunc() ?? 0 let s2: Int = wrapper() ?? 0 Console output: non generic Int generic I can't understand why last method called is generic. Shouldn't overload be choosen dynamically? If so, we can see that T.self == Int.self, and non generic method should be called. Where I'm wrong?
In Swift, "Overloaded functions are chosen at compile time". That means your call to internalFunc() inside of wrapper will always dispatch to the generic version, because the compiler can't specialize it. The whole article series on airspeedvelocity is worth reading--it helped clarify my understanding of overloading quite a bit. For example, the next section of the article talks about getting runtime polymorphism using methods on classes rather than unbound functions.