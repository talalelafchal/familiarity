Toll-free bridging and pointer access in Swift
<p>I am porting an App from Objective-C to Swift and I need to use the following method:</p> <pre><code>CFStreamCreatePairWithSocketToHost(alloc: CFAllocator!, host: CFString!, port: UInt32, \ readStream: CMutablePointer&lt;Unmanaged&lt;CFReadStream&gt;?&gt;, \ writeStream: CMutablePointer&lt;Unmanaged&lt;CFWriteStream&gt;?&gt;) </code></pre> <p>The old logic looks like this (which several web sites seem to agree on):</p> <pre><code>CFReadStreamRef readStream = NULL; CFWriteStreamRef writeStream = NULL; CFStreamCreatePairWithSocketToHost(NULL, (__bridge CFStringRef)(host), port, \ &amp;readStream, &amp;writeStream); NSInputStream inputStream = (__bridge_transfer NSInputStream *)readStream; NSOutputStream outputStream = (__bridge_transfer NSOutputStream *)writeStream; </code></pre> <p>Which works fine thanks to toll-free bridging. However, ARC does not exist in "Swift-space", and the type system has changed.</p> <p>How do I turn my streams into instances of</p> <pre><code>CMutablePointer&lt;Unmanaged&lt;CFReadStream&gt;?&gt;, and CMutablePointer&lt;Unmanaged&lt;CFWriteStream&gt;?&gt; </code></pre> <p>And then convert them back into <code>NSStream</code> subclasses after the <code>CFStreamCreatePairWithSocketToHost</code> call?</p>
<p>I got it to work, here's my code: Make sure you keep a reference of the connection class somewhere :-)</p> <pre><code>class Connection : NSObject, NSStreamDelegate { let serverAddress: CFString = "127.0.0.1" let serverPort: UInt32 = 8443 private var inputStream: NSInputStream! private var outputStream: NSOutputStream! func connect() { println("connecting...") var readStream: Unmanaged&lt;CFReadStream&gt;? var writeStream: Unmanaged&lt;CFWriteStream&gt;? CFStreamCreatePairWithSocketToHost(nil, self.serverAddress, self.serverPort, &amp;readStream, &amp;writeStream) // Documentation suggests readStream and writeStream can be assumed to // be non-nil. If you believe otherwise, you can test if either is nil // and implement whatever error-handling you wish. self.inputStream = readStream!.takeRetainedValue() self.outputStream = writeStream!.takeRetainedValue() self.inputStream.delegate = self self.outputStream.delegate = self self.inputStream.scheduleInRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode) self.outputStream.scheduleInRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode) self.inputStream.open() self.outputStream.open() } func stream(stream: NSStream, handleEvent eventCode: NSStreamEvent) { println("stream event") } } </code></pre>
<p>I worked out how to do it. A few important notes:</p> <ol> <li><code>CMutablePointers</code> will be automatically created if you use the &amp; operator.</li> <li>You can get at the <code>T</code> in an <code>Unmanaged&lt;T&gt;</code> with <code>.getUnretainedValue()</code> and <code>getRetainedValue()</code> (Seems <code>.getUnretainedValue()</code> is analogous to <code>__bridge_transfer</code>)</li> <li>Optionals are automatically initialised to <code>nil</code>.</li> <li>If an optional is <code>nil</code> it will translate into a <code>false</code> condition.</li> </ol> <p>So far I have (untested):</p> <pre><code>var readStream: Unmanaged&lt;CFReadStream&gt;? var writeStream: Unmanaged&lt;CFWriteStream&gt;? CFStreamCreatePairWithSocketToHost(kCFAllocatorDefault, host, port, \ &amp;readStream, &amp;writeStream) if (readStream &amp;&amp; writeStream) { inputStream = readStream!.takeUnretainedValue(); outputStream = writeStream!.takeUnretainedValue(); } </code></pre>
<p>I wasn't able to get the examples others have provided in this thread to work. Sure, they compiled, but they crashed as soon as the connection was open.</p> <p>However, I noticed in the WWDC 2014 discussions (and iOS 8 release notes) that there is a new method for initializing an NSStream for creating a bound pair of in/out streams.</p> <p>See below:</p> <pre><code>var inputStream: NSInputStream? var outputStream: NSOutputStream? NSStream.getStreamsToHostWithName("localhost", port: 1234, inputStream: &amp;inputStream, outputStream: &amp;outputStream) </code></pre> <p>This removes the need for the awkward CFStreamCreatePairWithSocketToHost call as well as removing the need for Unmanaged resources.</p>
<p>I am using getStreamsToHostWithName function of NSStream class. It is more easy and beeter than CFStreamCreatePairWithSocketToHost</p> <p>func initNetworkCommunication() {</p> <pre><code>print("connecting...") let serverAddress = "gzoa.vps.infomaniak.com" let serverPort = 1234 NSStream.getStreamsToHostWithName(serverAddress, port: serverPort, inputStream: &amp;inputStream, outputStream: &amp;outputStream) self.inputStream!.delegate = self self.outputStream!.delegate = self self.inputStream!.scheduleInRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode) self.outputStream!.scheduleInRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode) self.inputStream!.open() self.outputStream!.open() </code></pre> <p>}</p>