What is the difference between a weak reference and an unowned reference?
<p>Swift has:</p> <ul> <li>Strong References</li> <li>Weak References</li> <li>Unowned References</li> </ul> <p>How is an unowned reference different from a weak reference?</p> <p>When is it safe to use an unowned reference?</p> <p>Are unowned references a security risk like <a href="http://en.wikipedia.org/wiki/Dangling_pointer">dangling pointers</a> in C/C++?</p>
<p>Unowned references are a kind of weak reference used in the case of a Same-Lifetime relationship between two objects, when an object should only ever be owned by one other object. It's a way to create an immutable binding between an object and one of its properties.</p> <p>In the example given in the intermediate swift WWDC video, a person owns a credit card, and a credit card can only have one holder. On the credit card, the person should not be an optional property, because you don't want to have a credit card floating around with only one owner. You could break this cycle by making the holder property on the credit a weak reference, but that also requires you to make it optional as well as variable (as opposed to constant). The unowned reference in this case means that although CreditCard does not have an owning stake in a Person, its life depends on it.</p> <pre><code>class Person { var card: CreditCard? } class CreditCard { unowned let holder: Person init (holder: Person) { self.holder = holder } } </code></pre>
<p>Both <code>weak</code> and <code>unowned</code> references do not create a <code>strong</code> hold on the referred object (a.k.a. they don't increase the retain count in order to prevent ARC from deallocating the referred object).</p> <p>But why two keywords? This distinction has to do with the fact that <code>Optional</code> types are built-in the Swift language. Long story short about them: <a href="http://en.wikipedia.org/wiki/Option_type">optional types</a> offer memory safety (this works beautifully with <a href="https://developer.apple.com/library/prerelease/mac/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-XID_308">Swift's constructor rules</a> - which are strict in order to provide this benefit).</p> <p>A <code>weak</code> reference allows the posibility of it to become <code>nil</code> (this happens automatically when the referenced object is deallocated), therefore the type of your property must be optional - so you, as a programmer, are obligated to check it before you use it (basically the compiler forces you, as much as it can, to write safe code).</p> <p>An <code>unowned</code> reference presumes that it will never become <code>nil</code> during it's lifetime. A unowned reference must be set during initialization - this means that the reference will be defined as a non-optional type that can be used safely without checks. If somehow the object being referred is deallocated, then the app will crash when the unowned reference will be used.</p> <p>From the <a href="https://developer.apple.com/library/prerelease/mac/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html">Apple docs</a>:</p> <blockquote> <p>Use a weak reference whenever it is valid for that reference to become nil at some point during its lifetime. Conversely, use an unowned reference when you know that the reference will never be nil once it has been set during initialization.</p> </blockquote> <p>In the docs there are some examples that discusses retain cycles and how to break them. All these examples are extracted from <a href="https://developer.apple.com/library/prerelease/mac/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html">the docs</a>.</p> <p>Example for the <code>weak</code> keyword:</p> <pre><code>class Person { let name: String init(name: String) { self.name = name } var apartment: Apartment? } class Apartment { let number: Int init(number: Int) { self.number = number } weak var tenant: Person? } </code></pre> <p>And now, for some ASCII art (you should go <a href="https://developer.apple.com/library/prerelease/mac/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html">see the docs</a> - they have pretty diagrams):</p> <pre><code>Person ===(strong)==&gt; Apartment Person &lt;==(weak)===== Apartment </code></pre> <p>The <code>Person</code> and <code>Apartment</code> example shows a situation where two properties, both of which are allowed to be nil, have the potential to cause a strong reference cycle. This scenario is best resolved with a weak reference. Both entities can exist without having a strict dependency upon the other.</p> <p>Example for the <code>unowned</code> keyword:</p> <pre><code>class Customer { let name: String var card: CreditCard? init(name: String) { self.name = name } } class CreditCard { let number: UInt64 unowned let customer: Customer init(number: UInt64, customer: Customer) { self.number = number; self.customer = customer } } </code></pre> <p>In this example, a <code>Customer</code> may or may not have a <code>CreditCard</code>, but a <code>CreditCard</code> <strong>will always</strong> be associated with a <code>Customer</code>. To represent this, the <code>Customer</code> class has an optional <code>card</code> property, but the <code>CreditCard</code> class has a non-optional (and unowned) <code>customer</code> property.</p> <pre><code>Customer ===(strong)==&gt; CreditCard Customer &lt;==(unowned)== CreditCard </code></pre> <p>The <code>Customer</code> and <code>CreditCard</code> example shows a situation where one property that is allowed to be nil and another property that cannot be nil have the potential to cause a strong reference cycle. This scenario is best resolved with an unowned reference.</p> <p>Note from Apple:</p> <blockquote> <p>Weak references must be declared as variables, to indicate that their value can change at runtime. A weak reference cannot be declared as a constant.</p> </blockquote> <p>There is also a third scenario when both properties should always have a value, and neither property should ever be nil once initialization is complete. </p> <p>And there are also the classic retain cycle scenarios to avoid when working with closures.</p> <p>For this, I encourage you to visit the <a href="https://developer.apple.com/library/prerelease/mac/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html">Apple docs</a>, or read <a href="https://itunes.apple.com/us/book/swift-programming-language/id881256329?mt=11">the book</a>.</p>
<p><strong>Q1. How is an “Unowned reference” different from a “Week Reference”?</strong></p> <p>Weak Reference:</p> <blockquote> <p>A weak reference is a reference that does not keep a strong hold on the instance it refers to, and so does not stop ARC from disposing of the referenced instance. Because weak references are allowed to have “no value”, you must declare every weak reference as having an optional type. <strong>(Apple Docs)</strong></p> </blockquote> <p>Unowned Reference:</p> <blockquote> <p>Like weak references, an unowned reference does not keep a strong hold on the instance it refers to. Unlike a weak reference, however, an unowned reference is assumed to always have a value. Because of this, an unowned reference is always defined as a non-optional type. <strong>(Apple Docs)</strong></p> </blockquote> <p>When to Use Each: </p> <blockquote> <p>Use a weak reference whenever it is valid for that reference to become nil at some point during its lifetime. Conversely, use an unowned reference when you know that the reference will never be nil once it has been set during initialization. <strong>(Apple Docs)</strong></p> </blockquote> <hr> <p><strong>Q2. When is it safe to use an “unowned reference”?</strong></p> <p>As quoted above, an unowned reference is assumed to always have a value. So you should only use it when you are sure that the reference will never be nil. Apple Docs illustrate a use-case for unowned references through the following example.</p> <p>Suppose we have two classes <code>Customer</code> and <code>CreditCard</code>. A customer can exist without a credit card, but a credit card will not exist without a customer, i.e. it can be assumed that a credit card will always have a customer. So, they should have the following relationship:</p> <pre><code>class Customer { var card: CreditCard? } class CreditCard { unowned let customer: Customer } </code></pre> <hr> <p><strong>Q3. Are “unowned reference” reference an security risk like “dangling pointers” in C/C++</strong></p> <p>I don't think so.</p> <p>Since unowned references are just weak references that are guaranteed to have a value, it shouldn't be a security risk in any way. However, if you try to access an unowned reference after the instance that it references is deallocated, you will trigger a runtime error, and the app will crash. </p> <p>That's the only risk I see with it.</p> <p><a href="https://developer.apple.com/library/ios/documentation/swift/conceptual/swift_programming_language/AutomaticReferenceCounting.html">Link to Apple Docs</a></p>
<p>If <strong>self</strong> could be nil in the closure use <strong>[weak self]</strong>.</p> <p>If <strong>self</strong> will never be nil in the closure use <strong>[unowned self]</strong>.</p> <p>If it's crashing when you use <strong>[unowned self]</strong> then self is probably nil at some point in that closure and you probably need to use <strong>[weak self]</strong> instead.</p> <p>Check out the examples on using <strong>strong</strong>, <strong>weak</strong>, and <strong>unowned</strong> in closures:</p> <p><a href="https://developer.apple.com/library/ios/documentation/swift/conceptual/swift_programming_language/AutomaticReferenceCounting.html">https://developer.apple.com/library/ios/documentation/swift/conceptual/swift_programming_language/AutomaticReferenceCounting.html</a></p>
<p>Extracts from <a href="http://www.andrewcbancroft.com/2015/05/08/strong-weak-and-unowned-sorting-out-arc-and-swift/" rel="nofollow">link</a></p> <p>Few Concluding points</p> <ul> <li>To determine if you even need to worry about strong, weak, or unowned, ask, “Am I dealing with reference types”. If you’re working with Structs or Enums, ARC isn’t managing the memory for those Types and you don’t even need to worry about specifying weak or unowned for those constants or variables.</li> <li>Strong references are fine in hierarchical relationships where the parent references the child, but not vice-versa. In fact, strong references are the most appropraite kind of reference most of the time.</li> <li>When two instances are optionally related to one another, make sure that one of those instances holds a weak reference to the other.</li> <li>When two instances are related in such a way that one of the instances can’t exist without the other, the instance with the mandatory dependency needs to hold an unowned reference to the other instance.</li> </ul>