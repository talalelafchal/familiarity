Does Swift support reflection?
<p>Does Swift supports reflection, e.g. is the something like <code>valueForKeyPath:</code> and <code>setValue:forKeyPath:</code> with Swift objects? Actually does it even have a dynamic type system, something like <code>obj.class</code> in Objective-C?</p>
<p>If a class extends <code>NSObject</code>, then all of Objective-C's introspection and dynamism works. This includes: </p> <ul> <li>The ability to ask a class about its methods and properties, and to invoke methods or set properties. </li> <li>The ability to exchange method implementations. (add functionality to all instances). </li> <li>The ability to generate and assign a new sub-class on the fly. (add functionality to a given instance)</li> </ul> <p>One shortcoming of this functionality is support for Swift optional value types. For example Int properties can be enumerated and modified but Int? properties cannot. Optional types can be enumerated partially using reflect/MirrorType, but still not modified.</p> <p>If a class does not extend <code>NSObject</code>, then only the new, very limited (and in progress?) reflection works (see reflect/MirrorType), which adds limited ability to ask a instance about its class and properties, but none of the additional features above. </p> <p>When not extending NSObject, or using the '@objc' directive, Swift defaults to static- and vtable-based dispatch. This is faster, however, in the absence of a virtual machine does not allow runtime method interception. This interception is a fundamental part of Cocoa and is required for the following types of features: </p> <ul> <li>Cocoa's elegant property observers. (Property observers are baked right in to the Swift language). </li> <li>Non-invasively applying cross-cutting concerns like logging, transaction management (i.e Aspect Oriented Programming). </li> <li>Proxies, message forwarding, etc. </li> </ul> <p>Therefore its recommended that clases in Cocoa/CocoaTouch applications implemented with Swift: </p> <ul> <li>Extend from NSObject. The new class dialog in Xcode steers in this direction. </li> <li>Where the overhead of of a dynamic dispatch leads to performance issues, then static dispatch can be used - in tight loops with calls to methods with very small bodies, for example. </li> </ul> <p><strong>Summary:</strong></p> <ul> <li>Swift can behave like C++, with fast static/vtable dispatch and limited reflection. This makes it suitable for lower level or performance intensive applications, but without the complexity, learning curve or risk of error associated with C++</li> <li>While Swift is a compiled language, the messaging style of method invocation adds the introspection and dynamism found in modern languages like Ruby and Python, just like Objective-C, but without Objective-C's legacy syntax. </li> </ul> <p><strong>Reference data: Execution overhead for method invocations:</strong></p> <ul> <li>static : &lt; 1.1ns</li> <li>vtable : ~ 1.1ns</li> <li>dynamic : ~4.9ns</li> </ul> <p>(actual performance depends on hardware, but the ratios will remain similar). </p> <p>Also, the dynamic attribute allows us to explicitly instruct Swift that a method should use dynamic dispatch, and will therefore support interception. </p> <pre><code>public dynamic func foobar() -&gt; AnyObject { } </code></pre>
<p>Looks like there's the start of some reflection support:</p> <pre><code>class Fruit { var name="Apple" } reflect(Fruit()).count // 1 reflect(Fruit())[0].0 // "name" reflect(Fruit())[0].1.summary // "Apple" </code></pre> <p>From mchambers gist, here: <a href="https://gist.github.com/mchambers/fb9da554898dae3e54f2">https://gist.github.com/mchambers/fb9da554898dae3e54f2</a></p>
<p>The documentation speaks about a dynamic type system, mainly about</p> <p><code>Type</code> and <code>dynamicType</code></p> <p>See <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/doc/uid/TP40014097-CH31-XID_988">Metatype Type (in Language Reference)</a></p> <p>Example:</p> <pre><code>var clazz = TestObject.self var instance: TestObject = clazz() var type = instance.dynamicType println("Type: \(type)") //Unfortunately this prints only "Type: Metatype" </code></pre> <p>Now assuming <code>TestObject</code> extends <code>NSObject</code></p> <pre><code>var clazz: NSObject.Type = TestObject.self var instance : NSObject = clazz() if let testObject = instance as? TestObject { println("yes!") //prints "yes!" } </code></pre> <p>Currently, there is no reflection implemented.</p> <p><b>EDIT:</b> I was apparently wrong, see stevex's answer. There is some simple readonly reflection for properties build in, probably to allow IDEs to inspect object contents.</p>
<p>It seems that a Swift reflection API is not a high priority for Apple at the moment. But besides @stevex <a href="http://stackoverflow.com/a/24069875/292145">answer</a> there is another function in the standard library that helps.</p> <p>As of beta 6 <code>_stdlib_getTypeName</code> gets the mangled type name of a variable. Paste this into an empty playground:</p> <pre><code>import Foundation class PureSwiftClass { } var myvar0 = NSString() // Objective-C class var myvar1 = PureSwiftClass() var myvar2 = 42 var myvar3 = "Hans" println( "TypeName0 = \(_stdlib_getTypeName(myvar0))") println( "TypeName1 = \(_stdlib_getTypeName(myvar1))") println( "TypeName2 = \(_stdlib_getTypeName(myvar2))") println( "TypeName3 = \(_stdlib_getTypeName(myvar3))") </code></pre> <p>The output is:</p> <pre><code>TypeName0 = NSString TypeName1 = _TtC13__lldb_expr_014PureSwiftClass TypeName2 = _TtSi TypeName3 = _TtSS </code></pre> <p><a href="http://www.eswick.com/2014/06/inside-swift/">Ewan Swick's blog entry</a> helps to decipher these strings: </p> <p>e.g. <code>_TtSi</code> stands for Swift's internal <code>Int</code> type.</p> <p><a href="https://www.mikeash.com/pyblog/friday-qa-2014-08-15-swift-name-mangling.html">Mike Ash has a great blog entry covering the same topic</a>.</p>
<p>You might want to consider using <strong>toString()</strong> instead. It is public and works just the same as <strong>_stdlib_getTypeName()</strong> with the difference that it also works on <strong>AnyClass</strong>, e.g. in a Playground enter</p> <pre><code>class MyClass {} toString(MyClass.self) // evaluates to "__lldb_expr_49.MyClass" </code></pre>
<p>Look at <a href="https://developer.apple.com/reference/objectivec/1657527-objective_c_runtime" rel="nofollow noreferrer">Objective C Runtime</a>. Hope this is useful.</p>