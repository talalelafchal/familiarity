How to use Namespaces in Swift?
<p>The documentation only mentions nested types, but it's not clear if they can be used as namespaces. I haven't found any explicit mentioning of namespaces.</p>
<p>I believe this is achieved using:</p> <pre><code>struct Foo { class Bar { } } </code></pre> <p>Then it can be accessed using:</p> <pre><code>var dds = Foo.Bar(); </code></pre>
<p>Answered by <em>SevenTenEleven</em> in the <a href="https://devforums.apple.com/thread/227468?tstart=100">Apple dev forum</a>:</p> <blockquote> <p>Namespaces are not per-file; they're per-target (based on the "Product Module Name" build setting). So you'd end up with something like this: import FrameworkA import FrameworkB</p> <p>FrameworkA.foo() All Swift declarations are considered to be part of some module, so even when you say "NSLog" (yes, it still exists) you're getting what Swift thinks of as "Foundation.NSLog".</p> </blockquote> <p>Also <a href="https://twitter.com/clattner_llvm/status/474730716941385729"><em>Chris Lattner</em> tweeted about namespacing</a>.</p> <blockquote> <p>Namespacing is implicit in swift, all classes (etc) are implicitly scoped by the module (Xcode target) they are in. no class prefixes needed</p> </blockquote> <p>Seems to be very different what I have been thinking.</p>
<p>Swift uses modules much like in python (see <a href="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Types.html#//apple_ref/doc/uid/TP40014097-CH31-XID_988">here</a> and <a href="https://docs.python.org/2/tutorial/modules.html">here</a>) and as @Kevin Sylvestre suggested you can also use the <a href="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/NestedTypes.html#//apple_ref/doc/uid/TP40014097-CH23-XID_309">nested types</a> as namespaces.</p> <p>And to extend the answer from @Daniel A. White, in WWDC they were talking about the modules in swift.</p> <p>Also <a href="https://developer.apple.com/swift/">here</a> is explained:</p> <blockquote> <p>Inferred types make code cleaner and less prone to mistakes, while modules eliminate headers and provide namespaces.</p> </blockquote>
<p>While doing some experimentation with this I ended up creating these "namespaced" classes in their own files by extending the root "package". Not sure if this is against best practices or if it has any implications I'm mot aware of(?)</p> <p>AppDelegate.swift</p> <pre><code>var n1 = PackageOne.Class(name: "Package 1 class") var n2 = PackageTwo.Class(name: "Package 2 class") println("Name 1: \(n1.name)") println("Name 2: \(n2.name)") </code></pre> <p>PackageOne.swift</p> <pre><code>import Foundation struct PackageOne { } </code></pre> <p>PackageTwo.swift</p> <pre><code>import Foundation struct PackageTwo { } </code></pre> <p>PackageOneClass.swift</p> <pre><code>extension PackageOne { class Class { var name: String init(name:String) { self.name = name } } } </code></pre> <p>PackageTwoClass.swift</p> <pre><code>extension PackageTwo { class Class { var name: String init(name:String) { self.name = name } } } </code></pre> <hr> <p><strong>Edit:</strong></p> <p>Just found out that creating "subpackages" in above code wont work if using separate files. Maybe someone can hint on why that would be the case?</p> <p>Adding following files to the above:</p> <p>PackageOneSubPackage.swift</p> <pre><code>import Foundation extension PackageOne { struct SubPackage { } } </code></pre> <p>PackageOneSubPackageClass.swift</p> <pre><code>extension PackageOne.SubPackage { class Class { var name: String init(name:String) { self.name = name } } } </code></pre> <p>Its throwing a compiler error: 'SubPackage' is not a member type of 'PackageOne'</p> <p>If I move the code from PackageOneSubPackageClass.swift to PackageOneSubPackage.swift it works. Anyone?</p> <p><strong>Edit 2:</strong></p> <p>Fiddling around with this still and found out (in Xcode 6.1 beta 2) that by defining the packages in one file they can be extended in separate files:</p> <pre><code>public struct Package { public struct SubPackage { public struct SubPackageOne { } public struct SubPackageTwo { } } } </code></pre> <p>Here are my files in a gist: <a href="https://gist.github.com/mikajauhonen/d4b3e517122ad6a132b8">https://gist.github.com/mikajauhonen/d4b3e517122ad6a132b8</a></p>
<p>In case anyone was curious, as of June 10th 2014, this is a known bug in Swift:</p> <p>From <em>SevenTenEleven</em></p> <p>"Known bug, sorry! <em>rdar://problem/17127940</em> Qualifying Swift types by their module name doesn't work."</p>
<p>I would describe Swift's namespacing as aspirational; it's been given a lot of advertising that doesn't correspond to any meaningful reality on the ground.</p> <p>For example, the WWDC videos state that if a framework you're importing has a class MyClass and your code has a class MyClass, those names do not conflict because "name mangling" gives them different internal names. In reality, however, they <em>do</em> conflict, in the sense that your own code's MyClass wins, and you can't specify "No no, I mean the MyClass in the framework" â€” saying <code>TheFramework.MyClass</code> doesn't work (the compiler knows what you mean, but it says it can't find such a class in the framework).</p> <p>My experience is that Swift therefore is not namespaced in the slightest. In turning one of my apps from Objective-C to Swift, I created an embedded framework because it was so easy and cool to do. Importing the framework, however, imports all the Swift stuff in the framework - so presto, once again there is just one namespace and it's global. And there are no Swift headers so you can't hide any names.</p> <p><strong>EDIT:</strong> In seed 3, this feature is now starting to come online, in the following sense: if your main code contains MyClass and your framework MyFramework contains MyClass, the former overshadows the latter by default, but you can reach the one in the framework by using the syntax <code>MyFramework.MyClass</code>. Thus we do in fact have the rudiments of a distinct namespace!</p> <p><strong>EDIT 2:</strong> In seed 4, we now have access controls! Plus, in one of my apps I have an embedded framework and sure enough, everything was hidden by default and I had to expose all the bits of the public API explicitly. This is a big improvement. </p>
<p>You can use <code>extension</code> to use the mentioned <code>struct</code>s approach for namespacing without having to indent all of your code towards the right. I've been toying with this a bit and I'm not sure I'd go as far as creating <code>Controllers</code> and <code>Views</code> namespaces like in the example below, but it does illustrate how far it can go:</p> <p><strong>Profiles.swift</strong>:</p> <pre><code>// Define the namespaces struct Profiles { struct Views {} struct ViewControllers {} } </code></pre> <p><strong>Profiles/ViewControllers/Edit.swift</strong></p> <pre><code>// Define your new class within its namespace extension Profiles.ViewControllers { class Edit: UIViewController {} } // Extend your new class to avoid the extra whitespace on the left extension Profiles.ViewControllers.Edit { override func viewDidLoad() { // Do some stuff } } </code></pre> <p><strong>Profiles/Views/Edit.swift</strong></p> <pre><code>extension Profiles.Views { class Edit: UIView {} } extension Profiles.Views.Edit { override func drawRect(rect: CGRect) { // Do some stuff } } </code></pre> <p>I haven't used this in an app since I haven't needed this level of separation yet but I think it's an interesting idea. This removes the need for even class suffixes such as the ubiquitous *ViewController suffix which is annoyingly long. </p> <p>However, it doesn't shorten anything when it's referenced such as in method parameters like this:</p> <pre><code>class MyClass { func doSomethingWith(viewController: Profiles.ViewControllers.Edit) { // secret sauce } } </code></pre>
<blockquote> <ul> <li><p>Namespaces are useful when you need to define class with <strong>the same</strong> name as class in existing framework. </p></li> <li><p>Suppose your app has <code>MyApp</code> name, and you need to declare your custom <code>UICollectionViewController</code>. </p></li> </ul> </blockquote> <p>You <strong>don't need</strong> to prefix and subclass like this:</p> <pre><code>class MAUICollectionViewController: UICollectionViewController {} </code></pre> <p>Do it like this:</p> <pre><code>class UICollectionViewController {} //no error "invalid redeclaration o..." </code></pre> <p><strong>Why?</strong>. Because what you've declared is declared in <strong>current module</strong>, which is your <strong>current target</strong>. And <code>UICollectionViewController</code> from <code>UIKit</code> is declared in <code>UIKit</code> module.</p> <p><strong>How to use it within current module?</strong></p> <pre><code>var customController = UICollectionViewController() //your custom class var uikitController = UIKit.UICollectionViewController() //class from UIKit </code></pre> <p><strong>How to distinguish them from another module?</strong></p> <pre><code>var customController = MyApp.UICollectionViewController() //your custom class var uikitController = UIKit.UICollectionViewController() //class from UIKit </code></pre>