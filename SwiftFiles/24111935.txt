How to transition scenes in Swift
<p>In Objective-C, using Sprite-Kit, I would <strong>successfully</strong> use something like the following code in Objective-C to bring up a new scene</p> <pre><code>if ([touchedNode.name isEqual: @"Game Button"]) { SKTransition *reveal = [SKTransition revealWithDirection:SKTransitionDirectionDown duration:1.0]; GameScene *newGameScene = [[GameScene alloc] initWithSize: self.size]; // Optionally, insert code to configure the new scene. newGameScene.scaleMode = SKSceneScaleModeAspectFill; [self.scene.view presentScene: newGameScene transition: reveal]; } </code></pre> <p>In trying to port my simple game to Swift, so far I have this working...</p> <pre><code>for touch: AnyObject in touches { let touchedNode = nodeAtPoint(touch.locationInNode(self)) println("Node touched: " + touchedNode.name); let touchedNodeName:String = touchedNode.name switch touchedNodeName { case "Game Button": println("Put code here to launch the game scene") default: println("No routine established for this") } </code></pre> <p>But I do not know what code to write to actually transition to another scene. Question(s):</p> <ol> <li>Can someone please provide an example of using SKTransition with Swift?</li> <li>Would you normally create another "file" to put the other scene code in for the other scene, assuming you would have under Objective-C, or is there something about using Swift that means I should approach it differently?</li> </ol> <p>Thank you</p>
<p>To start with your second question, it's kind of up to you. If you wish to, you can continue to follow the Objective-C convention of having one class per file, although this isn't a requirement, and wasn't in Objective-C either. That being said, if you have a couple of classes that are tightly related, but aren't made up of much code, it wouldn't be unreasonable to have them grouped in a single file. Just do what feels right, and don't make a huge blob of code in a single file.</p> <p>Then for your first questions... Yes, you had a good deal of it already. Basically, from where you got up to, you need to create the instance of GameScene through its size: initializer. From there, you just set the properties and call present.</p> <pre><code>override func touchesBegan(touches: NSSet!, withEvent event: UIEvent!) { super.touchesBegan(touches, withEvent: event) let location = touches.anyObject().locationInNode(self) let touchedNode = self.nodeAtPoint(location) if touchedNode.name == "Game Button" { let transition = SKTransition.revealWithDirection(SKTransitionDirection.Down, duration: 1.0) let nextScene = GameScene(size: self.scene.size) nextScene.scaleMode = SKSceneScaleMode.AspectFill self.scene.view.presentScene(nextScene, transition: transition) } } </code></pre> <p>Or in modern Swift:</p> <pre><code>override func touchesBegan(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?) { super.touchesBegan(touches, withEvent: event) if let location = touches.first?.locationInNode(self) { let touchedNode = nodeAtPoint(location) if touchedNode.name == "Game Button" { let transition = SKTransition.revealWithDirection(.Down, duration: 1.0) let nextScene = GameScene(size: scene!.size) nextScene.scaleMode = .AspectFill scene?.view?.presentScene(nextScene, transition: transition) } } } </code></pre>
<p>if you have to work on touch-begain or node action , Then use it:</p> <pre><code>override func touchesBegan(touches: NSSet!, withEvent event: UIEvent!) { let touch = touches.anyObject() as UITouch if CGRectContainsPoint(btncloseJump.frame, touch.locationInNode(self)) { self.scene.removeFromParent() btncloseJump.removeFromParent() let skView = self.view as SKView skView.ignoresSiblingOrder = true var scene: HomeScene! scene = HomeScene(size: skView.bounds.size) scene.scaleMode = .AspectFill skView.presentScene(scene, transition: SKTransition.fadeWithColor(SKColor(red: 25.0/255.0, green: 55.0/255.0, blue: 12.0/255.0, alpha: 1), duration: 1.0)) } } </code></pre>