How to implement two inits with same content without code duplication in Swift?
<p>Assume a class that is derived from <code>UIView</code> as follows:</p> <pre><code>class MyView: UIView { var myImageView: UIImageView init(frame: CGRect) { super.init(frame: frame) } init(coder aDecoder: NSCoder!) { super.init(coder: aDecoder) } ... </code></pre> <p>If I wanted to have the same code in both of the initializers, like</p> <pre><code>self.myImageView = UIImageView(frame: CGRectZero) self.myImageView.contentMode = UIViewContentMode.ScaleAspectFill </code></pre> <p>and <strong>NOT duplicate that code</strong> twice in the class implementation, how would I structure the <code>init</code> methods?</p> <p>Tried approaches:</p> <ul> <li>Created a method <code>func commonInit()</code> that is called after <code>super.init</code> -> Swift compiler gives an error about an uninitialized variable <code>myImageView</code> before calling <code>super.init</code></li> <li>Calling <code>func commonInit()</code> before <code>super.init</code> fails self-evidently with a compiler error <em>"'self' used before super.init call"</em></li> </ul>
<p>Assign <code>myImageView</code> in both the <code>init()</code> methods based on a single image create function. As such:</p> <pre><code>self.myImageView = self.createMyImageView (); </code></pre> <p>For example, like such:</p> <pre><code> 14&gt; class Bar : Foo { 15. var x : Int? 16. func createX () -&gt; Int { return 1 } 17. init () { 18. super.init () 19. self.x = self.createX () 20. } 21. } </code></pre> <p>Note the 'optional' use at <code>Int?</code></p>
<p>I just had the <a href="http://stackoverflow.com/questions/24051188/how-to-share-common-init-code-between-different-designated-init-methods?lq=1">same problem</a>. </p> <p>As GoZoner said, marking your variables as optional will work. It's not a very elegant way because you then have to unwrap the value each time you want to access it. </p> <p>I will file an enhancement request with Apple, maybe we could get something like a "beforeInit" method that is called before every init where we can assign the variables so we don't have to use optional vars. </p> <p>Until then, I will just put all assignments into a commonInit method which is called from the dedicated initialisers. E.g.:</p> <pre><code>class GradientView: UIView { var gradientLayer: CAGradientLayer? // marked as optional, so it does not have to be assigned before super.init func commonInit() { gradientLayer = CAGradientLayer() gradientLayer!.frame = self.bounds // more setup } init(coder aDecoder: NSCoder!) { super.init(coder: aDecoder) commonInit() } init(frame: CGRect) { super.init(frame: frame) commonInit() } override func layoutSubviews() { super.layoutSubviews() gradientLayer!.frame = self.bounds // unwrap explicitly because the var is marked optional } } </code></pre> <hr> <p>Thanks to David I had a look at the book again and I found something which might be helpful for our deduplication efforts without having to use the optional variable hack. One can use a closure to initialize a variable. </p> <blockquote> <p><strong>Setting a Default Property Value with a Closure or Function</strong></p> <p>If a stored property’s default value requires some customization or setup, you can use a closure or global function to provide a customized default value for that property. Whenever a new instance of the type that the property belongs to is initialized, the closure or function is called, and its return value is assigned as the property’s default value. These kinds of closures or functions typically create a temporary value of the same type as the property, tailor that value to represent the desired initial state, and then return that temporary value to be used as the property’s default value.</p> <p>Here’s a skeleton outline of how a closure can be used to provide a default property value:</p> <pre><code>class SomeClass { let someProperty: SomeType = { // create a default value for someProperty inside this closure // someValue must be of the same type as SomeType return someValue }() } </code></pre> <p>Note that the closure’s end curly brace is followed by an empty pair of parentheses. This tells Swift to execute the closure immediately. If you omit these parentheses, you are trying to assign the closure itself to the property, and not the return value of the closure.</p> <p><strong>NOTE</strong></p> <p>If you use a closure to initialize a property, remember that the rest of the instance has not yet been initialized at the point that the closure is executed. This means that you cannot access any other property values from within your closure, even if those properties have default values. You also cannot use the implicit self property, or call any of the instance’s methods.</p> <p>Excerpt From: Apple Inc. “The Swift Programming Language.” iBooks. <a href="https://itun.es/de/jEUH0.l">https://itun.es/de/jEUH0.l</a></p> </blockquote> <p>This is the way I will use from now on, because it does not circumvent the useful feature of not allowing nil on variables. For my example it'll look like this:</p> <pre><code>class GradientView: UIView { var gradientLayer: CAGradientLayer = { return CAGradientLayer() }() func commonInit() { gradientLayer.frame = self.bounds /* more setup */ } init(coder aDecoder: NSCoder!) { super.init(coder: aDecoder) commonInit() } init(frame: CGRect) { super.init(frame: frame) commonInit() } </code></pre>
<p>Does it necessarily have to come before? I think this is one of the things implicitly unwrapped optionals can be used for:</p> <pre><code>class MyView: UIView { var myImageView: UIImageView! init(frame: CGRect) { super.init(frame: frame) self.commonInit() } init(coder aDecoder: NSCoder!) { super.init(coder: aDecoder) self.commonInit() } func commonInit() { self.myImageView = UIImageView(frame: CGRectZero) self.myImageView.contentMode = UIViewContentMode.ScaleAspectFill } ... } </code></pre> <p>Implicitly unwrapped optionals allow you skip variable assignment before you call <code>super</code>. However, you can still access them like normal variables:</p> <p><code>var image: UIImageView = self.myImageView // no error</code></p>
<p>How about this?</p> <pre><code>public class MyView : UIView { var myImageView: UIImageView = UIImageView() private func setup() { myImageView.contentMode = UIViewContentMode.ScaleAspectFill } override public init(frame: CGRect) { super.init(frame: frame) setup() } required public init(coder aDecoder: NSCoder) { super.init(coder: aDecoder) setup() } } </code></pre>
<p>What we need is a common place to put our initialization code before calling any superclass's initializers, so what I currently using, shown in a code below. (It also cover the case of interdependence among defaults and keep them constant.)</p> <pre><code>import UIKit class MyView: UIView { let value1: Int let value2: Int enum InitMethod { case Coder(NSCoder) case Frame(CGRect) } override convenience init(frame: CGRect) { self.init(.Frame(frame))! } required convenience init?(coder aDecoder: NSCoder) { self.init(.Coder(aDecoder)) } private init?(_ initMethod: InitMethod) { value1 = 1 value2 = value1 * 2 //interdependence among defaults switch initMethod { case let .Coder(coder): super.init(coder: coder) case let .Frame(frame): super.init(frame: frame) } } } </code></pre>