How to create NS_OPTIONS-style bitmask enumerations in Swift?
<p>In Apple's documentation about interacting with C APIs, they describe the way <code>NS_ENUM</code>-marked C-style enumerations are imported as Swift enumerations. This makes sense, and since enumerations in Swift are readily provided as the <code>enum</code> value type it's easy to see how to create our own.</p> <p>Further down, it says this about <code>NS_OPTIONS</code>-marked C-style options:</p> <blockquote> <p>Swift also imports options marked with the <code>NS_OPTIONS</code> macro. Whereas options behave similarly to imported enumerations, options can also support some bitwise operations, such as <code>&amp;</code>, <code>|</code>, and <code>~</code>. In Objective-C, you represent an empty option set with the constant zero (<code>0</code>). In Swift, use <code>nil</code> to represent the absence of any options.</p> </blockquote> <p>Given that there isn't an <code>options</code> value type in Swift, how can we create a C-Style options variable to work with?</p>
<h1>Swift 3.0</h1> <p>Almost identical to Swift 2.0. OptionSetType was renamed to OptionSet and enums are written lower case by convention.</p> <pre><code>struct MyOptions : OptionSet { let rawValue: Int static let firstOption = MyOptions(rawValue: 1 &lt;&lt; 0) static let secondOption = MyOptions(rawValue: 1 &lt;&lt; 1) static let thirdOption = MyOptions(rawValue: 1 &lt;&lt; 2) } </code></pre> <p>Instead of providing a <code>none</code> option, the Swift 3 recommendation is to simply use an empty array literal:</p> <pre><code>let noOptions: MyOption = [] </code></pre> <p>Other usage:</p> <pre><code>let singleOption = MyOptions.firstOption let multipleOptions: MyOptions = [.firstOption, .secondOption] if multipleOptions.contains(.secondOption) { print("multipleOptions has SecondOption") } let allOptions = MyOptions(rawValue: 7) if allOptions.contains(.thirdOption) { print("allOptions has ThirdOption") } </code></pre> <h1>Swift 2.0</h1> <p>In Swift 2.0, protocol extensions take care of most of the boilerplate for these, which are now imported as a struct that conforms to <code>OptionSetType</code>. (<code>RawOptionSetType</code> has disappeared as of Swift 2 beta 2.) The declaration is far simpler:</p> <pre><code>struct MyOptions : OptionSetType { let rawValue: Int static let None = MyOptions(rawValue: 0) static let FirstOption = MyOptions(rawValue: 1 &lt;&lt; 0) static let SecondOption = MyOptions(rawValue: 1 &lt;&lt; 1) static let ThirdOption = MyOptions(rawValue: 1 &lt;&lt; 2) } </code></pre> <p>Now we can use set-based semantics with <code>MyOptions</code>:</p> <pre><code>let singleOption = MyOptions.FirstOption let multipleOptions: MyOptions = [.FirstOption, .SecondOption] if multipleOptions.contains(.SecondOption) { print("multipleOptions has SecondOption") } let allOptions = MyOptions(rawValue: 7) if allOptions.contains(.ThirdOption) { print("allOptions has ThirdOption") } </code></pre> <h1>Swift 1.2</h1> <p>Looking at the Objective-C options that were imported by Swift (<code>UIViewAutoresizing</code>, for example), we can see that options are declared as a <code>struct</code> that conforms to protocol <code>RawOptionSetType</code>, which in turn conforms to <code>_RawOptionSetType</code>, <code>Equatable</code>, <code>RawRepresentable</code>, <code>BitwiseOperationsType</code>, and <code>NilLiteralConvertible</code>. We can create our own like this:</p> <pre><code>struct MyOptions : RawOptionSetType { typealias RawValue = UInt private var value: UInt = 0 init(_ value: UInt) { self.value = value } init(rawValue value: UInt) { self.value = value } init(nilLiteral: ()) { self.value = 0 } static var allZeros: MyOptions { return self(0) } static func fromMask(raw: UInt) -&gt; MyOptions { return self(raw) } var rawValue: UInt { return self.value } static var None: MyOptions { return self(0) } static var FirstOption: MyOptions { return self(1 &lt;&lt; 0) } static var SecondOption: MyOptions { return self(1 &lt;&lt; 1) } static var ThirdOption: MyOptions { return self(1 &lt;&lt; 2) } } </code></pre> <p>Now we can treat this new option set, <code>MyOptions</code>, just like described in Apple's documentation: you can use <code>enum</code>-like syntax:</p> <pre><code>let opt1 = MyOptions.FirstOption let opt2: MyOptions = .SecondOption let opt3 = MyOptions(4) </code></pre> <p>And it also behaves like we'd expect options to behave:</p> <pre><code>let singleOption = MyOptions.FirstOption let multipleOptions: MyOptions = singleOption | .SecondOption if multipleOptions &amp; .SecondOption != nil { // see note println("multipleOptions has SecondOption") } let allOptions = MyOptions.fromMask(7) // aka .fromMask(0b111) if allOptions &amp; .ThirdOption != nil { println("allOptions has ThirdOption") } </code></pre> <p>I've built a <a href="http://natecook.com/blog/2014/07/swift-options-bitmask-generator/">generator to create a Swift option set</a> without all the find/replacing. </p> <p><strong>Latest:</strong> Modifications for Swift 1.1 beta 3.</p>
<p>Xcode 6.1 Beta 2 brought some changes to the <code>RawOptionSetType</code>protocol (see this <a href="http://airspeedvelocity.net/2014/09/15/changes-to-the-swift-standard-library-in-1-1-beta-2/">Airspeedvelocity blog entry</a> and the <a href="http://adcdownload.apple.com//Developer_Tools/xcode_6.1_beta_3_kant8u/xcode_6.1_beta_release_notes.pdf">Apple release notes</a>).</p> <p>Based on Nate Cooks example here is an updated solution. You can define your own option set like this:</p> <pre><code>struct MyOptions : RawOptionSetType, BooleanType { private var value: UInt init(_ rawValue: UInt) { self.value = rawValue } // MARK: _RawOptionSetType init(rawValue: UInt) { self.value = rawValue } // MARK: NilLiteralConvertible init(nilLiteral: ()) { self.value = 0} // MARK: RawRepresentable var rawValue: UInt { return self.value } // MARK: BooleanType var boolValue: Bool { return self.value != 0 } // MARK: BitwiseOperationsType static var allZeros: MyOptions { return self(0) } // MARK: User defined bit values static var None: MyOptions { return self(0) } static var FirstOption: MyOptions { return self(1 &lt;&lt; 0) } static var SecondOption: MyOptions { return self(1 &lt;&lt; 1) } static var ThirdOption: MyOptions { return self(1 &lt;&lt; 2) } static var All: MyOptions { return self(0b111) } } </code></pre> <p>It can then be used like this to define variables:</p> <pre><code>let opt1 = MyOptions.FirstOption let opt2:MyOptions = .SecondOption let opt3 = MyOptions(4) </code></pre> <p>And like this to test for bits:</p> <pre><code>let singleOption = MyOptions.FirstOption let multipleOptions: MyOptions = singleOption | .SecondOption if multipleOptions &amp; .SecondOption { println("multipleOptions has SecondOption") } let allOptions = MyOptions.All if allOptions &amp; .ThirdOption { println("allOptions has ThirdOption") } </code></pre>
<p>If the only functionality we are needing is a way to combine options with <code>|</code> and check if combined options contain a particular option with <code>&amp;</code> an alternative to Nate Cook's answer could be this:</p> <p>Create an options <code>protocol</code> and overload <code>|</code> and <code>&amp;</code>:</p> <pre><code>protocol OptionsProtocol { var value: UInt { get } init (_ value: UInt) } func | &lt;T: OptionsProtocol&gt;(left: T, right: T) -&gt; T { return T(left.value | right.value) } func &amp; &lt;T: OptionsProtocol&gt;(left: T, right: T) -&gt; Bool { if right.value == 0 { return left.value == 0 } else { return left.value &amp; right.value == right.value } } </code></pre> <p>Now we can create options structs more simply like so:</p> <pre><code>struct MyOptions: OptionsProtocol { private(set) var value: UInt init (_ val: UInt) {value = val} static var None: MyOptions { return self(0) } static var One: MyOptions { return self(1 &lt;&lt; 0) } static var Two: MyOptions { return self(1 &lt;&lt; 1) } static var Three: MyOptions { return self(1 &lt;&lt; 2) } } </code></pre> <p>They can be used as follows:</p> <pre><code>func myMethod(#options: MyOptions) { if options &amp; .One { // Do something } } myMethod(options: .One | .Three) </code></pre>
<p>If you don't need to interoperate with Objective-C and just want the <em>surface semantics</em> of bit masks in Swift, I've written a simple "library" called BitwiseOptions that can do this with regular Swift enumerations, e.g.:</p> <pre><code>enum Animal: BitwiseOptionsType { case Chicken case Cow case Goat static let allOptions = [.Chicken, .Cow, .Goat] } var animals = Animal.Chicken | Animal.Goat animals ^= .Goat if animals &amp; .Chicken == .Chicken { println("Chick-Fil-A!") } </code></pre> <p>and so on. No actual bits are being flipped here. These are set operations on opaque values. You can find the gist <a href="https://gist.github.com/Revolucent/beac15070d1f92f82d54" rel="nofollow">here</a>.</p>
<p>In Swift 2 (currently beta as part of the Xcode 7 beta), <code>NS_OPTIONS</code>-style types are imported as subtypes of the new <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Reference/Swift_OptionSetType_Protocol/index.html#//apple_ref/doc/uid/TP40016190"><code>OptionSetType</code></a> type. And thanks to the new <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID521">Protocol Extensions</a> feature and the way <code>OptionSetType</code> is implemented in the standard library, you can declare your own types that extend <code>OptionsSetType</code> and get all the same functions and methods that imported <code>NS_OPTIONS</code>-style types get.</p> <p>But those functions aren't based on bitwise arithmetic operators anymore. That working with a set of non-exclusive Boolean options in C requires masking and twiddling bits in a field is an implementation detail. Really, a set of options is a <em>set</em>... a collection of unique items. So <code>OptionsSetType</code> gets all the methods from the <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Reference/Swift_SetAlgebraType_Protocol/index.html#//apple_ref/swift/intf/s:PSs14SetAlgebraType"><code>SetAlgebraType</code></a> protocol, like creation from array literal syntax, queries like <code>contains</code>, masking with <code>intersection</code>, etc. (No more having to remember which funny character to use for which membership test!)</p>
<p>As Rickster already mentioned, you can use <a href="https://developer.apple.com/library/prerelease/mac/documentation/Swift/Reference/Swift_OptionSetType_Protocol/index.html" rel="nofollow">OptionSetType</a> in Swift 2.0. NS_OPTIONS types get imported as conforming to the <code>OptionSetType</code> protocol, which presents a set-like interface for options:</p> <pre><code>struct CoffeeManipulators : OptionSetType { let rawValue: Int static let Milk = CoffeeManipulators(rawValue: 1) static let Sugar = CoffeeManipulators(rawValue: 2) static let MilkAndSugar = [Milk, Sugar] } </code></pre> <p>It gives you this way of working:</p> <pre><code>struct Coffee { let manipulators:[CoffeeManipulators] // You can now simply check if an option is used with contains func hasMilk() -&gt; Bool { return manipulators.contains(.Milk) } func hasManipulators() -&gt; Bool { return manipulators.count != 0 } } </code></pre>
<p>Swift 2.0 example from the documentation:</p> <pre><code>struct PackagingOptions : OptionSetType { let rawValue: Int init(rawValue: Int) { self.rawValue = rawValue } static let Box = PackagingOptions(rawValue: 1) static let Carton = PackagingOptions(rawValue: 2) static let Bag = PackagingOptions(rawValue: 4) static let Satchel = PackagingOptions(rawValue: 8) static let BoxOrBag: PackagingOptions = [Box, Bag] static let BoxOrCartonOrBag: PackagingOptions = [Box, Carton, Bag] } </code></pre> <p>You can find it <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Reference/Swift_OptionSetType_Protocol/">here</a></p>
<pre><code>//Swift 2.0 //create struct Direction : OptionSetType { let rawValue: Int static let None = Direction(rawValue: 0) static let Top = Direction(rawValue: 1 &lt;&lt; 0) static let Bottom = Direction(rawValue: 1 &lt;&lt; 1) static let Left = Direction(rawValue: 1 &lt;&lt; 2) static let Right = Direction(rawValue: 1 &lt;&lt; 3) } //declare var direction: Direction = Direction.None //using direction.insert(Direction.Right) //check if direction.contains(.Right) { //`enter code here` } </code></pre>
<p>Just posting an extra example for anyone else who was wondering if you could combine compound options. You can, and they combine like you'd expect if you're used to good old bitfields:</p> <pre><code>struct State: OptionSetType { let rawValue: Int static let A = State(rawValue: 1 &lt;&lt; 0) static let B = State(rawValue: 1 &lt;&lt; 1) static let X = State(rawValue: 1 &lt;&lt; 2) static let AB:State = [.A, .B] static let ABX:State = [.AB, .X] // Combine compound state with .X } let state: State = .ABX state.contains(.A) // true state.contains(.AB) // true </code></pre> <p>It flattens the set <code>[.AB, .X]</code> into <code>[.A, .B, .X]</code> (at least semantically):</p> <pre><code>print(state) // 0b111 as expected: "State(rawValue: 7)" print(State.AB) // 0b11 as expected: "State(rawValue: 3)" </code></pre>
<p>No one else has mentioned it -- and I kind of blundered onto it after some tinkering -- but a Swift Set seems to work fairly well.</p> <p>If we think (maybe to a Venn diagram?) about what a bit mask is actually representing, it is a possibly empty set.</p> <p>Of course, in approaching the problem from first principles, we lose the convenience of bitwise operators, but gain powerful set-based methods which improves readability.</p> <p>Here is my tinkering for example:</p> <pre><code>enum Toppings : String { // Just strings 'cause there's no other way to get the raw name that I know of... // Could be 1 &lt;&lt; x too... case Tomato = "tomato" case Salami = "salami" case Cheese = "cheese" case Chicken = "chicken" case Beef = "beef" case Anchovies = "anchovies" static let AllOptions: Set&lt;Toppings&gt; = [.Tomato, .Salami, .Cheese, .Chicken, .Anchovies, .Beef] } func checkPizza(toppings: Set&lt;Toppings&gt;) { if toppings.contains(.Cheese) { print("Possible dairy allergies?") } let meats: Set&lt;Toppings&gt; = [.Beef, .Chicken, .Salami] if toppings.isDisjointWith(meats) { print("Vego-safe!") } if toppings.intersect(meats).count &gt; 1 { print("Limit one meat, or 50¢ extra charge!") } if toppings == [Toppings.Cheese] { print("A bit boring?") } } checkPizza([.Tomato, .Cheese, .Chicken, .Beef]) checkPizza([.Cheese]) </code></pre> <p>I find this nice because I feel it comes from a first principles approach to the problem -- much like Swift -- rather than trying to adapt C-style solutions.</p> <p>Would also like to hear some Obj-C use cases that would challenge this different paradigm, where the integer raw values still shows merit. </p>
<p><a href="http://stackoverflow.com/a/24066171/265072">Nate's answer</a> is good but I would make it DIY, like so:</p> <pre><code>struct MyOptions : OptionSetType { let rawValue: Int static let None = Element(rawValue: 0) static let FirstOption = Element(rawValue: 1 &lt;&lt; 0) static let SecondOption = Element(rawValue: 1 &lt;&lt; 1) static let ThirdOption = Element(rawValue: 1 &lt;&lt; 2) } </code></pre>