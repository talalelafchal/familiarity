Why is it slow to update a class property compared to a local on in Swift?
<p>Consider the following <code>UIViewController</code> implementation:</p> <pre><code>class ViewController: UIViewController { var foo:String[] = ["A","b","c"]; override func viewDidLoad() { super.viewDidLoad() for (var i=0; i &lt; 1000; i++) { foo += "bar"; } } } </code></pre> <p>This loop takes around 34 seconds to complete, consumes 100% cpu and uses up 54MB ram.</p> <p>if I move the foo declaration into <code>viewDidLoad</code> we get near instant results.</p> <p>My question: What is causing this?</p>
<p>In the Playground I've tried the following:</p> <ul> <li>Changed Environment to iOS</li> <li>Built one function that just calls super.viewDidLoad() and another which does the additional array concatenation</li> </ul> <p>It takes approx. <strong>7secs</strong> for just calling the super-method and additional 3secs (<strong>10secs</strong>) with the array-stuff. For me 3 seconds for just 1000 operations seems like there must be any additional Debug-Options enabled. So, according to @nschum, try to make a release build.</p> <p>Here is my code:</p> <pre><code>import UIKit class ViewController: UIViewController { var foo:String[] = ["A","b","c"]; func viewDidLoadWithout() { super.viewDidLoad() } func viewDidLoadWith() { super.viewDidLoad() for (var i=0; i &lt; 1000; i++) { foo += "bar"; } } } var time: Int = Int(NSDate.timeIntervalSinceReferenceDate()) var cntrl = ViewController() cntrl.viewDidLoadWithout() time -= Int(NSDate.timeIntervalSinceReferenceDate()) time *= (-1) // 7secs time = Int(NSDate.timeIntervalSinceReferenceDate()) cntrl = ViewController() cntrl.viewDidLoadWith() time -= Int(NSDate.timeIntervalSinceReferenceDate()) time *= (-1) // 10secs </code></pre>
<p>Just guessing here.</p> <p>In the former case you have a property of an objc class and the value is in fact an NSString. At each update of the property not only you have a dynamic dispatch call to update the property, but also another to compute the new string. Each time there is a check for the possibility that there's some Objective C observer that needs notifying. And each intermediate value is allocated on the heap. All the strings also gets eventually released and deallocated.</p> <p>In the latter case it's a stack value of type String (not an NSString). And there's no one that can see it but this code. The compiler could in fact even pre-compute the size of the final result and allocate it just once, then just do a quick loop to fill it.</p> <p>Not saying this is exactly what happens. I'm guessing. But the two things are certainly different.</p> <p>34 seconds however is <strong>a lot</strong>. There must be something else too.</p>