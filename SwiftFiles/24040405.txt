NSIndexPath? does not have a member name 'row' error in Swift
<p>I'm creating a UITableViewController with Swift language and in a method</p> <pre><code>override func tableView(tableView: UITableView?, cellForRowAtIndexPath indexPath: NSIndexPath?) -&gt; UITableViewCell? </code></pre> <p>I'm getting this error</p> <blockquote> <p>NSIndexPath? does not have a member name 'row' error in Swift </p> </blockquote> <p>and I don't understand why.</p> <p>This is my code</p> <pre><code>import UIKit class DPBPlainTableViewController: UITableViewController { var dataStore: NSArray = NSArray() override func viewDidLoad() { super.viewDidLoad() self.dataStore = ["one","two","three"] println(self.dataStore) } // #pragma mark - Table view data source override func numberOfSectionsInTableView(tableView: UITableView?) -&gt; Int { // Return the number of sections. return 1 } override func tableView(tableView: UITableView?, numberOfRowsInSection section: Int) -&gt; Int { // Return the number of rows in the section. return self.dataStore.count } override func tableView(tableView: UITableView?, cellForRowAtIndexPath indexPath: NSIndexPath?) -&gt; UITableViewCell? { let cell: UITableViewCell = UITableViewCell(style: UITableViewCellStyle.Default, reuseIdentifier: "Cell") cell.textLabel.text = self.dataStore[indexPath.row] return cell } } </code></pre> <p>Then, how can set the cell.text with the array dataStore element?</p>
<p>You can either unwrap the optional <code>indexPath</code> parameter with <code>if let...</code>:</p> <pre><code>if let row = indexPath?.row { cell.textLabel.text = self.dataStore[row] } </code></pre> <p>or if you're sure <code>indexPath</code> isn't <code>nil</code>, you can force the unwrapping with <code>!</code>:</p> <pre><code>cell.textLabel.text = self.dataStore[indexPath!.row] </code></pre> <p>Just keep in mind that <code>indexPath!</code> on a nil value will be a runtime exception, so it's better practice to unwrap it as in the first example.</p>
<p>You can use the optional chaining syntax for this call (setting cell.textLabel.text to <code>nil</code> if <code>indexPath</code> is <code>nil</code>):</p> <pre><code>cell.textLabel.text = indexPath? ? self.dataStore[indexPath!.row] : nil </code></pre> <p>or explicitly unwrap it (causing a runtime error if indexPath is <code>nil</code>):</p> <pre><code>cell.textLabel.text = self.dataStore[indexPath!.row] </code></pre> <p>or use the more verbose <code>if let</code> syntax suggested by @NateCook.</p>
<p>All you have to do to access <code>NSIndexPath</code>'s row and section are to import the header of the file where these extensions to the base <code>NSIndexPath</code> class are defined.</p> <p>If you don't, your class will act like row and section just don't exist on an instance of <code>NSIndexPath</code>.</p> <p>The row and section extensions to <code>NSIndexPath</code> are declared within the UIKit framework inside <code>UITableView.h</code>.</p> <p>To fix this problem, all you need to do is import <code>UITableView.h</code> into your class. That's it.</p> <p>Here is where the extensions to the class are defined in UITableView.h in Objective-C. I'm sure Swift has a similar section.</p> <pre><code>// This category provides convenience methods to make it easier to use an NSIndexPath to represent a section and row @interface NSIndexPath (UITableView) + (instancetype)indexPathForRow:(NSInteger)row inSection:(NSInteger)section; @property (nonatomic, readonly) NSInteger section; @property (nonatomic, readonly) NSInteger row; @end </code></pre>