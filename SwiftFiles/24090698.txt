Swift contains extension for Array
<p>I'm trying to add an extension method in Array like so:</p> <pre><code>extension Array { func contains(obj: T) -&gt; Bool { let filtered = self.filter {$0 == obj} return filtered.count &gt; 0 } } </code></pre> <p>But <code>self.filter {$0 == obj}</code> don't work. Compiler error:</p> <blockquote> <p>could not find an overload for '==' that accepts the supplied arguments</p> </blockquote>
<h3>Swift 1.x</h3> <p>As I mentioned in the comments, there is a <code>contains</code> function. But to answer the question of how to write an extension and what the compiler error means:</p> <p>The elements in the array can't necessarily be compared with <code>==</code>. You need to make sure the parameter is <code>Equatable</code> and you need to make sure the array element is of the same type.</p> <pre><code>extension Array { func contains&lt;T : Equatable&gt;(obj: T) -&gt; Bool { let filtered = self.filter {$0 as? T == obj} return filtered.count &gt; 0 } } </code></pre> <h3>Swift 2/Xcode 7 (Beta)</h3> <p>Swift 2 includes <code>SequenceType.contains</code>, which is exactly what you were trying to create.</p> <p>This is made possible by a Swift syntax that allows restricting methods to certain (e.g. Equatable) type arguments. It looks like this:</p> <pre><code>extension SequenceType where Generator.Element: Equatable { func contains(element: Self.Generator.Element) -&gt; Bool { ... } } </code></pre>
<p>you don't actually need to write an extension, you can use the global func <code>contains</code> from the Swift library:</p> <pre><code>contains([1,2,3], 1) </code></pre>
<p>Not perfect, but this version built on <a href="http://stackoverflow.com/a/24091052/214350">nschum's answer</a> supports optional arguments (though not arrays with optional types) as well:</p> <pre><code>extension Array { private func typeIsOptional() -&gt; Bool { return reflect(self[0]).disposition == .Optional } func contains&lt;U : Equatable&gt;(obj: U) -&gt; Bool { if isEmpty { return false } if (typeIsOptional()) { NSException(name:"Not supported", reason: "Optional Array types not supported", userInfo: nil).raise() } // cast type of array to type of argument to make it equatable for item in self.map({ $0 as? U }) { if item == obj { return true } } return false } // without this version, contains("foo" as String?) won't compile func contains&lt;U : Equatable&gt;(obj: U?) -&gt; Bool { if isEmpty { return false } if (typeIsOptional()) { NSException(name:"Not supported", reason: "Optional Array types not supported", userInfo: nil).raise() } return obj != nil &amp;&amp; contains(obj!) } } </code></pre> <p>If you have an array of optionals, you can get a copy of it with non-optionals (nil arguments removed) with this global function <a href="http://stackoverflow.com/a/28230118/214350">thanks to jtbandes</a>:</p> <pre><code>func unwrapOptionals&lt;T&gt;(a: [T?]) -&gt; [T] { return a.filter { $0 != nil }.map { $0! } } </code></pre> <p>Usage:</p> <pre><code> 1&gt; func unwrapOptionals&lt;T&gt;(a: [T?]) -&gt; [T] { 2. return a.filter { $0 != nil }.map { $0! } 3. } 4&gt; 5&gt; let foo = ["foo" as String?] foo: [String?] = 1 value { [0] = "foo" } 6&gt; let bar = unwrapOptionals(foo) bar: [String] = 1 value { [0] = "foo" } </code></pre> <p>For good measure, add one that just returns the array if its type is not optional. This way you avoid runtime errors if you call <code>unwrapOptionals()</code> on a non-optional array:</p> <pre><code>func unwrapOptionals&lt;T&gt;(a: [T]) -&gt; [T] { return a } </code></pre> <p>Note you might think you could just call <code>unwrapOptionals</code> inside <code>func contains&lt;U : Equatable&gt;(obj: U?)</code>. However, that doesn't work, because the <code>Element</code> type in the Array extension is just a type--it doesn't "know" it's an optional type. So if you call <code>unwrapOptionals</code>, the second version will be invoked, and you'll just get the array full of optionals back.</p>
<p>I found that the built-in contains doesn't work with reference types. I needed this and solved it with the code below. I'm pasting it here because somebody else might be confused about contains() like I was.</p> <pre><code>extension Array { func containsReference(obj: AnyObject) -&gt; Bool { for ownedItem in self { if let ownedObject: AnyObject = ownedItem as? AnyObject { if (ownedObject === obj) { return true } } } return false } } </code></pre>
<p>This works with Swift 2.1 for reference types pretty good.</p> <pre><code>extension SequenceType where Generator.Element: AnyObject { func contains(obj: Self.Generator.Element?) -&gt; Bool { if obj != nil { for item in self { if item === obj { return true } } } return false } } </code></pre> <p>For value types you can add this:</p> <pre><code>extension SequenceType where Generator.Element: Equatable { func contains(val: Self.Generator.Element?) -&gt; Bool { if val != nil { for item in self { if item == val { return true } } } return false } } </code></pre>