NSNumberFormatter and 'th' 'st' 'nd' 'rd' (ordinal) number endings
<p>Is there a way to use NSNumberFormatter to get the 'th' 'st' 'nd' 'rd' number endings?</p> <p>EDIT:</p> <p>Looks like it does not exist. Here's what I'm using.</p> <pre><code>+(NSString*)ordinalNumberFormat:(NSInteger)num{ NSString *ending; int ones = num % 10; int tens = floor(num / 10); tens = tens % 10; if(tens == 1){ ending = @"th"; }else { switch (ones) { case 1: ending = @"st"; break; case 2: ending = @"nd"; break; case 3: ending = @"rd"; break; default: ending = @"th"; break; } } return [NSString stringWithFormat:@"%d%@", num, ending]; } </code></pre> <p>Adapted from nickf's answer here <a href="http://stackoverflow.com/questions/69262/is-there-an-easy-way-in-net-to-get-st-nd-rd-and-th-endings-for-numbers">Is there an easy way in .NET to get &quot;st&quot;, &quot;nd&quot;, &quot;rd&quot; and &quot;th&quot; endings for numbers?</a></p>
<p>I'm not aware of this capability. However, it's possible to do this yourself. In English, the ordinal (th, st, nd, rd, etc) has a really simple pattern:</p> <p>If the number ends with: => Use:</p> <ul> <li>0 => th</li> <li>1 => st</li> <li>2 => nd</li> <li>3 => rd</li> <li>4 => th</li> <li>5 => th</li> <li>6 => th</li> <li>7 => th</li> <li>8 => th</li> <li>9 => th</li> <li>11 => th</li> <li>12 => th</li> <li>13 => th</li> </ul> <p>This will not spell out the word for you, but it will allow you to do something like: "42nd", "1,340,697th", etc.</p> <p>This gets more complicated if you need it localized.</p>
<p>The following example demonstrates how to handle any number. It's in c# however it can easily converted to any language.</p> <p><a href="http://www.bytechaser.com/en/functions/b6yhfyxh78/convert-number-to-ordinal-like-1st-2nd-in-c-sharp.aspx" rel="nofollow noreferrer">http://www.bytechaser.com/en/functions/b6yhfyxh78/convert-number-to-ordinal-like-1st-2nd-in-c-sharp.aspx</a></p>
<p>Since the question asked for a number formatter, here's a rough one I made.</p> <pre><code>// // OrdinalNumberFormatter.h // #import &lt;Foundation/Foundation.h&gt; @interface OrdinalNumberFormatter : NSNumberFormatter { } @end </code></pre> <p>and the implementation:</p> <pre><code>// // OrdinalNumberFormatter.m // #import "OrdinalNumberFormatter.h" @implementation OrdinalNumberFormatter - (BOOL)getObjectValue:(id *)anObject forString:(NSString *)string errorDescription:(NSString **)error { NSInteger integerNumber; NSScanner *scanner; BOOL isSuccessful = NO; NSCharacterSet *letters = [NSCharacterSet letterCharacterSet]; scanner = [NSScanner scannerWithString:string]; [scanner setCaseSensitive:NO]; [scanner setCharactersToBeSkipped:letters]; if ([scanner scanInteger:&amp;integerNumber]){ isSuccessful = YES; if (anObject) { *anObject = [NSNumber numberWithInteger:integerNumber]; } } else { if (error) { *error = [NSString stringWithFormat:@"Unable to create number from %@", string]; } } return isSuccessful; } - (NSString *)stringForObjectValue:(id)anObject { if (![anObject isKindOfClass:[NSNumber class]]) { return nil; } NSString *strRep = [anObject stringValue]; NSString *lastDigit = [strRep substringFromIndex:([strRep length]-1)]; NSString *ordinal; if ([strRep isEqualToString:@"11"] || [strRep isEqualToString:@"12"] || [strRep isEqualToString:@"13"]) { ordinal = @"th"; } else if ([lastDigit isEqualToString:@"1"]) { ordinal = @"st"; } else if ([lastDigit isEqualToString:@"2"]) { ordinal = @"nd"; } else if ([lastDigit isEqualToString:@"3"]) { ordinal = @"rd"; } else { ordinal = @"th"; } return [NSString stringWithFormat:@"%@%@", strRep, ordinal]; } @end </code></pre> <p>Instantiate this as an Interface Builder object and attach the Text Field's formatter outlet to it. For finer control (such as setting maximum and minimum values, you should create an instance of the formatter, set the properties as you wish and attach it to text field using it's <code>setFormatter:</code> method.</p> <p>You can <a href="https://github.com/Abizern/ADNOrdinalNumberFormatter" rel="nofollow noreferrer">download the class from GitHub</a> (including an example project)</p>
<p>This does the trick in one method (for English). Thanks nickf <a href="http://stackoverflow.com/a/69284/1208690">http://stackoverflow.com/a/69284/1208690</a> for original code in PHP, I just adapted it to <code>objective C</code>:-</p> <pre><code>-(NSString *) addSuffixToNumber:(int) number { NSString *suffix; int ones = number % 10; int tens = (number/10) % 10; if (tens ==1) { suffix = @"th"; } else if (ones ==1){ suffix = @"st"; } else if (ones ==2){ suffix = @"nd"; } else if (ones ==3){ suffix = @"rd"; } else { suffix = @"th"; } NSString * completeAsString = [NSString stringWithFormat:@"%d%@", number, suffix]; return completeAsString; } </code></pre>
<p>Just adding another implementation as a class method. I didn't see this question posted until after I implemented this from an example in php.</p> <pre><code>+ (NSString *)buildRankString:(NSNumber *)rank { NSString *suffix = nil; int rankInt = [rank intValue]; int ones = rankInt % 10; int tens = floor(rankInt / 10); tens = tens % 10; if (tens == 1) { suffix = @"th"; } else { switch (ones) { case 1 : suffix = @"st"; break; case 2 : suffix = @"nd"; break; case 3 : suffix = @"rd"; break; default : suffix = @"th"; } } NSString *rankString = [NSString stringWithFormat:@"%@%@", rank, suffix]; return rankString; } </code></pre>
<p>This was my brute force implementation to taking a NSString* representation of the date and returning the ordinal value. I feel it's much easier to read. </p> <pre><code>NSDictionary *ordinalDates = @{ @"1": @"1st", @"2": @"2nd", @"3": @"3rd", @"4": @"4th", @"5": @"5th", @"6": @"6th", @"7": @"7th", @"8": @"8th", @"9": @"9th", @"10": @"10th", @"11": @"11th", @"12": @"12th", @"13": @"13th", @"14": @"14th", @"15": @"15th", @"16": @"16th", @"17": @"17th", @"18": @"18th", @"19": @"19th", @"20": @"20th", @"21": @"21st", @"22": @"22nd", @"23": @"23rd", @"24": @"24th", @"25": @"25th", @"26": @"26th", @"27": @"27th", @"28": @"28th", @"29": @"29th", @"30": @"30th", @"31": @"31st" }; </code></pre>
<p>It's quite simple in English. Here's a swift extension:</p> <pre><code>extension Int { var ordinal: String { get { var suffix = "th" switch self % 10 { case 1: suffix = "st" case 2: suffix = "nd" case 3: suffix = "rd" default: () } if 10 &lt; (self % 100) &amp;&amp; (self % 100) &lt; 20 { suffix = "th" } return String(self) + suffix } } } </code></pre> <p>Then call something like:</p> <pre><code> cell.label_position.text = (path.row + 1).ordinal </code></pre>
<p>Here's a Swift solution that cycles through the user's preferred languages until it finds one with known rules (which are pretty easy to add) for ordinal numbers:</p> <pre><code>extension Int { var localizedOrdinal: String { func ordinalSuffix(int: Int) -&gt; String { for language in NSLocale.preferredLanguages() as [String] { switch language { case let l where l.hasPrefix("it"): return "Â°" case let l where l.hasPrefix("en"): switch int { case let x where x != 11 &amp;&amp; x % 10 == 1: return "st" case let x where x != 12 &amp;&amp; x % 10 == 2: return "nd" case let x where x != 13 &amp;&amp; x % 10 == 3: return "rd" default: return "st" } default: break } } return "" } return "\(self)" + ordinalSuffix(self) } } </code></pre>
<p>Other Swift solutions do not produce correct result and contain mistakes. I have translated CmKndy solution to Swift</p> <pre><code>extension Int { var ordinal: String { var suffix: String let ones: Int = self % 10 let tens: Int = (self/10) % 10 if tens == 1 { suffix = "th" } else if ones == 1 { suffix = "st" } else if ones == 2 { suffix = "nd" } else if ones == 3 { suffix = "rd" } else { suffix = "th" } return "\(self)\(suffix)" } } </code></pre> <p>test result: 0th 1st 2nd 3rd 4th 5th 6th 7th 8th 9th 10th 11th 12th 13th 14th 15th 16th 17th 18th 19th 20th 21st 22nd 23rd</p>
<p>Many of the solutions here don't handle higher numbers like 112. Here is a simple way to do it.</p> <pre><code>for(int i=0;i&lt;1000;i++){ int n = i; NSString* ordinal = @"th"; if(n%10==1 &amp;&amp; n%100!=11) ordinal = @"st"; if(n%10==2 &amp;&amp; n%100!=12) ordinal = @"nd"; if(n%10==3 &amp;&amp; n%100!=13) ordinal = @"rd"; NSLog(@"You are the %d%@",i,ordinal); } </code></pre>
<p>This will convert date to string and also add ordinal in the date. You can modify the date formatte by changing <strong>NSDateFormatter</strong> object</p> <pre><code>-(NSString*) getOrdinalDateString:(NSDate*)date { NSString* string=@""; NSDateComponents *components = [[NSCalendar currentCalendar] components: NSCalendarUnitDay fromDate:date]; if(components.day == 1 || components.day == 21 || components.day == 31) string = @"st"; else if (components.day == 2 || components.day == 22) string = @"nd"; else if (components.day == 3 || components.day == 23) string = @"rd"; else string = @"th"; NSDateFormatter *dateFormatte = [[NSDateFormatter alloc] init]; [dateFormatte setFormatterBehavior:NSDateFormatterBehavior10_4]; [dateFormatte setDateFormat:[NSString stringWithFormat:@"d'%@' MMMM yyyy",string]]; NSString *dateString = [dateFormatte stringFromDate:date]; return dateString; } </code></pre>
<p>A clean Swift version (for English only):</p> <pre><code>func ordinal(number: Int) -&gt; String { if (11...13).contains(number % 100) { return "\(number)th" } switch number % 10 { case 1: return "\(number)st" case 2: return "\(number)nd" case 3: return "\(number)rd" default: return "\(number)th" } } </code></pre> <p>Can be done as an extension for <code>Int</code>:</p> <pre><code>extension Int { func ordinal() -&gt; String { return "\(self)\(ordinalSuffix())" } func ordinalSuffix() -&gt; String { if (11...13).contains(self % 100) { return "th" } switch self % 10 { case 1: return "st" case 2: return "nd" case 3: return "rd" default: return "th" } } } </code></pre>
<p>Here's a compact Swift extension suitable for all integer types:</p> <pre><code>extension IntegerType { func ordinalString() -&gt; String { switch self % 10 { case 1...3 where 11...13 ~= self % 100: return "\(self)" + "th" case 1: return "\(self)" + "st" case 2: return "\(self)" + "nd" case 3: return "\(self)" + "rd" default: return "\(self)" + "th" } } } </code></pre> <p>Example usage:</p> <pre><code>let numbers = (0...30).map { $0.ordinalString() } print(numbers.joinWithSeparator(", ")) </code></pre> <p>Output:</p> <blockquote> <p>0th, 1st, 2nd, 3rd, 4th, 5th, 6th, 7th, 8th, 9th, 10th, 11th, 12th, 13th, 14th, 15th, 16th, 17th, 18th, 19th, 20th, 21st, 22nd, 23rd, 24th, 25th, 26th, 27th, 28th, 29th, 30th</p> </blockquote>
<p>The correct way to do this from iOS 9 onwards, is:</p> <pre><code>NSNumberFormatter *numberFormatter = [[NSNumberFormatter alloc] init]; numberFormatter.numberStyle = NSNumberFormatterOrdinalStyle; NSLog(@"%@", [numberFormatter stringFromNumber:@(1)]); // 1st NSLog(@"%@", [numberFormatter stringFromNumber:@(2)]); // 2nd NSLog(@"%@", [numberFormatter stringFromNumber:@(3)]); // 3rd, etc. </code></pre>
<p>Here's a short Int extension for the English language that also accounts for and displays negative integers correctly:</p> <pre><code>extension Int { func ordinal() -&gt; String { let suffix: String! // treat negative numbers as positive for suffix let number = (self &lt; 0 ? self * -1 : self) switch number % 10 { case 0: suffix = self != 0 ? "th" : "" case 1: suffix = "st" case 2: suffix = "nd" case 3: suffix = "rd" default: suffix = "th" } return String(self) + suffix } } </code></pre>