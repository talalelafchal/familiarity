let declarations require an initializer expression
<p>I'm reading The Swift Programming Language, in the Simple Values section</p> <blockquote> <p>“Use let to make a constant and var to make a variable. The value of a constant doesn’t need to be known at compile time, but you must assign it a value exactly once”</p> </blockquote> <p>So I think I can do this</p> <pre><code>let aConstant:Int aConstant = 5 </code></pre> <p>But I get <strong>let declarations require an initializer expression</strong> !!</p> <p>Why is that ? What does they mean by "The value of a constant doesn’t need to be known at compile time" ?</p>
<p>the <code>let</code> keyword, by definition, defines a <code>constant</code>.</p> <p>Thus, you can't modify it once its been set.</p> <p>Since thats the case, they need to be initialized when they are declared!</p> <p>The solution here is to do either:</p> <pre><code>let aConstant = 5 </code></pre> <p>or change it to a <code>var</code></p> <pre><code>var aNonConstant:Int aNonConstant = 5 </code></pre>
<p>From the <a href="https://itun.es/ch/jEUH0.l" rel="nofollow">Swift Language Reference</a>:</p> <blockquote> <p>When a constant is declared at global scope, it must be initialized with a value.</p> </blockquote> <p>You can only defer initialization of a constant in classes/structs, where you can choose to initialize it in the initializer of the class/struct.</p> <p>The meaning of "The value of a constant doesn’t need to be known at compile time" refers to the value of the constant. In C/Objective-C a global constant needs to be assigned a value that can be computed by the compiler (usually a literal like <code>10</code> or <code>@"Hello"</code>). The following would not be allowed in Objective-C:</p> <pre><code>static const int foo = 10; // OK static const int bar = calculate_bar(); // Error: Initializer element is not a compile-time constant </code></pre> <p>In Swift you don't have this restriction:</p> <pre><code>let foo = 10 // OK let bar = calculateBar(); // OK </code></pre> <p><strong>Edit:</strong></p> <p>The following statement in the original answer is not correct:</p> <blockquote> <p>You can only defer initialization of a constant in classes/structs, where you can choose to initialize it in the initializer of the class/struct.</p> </blockquote> <p>The only place where you cannot defer is in <em>global scope</em> (i.e. top level <code>let</code> expressions). While it's true that you can defer initialization in a class/struct, that's not the only place. The following is also legal for example:</p> <pre><code>func foo() { let bar: Int bar = 1 } </code></pre>
<p>A constant does not need to be known at compile, but it must have a value after initialization:</p> <pre><code>class MyClass: NSObject { let aConstant: Integer; // no value init() { aConstant = 4; // must have a value before calling super super.init(); } } </code></pre> <p>This allows you to set the constant to a value after it is declared and potentially unknown at compile time.</p>
<p>Answer for Swift 2:</p> <p>You can write constants as follows:</p> <pre><code>let aConstant:Int aConstant = 5 </code></pre> <p>Setting the type this way means: "This will be constant and it will have value when you need it". Notice that you cannot use the constant before setting value to it, there is a compile time error:</p> <blockquote> <p>Constant 'aConstant' used before being initialized</p> </blockquote> <p>Furthermore you can set value to <code>aConstant</code> only once. If you try to set value for second time, there is compile time error:</p> <blockquote> <p>Immutable value 'aConstant' may only be initialized once</p> </blockquote> <p>Anyway you cannot do this for global constants, there is compile time error:</p> <blockquote> <p>Global 'let' declaration requires an initializer expression</p> </blockquote>