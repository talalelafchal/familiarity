@selector() in Swift?
<p>I'm trying to create an <code>NSTimer</code> in <code>Swift</code> but I'm having some trouble.</p> <pre><code>NSTimer(timeInterval: 1, target: self, selector: test(), userInfo: nil, repeats: true) </code></pre> <p><em><code>test()</code> is a function in the same class.</em></p> <hr> <p>I get an error in the editor: </p> <blockquote> <p>Could not find an overload for 'init' that accepts the supplied arguments</p> </blockquote> <p>When I change <code>selector: test()</code> to <code>selector: nil</code> the error disappears.</p> <p>I've tried:</p> <ul> <li><code>selector: test()</code></li> <li><code>selector: test</code></li> <li><code>selector: Selector(test())</code></li> </ul> <p>But nothing works and I can't find a solution in the references.</p>
<p>Swift <em>itself</em> doesn't use selectors — several design patterns that in Objective-C make use of selectors work differently in Swift. (For example, use optional chaining on protocol types or <code>is</code>/<code>as</code> tests instead of <code>respondsToSelector:</code>, and use closures wherever you can instead of <code>performSelector:</code> for better type/memory safety.)</p> <p>But there are still a number of important ObjC-based APIs that use selectors, including timers and the target/action pattern. Swift provides the <code>Selector</code> type for working with these. (Swift automatically uses this in place of ObjC's <code>SEL</code> type.)</p> <h3>In Swift 2.2 (Xcode 7.3) and later (including Swift 3 / Xcode 8):</h3> <p>You can construct a <code>Selector</code> from a Swift function type using the <code>#selector</code> expression.</p> <pre><code>let timer = Timer(timeInterval: 1, target: object, selector: #selector(MyClass.test), userInfo: nil, repeats: false) button.addTarget(object, action: #selector(MyClass.buttonTapped), for: .touchUpInside) view.perform(#selector(UIView.insertSubview(_:aboveSubview:)), with: button, with: otherButton) </code></pre> <p>The great thing about this approach? A function reference is checked by the Swift compiler, so you can use the <code>#selector</code> expression only with class/method pairs that actually exist and are eligible for use as selectors (see "Selector availability" below). You're also free to make your function reference only as specific as you need, as per <a href="https://developer.apple.com/library/prerelease/mac/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/doc/uid/TP40014097-CH32-ID400" rel="nofollow">the Swift 2.2+ rules for function-type naming</a>.</p> <p>(This is actually an improvement over ObjC's <code>@selector()</code> directive, because the compiler's <code>-Wundeclared-selector</code> check verifies only that the named selector exists. The Swift function reference you pass to <code>#selector</code> checks existence, membership in a class, and type signature.)</p> <p>There are a couple of extra caveats for the function references you pass to the <code>#selector</code> expression:</p> <ul> <li>Multiple functions with the same base name can be differentiated by their parameter labels using the aforementioned <a href="https://developer.apple.com/library/prerelease/mac/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/doc/uid/TP40014097-CH32-ID400" rel="nofollow">syntax for function references</a> (e.g. <code>insertSubview(_:at:)</code> vs <code>insertSubview(_:aboveSubview:)</code>). But if a function has no parameters, the only way to disambiguate it is to use an <code>as</code> cast with the function's type signature (e.g. <code>foo as () -&gt; ()</code> vs <code>foo(_:)</code>).</li> <li>There's a special syntax for property getter/setter pairs in Swift 3.0+. For example, given a <code>var foo: Int</code>, you can use <code>#selector(getter: MyClass.foo)</code> or <code>#selector(setter: MyClass.foo)</code>.</li> </ul> <h3>General notes:</h3> <p><strong>Cases where <code>#selector</code> doesn't work, and naming:</strong> Sometimes you don't have a function reference to make a selector with (for example, with methods dynamically registered in the ObjC runtime). In that case, you can construct a <code>Selector</code> from a string: e.g. <code>Selector("dynamicMethod:")</code> — though you lose the compiler's validity checking. When you do that, you need to follow ObjC naming rules, including colons (<code>:</code>) for each parameter.</p> <p><strong>Selector availability:</strong> The method referenced by the selector must be exposed to the ObjC runtime. This is already the case if it's in a class that (ultimately) inherits from <code>NSObject</code>, but if it's in a pure Swift class you'll need to preface that method's declaration with <code>@objc</code>. Remember that <code>private</code> symbols aren't exposed to the runtime, too — your method needs to have at least <code>internal</code> visibility.</p> <p><strong>Key paths:</strong> These are related to but not quite the same as selectors. There's a special syntax for these in Swift 3, too: e.g. <code>chris.valueForKeyPath(#keyPath(Person.friends.firstName))</code>. See <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0062-objc-keypaths.md" rel="nofollow">SE-0062</a> for details.</p> <p>You can read more about selectors under <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-XID_26" rel="nofollow">Interacting with Objective-C APIs</a> in <em>Using Swift with Cocoa and Objective-C</em>.</p> <p><sup><strong>Note:</strong> Before Swift 2.2, <code>Selector</code> conformed to <code>StringLiteralConvertible</code>, so you might find old code where bare strings are passed to APIs that take selectors. You'll want to run "Convert to Current Swift Syntax" in Xcode to get those using <code>#selector</code>.</sup></p>
<p>Here's a quick example on how to use the <code>Selector</code> class on Swift:</p> <pre><code>override func viewDidLoad() { super.viewDidLoad() var rightButton = UIBarButtonItem(title: "Title", style: UIBarButtonItemStyle.Plain, target: self, action: Selector("method")) self.navigationItem.rightBarButtonItem = rightButton } func method() { // Something cool here } </code></pre> <p>Note that if the method passed as a string doesn't work, it will fail at runtime, not compile time, and crash your app. Be careful</p>
<p>Selectors are an internal representation of a method name in Objective-C. In Objective-C "@selector(methodName)" would convert a source-code method into a data type of SEL. Since you can't use the @selector syntax in Swift (rickster is on point there), you have to manually specify the method name as a String object directly, or by passing a String object to the Selector type. Here is an example:</p> <pre><code>var rightBarButton = UIBarButtonItem( title: "Logout", style: UIBarButtonItemStyle.Plain, target: self, action:"logout" ) </code></pre> <p>or </p> <pre><code>var rightBarButton = UIBarButtonItem( title: "Logout", style: UIBarButtonItemStyle.Plain, target: self, action:Selector("logout") ) </code></pre>
<p>Also, if your (Swift) class does not descend from an Objective-C class, then you must have a colon at the end of the target method name string and you must use the @objc property with your target method e.g.</p> <pre><code>var rightButton = UIBarButtonItem(title: "Title", style: UIBarButtonItemStyle.Plain, target: self, action: Selector("method")) @objc func method() { // Something cool here } </code></pre> <p>otherwise you will get a "Unrecognised Selector" error at runtime.</p>
<p>you create the Selector like below.<br> 1.</p> <pre><code>UIBarButtonItem( title: "Some Title", style: UIBarButtonItemStyle.Done, target: self, action: "flatButtonPressed" ) </code></pre> <p>2.<br></p> <pre><code>flatButton.addTarget(self, action: "flatButtonPressed:", forControlEvents: UIControlEvents.TouchUpInside) </code></pre> <p>Take note that the @selector syntax is gone and replaced with a simple String naming the method to call. There’s one area where we can all agree the verbosity got in the way. Of course, if we declared that there is a target method called flatButtonPressed: we better write one:<br></p> <pre><code>func flatButtonPressed(sender: AnyObject) { NSLog("flatButtonPressed") } </code></pre> <p>set the timer:<br></p> <pre><code> var timer = NSTimer.scheduledTimerWithTimeInterval(1.0, target: self, selector: Selector("flatButtonPressed"), userInfo: userInfo, repeats: true) let mainLoop = NSRunLoop.mainRunLoop() //1 mainLoop.addTimer(timer, forMode: NSDefaultRunLoopMode) //2 this two line is optinal </code></pre> <p>In order to be complete, here’s the flatButtonPressed </p> <pre><code>func flatButtonPressed(timer: NSTimer) { } </code></pre>
<p>It may be useful to note where you setup the control that triggers the action matters.</p> <p>For example, I have found that when setting up a UIBarButtonItem, I had to create the button within viewDidLoad or else I would get an unrecognized selector exception.</p> <pre><code>override func viewDidLoad() { super.viewDidLoad() // add button let addButton = UIBarButtonItem(image: UIImage(named: "746-plus-circle.png"), style: UIBarButtonItemStyle.Plain, target: self, action: Selector("addAction:")) self.navigationItem.rightBarButtonItem = addButton } func addAction(send: AnyObject?) { NSLog("addAction") } </code></pre>
<p>Just in case somebody else have the same problem I had with NSTimer where none of the other answers fixed the issue, is really important to mention that, if you are using a class that do not inherits from NSObject either directly or deep in the hierarchy(e.g. manually created swift files), none of the other answers will work even when is specified as follows:</p> <pre><code>let timer = NSTimer(timeInterval: 1, target: self, selector: "test", userInfo: nil, repeats: false) func test () {} </code></pre> <p>Without changing anything else other than just making the class inherit from NSObject I stopped getting the "Unrecognized selector" Error and got my logic working as expected.</p>
<pre><code>Create Refresh control using Selector method. var refreshCntrl : UIRefreshControl! refreshCntrl = UIRefreshControl() refreshCntrl.tintColor = UIColor.whiteColor() refreshCntrl.attributedTitle = NSAttributedString(string: "Please Wait...") refreshCntrl.addTarget(self, action:"refreshControlValueChanged", forControlEvents: UIControlEvents.ValueChanged) atableView.addSubview(refreshCntrl) </code></pre> <p>//Refresh Control Method</p> <pre><code>func refreshControlValueChanged(){ atableView.reloadData() refreshCntrl.endRefreshing() } </code></pre>
<p>If you want to pass a parameter to the function from the NSTimer then here is your solution:</p> <pre><code>var somethingToPass = "It worked" let timer = NSTimer.scheduledTimerWithTimeInterval(0.01, target: self, selector: "tester:", userInfo: somethingToPass, repeats: false) func tester(timer: NSTimer) { let theStringToPrint = timer.userInfo as String println(theStringToPrint) } </code></pre> <p>Include the colon in the selector text (tester:), and your parameter(s) go in userInfo.</p> <p>Your function should take NSTimer as a parameter. Then just extract userInfo to get the parameter that passed.</p>
<p>Change as a simple string naming in the method calling for <strong>selector syntax</strong></p> <pre><code>var timer1 : NSTimer? = nil timer1= NSTimer(timeInterval: 0.1, target: self, selector: Selector("test"), userInfo: nil, repeats: true) </code></pre> <p>After that, type func test(). </p>
<p>you create the Selector like below.</p> <p>1.add the event to a button like: <br></p> <pre><code>button.addTarget(self, action: "clickedButton:", forControlEvents: UIControlEvents.TouchUpInside) </code></pre> <p>and the function will be like below: <br></p> <pre><code>func clickedButton(sender: AnyObject) { NSLog("clickedButton") } </code></pre>
<p>For future readers, I found that I experienced a problem and was getting an <strong><em><code>unrecognised selector sent to instance</code></em></strong> error that was caused by marking the target <code>func</code> as private.</p> <p>The <code>func</code> <strong>MUST</strong> be publicly visible to be called by an object with a reference to a selector. </p>
<p>I found many of these answers to be helpful but it wasn't clear how to do this with something that wasn't a button. I was adding a gesture recognizer to a UILabel in swift and struggled so here's what I found worked for me after reading everything above:</p> <pre><code>let tapRecognizer = UITapGestureRecognizer( target: self, action: "labelTapped:") </code></pre> <p>Where the "Selector" was declared as:</p> <pre><code>func labelTapped(sender: UILabel) { } </code></pre> <p>Note that it is public and that I am not using the Selector() syntax but it is possible to do this as well.</p> <pre><code>let tapRecognizer = UITapGestureRecognizer( target: self, action: Selector("labelTapped:")) </code></pre>
<p>When using <code>performSelector()</code> </p> <p><code>/addtarget()/NStimer.scheduledTimerWithInterval()</code> methods your method (matching the selector) should be marked as </p> <pre><code>@objc For Swift 2.0: { //... self.performSelector(“performMethod”, withObject: nil , afterDelay: 0.5) //... //... btnHome.addTarget(self, action: “buttonPressed:", forControlEvents: UIControlEvents.TouchUpInside) //... //... NSTimer.scheduledTimerWithTimeInterval(0.5, target: self, selector : “timerMethod”, userInfo: nil, repeats: false) //... } @objc private func performMethod() { … } @objc private func buttonPressed(sender:UIButton){ …. } @objc private func timerMethod () { …. } </code></pre> <p>For Swift 2.2, you need to write '#selector()' instead of string and selector name so the possibilities of spelling error and crash due to that will not be there anymore. Below is example</p> <pre><code>self.performSelector(#selector(MyClass.performMethod), withObject: nil , afterDelay: 0.5) </code></pre>
<p><strong>Swift 2.2 / Xcode 7.3 Update</strong></p> <p>Use the new <code>#selector</code> expression, which eliminates the need to use string literals, making usage less error-prone. For reference:</p> <pre><code>Selector("keyboardDidHide:") </code></pre> <p>becomes</p> <pre><code>#selector(keyboardDidHide(_:)) </code></pre> <p>See also: <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0022-objc-selectors.md">Swift Evolution Proposal</a></p>
<p>Using <strong>#selector</strong> will check your code at compile time to make sure the method you want to call actually exists. Even better, if the method doesn’t exist, you’ll get a compile error: Xcode will refuse to build your app, thus banishing to oblivion another possible source of bugs.</p> <pre><code>override func viewDidLoad() { super.viewDidLoad() navigationItem.rightBarButtonItem = UIBarButtonItem(barButtonSystemItem: .Add, target: self, action: #selector(addNewFireflyRefernce)) } func addNewFireflyReference() { gratuitousReferences.append("Curse your sudden but inevitable betrayal!") } </code></pre>
<pre><code>// for swift 2.2 // version 1 buttton.addTarget(self, action: #selector(ViewController.tappedButton), forControlEvents: .TouchUpInside) buttton.addTarget(self, action: #selector(ViewController.tappedButton2(_:)), forControlEvents: .TouchUpInside) // version 2 buttton.addTarget(self, action: #selector(self.tappedButton), forControlEvents: .TouchUpInside) buttton.addTarget(self, action: #selector(self.tappedButton2(_:)), forControlEvents: .TouchUpInside) // version 3 buttton.addTarget(self, action: #selector(tappedButton), forControlEvents: .TouchUpInside) buttton.addTarget(self, action: #selector(tappedButton2(_:)), forControlEvents: .TouchUpInside) func tappedButton() { print("tapped") } func tappedButton2(sender: UIButton) { print("tapped 2") } </code></pre>
<p>Since Swift 3.0 is published, it is even a little bit more subtle to declare a targetAction appropriate</p> <pre><code>class MyCustomView : UIView { func addTapGestureRecognizer() { // the "_" is important let tapGestureRecognizer = UITapGestureRecognizer(target: self, action: #selector(MyCustomView.handleTapGesture(_:))) tapGestureRecognizer.numberOfTapsRequired = 1 addGestureRecognizer(tapGestureRecognizer) } // since Swift 3.0 this "_" in the method implementation is very important to // let the selector understand the targetAction func handleTapGesture(_ tapGesture : UITapGestureRecognizer) { if tapGesture.state == .ended { print("TapGesture detected") } } } </code></pre>