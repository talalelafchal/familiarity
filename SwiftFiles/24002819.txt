Difference between == and ===
<p>In swift there seem to be two equality operators: the double equals (<strong><code>==</code></strong>) and the triple equals (<strong><code>===</code></strong>), what is the difference between the two?</p>
<p><code>!==</code> and <code>===</code> are identity operators and are used to determine if two objects have the same reference.</p> <blockquote> <p>Swift also provides two identity operators (=== and !==), which you use to test whether two object references both refer to the same object instance.</p> </blockquote> <p>Excerpt From: Apple Inc. “The Swift Programming Language.” iBooks. <a href="https://itun.es/us/jEUH0.l">https://itun.es/us/jEUH0.l</a></p>
<p>For example, if you create two instances of a class e.g. <code>myClass</code>:</p> <pre><code>var inst1 = myClass() var inst2 = myClass() </code></pre> <p>you can compare those instances, </p> <pre><code>if inst1 === inst2 </code></pre> <p>cited:</p> <blockquote> <p>which you use to test whether two object references both refer to the same object instance.</p> </blockquote> <p>Excerpt From: Apple Inc. “The Swift Programming Language.” iBooks. <a href="https://itun.es/sk/jEUH0.l">https://itun.es/sk/jEUH0.l</a></p>
<p>In both Objective-C and Swift, the <code>==</code> and <code>!=</code> operators test for value equality for number values (e.g., <code>NSInteger</code>, <code>NSUInteger</code>, <code>NSNumber</code> in Objective-C and <code>Int</code>, <code>UInt</code>, etc. in Swift). For objects (NSObject and subclasses) in Objective-C and reference types in Swift, <code>==</code> and <code>!=</code> test that the objects/reference types are the same identical thing -- i.e., same hash value -- or are not the same identical thing, respectively.</p> <pre><code>let a = NSObject() let b = NSObject() let c = a a == b // false a == c // true </code></pre> <p>Swift's <em>identity equality</em> operators, <code>===</code> and <code>!==</code>, check referential equality -- and thus, should probably be called the <em>referential equality</em> operators IMO.</p> <pre><code>a === b // false a === c // true </code></pre> <p>It's also worth pointing out that custom reference types in Swift (that do not subclass a class that conforms to Equatable) do not automatically implement the equal to operators, but the <em>identity equality</em> operators still apply. Also, by implementing <code>==</code>, <code>!=</code> is automatically implemented.</p> <pre><code>class MyClass: Equatable { let myProperty: String init(s: String) { myProperty = s } } func ==(lhs: MyClass, rhs: MyClass) -&gt; Bool { return lhs.myProperty == rhs.myProperty } let myClass1 = MyClass(s: "Hello") let myClass2 = MyClass(s: "Hello") myClass1 == myClass2 // true myClass1 != myClass2 // false myClass1 === myClass2 // false myClass1 !== myClass2 // true </code></pre> <p>These equality operators are not implemented for other types such as structures in either language. However, custom operators can be created in Swift, which would, for example, enable you to create an operator to check equality of a CGPoint.</p> <pre><code>infix operator &lt;==&gt; { precedence 130 } func &lt;==&gt; (lhs: CGPoint, rhs: CGPoint) -&gt; Bool { return lhs.x == rhs.x &amp;&amp; lhs.y == rhs.y } let point1 = CGPoint(x: 1.0, y: 1.0) let point2 = CGPoint(x: 1.0, y: 1.0) point1 &lt;==&gt; point2 // true </code></pre>
<p>There are subtleties with Swifts <code>===</code> that go beyond mere pointer arithmetics. While in Objective-C you were able to compare any two pointers (i.e. <code>NSObject *</code>) with <code>==</code> this is no longer true in Swift since types play a much greater role during compilation.</p> <p>A Playground will give you</p> <pre><code>1 === 2 // false 1 === 1 // true let one = 1 // 1 1 === one // compile error: Type 'Int' does not conform to protocol 'AnyObject' 1 === (one as AnyObject) // true (surprisingly (to me at least)) </code></pre> <p>With strings we will have to get used to this:</p> <pre><code>var st = "123" // "123" var ns = (st as NSString) // "123" st == ns // true, content equality st === ns // compile error ns === (st as NSString) // false, new struct ns === (st as AnyObject) // false, new struct (st as NSString) === (st as NSString) // false, new structs, bridging is not "free" (as in "lunch") NSString(string:st) === NSString(string:st) // false, new structs var st1 = NSString(string:st) // "123" var st2 = st1 // "123" st1 === st2 // true var st3 = (st as NSString) // "123" st1 === st3 // false (st as AnyObject) === (st as AnyObject) // false </code></pre> <p>but then you can also have fun as follows:</p> <pre><code>var st4 = st // "123" st4 == st // true st4 += "5" // "1235" st4 == st // false, not quite a reference, copy on write semantics </code></pre> <p>I am sure you can think of a lot more funny cases :-)</p>