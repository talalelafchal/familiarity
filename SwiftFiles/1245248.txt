How to correctly subclass UIControl?
<p>I don't want UIButton or anything like that. I want to subclass UIControl directly and make my own, very special control.</p> <p>But for some reason, none of any methods I override get ever called. The target-action stuff works, and the targets receive appropriate action messages. However, inside my UIControl subclass I have to catch touch coordinates, and the only way to do so seems to be overriding these guys:</p> <pre><code>- (BOOL)beginTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event { NSLog(@"begin touch track"); return YES; } - (BOOL)continueTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event { NSLog(@"continue touch track"); return YES; } </code></pre> <p>They get never called, even though the UIControl is instantiated with the designates initializer from UIView, initWithFrame:.</p> <p>All examples I can find alyways use a UIButton or UISlider as base for subclassing, but I want to go closer to UIControl since that's the source for what I want: Fast and undelayed Touch coordinates.</p>
<p>I think that you forgot to add [super] calls to touchesBegan/touchesEnded/touchesMoved. Methods like </p> <pre><code>(BOOL)beginTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event (BOOL)continueTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event </code></pre> <p>aren't working if you overriding touchesBegan / touchesEnded like this :</p> <pre><code>- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { NSLog(@"Touches Began"); } - (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event { NSLog(@"Touches Moved"); } - (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event { NSLog(@"Touches Ended"); } </code></pre> <p>But! All works fine if methods will be like :</p> <pre><code>- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { [super touchesBegan:touches withEvent:event]; NSLog(@"Touches Began"); } - (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event { [super touchesMoved:touches withEvent:event]; NSLog(@"Touches Moved"); } - (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event { [super touchesEnded:touches withEvent:event]; NSLog(@"Touches Ended"); } </code></pre>
<p>The simplest approach that I often use is to extend UIControl, but to make use of the inherited addTarget method to receive callbacks for the various events. The key is to listen for both the sender and the event so that you can find out more information about the actual event (such as the location of where the event occurred).</p> <p>So, just simply subclass UIControl and then in the init method (make sure your initWithCoder is also setup if you are using nibs) , add the following:</p> <pre><code>[self addTarget:self action:@selector(buttonPressed:forEvent:) forControlEvents:UIControlEventTouchUpInside]; </code></pre> <p>Of course, you can choose any of the standard control events including UIControlEventAllTouchEvents. Notice that the selector will get passed two objects. The first is the control. The second is the info about the event. Here's an example of using the touch event to toggle a button depending on if the user pressed on the left and right.</p> <pre><code>- (IBAction)buttonPressed:(id)sender forEvent:(UIEvent *)event { if (sender == self.someControl) { UITouch* touch = [[event allTouches] anyObject]; CGPoint p = [touch locationInView:self.someControl]; if (p.x &lt; self. someControl.frame.size.width / 2.0) { // left side touch } else { // right side touch } } } </code></pre> <p>Granted, this is for pretty simplistic controls and you may reach a point where this will not give you enough functionality, but this has worked for all my purposes for custom controls to this point and is really easy to use since I typically care about the same control events that the UIControl already supports (touch up, drag, etc...)</p> <p>Code sample of custom control here: <a href="http://www.homick.com/posts/custom-uiswitch-control" rel="nofollow noreferrer">Custom UISwitch</a> (note: this does not register with the buttonPressed:forEvent: selector, but you can figure that out from the code above)</p>
<p>I have looked long and hard for a solution to this problem and I don't think there is one. However, on closer inspection of the documentation I think it might be a misunderstanding that <code>begintrackingWithTouch:withEvent:</code> and <code>continueTrackingWithTouch:withEvent:</code> are supposed to be called at all...</p> <p><code>UIControl</code> documentation says:</p> <blockquote> <p>You may want to extend a <code>UIControl</code> subclass for two basic reasons:</p> <p>To observe or modify the dispatch of action messages to targets for particular events To do this, override <code>sendAction:to:forEvent:</code>, evaluate the passed-in selector, target object, or “Note” bit mask and proceed as required.</p> <p>To provide custom tracking behavior (for example, to change the highlight appearance) To do this, override one or all of the following methods: <code>beginTrackingWithTouch:withEvent:</code>, <code>continueTrackingWithTouch:withEvent:</code>, <code>endTrackingWithTouch:withEvent:</code>.</p> </blockquote> <p>The critical part of this, which is not very clear in my view, is that it says you may want to extend a <code>UIControl</code> subclass - NOT you may want to extend <code>UIControl</code> directly. It's possible that <code>beginTrackingWithTouch:withEvent:</code> and <code>continuetrackingWithTouch:withEvent:</code> are not supposed to get called in response to touches and that <code>UIControl</code> direct subclasses are supposed to call them so that <em>their</em> subclasses can monitor tracking.</p> <p>So my solution to this is to override <code>touchesBegan:withEvent:</code> and <code>touchesMoved:withEvent:</code> and call them from there as follows. Note that multi-touch is not enabled for this control and that I don't care about touches ended and touches canceled events, but if you want to be complete/thorough you should probably implement those too.</p> <pre><code>- (void)touchesBegan:(NSSet*)touches withEvent:(UIEvent*)event { [super touchesBegan:touches withEvent:event]; // Get the only touch (multipleTouchEnabled is NO) UITouch* touch = [touches anyObject]; // Track the touch [self beginTrackingWithTouch:touch withEvent:event]; } - (void)touchesMoved:(NSSet*)touches withEvent:(UIEvent*)event { [super touchesMoved:touches withEvent:event]; // Get the only touch (multipleTouchEnabled is NO) UITouch* touch = [touches anyObject]; // Track the touch [self continueTrackingWithTouch:touch withEvent:event]; } </code></pre> <p>Note that you should also send any <code>UIControlEvent*</code> messages that are relevant for your control using <code>sendActionsForControlEvents:</code> - these may be called from the super methods, I haven't tested it.</p>
<p>I know this question is ancient, but I had the same problem and I thought I should give my 2 cents.</p> <p>If your control has any subviews at all, <code>beginTrackingWithTouch</code>, <code>touchesBegan</code>, etc might not get called because those subviews are swallowing the touch events.</p> <p>If you don't want those subviews to handle touches, you can set <code>userInteractionEnabled</code> to <code>NO</code>, so the subviews simply passes the event through. Then you can override <code>touchesBegan/touchesEnded</code> and manage all your touches there.</p> <p>Hope this helps.</p>
<p>I was having trouble with a UIControl not responding to <code>beginTrackingWithTouch</code> and <code>continueTrackingWithTouch</code>.</p> <p>I found my problem was when I did <code>initWithFrame:CGRectMake()</code> I made the frame to small (the area that reacts) and had only a couple point spot where it did work. I made the frame the same size as the control and then anytime I pressed on anywhere in the control it responded.</p>
<h1>Swift</h1> <p>These is more than one way to subclass <code>UIControl</code>. When a parent view needs to react to touch events or get other data from the control, this is usually done using (1) targets or (2) the delegate pattern with overridden touch events. For completeness I will also show how to (3) do the same thing with a gesture recognizer. Each of these methods will behave like the following animation:</p> <p><a href="https://i.stack.imgur.com/CABvJ.gif" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/CABvJ.gif" alt="enter image description here"></a></p> <p>You only need to choose one of the following methods.</p> <hr> <h1>Method 1: Add a Target</h1> <p>A <code>UIControl</code> subclass has support for targets already built in. If you don't need to pass a lot of data to the parent, this is probably the method you want. </p> <p><strong>MyCustomControl.swift</strong></p> <pre><code>import UIKit class MyCustomControl: UIControl { // You don't need to do anything special in the control for targets to work. } </code></pre> <p><strong>ViewController.swift</strong></p> <pre><code>import UIKit class ViewController: UIViewController { @IBOutlet weak var myCustomControl: MyCustomControl! @IBOutlet weak var trackingBeganLabel: UILabel! @IBOutlet weak var trackingEndedLabel: UILabel! @IBOutlet weak var xLabel: UILabel! @IBOutlet weak var yLabel: UILabel! override func viewDidLoad() { super.viewDidLoad() // Add the targets // Whenever the given even occurs, the action method will be called myCustomControl.addTarget(self, action: #selector(touchedDown), forControlEvents: UIControlEvents.TouchDown) myCustomControl.addTarget(self, action: #selector(didDragInsideControl(_:withEvent:)), forControlEvents: UIControlEvents.TouchDragInside) myCustomControl.addTarget(self, action: #selector(touchedUpInside), forControlEvents: UIControlEvents.TouchUpInside) } // MARK: - target action methods func touchedDown() { trackingBeganLabel.text = "Tracking began" } func touchedUpInside() { trackingEndedLabel.text = "Tracking ended" } func didDragInsideControl(control: MyCustomControl, withEvent event: UIEvent) { if let touch = event.touchesForView(control)?.first { let location = touch.locationInView(control) xLabel.text = "x: \(location.x)" yLabel.text = "y: \(location.y)" } } } </code></pre> <p><strong>Notes</strong></p> <ul> <li>There is nothing special about the action method names. I could have called them anything. I just have to be careful to spell the method name exactly like I did where I added the target. Otherwise you get a crash.</li> <li>The two colons in <code>didDragInsideControl:withEvent:</code> means that two parameters are being passed to the <code>didDragInsideControl</code> method. If you forget to add a colon or if you don't have the correct number of parameters, you will get a crash.</li> <li>Thanks to <a href="http://stackoverflow.com/a/35027575/3681880">this answer</a> for help with the <code>TouchDragInside</code> event. </li> </ul> <p><strong>Passing other data</strong></p> <p>If you have some value in your custom control </p> <pre><code>class MyCustomControl: UIControl { var someValue = "hello" } </code></pre> <p>that you want to access in the target action method, then you can pass in a reference to the control. When you are setting the target, add a colon after the action method name. For example:</p> <pre><code>myCustomControl.addTarget(self, action: #selector(touchedDown), forControlEvents: UIControlEvents.TouchDown) </code></pre> <p>Notice that it is <code>touchedDown:</code> (with a colon) and not <code>touchedDown</code> (without a colon). The colon means that a parameter is being passed to the action method. In the action method, specify that the parameter is a reference to your <code>UIControl</code> subclass. With that reference, you can get data from your control.</p> <pre><code>func touchedDown(control: MyCustomControl) { trackingBeganLabel.text = "Tracking began" // now you have access to the public properties and methods of your control print(control.someValue) } </code></pre> <hr> <h1>Method 2: Delegate Pattern and Override Touch Events</h1> <p>Subclassing <code>UIControl</code> gives us access to the following methods:</p> <ul> <li><code>beginTrackingWithTouch</code> is called when the finger first touches down within the control's bounds.</li> <li><code>continueTrackingWithTouch</code> is called repeatedly as the finger slides across the control and even outside of the control's bounds.</li> <li><code>endTrackingWithTouch</code> is called when the finger lifts off the screen.</li> </ul> <p>If you need special control of the touch events or if you have a lot of data communication to do with the parent, then this method may work better then adding targets.</p> <p>Here is how to do it:</p> <p><strong>MyCustomControl.swift</strong></p> <pre><code>import UIKit // These are out self-defined rules for how we will communicate with other classes protocol ViewControllerCommunicationDelegate: class { func myTrackingBegan() func myTrackingContinuing(location: CGPoint) func myTrackingEnded() } class MyCustomControl: UIControl { // whichever class wants to be notified of the touch events must set the delegate to itself weak var delegate: ViewControllerCommunicationDelegate? override func beginTrackingWithTouch(touch: UITouch, withEvent event: UIEvent?) -&gt; Bool { // notify the delegate (i.e. the view controller) delegate?.myTrackingBegan() // returning true means that future events (like continueTrackingWithTouch and endTrackingWithTouch) will continue to be fired return true } override func continueTrackingWithTouch(touch: UITouch, withEvent event: UIEvent?) -&gt; Bool { // get the touch location in our custom control's own coordinate system let point = touch.locationInView(self) // Update the delegate (i.e. the view controller) with the new coordinate point delegate?.myTrackingContinuing(point) // returning true means that future events will continue to be fired return true } override func endTrackingWithTouch(touch: UITouch?, withEvent event: UIEvent?) { // notify the delegate (i.e. the view controller) delegate?.myTrackingEnded() } } </code></pre> <p><strong>ViewController.swift</strong></p> <p>This is how the view controller is set up to be the delegate and respond to touch events from our custom control.</p> <pre><code>import UIKit class ViewController: UIViewController, ViewControllerCommunicationDelegate { @IBOutlet weak var myCustomControl: MyCustomControl! @IBOutlet weak var trackingBeganLabel: UILabel! @IBOutlet weak var trackingEndedLabel: UILabel! @IBOutlet weak var xLabel: UILabel! @IBOutlet weak var yLabel: UILabel! override func viewDidLoad() { super.viewDidLoad() myCustomControl.delegate = self } func myTrackingBegan() { trackingBeganLabel.text = "Tracking began" } func myTrackingContinuing(location: CGPoint) { xLabel.text = "x: \(location.x)" yLabel.text = "y: \(location.y)" } func myTrackingEnded() { trackingEndedLabel.text = "Tracking ended" } } </code></pre> <p><strong>Notes</strong></p> <ul> <li>To learn more about the delegate pattern, see <a href="http://stackoverflow.com/a/33549729/3681880">this answer</a>.</li> <li><p>It is not necessary to use a delegate with these methods if they are only being used within the custom control itself. I could have just added a <code>print</code> statement to show how the events are being called. In that case, the code would be simplified to</p> <pre><code>import UIKit class MyCustomControl: UIControl { override func beginTrackingWithTouch(touch: UITouch, withEvent event: UIEvent?) -&gt; Bool { print("Began tracking") return true } override func continueTrackingWithTouch(touch: UITouch, withEvent event: UIEvent?) -&gt; Bool { let point = touch.locationInView(self) print("x: \(point.x), y: \(point.y)") return true } override func endTrackingWithTouch(touch: UITouch?, withEvent event: UIEvent?) { print("Ended tracking") } } </code></pre></li> </ul> <hr> <h1>Method 3: Use a Gesture Recognizer</h1> <p>Adding a gesture recognizer can be done on any view and it also works on a <code>UIControl</code>. To get similar results to the example at the top, we will use a <code>UIPanGestureRecognizer</code>. Then by testing the various states when an event is fired we can determine what is happening.</p> <p><strong>MyCustomControl.swift</strong></p> <pre><code>import UIKit class MyCustomControl: UIControl { // nothing special is required in the control to make it work } </code></pre> <p><strong>ViewController.swift</strong></p> <pre><code>import UIKit class ViewController: UIViewController { @IBOutlet weak var myCustomControl: MyCustomControl! @IBOutlet weak var trackingBeganLabel: UILabel! @IBOutlet weak var trackingEndedLabel: UILabel! @IBOutlet weak var xLabel: UILabel! @IBOutlet weak var yLabel: UILabel! override func viewDidLoad() { super.viewDidLoad() // add gesture recognizer let gestureRecognizer = UIPanGestureRecognizer(target: self, action: #selector(gestureRecognized(_:))) myCustomControl.addGestureRecognizer(gestureRecognizer) } // gesture recognizer action method func gestureRecognized(gesture: UIPanGestureRecognizer) { if gesture.state == UIGestureRecognizerState.Began { trackingBeganLabel.text = "Tracking began" } else if gesture.state == UIGestureRecognizerState.Changed { let location = gesture.locationInView(myCustomControl) xLabel.text = "x: \(location.x)" yLabel.text = "y: \(location.y)" } else if gesture.state == UIGestureRecognizerState.Ended { trackingEndedLabel.text = "Tracking ended" } } } </code></pre> <p><strong>Notes</strong></p> <ul> <li>Don't forget to add the colon after the action method name in <code>action: "gestureRecognized:"</code>. The colon means that parameters are being passed in.</li> <li>If you need to get data from the control, you could implement the delegate pattern as in method 2 above.</li> </ul>
<h1>Obj C</h1> <p>I found a related article from 2014 <a href="https://www.objc.io/issues/13-architecture/behaviors/" rel="nofollow">https://www.objc.io/issues/13-architecture/behaviors/</a>.</p> <p>The interesting thing about it is that its approach is to make use of IB and encapsulate the event handling logic inside a designated object (they call it behaviors), thus removing logic from your view/viewController making it lighter. </p> <ul> <li>Github sample case: <a href="https://github.com/krzysztofzablocki/BehavioursExample" rel="nofollow">https://github.com/krzysztofzablocki/BehavioursExample</a></li> </ul>