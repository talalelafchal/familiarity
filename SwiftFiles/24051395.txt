How to go from CMutablePointer&lt;CGFloat&gt; to CGFloat[] in Swift
<p>I am trying to convert an ObjC class that uses <a href="http://github.com/facebook.pop">Facebook's pop library</a> to Swift. Pop uses quite a bit of C.</p> <p>In ObjC, I have a block that looks like this...</p> <pre><code>prop.readBlock = ^(SHVGraphViewObjc *graphView, CGFloat values[]) { values[0] = [graphView.centerOffsets[idx] doubleValue]; }; </code></pre> <p>The equivalent closure definition in Swift would be</p> <p><code>prop.readBlock = {(graphView: AnyObject!, values: CMutablePointer&lt;CGFloat&gt;) in }</code></p> <p>What I can't figure out is how to convert the <code>values[0] = [graphView.centerOffsets[idx] doubleValue];</code> to Swift? How do I let Swift know that <code>CMutablePointer&lt;CGFloat&gt;</code> should be a <code>CGFloat[]</code>?</p>
<p>EDIT: Just wanted to clarify a few things after learning a bit more from the <a href="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/buildingcocoaapps/BuildingCocoaApps.pdf">online documentation (PDF)</a>.</p> <p>There are a few commonly used pointer types in Swift, here is how they map to C equivalents:</p> <h2>Pointers as Arguments</h2> <pre><code>CConstVoidPointer =&gt; const void * CMutableVoidPointer =&gt; void * CConstPointer&lt;Type&gt; =&gt; const Type * CMutablePointer&lt;Type&gt; =&gt; Type * </code></pre> <h2>Pointers as Return Types, Variables, and Arguments*</h2> <pre><code>COpaquePointer =&gt; void * UnsafePointer&lt;Type&gt; =&gt; Type * </code></pre> <p><strong>NOTE:</strong> Arguments follow this rule <strong>only</strong> when they are more than one pointer level deep, otherwise see above.</p> <h2>Pointers for Class Types</h2> <pre><code>CConstPointer&lt;Type&gt; =&gt; Type * const * CMutablePointer&lt;Type&gt; =&gt; Type * __strong * AutoreleasingUnsafePointer&lt;Type&gt; =&gt; Type ** </code></pre> <h2>Swift Pointers</h2> <p>When using the <code>CConstPointer&lt;Type&gt;</code> pointer in Swift, you may pass any one of these:</p> <ul> <li><code>nil</code>, which will be evaluated as a <code>NULL</code> pointer</li> <li>A <code>CConstPointer&lt;Type&gt;</code> value</li> <li>A <code>CConstVoidPointer</code> value</li> <li>A <code>CMutablePointer&lt;Type&gt;</code> value</li> <li>A <code>CMutableVoidPointer</code></li> <li>A <code>AutoreleasingUnsafePointer&lt;Type&gt;</code> value which will be converted to <code>CConstPointer&lt;Type&gt;</code> if necessary</li> <li>A <code>Type</code> value passed by address (<code>&amp;</code> operator)</li> <li>A <code>Type[]</code> array</li> </ul> <p><strong>NOTE:</strong><code>CConstVoidPointer</code> can take any of the above values as well.</p> <p>When using the <code>CMutablePointer&lt;Type&gt;</code> pointer in Swift, you may pass any one of these:</p> <ul> <li><code>nil</code>, which will be evaluated as a <code>NULL</code> pointer</li> <li>A <code>CMutablePointer&lt;Type&gt;</code> value</li> <li>A <code>Type</code> value passed by address (<code>&amp;</code> operator)</li> <li>A <code>Type[]</code> array passed by address (<code>&amp;</code> operator) </li> </ul> <p><strong>NOTE:</strong><code>CMutableVoidPointer</code> can take any of the above in addition to <code>CMUtableVoidPointer</code> values.</p> <p>So it would seem in your case that a <code>CMutablePointer&lt;CGFloat&gt;</code> could also be a pointer to an array of <code>CGFloat</code> values. Though I am not completely sure how to dereference that in Swift. (Perhaps the <code>as</code> operator?)</p>
<p>While SiLo's answer is extremely detailed, the specific question here is answered by Ross' comments underneath it, so I thought I'd expand those into a full answer.</p> <p>I needed to do this recently in order to interface with my GPUImage framework via Swift. For my Harris corner detector, I use a callback block on each processed frame that provides a C array of OpenGL floating-point values in X, Y coordinate pairs, along with the size of that array in pairs. I use a C array for performance, since this will be provided 30-60 times per second on live video. In Objective-C, I would set this up using code like the following:</p> <pre><code>UIImage *sourceImage = [UIImage imageNamed:@"ChairTest.png"]; GPUImageHarrisCornerDetector *cornerDetector = [[GPUImageHarrisCornerDetectionFilter alloc] init]; [cornerDetector setCornersDetectedBlock:^(GLfloat* cornerArray, NSUInteger cornersDetected, CMTime frameTime) { NSLog(@"Number of corners detected: %d", cornersDetected); NSLog(@"Corner 1, X: %f, Y: %f", cornerArray[0], cornerArray[1]); }]; GPUImagePicture *inputPicture = [[GPUImagePicture alloc] initWithImage:sourceImage]; [inputPicture addTarget:cornerDetector]; [inputPicture processImage]; </code></pre> <p>After I deciphered the proper closure syntax, I couldn't quite figure out how to access the values of the input C array where I hand over corner coordinates to the processing block. <a href="https://twitter.com/BigZaphod/status/475137485602045952" rel="nofollow">Sean Heber's tweet about this</a> points out one way to do this, which I used to translate the above Objective-C to the following Swift code:</p> <pre><code>let sourceImage = UIImage(named: "ChairTest.png") let cornerDetector = GPUImageHarrisCornerDetectionFilter() cornerDetector.cornersDetectedBlock = { (cornerArray:CMutablePointer&lt;GLfloat&gt;, cornersDetected:Int, frameTime:CMTime) in println("Number of corners detected: \(cornersDetected)") let corners = UnsafePointer&lt;GLfloat&gt;(cornerArray) println("Corner 1, X: \(corners[0]) Y: \(corners[1])") } let inputPicture = GPUImagePicture(image: sourceImage) inputPicture.addTarget(cornerDetector) inputPicture.processImage() </code></pre> <p>This appears to be functionally identical. It might be safer to use <code>.withUnsafePointer()</code>, but I haven't quite gotten the syntax on that down.</p>