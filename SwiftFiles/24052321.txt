Using Getters and Setters to modify values w/o Subclassing in Swift
<p>Let's say I have a class, and when I set its property, I want it to append that property with a file type like <code>.fileType</code>:</p> <pre><code>class File { var fileName: String { get { return self.fileName } set { self.fileName = fileName + ".fileType" } } } </code></pre> <p>Which I try to use like this:</p> <pre><code>let newFile = File() newFile.fileName = "My File" </code></pre> <p>Unfortunately, the variable never sets:</p> <p><img src="https://i.stack.imgur.com/VO5Bn.png" alt="Checkpoints"></p> <p>I have two possible workarounds. </p> <h3> Option 1: Observe Value After Set </h3> <pre><code>class File { var fileName: String = "" { didSet { self.fileName += ".fileType" } } } let file = File() file.fileName = "SomeName" // SomeName.fileType </code></pre> <p>But with this, I must wait until the value is already set before I can modify it. For this particular example, it doesn't make too much difference; however, I'd like to be able to avoid this.</p> <h3> Option 2: Subclass </h3> <p>This solution is based on the example <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Inheritance.html#//apple_ref/doc/uid/TP40014097-CH17-XID_265" rel="nofollow noreferrer">here.</a> Search for 'speedLimitedCar'</p> <pre><code>class File { var fileName = "" } class SubFile: File { override var fileName: String { get { return super.fileName } set { super.fileName = newValue + ".fileType" } } } let subfile = SubFile() subfile.fileName = "Hello" // Hello.fileType </code></pre> <h3> Question </h3> <p>I could also just create a secondary property to store the value and access that in the fileName's getter/setter, but is there a way to avoid all that and modify a property directly within its getter / setter?</p>
<p>If you use <code>set</code> and <code>get</code> then the property must be computed. There is no actual storage for it. </p> <p>This code defines a <code>var</code> to hold the data and a computed <code>var</code> to handle the access. This is similar to what you had in Objective C (except that in Objective C you could "hide" the actual variable by making it private or, more recently, having it synthesized an never mentioned in the header).</p> <pre><code>class File { // this stores the actual data, do not access it directly, consider it private var theFileName: String = "" // this is the real interface var fileName: String { get { return self.theFileName } set(name) { self.theFileName = name + ".fileType" } } } </code></pre> <p>You can also write the <code>set</code> like this:</p> <pre><code> set { self.theFileName = newValue + ".fileType" } </code></pre> <p>where <code>newValue</code> is the default name if you omit the argument declaration for <code>set</code>.</p> <p>But what you probably want to do is what you already did (and rejected for unknown reasons):</p> <pre><code>var fileName: String = "" { didSet { self.fileName += ".fileType" } } </code></pre> <p>This is the correct way. Note that "I must wait until the value is already set before I can modify it." is not true. It <em>looks</em> like that, but the compiler can very well optimize the code (and probably will).</p>