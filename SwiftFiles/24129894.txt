How to implement decodeObjectOfClasses in Swift
<p>I'm having trouble finding the correct way to conform the the <code>NSSecureCoding</code> protocol in <strong>Swift</strong>, specifically when decoding objects that is an array of other objects.</p> <p>I can't create an <code>NSSet</code> of class types in swift.</p> <p>In Objective-C I would use</p> <pre><code>self.books = [aDecoder decodeObjectOfClasses:[NSSet setWithObjects:[NSArray class], [Book class], nil] forKey:@"books"]; </code></pre> <p>in Swift I'm having issues creating the <code>NSSet</code> like this : </p> <pre><code>self.books = aDecoder.decodeObjectOfClasses(NSSet().setByAddingObject(NSArray.self).setByAddingObject(Book.self), forKey:"books") </code></pre> <p>Here's the error:</p> <pre><code>Type 'NSArray.Type' does not conform to protocol 'AnyObject' </code></pre>
<p><strong><a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSCoder_Class/index.html#//apple_ref/occ/instm/NSCoder/decodeObjectOfClasses:forKey:" rel="nofollow noreferrer">Declaration</a></strong></p> <p><em>SWIFT</em></p> <pre><code>func decodeObjectOfClasses(_ classes: NSSet, forKey key: String) -&gt; AnyObject? </code></pre> <p>Since Swift 3.0:</p> <pre><code>func decodeObject&lt;DecodedObjectType where DecodedObjectType : NSCoding, DecodedObjectType : NSObject&gt;(of cls: DecodedObjectType.Type, forKey key: String) -&gt; DecodedObjectType? </code></pre> <p><em>OBJECTIVE-C</em></p> <pre><code>- (id)decodeObjectOfClasses:(NSSet *)classes forKey:(NSString *)key let books: AnyObject? = aDecoder.decodeObjectOfClasses(NSSet().setByAddingObject(NSArray.self).setByAddingObject(Book.self), forKey:"books") </code></pre>
<p>For simple objects:</p> <pre><code>self.myObject = aDecoder.decodeObjectOfClass(MyObject.self, forKey: "myObject")! </code></pre> <p>Since Swift 3.0:</p> <pre><code>self.myObject = aDecoder.decodeObject(of:MyObject.self, forKey: "myObject")! </code></pre> <p>For nested objects:</p> <pre><code>NSSet(objects: [NSArray.self, Book.self]) </code></pre>
<p>Not exactly the same as when I originally posted the question, but I've achieved what I wanted by using typed collections as seen below</p> <pre><code>class Bookshelf: NSObject, NSSecureCoding { var authors = [Author]() var books = [Book]() override init () { super.init() } @objc func encodeWithCoder(aCoder: NSCoder) { aCoder.encodeObject(self.authors, forKey: "authors") aCoder.encodeObject(self.books, forKey: "books") } @objc required init?(coder aDecoder: NSCoder) { self.authors = (aDecoder.decodeObjectForKey("authors") as? [Author])! self.books = (aDecoder.decodeObjectForKey("books") as? [Book])! } @objc static func supportsSecureCoding() -&gt; Bool { return true } } </code></pre>