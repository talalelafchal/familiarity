How do I shuffle an array in Swift?
<p>How do I randomize or shuffle the elements within an array in Swift? For example, if my array consists of 52 playing cards, I want to <strong>shuffle</strong> the array in order to shuffle the deck.</p>
<p>Here's some code that runs in playground. You won't need to import Darwin in an actual Xcode project.</p> <pre><code>import darwin var a = [1,2,3,4,5,6,7] func shuffle&lt;ItemType&gt;(item1: ItemType, item2: ItemType) -&gt; Bool { return drand48() &gt; 0.5 } sort(a, shuffle) println(a) </code></pre>
<p>This answer details how to add a Fisher-Yates (fast an uniform) shuffle in the various versions of Swift. The Swift 3 version is the most permissive, but they all at least work for arrays. The naming and behavior for each Swift version matches the mutating and nonmutating sorting methods for that version.</p> <h1>Swift 3.0</h1> <p>These extensions add a <code>shuffle()</code> method to any mutable collection and a <code>shuffled()</code> method to any sequence:</p> <pre><code>extension MutableCollection where Indices.Iterator.Element == Index { /// Shuffles the contents of this collection. mutating func shuffle() { let c = count guard c &gt; 1 else { return } for (firstUnshuffled , unshuffledCount) in zip(indices, stride(from: c, to: 1, by: -1)) { let d: IndexDistance = numericCast(arc4random_uniform(numericCast(unshuffledCount))) guard d != 0 else { continue } let i = index(firstUnshuffled, offsetBy: d) swap(&amp;self[firstUnshuffled], &amp;self[i]) } } } extension Sequence { /// Returns an array with the contents of this sequence, shuffled. func shuffled() -&gt; [Iterator.Element] { var result = Array(self) result.shuffle() return result } } let x = [1, 2, 3].shuffled() // x == [2, 3, 1] let fiveStrings = stride(from: 0, through: 100, by: 5).map(String.init).shuffled() // fiveStrings == ["20", "45", "70", "30", ...] var numbers = [1, 2, 3, 4] numbers.shuffle() // numbers == [3, 2, 1, 4] </code></pre> <hr> <h1>Swift 2.0</h1> <pre><code>extension MutableCollectionType where Index == Int { /// Shuffle the elements of `self` in-place. mutating func shuffleInPlace() { // empty and single-element collections don't shuffle if count &lt; 2 { return } for i in startIndex ..&lt; endIndex - 1 { let j = Int(arc4random_uniform(UInt32(count - i))) + i guard i != j else { continue } swap(&amp;self[i], &amp;self[j]) } } } extension CollectionType { /// Return a copy of `self` with its elements shuffled. func shuffle() -&gt; [Generator.Element] { var list = Array(self) list.shuffleInPlace() return list } } [1, 2, 3].shuffle() // [2, 3, 1] let fiveStrings = 0.stride(through: 100, by: 5).map(String.init).shuffle() // ["20", "45", "70", "30", ...] var numbers = [1, 2, 3, 4] numbers.shuffleInPlace() // [3, 2, 1, 4] </code></pre> <hr> <h1>Swift 1.2</h1> <h2><code>shuffle</code> as a function</h2> <p><strong>This is the simplest version</strong>: add this function anywhere at the top level and you'll be able to shuffle arrays and slices:</p> <pre><code>func shuffle&lt;C: MutableCollectionType where C.Index == Int&gt;(var list: C) -&gt; C { let c = count(list) if c &lt; 2 { return list } for i in 0..&lt;(c - 1) { let j = Int(arc4random_uniform(UInt32(c - i))) + i swap(&amp;list[i], &amp;list[j]) } return list } shuffle([1, 2, 3, 4, 5, 6, 7, 8]) // e.g., [6, 1, 8, 3, 2, 4, 7, 5] shuffle(["hello", "goodbye", "ciao"]) // e.g., ["ciao", "goodbye", "hello"] </code></pre> <h2><code>shuffle</code> as a mutating array method</h2> <p>This extension will let you shuffle a mutable <code>Array</code> instance in place:</p> <pre><code>extension Array { mutating func shuffle() { if count &lt; 2 { return } for i in 0..&lt;(count - 1) { let j = Int(arc4random_uniform(UInt32(count - i))) + i swap(&amp;self[i], &amp;self[j]) } } } var numbers = [1, 2, 3, 4, 5, 6, 7, 8] numbers.shuffle() // e.g., numbers == [6, 1, 8, 3, 2, 4, 7, 5] </code></pre> <h2><code>shuffled</code> as a non-mutating array method</h2> <p>This extension will let you retrieve a shuffled copy of an <code>Array</code> instance:</p> <pre><code>extension Array { func shuffled() -&gt; [T] { if count &lt; 2 { return self } var list = self for i in 0..&lt;(list.count - 1) { let j = Int(arc4random_uniform(UInt32(list.count - i))) + i swap(&amp;list[i], &amp;list[j]) } return list } } let numbers = [1, 2, 3, 4, 5, 6, 7, 8] let mixedup = numbers.shuffled() // e.g., mixedup == [6, 1, 8, 3, 2, 4, 7, 5] </code></pre> <hr> <p>You can get all these in a more copy-pastable format from <a href="https://gist.github.com/natecook1000/0ac03efe07f647b46dae" rel="nofollow noreferrer">this gist</a>.</p>
<p>Here's something possibly a little shorter:</p> <pre><code>sorted(a) {_, _ in arc4random() % 2 == 0} </code></pre>
<p>You can use generic <code>swap</code> function as well and implement mentioned Fisher-Yates:</p> <pre><code>for idx in 0..&lt;arr.count { let rnd = Int(arc4random_uniform(UInt32(idx))) if rnd != idx { swap(&amp;arr[idx], &amp;arr[rnd]) } } </code></pre> <p>or less verbose:</p> <pre><code>for idx in 0..&lt;steps.count { swap(&amp;steps[idx], &amp;steps[Int(arc4random_uniform(UInt32(idx)))]) } </code></pre>
<p>This is what I use:</p> <pre><code>func newShuffledArray(array:NSArray) -&gt; NSArray { var mutableArray = array.mutableCopy() as! NSMutableArray var count = mutableArray.count if count&gt;1 { for var i=count-1;i&gt;0;--i{ mutableArray.exchangeObjectAtIndex(i, withObjectAtIndex: Int(arc4random_uniform(UInt32(i+1)))) } } return mutableArray as NSArray } </code></pre>
<p>There are some good answers here already, as well as some good illustrations of why writing your own shuffle can be error-prone if you're not careful. </p> <p>In iOS 9 and OS X 10.11, you don't have to write your own. There's <a href="https://developer.apple.com/library/prerelease/ios/documentation/GameplayKit/Reference/GKRandomSource_Class/index.html#//apple_ref/occ/instm/GKRandomSource/arrayByShufflingObjectsInArray:">an efficient, correct implementation of Fisher-Yates</a> in GameplayKit (which, despite the name, is not just for games).</p> <p>If you just want a unique shuffle:</p> <pre><code>let shuffled = GKRandomSource.sharedRandom().arrayByShufflingObjectsInArray(array) </code></pre> <p>If you want to be able to replicate a shuffle or series of shuffles, choose and seed a specific random source; e.g.</p> <pre><code>let lcg = GKLinearCongruentialRandomSource(seed: mySeedValue) let shuffled = lcg.arrayByShufflingObjectsInArray(array) </code></pre>
<p>Taking <a href="http://stackoverflow.com/a/24029847/250190">Nate's</a> algorithm I wanted to see how this would look with Swift 2 and protocol extensions.</p> <p>This is what I came up with.</p> <pre><code>extension MutableCollectionType where Self.Index == Int { mutating func shuffleInPlace() { let c = self.count for i in 0..&lt;(c - 1) { let j = Int(arc4random_uniform(UInt32(c - i))) + i swap(&amp;self[i], &amp;self[j]) } } } extension MutableCollectionType where Self.Index == Int { func shuffle() -&gt; Self { var r = self let c = self.count for i in 0..&lt;(c - 1) { let j = Int(arc4random_uniform(UInt32(c - i))) + i swap(&amp;r[i], &amp;r[j]) } return r } } </code></pre> <p>Now, any <code>MutableCollectionType</code> can use these methods given it uses <code>Int</code> as an <code>Index</code></p>
<p>It stop at "swap(&amp;self[i], &amp;self[j])" when I upgrade the xCode version to 7.4 beta.<br/> fatal error: swapping a location with itself is not supported<br/></p> <blockquote> <p>I found the reason that i = j (function of swap will exploded)</p> </blockquote> <p>So I add a condition as below</p> <pre><code>if (i != j){ swap(&amp;list[i], &amp;list[j]) } </code></pre> <p>YA! It's OK for me.</p>
<p>If you want to shuffle an array in place or get a new shuffled array from an array, <a href="https://developer.apple.com/reference/swift/anyiterator" rel="nofollow noreferrer"><code>AnyIterator</code></a> can help you. The idea is to create an array of indices from your array, to shuffle those indices with an <code>AnyIterator</code> instance and <a href="https://developer.apple.com/reference/swift/1540890-swap" rel="nofollow noreferrer"><code>swap(_:_:)</code></a> function and to map each element of this <code>AnyIterator</code> instance with the array's corresponding element.</p> <hr> <p>The following Playground code shows how it works:</p> <pre><code>import Darwin // required for arc4random_uniform let array = ["Jock", "Ellie", "Sue Ellen", "Bobby", "JR", "Pamela"] var indexArray = Array(array.indices) var index = indexArray.endIndex let indexIterator: AnyIterator&lt;Int&gt; = AnyIterator { guard let nextIndex = indexArray.index(index, offsetBy: -1, limitedBy: indexArray.startIndex) else { return nil } index = nextIndex let randomIndex = Int(arc4random_uniform(UInt32(index))) if randomIndex != index { swap(&amp;indexArray[randomIndex], &amp;indexArray[index]) } return indexArray[index] } let newArray = indexIterator.map { array[$0] } print(newArray) // may print: ["Jock", "Ellie", "Sue Ellen", "JR", "Pamela", "Bobby"] </code></pre> <hr> <p>You can refactor the previous code and create a <code>shuffled()</code> function inside an <code>Array</code> extension in order to get a new shuffled array from an array:</p> <pre><code>import Darwin // required for arc4random_uniform extension Array { func shuffled() -&gt; Array&lt;Element&gt; { var indexArray = Array&lt;Int&gt;(indices) var index = indexArray.endIndex let indexIterator = AnyIterator&lt;Int&gt; { guard let nextIndex = indexArray.index(index, offsetBy: -1, limitedBy: indexArray.startIndex) else { return nil } index = nextIndex let randomIndex = Int(arc4random_uniform(UInt32(index))) if randomIndex != index { swap(&amp;indexArray[randomIndex], &amp;indexArray[index]) } return indexArray[index] } return indexIterator.map { self[$0] } } } </code></pre> <p><em>Usage:</em> </p> <pre><code>let array = ["Jock", "Ellie", "Sue Ellen", "Bobby", "JR", "Pamela"] let newArray = array.shuffled() print(newArray) // may print: ["Bobby", "Pamela", "Jock", "Ellie", "JR", "Sue Ellen"] </code></pre> <pre><code>let emptyArray = [String]() let newEmptyArray = emptyArray.shuffled() print(newEmptyArray) // prints: [] </code></pre> <hr> <p>As an alternative to the previous code, you can create a <code>shuffle()</code> function inside an <code>Array</code> extension in order to shuffle an array in place:</p> <pre><code>import Darwin // required for arc4random_uniform extension Array { mutating func shuffle() { var indexArray = Array&lt;Int&gt;(indices) var index = indexArray.endIndex let indexIterator = AnyIterator&lt;Int&gt; { guard let nextIndex = indexArray.index(index, offsetBy: -1, limitedBy: indexArray.startIndex) else { return nil } index = nextIndex let randomIndex = Int(arc4random_uniform(UInt32(index))) if randomIndex != index { swap(&amp;indexArray[randomIndex], &amp;indexArray[index]) } return indexArray[index] } self = indexIterator.map { self[$0] } } } </code></pre> <p><em>Usage:</em> </p> <pre><code>var mutatingArray = ["Jock", "Ellie", "Sue Ellen", "Bobby", "JR", "Pamela"] mutatingArray.shuffle() print(mutatingArray) // may print ["Sue Ellen", "Pamela", "Jock", "Ellie", "Bobby", "JR"] </code></pre>
<p>In <strong>Swift 2.0</strong>, GameplayKit may come to the rescue! (supported by <strong>iOS9</strong> or later)</p> <pre><code>import GameplayKit func shuffle() { array = GKRandomSource.sharedRandom().arrayByShufflingObjectsInArray(array) } </code></pre>
<p>Swift 3 solution, following @Nate Cook answer: (work if the index starts with 0, see comments below)</p> <pre><code>extension Collection { /// Return a copy of `self` with its elements shuffled func shuffle() -&gt; [Generator.Element] { var list = Array(self) list.shuffleInPlace() return list } } extension MutableCollection where Index == Int { /// Shuffle the elements of `self` in-place. mutating func shuffleInPlace() { // empty and single-element collections don't shuffle if count &lt; 2 { return } let countInt = count as! Int for i in 0..&lt;countInt - 1 { let j = Int(arc4random_uniform(UInt32(countInt - i))) + i guard i != j else { continue } swap(&amp;self[i], &amp;self[j]) } } } </code></pre>
<p>This is how its done in a Simplest way.<code>import Gamplaykit</code> to your VC and use the below code. Tested in Xcode 8.</p> <pre><code> import GameplayKit let array: NSArray = ["Jock", "Ellie", "Sue Ellen", "Bobby", "JR", "Pamela"] override func viewDidLoad() { super.viewDidLoad() print(array.shuffled()) } </code></pre> <p>If you want to get a shuffled String from an Array you can use below code..</p> <pre><code>func suffleString() { let ShuffleArray = array.shuffled() suffleString.text = ShuffleArray.first as? String print(suffleString.text!) } </code></pre>
<p>In my case, I had some problems of swapping objects in Array. Then I scratched my head and go for reinventing the wheel.</p> <pre><code>// swift 3.0 ready extension Array { func shuffled() -&gt; [Element] { var results = [Element]() var indexes = (0 ..&lt; count).map { $0 } while indexes.count &gt; 0 { let indexOfIndexes = Int(arc4random_uniform(UInt32(indexes.count))) let index = indexes[indexOfIndexes] results.append(self[index]) indexes.remove(at: indexOfIndexes) } return results } } </code></pre>