Adding observer for KVO without pointers using Swift
<p>In Objective-C, I would normally use something like this:</p> <pre><code>static NSString *kViewTransformChanged = @"view transform changed"; // or static const void *kViewTransformChanged = &amp;kViewTransformChanged; [clearContentView addObserver:self forKeyPath:@"transform" options:NSKeyValueObservingOptionNew context:&amp;kViewTransformChanged]; </code></pre> <p>I have two overloaded methods to choose from to add an observer for KVO with the only difference being the context argument:</p> <pre><code> clearContentView.addObserver(observer: NSObject?, forKeyPath: String?, options: NSKeyValueObservingOptions, context: CMutableVoidPointer) clearContentView.addObserver(observer: NSObject?, forKeyPath: String?, options: NSKeyValueObservingOptions, kvoContext: KVOContext) </code></pre> <p>With Swift not using pointers, I'm not sure how to dereference a pointer to use the first method.</p> <p>If I create my own KVOContext constant for use with the second method, I wind up with it asking for this:</p> <pre><code>let test:KVOContext = KVOContext.fromVoidContext(context: CMutableVoidPointer) </code></pre> <p>EDIT: What is the difference between CMutableVoidPointer and KVOContext? Can someone give me an example how how to use them both and when I would use one over the other?</p> <p>EDIT #2: A dev at Apple just posted this to the forums: KVOContext is going away; using a global reference as your context is the way to go right now.</p>
<p>Now that KVOContext is gone in Xcode 6 beta 3, you can do the following. Define a global (i.e. not a class property) like so:</p> <pre><code>let myContext = UnsafePointer&lt;()&gt;() </code></pre> <p>Add an observer:</p> <pre><code>observee.addObserver(observer, forKeyPath: …, options: nil, context: myContext) </code></pre> <p>In the observer:</p> <pre><code>override func observeValueForKeyPath(keyPath: String!, ofObject object: AnyObject!, change: [NSObject : AnyObject]!, context: UnsafePointer&lt;()&gt;) { if context == myContext { … } else { super.observeValueForKeyPath(keyPath, ofObject: object, change: change, context: context) } } </code></pre>
<p>There is now a technique officially <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-ID12">recommended in the documentation</a>, which is to create a <strong>private mutable variable</strong> and use its address as the context.</p> <pre><code>// Set up non-zero-sized storage. We don't intend to mutate this variable, // but it needs to be `var` so we can pass its address in as UnsafeMutablePointer. private static var myContext = 0 // NOTE: `static` is not necessary if you want it to be a global variable observee.addObserver(self, forKeyPath: …, options: [], context: &amp;myContext) override func observeValueForKeyPath(keyPath: String?, ofObject object: AnyObject?, change: [NSObject : AnyObject]?, context: UnsafePointer&lt;Void&gt;) { if context == &amp;myContext { … } else { super.observeValueForKeyPath(keyPath, ofObject: object, change: change, context: context) } } </code></pre>
<p>Since Aderstedt's and jtbandes' solution did not work I am documenting my approach here:</p> <pre><code>var myContext:Int? = nil func setup(){ someObject.addObserver(self, forKeyPath: "somePath", options: [], context: &amp;myContext) } override func observeValueForKeyPath(keyPath: String?, ofObject object: AnyObject?, change: [String : AnyObject]?, context: UnsafeMutablePointer&lt;Void&gt;) { guard &amp;myContext == context else { super.observeValueForKeyPath(keyPath, ofObject: object, change: change, context: context) return } switch keyPath!{ case "somePath": // Do your stuff here default: super.observeValueForKeyPath(keyPath, ofObject: object, change: change, context: context) } } </code></pre>
<p>Complete example using Swift:</p> <pre><code>// // AppDelegate.swift // Photos-MediaFramework-swift // // Created by Phurg on 11/11/16. // // Displays URLs for all photos in Photos Library // // @see http://stackoverflow.com/questions/30144547/programmatic-access-to-the-photos-library-on-mac-os-x-photokit-photos-framewo // import Cocoa import MediaLibrary // For KVO: https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-ID12 private var mediaLibraryLoaded = 1 private var rootMediaGroupLoaded = 2 private var mediaObjectsLoaded = 3 @NSApplicationMain class AppDelegate: NSObject, NSApplicationDelegate { @IBOutlet weak var window: NSWindow! var mediaLibrary : MLMediaLibrary! var allPhotosAlbum : MLMediaGroup! func applicationDidFinishLaunching(_ aNotification: Notification) { NSLog("applicationDidFinishLaunching:"); let options:[String:Any] = [ MLMediaLoadSourceTypesKey: MLMediaSourceType.image.rawValue, // Can't be Swift enum MLMediaLoadIncludeSourcesKey: [MLMediaSourcePhotosIdentifier], // Array ] self.mediaLibrary = MLMediaLibrary(options:options) NSLog("applicationDidFinishLaunching: mediaLibrary=%@", self.mediaLibrary); self.mediaLibrary.addObserver(self, forKeyPath:"mediaSources", options:[], context:&amp;mediaLibraryLoaded) NSLog("applicationDidFinishLaunching: added mediaSources observer"); // Force load self.mediaLibrary.mediaSources?[MLMediaSourcePhotosIdentifier] NSLog("applicationDidFinishLaunching: done"); } override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) { NSLog("observeValue: keyPath=%@", keyPath!) let mediaSource:MLMediaSource = self.mediaLibrary.mediaSources![MLMediaSourcePhotosIdentifier]! if (context == &amp;mediaLibraryLoaded) { NSLog("observeValue: mediaLibraryLoaded") mediaSource.addObserver(self, forKeyPath:"rootMediaGroup", options:[], context:&amp;rootMediaGroupLoaded) // Force load mediaSource.rootMediaGroup } else if (context == &amp;rootMediaGroupLoaded) { NSLog("observeValue: rootMediaGroupLoaded") let albums:MLMediaGroup = mediaSource.mediaGroup(forIdentifier:"TopLevelAlbums")! for album in albums.childGroups! { let albumIdentifier:String = album.attributes["identifier"] as! String if (albumIdentifier == "allPhotosAlbum") { self.allPhotosAlbum = album album.addObserver(self, forKeyPath:"mediaObjects", options:[], context:&amp;mediaObjectsLoaded) // Force load album.mediaObjects } } } else if (context == &amp;mediaObjectsLoaded) { NSLog("observeValue: mediaObjectsLoaded") let mediaObjects:[MLMediaObject] = self.allPhotosAlbum.mediaObjects! for mediaObject in mediaObjects { let url:URL? = mediaObject.url // URL does not extend NSObject, so can't be passed to NSLog; use string interpolation NSLog("%@", "\(url)") } } } } </code></pre>