UIKeyboard not appearing when tapping on UITextField
<p><img src="https://i.stack.imgur.com/uG0XS.png" alt="This is the Signup VC ,as Tapping pops the white space Not the KeyBoard"><img src="https://i.stack.imgur.com/MIspK.png" alt="This is the login VC ,as Tapping pops the white space Not the KeyBoard"></p> <p>I had been into a weird problem, As every other thing is working fine. All of sudden when I compile my application and got this problem, when I tapped on the <code>UITextField</code> white space is popping up, but the keyboard is not visible and I am not able to enter anything.</p>
<p>check if at some point you're doing something like</p> <pre><code>[self.view endEditing:YES]; [self.myTextField resignFirstResponder]; </code></pre> <p>or maybe you're assigning the first responder to some other control.</p> <p>Hope it helps</p>
<p>in this regard check two things</p> <p>1-<code>userInteractionEnabled=true</code></p> <p>2- <code>textFielfd.editable = YES;</code></p> <p>Hope this will solve your problem.</p>
<p>Following will fix the keyboard issue </p> <p><em>Simulator -> Hardware -> Keyboard -> Toggle Software Keyboard</em> should solve this problem.</p> <p><img src="https://i.stack.imgur.com/WNOpU.png" alt="![Simulator-&gt;Hardware-&gt;Keyboard-&gt;Toggle Software Keyboard]"></p>
<p>Add <code>[textField canBecomeFirstresponder];</code></p>
<p>Check if the outlet is mapped and the delegate set to the controller ? Also check if the controller has <code>&lt;UITextFieldDelegate&gt;</code> set. Send screen shot of the file inspector, perhaps?</p>
<p>This can also happen with Xcode 6/iOS 8 because of simulator settings:</p> <p><a href="http://stackoverflow.com/questions/24420873/swift-xcode-6-keyboard-not-showing-up-in-ios-simulator">Swift Xcode 6: keyboard not showing up in ios simulator</a></p>
<p>I've got the same problem but only on 5s simulator. And, I tried to go to simulator->reset content and settings. That actually solved the problem.</p>
<p>Try this:</p> <p>Goto: <br/></p> <pre><code>iOS Simulator -&gt; Hardware -&gt; Keyboard </code></pre> <p>And Uncheck</p> <pre><code>'Connect Hardware Keyboard' </code></pre> <p>Or simply do: <kbd>⇧ shift</kbd> + <kbd>⌘ Command</kbd> + <kbd>K</kbd></p> <p>Keep Coding......... :)</p>
<p>I had the similar problem but on the actual device.<br> I talked to apple developer technical support (Apple DTS) and they told me that it's a swift compiler or Xcode bug.<br> I did a little workaround. Don't think that It's a best solution until apple solves this problem but it works without any problem now.</p> <p>Just override the UITextField class: </p> <pre><code>class PBTextField : UITextField { var keyboardShowDate = NSDate() required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) self.initialisation() } override init(frame: CGRect) { super.init(frame: frame) self.initialisation() } func initialisation() { self.addTarget(self, action: "editingDidBegin:", forControlEvents: UIControlEvents.EditingDidBegin) self.addTarget(self, action: "editingDidEnd:", forControlEvents: UIControlEvents.EditingDidEnd) } // MARK: Delegates func editingDidBegin(sender: AnyObject) { self.becomeFirstResponder() self.keyboardShowDate = NSDate() } func editingDidEnd(sender: AnyObject) { if(fabs(self.keyboardShowDate.timeIntervalSinceNow) &lt;= 0.5) { self.becomeFirstResponder() dispatch_after(0.1, block: { () -&gt; Void in self.becomeFirstResponder() }) } } } </code></pre> <p>dispatch methods: </p> <pre><code>typealias dispatch_cancelable_block_t = ((cancel: Bool) -&gt; Void) func dispatch_async(block: dispatch_block_t, background: Bool = true) -&gt; dispatch_cancelable_block_t? { return dispatch_after(0, block: block, background: background) } func dispatch_after(delay: NSTimeInterval = 0, block: dispatch_block_t, background: Bool = false) -&gt; dispatch_cancelable_block_t? { var cancelableBlock : dispatch_cancelable_block_t? let delayBlock : dispatch_cancelable_block_t = { (cancel) -&gt; Void in if(cancel == false) { if(background) { block() } else { dispatch_async(dispatch_get_main_queue(), block) } } cancelableBlock = nil }; cancelableBlock = delayBlock dispatch_after(dispatch_time(DISPATCH_TIME_NOW, Int64(delay * NSTimeInterval(NSEC_PER_SEC))), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), { if let cb = cancelableBlock { cb(cancel: false) } }) return cancelableBlock } func cancel_block(block: dispatch_cancelable_block_t) { block(cancel: true) } </code></pre> <p>Hope this will help to someone.<br> If you got better solution, please let me know in comments.<br> Thanks<br> Giorgi</p>
<p>Also make sure you aren't messing with <code>yourTextField.inputView</code></p>