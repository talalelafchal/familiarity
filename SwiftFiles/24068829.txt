Lazy loading Properties in swift
<p>I'm attempting to wrap my head around the Swift language. A common pattern when building views in code with Objective-C is to override UI properties and lazy load them like so:</p> <pre><code>@property(nonatomic, strong) UILabel *myLabel; - (UILabel *)myLabel { if (!_myLabel) { _myLabel = [[UILabel alloc] initWithFrame:CGRectMake(20.0f, 75.0f, 320.0f, 20.0f)]; [_myLabel setFont:[UIFont subHeadlineFont]]; [_myLabel setTextColor:[UIColor subHeadlineColor]]; [_myLabel setText:@"Hello World"]; } return _myLabel; } - (void)viewDidLoad { [super viewDidLoad]; [self.view addSubview:self.myLabel]; } </code></pre> <p>This allows for the configuration of UIElements to be self contained within their setup but doesn't result in reconfiguring them every time.</p> <p>It seems we don't have access to the backing store in Swift and the <code>@lazy</code> keyword doesn't really have the same semantics.</p> <p>I'm curious if anyone has identified a similar pattern in Swift that allows one to keep the configuration of variables and constants together with their declaration in a neat syntactic way that doesn't result in reconfiguration every time?</p>
<p>This is pretty much the Swift version as your ObjectiveC example. (simplified to use an <code>Int</code> rather than a view)</p> <pre><code>class Foo { var _value: Int? var value: Int { get { if !_value { _value = 123 } return _value! } } } Foo().value //-&gt; 123 </code></pre> <p>Though it's not very pretty.</p>
<p>You can provide a closure on your @lazy variable to declare how it should be created:</p> <pre><code>class Blah { @lazy var label: () -&gt; UILabel = { var view:UILabel = UILabel(); //Do stuff here return view; } } </code></pre>
<p>I think a <code>lazy</code> property initialized with a closure would work:</p> <pre><code>lazy var myLabel: UILabel = { var temporaryLabel: UILabel = UILabel() ... return temporaryLabel }() </code></pre> <p>As I read “The Swift Programming Language.” (Checkerboard example) the closure is only evaluated once).</p>
<pre><code>class Thingy { init(){ println("making a new Thingy") } } var thingy = { Thingy(); }() println("\(self.thingy)") println("\(self.thingy)") </code></pre> <p>The log message "making a new Thingy" appears just once, proving that only one Thingy was created - the closure was called only once, namely to initialize this property. This is effectively what you are describing. All you have to do is add more to the closure so as to configure it the returned object.</p> <p>If you make the var <code>@lazy</code> and comment out the <code>println</code> statements, <em>no</em> Thingy is created, proving that the laziness does what it is intended to do; you could omit this, however, since you know that the label will in fact always be needed early on. The point of <code>@lazy</code> is to prevent the closure from <em>ever</em> being called unless the getter is called, but you are always going to call the getter so that is pointless in your situation.</p>
<p>Just as a variant to Christian Otkjær's answer it is also possible to assign a class method to the @lazy var:</p> <pre><code>class MyClass { @lazy var myLabel : UILabel = MyClass.newLabel() class func newLabel() -&gt; UILabel { var temporaryLabel : UILabel = UILabel() ... return temporaryLabel } } </code></pre> <p>It's effectively the same as using a closure but in case there are too many lines of code in the closure, it's an option to put that code in a class method somewhere else after the declaration of all properties and initialization methods.</p>
<p>Apple seems to be doing it differently... If I create a new project in Xcode and add Core Data, there's an example of it in the <code>AppDelegate.swift</code>:</p> <pre><code>// Returns the managed object model for the application. // If the model doesn't already exist, it is created from the application's model. var managedObjectModel: NSManagedObjectModel { if !_managedObjectModel { let modelURL = NSBundle.mainBundle().URLForResource("MyApp", withExtension: "momd") _managedObjectModel = NSManagedObjectModel(contentsOfURL: modelURL) } return _managedObjectModel! } var _managedObjectModel: NSManagedObjectModel? = nil </code></pre> <p>Though, this reads to me as the variable is created on initialization, however just read subsequently and <code>@lazy</code> seems like a nicer implementation. Any thoughts?</p> <p>So I tried this:</p> <pre><code>class TestClass { @lazy var myLabel : UILabel = { var temporaryLabel : UILabel = UILabel() return temporaryLabel }() var testLabel: UILabel { if !_testLabel { _testLabel = UILabel() } return _testLabel! } var _testLabel: UILabel? = nil func test () { println(myLabel) println(self.testLabel) } } </code></pre> <p>And both are indeed just created lazily. As @bradlarson <a href="https://twitter.com/bradlarson/status/477481695294148608">points out on Twitter</a>:</p> <blockquote> <p>@runmad The one thing that your approach preserves is the read-only state of the property. @lazy can’t be used with let, which is an issue.</p> </blockquote>
<h2>Swift 3.0</h2> <p>I prefer this inline style. </p> <pre><code>lazy var myLabel: UILabel = self.createMyLabel() private func createMyLabel() -&gt; UILabel { let mylabel = UILabel() // ... return mylabel } </code></pre>