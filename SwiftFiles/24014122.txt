Custom class clusters in Swift
<p>This is a relatively common design pattern:</p> <p><a href="http://stackoverflow.com/a/17015041/743957">http://stackoverflow.com/a/17015041/743957</a></p> <p>It allows you to return a subclass from your <code>init</code> calls.</p> <p>I'm trying to figure out the best method of achieving the same thing using Swift.</p> <p>I do know that it is very likely that there is a better method of achieving the same thing with Swift. However, my class is going to be initialized by an existing Obj-C library which I don't have control over. So it does need to work this way and be callable from Obj-C.</p> <p>Any pointers would be very much appreciated.</p>
<p>I don't believe that this pattern can be directly supported in Swift, because initialisers do not return a value as they do in Objective C - so you do not get an opportunity to return an alternate object instance. </p> <p>You can use a type method as an object factory - a fairly contrived example is - </p> <pre><code>class Vehicle { var wheels: Int? { get { return nil } } class func vehicleFactory(wheels:Int) -&gt; Vehicle { var retVal:Vehicle if (wheels == 4) { retVal=Car() } else if (wheels == 18) { retVal=Truck() } else { retVal=Vehicle() } return retVal } } class Car:Vehicle { override var wheels: Int { get { return 4 } } } class Truck:Vehicle { override var wheels: Int { get { return 18 } } } </code></pre> <p>main.swift</p> <pre><code>let c=Vehicle.vehicleFactory(4) // c is a Car println(c.wheels) // outputs 4 let t=Vehicle.vehicleFactory(18) // t is a truck println(t.wheels) // outputs 18 </code></pre>
<p>I think actually the Cluster pattern can be implemented in Swift using runtime functions. The main point is to replace the class of your new object with a subclass when initializing. The code below works fine though I think more attention should be paid to subclass' initialization.</p> <pre><code>class MyClass { var name: String? convenience init(type: Int) { self.init() var subclass: AnyClass? if type == 1 { subclass = MySubclass1.self } else if type == 2 { subclass = MySubclass2.self } object_setClass(self, subclass) self.customInit() } func customInit() { // to be overridden } } class MySubclass1 : MyClass { override func customInit() { self.name = "instance of MySubclass1" } } class MySubclass2 : MyClass { override func customInit() { self.name = "instance of MySubclass2" } } let myObject1 = MyClass(type: 1) let myObject2 = MyClass(type: 2) println(myObject1.name) println(myObject2.name) </code></pre>
<p>The "swifty" way of creating class clusters would actually be to expose a protocol instead of a base class.</p> <p>Apparently the compiler forbids static functions on protocols or protocol extensions.</p> <p>Until e.g. <a href="https://github.com/apple/swift-evolution/pull/247" rel="nofollow">https://github.com/apple/swift-evolution/pull/247</a> (factory initializers) is accepted and implemented, the only way I could find to do this is the following:</p> <pre><code>import Foundation protocol Building { func numberOfFloors() -&gt; Int } func createBuilding(numberOfFloors numFloors: Int) -&gt; Building? { switch numFloors { case 1...4: return SmallBuilding(numberOfFloors: numFloors) case 5...20: return BigBuilding(numberOfFloors: numFloors) case 21...200: return SkyScraper(numberOfFloors: numFloors) default: return nil } } private class BaseBuilding: Building { let numFloors: Int init(numberOfFloors:Int) { self.numFloors = numberOfFloors } func numberOfFloors() -&gt; Int { return self.numFloors } } private class SmallBuilding: BaseBuilding { } private class BigBuilding: BaseBuilding { } private class SkyScraper: BaseBuilding { } </code></pre> <p>.</p> <pre><code>// this sadly does not work as static functions are not allowed on protocols. //let skyscraper = Building.create(numberOfFloors: 200) //let bigBuilding = Building.create(numberOfFloors: 15) //let smallBuilding = Building.create(numberOfFloors: 2) // Workaround: let skyscraper = createBuilding(numberOfFloors: 200) let bigBuilding = createBuilding(numberOfFloors: 15) let smallBuilding = createBuilding(numberOfFloors: 2) </code></pre>
<p>Since <code>init()</code> doesn't return values like <code>-init</code> does in Objective C, using a factory method seems like the easiest option.</p> <p>One trick is to mark your initializers as <code>private</code>, like this:</p> <pre><code>class Person : CustomStringConvertible { static func person(age: UInt) -&gt; Person { if age &lt; 18 { return ChildPerson(age) } else { return AdultPerson(age) } } let age: UInt var description: String { return "" } private init(_ age: UInt) { self.age = age } } extension Person { class ChildPerson : Person { let toyCount: UInt private override init(_ age: UInt) { self.toyCount = 5 super.init(age) } override var description: String { return "\(self.dynamicType): I'm \(age). I have \(toyCount) toys!" } } class AdultPerson : Person { let beerCount: UInt private override init(_ age: UInt) { self.beerCount = 99 super.init(age) } override var description: String { return "\(self.dynamicType): I'm \(age). I have \(beerCount) beers!" } } } </code></pre> <p>This results in the following behavior:</p> <pre><code>Person.person(10) // "ChildPerson: I'm 10. I have 5 toys!" Person.person(35) // "AdultPerson: I'm 35. I have 99 beers!" Person(35) // 'Person' cannot be constructed because it has no accessible initializers Person.ChildPerson(35) // 'Person.ChildPerson' cannot be constructed because it has no accessible initializers </code></pre> <p>It's not quite as nice as Objective C, since <code>private</code> means all the subclasses need to be implemented in the same source file, and there's that the minor syntax difference <code>Person.person(x)</code> (or <code>Person.create(x)</code> or whatever) instead of simply <code>Person(x)</code>, but practically speaking, it works the same.</p> <p>To be able to instantiate literally as <code>Person(x)</code>, you could turn <code>Person</code> into a proxy class which contains a private instance of the actual base class and forwards everything to it. Without message forwarding, this works for simple interfaces with few properties/methods but it gets unwieldy for anything more complex :P</p>