Multiple Type Constraints in Swift
<p>Let's say I have these protocols:</p> <pre><code>protocol SomeProtocol { } protocol SomeOtherProtocol { } </code></pre> <p>Now, if I want a function that takes a generic type, but that type must conform to <code>SomeProtocol</code> I could do:</p> <pre><code>func someFunc&lt;T: SomeProtocol&gt;(arg: T) { // do stuff } </code></pre> <p>But is there a way to add a type constraint for multiple protocols?</p> <pre><code>func bothFunc&lt;T: SomeProtocol | SomeOtherProtocol&gt;(arg: T) { } </code></pre> <p>Similar things use commas, but in this case, it would start the declaration of a different type. Here's what I've tried.</p> <pre><code>&lt;T: SomeProtocol | SomeOtherProtocol&gt; &lt;T: SomeProtocol , SomeOtherProtocol&gt; &lt;T: SomeProtocol : SomeOtherProtocol&gt; </code></pre>
<p>You can use a <a href="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/GenericParametersAndArguments.html#//apple_ref/doc/uid/TP40014097-CH37-XID_775">where clause</a> which lets you specify as many requirements as you want (all of which must be fulfilled) separated by commas</p> <h2>Swift 2:</h2> <pre><code>func someFunc&lt;T where T:SomeProtocol, T:SomeOtherProtocol&gt;(arg: T) { // stuff } </code></pre> <h2>Swift 3:</h2> <pre><code>func someFunc&lt;T: SomeProtocol &amp; SomeOtherProtocol&gt;(arg: T) { // stuff } </code></pre> <p>or the more powerful where clause:</p> <pre><code>func someFunc&lt;T&gt;(arg: T) where T:SomeProtocol, T:SomeOtherProtocol{ // stuff } </code></pre> <p>You can of course use protocol composition (e.g., <code>protocol&lt;SomeProtocol, SomeOtherProtocol&gt;</code> ), but it's a little less flexible. </p> <p>Using <code>where</code> let's you deal with cases where there are multiple types involved.</p> <p>You may still want to compose protocols for reuse in multiple places, or just to give the composed protocol a meaningful name.</p>
<p>You have two possibilities:</p> <ol> <li><p>You use a <strong><a href="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/GenericParametersAndArguments.html#//apple_ref/doc/uid/TP40014097-CH37-XID_775">where clause</a></strong> as indicated in Jiaaro's answer:</p> <pre><code>func someFunc&lt;T where T : SomeProtocol, T : SomeOtherProtocol&gt;(arg: T) { // do stuff } </code></pre></li> <li><p>You use a <strong><a href="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Types.html#//apple_ref/swift/grammar/protocol-composition-type">protocol composition type</a></strong>:</p> <pre><code>func someFunc&lt;T : protocol&lt;SomeProtocol, SomeOtherProtocol&gt;&gt;(arg: T) { // do stuff } </code></pre></li> </ol>
<p>The evolution to Swift 3.0 brings some changes. Our two choices now look a little different.</p> <p><strong>Using a <code>where</code> clause in Swift 3.0:</strong></p> <p>The <code>where</code> clause has now moved to the end of a function signature to improve readability. So multiple protocol inheritance now looks like this:</p> <pre><code>func someFunc&lt;T&gt;(arg: T) where T:SomeProtocol, T:SomeOtherProtocol { } </code></pre> <p><strong>Using the <code>protocol&lt;&gt;</code> construct in Swift 3.0:</strong></p> <p>Composition using the <code>protocol&lt;&gt;</code> construct is being deprecated. The earlier <code>protocol&lt;SomeProtocol, SomeOtherProtocol&gt;</code> now looks like this:</p> <pre><code>func someFunc&lt;T:SomeProtocol &amp; SomeOtherProtocol&gt;(arg: T) { } </code></pre> <p><strong>References.</strong></p> <p>More info on the changes for <code>where</code> are here: <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0081-move-where-expression.md">https://github.com/apple/swift-evolution/blob/master/proposals/0081-move-where-expression.md</a></p> <p>And, more on the changes for the protocol&lt;> construct are here: <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0095-any-as-existential.md">https://github.com/apple/swift-evolution/blob/master/proposals/0095-any-as-existential.md</a></p>
<p>Swift 3 offers up to 3 different ways to declare your function.</p> <pre><code>protocol SomeProtocol { /* ... */ } protocol SomeOtherProtocol { /* ... */ } </code></pre> <h2>1. Using <code>&amp;</code> operator</h2> <pre><code>func someFunc&lt;T: SomeProtocol &amp; SomeOtherProtocol&gt;(arg: T) { /* ... */ } </code></pre> <h2>2. Using <code>where</code> clause</h2> <pre><code>func someFunc&lt;T&gt;(arg: T) where T: SomeProtocol, T: SomeOtherProtocol { /* ... */ } </code></pre> <h2>3. Using <code>where</code> clause and <code>&amp;</code> operator</h2> <pre><code>func someFunc&lt;T&gt;(arg: T) where T: SomeProtocol &amp; SomeOtherProtocol { /* ... */ } </code></pre> <hr> <p>Also note that you can use <code>typealias</code> in order to shorten your function declaration.</p> <pre><code>typealias RequiredProtocols = SomeProtocol &amp; SomeOtherProtocol func someFunc&lt;T: RequiredProtocols&gt;(arg: T) { /* ... */ } </code></pre>