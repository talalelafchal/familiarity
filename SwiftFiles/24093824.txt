How can I specify a generic constraint that enforces a subscript in Swift?
<p>How can I define a relationship that specifies that <code>T</code> supports an <code>Int</code> subscript in my generic constraint so this function compiles?</p> <pre><code>func index&lt;T,U&gt;(x:T) -&gt; U { return x[0] //Invalid capability as expected } </code></pre> <p>My first guess is something like <code>T[Int] == U</code> where I can specify <code>T</code> can be indexed with an <code>Int</code> and returns <code>U</code>, i.e:</p> <pre><code>func index&lt;T,U where T[Int] == U&gt;(x:T) -&gt; U { return x[0] } </code></pre> <p>But this made up syntax doesn't work. Is there anyway I can specify this relationship either as a generic constraint or a protocol?</p>
<p>You can use a protocol that implements subscript functionality. For example:</p> <pre><code>protocol Container { typealias ItemType mutating func append(item: ItemType) var count: Int { get } subscript(i: Int) -&gt; ItemType { get } } func index&lt;T:Container, U where U == T.ItemType&gt;(x:T) -&gt; U { return x[0] } </code></pre>