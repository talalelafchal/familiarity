Unbounded memory growth - iOS
<p><strong>SOLVED BELOW</strong></p> <p>I'm reading this article from raywenderlich blog: <a href="http://www.raywenderlich.com/23037/how-to-use-instruments-in-xcode" rel="nofollow noreferrer">http://www.raywenderlich.com/23037/how-to-use-instruments-in-xcode</a> to learn about instruments and figure out if I´m doing something wrong in some old projects.</p> <p>I've seen that in one particular point of my code, when I'm showing a modal view that eventually is closed, the memory allocated remains there. As you can see in the following image.</p> <p><img src="https://i.stack.imgur.com/6OwLl.png" alt="enter image description here"></p> <p>The execution have 4 marks generated. Between the 2n and the 3t mark, the view is showed, as you can see, new memory is allocated. But between the 3t and the 4th, I've called dismissViewController, and the view no longer remains. But the memory remains allocated.</p> <p>All the properties, are created as strong (probably no the best approach):</p> <p><img src="https://i.stack.imgur.com/QN339.png" alt="enter image description here"> <img src="https://i.stack.imgur.com/UryHa.png" alt="enter image description here"></p> <p>And I´ve an NSTimer, that is initialized in viewDidLoad method, and set to nil at viewWillDisappear:</p> <pre><code>[self.secondTimer invalidate]; self.secondTimer = nil; </code></pre> <p>So, do you have any idea about what's happening? From what I know, even the properties are declared as strong, when the UIViewController is released, all of them are going to be released to.</p> <p><strong>EDIT</strong></p> <p>Thanks to all, with the information I provided, wasn't enough.</p> <p>As you can see, QRViewController inherits from BaseViewController.</p> <p>This controller had a delegate defined as strong storage, terrible.</p> <p>So that's all.</p>
<p>It's difficult to pinpoint precisely the problem, but usually when things like this happen to me, it winds up being one (or a few) "root" culprits -- you find that one, clear it up, and then lots of others clear up too. So one strategy you can try is to sift through the Instruments data looking for any sort of "hierarchy" (think about how your app is structured and how the objects relate to each other) and look for objects closer to the base, then cross-reference against your code to see if they might have a retain cycle or some other such issue.</p> <p>One immediate change I would make would be to change your <code>IBOutlet</code> declarations from <code>strong</code> to <code>weak</code>. For the most part, <code>IBOutlet</code> properties should be <code>weak</code>, for objects that are within a hierarchy. So if say you've got some <code>UILabel</code> within your xib's main <code>view</code>, that label should be weakly-retained so as to avoid a retain cycle. But if say that <code>UILabel</code> is standing alone as a root item within the xib, then it would need a <code>strong</code> reference. I'm going to guess most (if not all) of your <code>IBOutlet</code>s there are within a hierarchy, so make them <code>weak</code> and try again. It may not solve all the leaks, but see if it makes any difference.</p>
<p>In the view controller hierarchy, <code>self.view</code> holds ALL his subviews with <code>strong</code>, so everything under <code>self.view</code> (Probably all your <code>IBOutlet</code> properties) can switch to <code>weak</code>. That probably won't solve the problem though.</p> <p>What might help you is the fact that any <code>block</code> you have holds every single object used in that block as a strong, to make sure the block can run it's code at the time being. If nothing holds that block (like a <code>animationWithDuration:</code>) than no worries. But if you have any block that an object is holding (Like and object's "completion-block" or any other creative use of blocks), everything within that block will be <code>strong</code>, and there's a chance you create a retain cycle that way. For example: the presenting view controller is calling the presented view controller with a completion block, and in that block you use <code>self</code>. Now presented VC is holding a block to perform on dismiss, and the block holds the presenting VC. When dismissed you will end up with a VC that holds a block that holds a VC that holds the presented VC....</p> <p>A simple solution would be to give the block a <code>weak</code> version of <code>self</code> and only when the block executes, make it <code>strong</code> for the time of running the block (To avoid dealloc while running the block):</p> <pre><code>__weak myViewController *weakself = self; [self.someObject setBlockHandler:^(BOOL foo){ myViewController *strongself = weakself; if (strongself) { // Do whatever... } }]; </code></pre>
<p>This is called <strong>Abandoned Memory</strong>, check this <a href="https://developer.apple.com/library/ios/recipes/Instruments_help_articles/FindingAbandonedMemory/FindingAbandonedMemory.html#//apple_ref/doc/uid/TP40012965-CH34-SW1" rel="nofollow">link</a>.</p> <p><strong>TIP:</strong> If you are navigating between view controllers, and you perform the navigation inside a closure, you should use a <code>weak</code> or <code>unowned</code> version of <code>self</code>, example:</p> <pre><code> //Swift 2.1 //Performing naivgation on the main thread for responsiveness: dispatch_async(dispatch_get_main_queue(), {[weak self] () -&gt; Void in if let weakSelf = self{ weakSelf.performSegueWithIdentifier("myOtherView", sender: weakSelf) } }) </code></pre> <p>Also, when dismissing the view controller is the same:</p> <pre><code>dispatch_async(dispatch_get_main_queue(), {[weak self] () -&gt; Void in if let weakSelf = self{ weakSelf.dismissViewControllerAnimated(true, completion: nil) } }) </code></pre> <p>The posted link above shows a practical example on how to catch abanodend memory using Xcode Instruments.</p>