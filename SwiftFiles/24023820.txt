Why is 'init' not assignable?
<p>I just read that the <code>init</code> method can't be used as a value. Meaning:</p> <pre><code>var x = SomeClass.someClassFunction // ok var y = SomeClass.init // error </code></pre> <p>Example found on <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/primary-expression" rel="nofollow">Language reference</a></p> <p>Why should it be like that? Is it a way to enforce language level that <em>too dirty tricks</em> come into place, because of some cohertion or maybe because it interferes with another feature?</p>
<p>Unlike Obj-C, where the <code>init</code> function can be called multiple times without problems, in Swift there actually is no method called <code>init</code>.</p> <p><code>init</code> is just a keyword meaning "the following is a constructor". The constructor is called always via <code>MyClass()</code> during the creation of a new instance. It's never called separately as a method <code>myInstance.init()</code>. You can't get a reference to the underlying function because it would be impossible to call it.</p> <p>This is also connected with the fact that constructors cannot be inherited. Code</p> <pre><code>var y = SomeClass.init </code></pre> <p>would also break subtyping because the subtypes are not required to have the same initializers.</p>
<blockquote> <p>Why should it be like that?</p> </blockquote> <p><code>init</code> is a special member, not a regular method.</p> <p>Beyond that, there's no reason that you'd ever need to store <code>init</code> in a variable. The only objects that could use that function in a valid way are instances of the class where that particular <code>init</code> is defined, and any such object will have already been initialized before you could possibly make the assignment.</p>
<p>Initializers don't have a return value. In order to assign it to something, it should be able to return something - and it doesn't.</p>