Using key-value programming (KVP) with Swift
<p>In Objective-C with Cocoa a lot of tasks can be accomplished without explicit loops by using Key-Value Programming (KVP). For example, I can find the largest number in an array with a single line of code:</p> <pre><code>NSNumber * max = [numbers valueForKeyPath:@"@max.intValue"]; </code></pre> <p>How can I do the same thing with swift? Arrays do not appear to support valueForKeyPath method.</p>
<p>I'm not sure about KVP, but KVO isn't currently supported in Swift. See also this dev forums thread: </p> <p><a href="https://devforums.apple.com/thread/227909" rel="nofollow">https://devforums.apple.com/thread/227909</a></p>
<p>You can still use (at least) the <code>didSet</code> <code>willSet</code> provided by Swift on properties. I guess it's better than nothing. </p>
<p>The array will actually respond to valueForKeyPath function - you just need to cast the array to <code>AnyObject</code> so that the compiler doesn't complain. As follows:</p> <pre><code>var max = (numbers as AnyObject).valueForKeyPath("@max.self") as Double </code></pre> <p>or even, for a union of objects:</p> <pre><code>(labels as AnyObject).valueForKeyPath("@unionOfObjects.text") </code></pre> <p>If <code>labels</code> above is a collection of labels, the above will return an array of all the strings of the <code>text</code> property of each label.</p> <p>It is also equivalent to the following:</p> <pre><code>(labels as AnyObject).valueForKey("text") </code></pre> <p>... just as it is in Objective-C :)</p>
<p>You can also use the reduce function of Array</p> <pre><code>let numbers = [505,4,33,12,506,21,1,0,88] let biggest = numbers.reduce(Int.min,{max($0, $1)}) println(biggest) // prints 506 </code></pre> <p>Good explanation <a href="http://www.weheartswift.com/higher-order-functions-map-filter-reduce-and-more/" rel="nofollow">here</a></p>