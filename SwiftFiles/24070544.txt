Suppressing Implicit Returns in Swift
<p>Consider the following set of functions:</p> <pre><code>func testFunc(someFunc: (Int[]) -&gt; ()) { someFunc([1, 2, 3]) } func someFunc&lt;T&gt;(arr : T[]) -&gt; T[] { return arr } func someOtherFunc&lt;T&gt;(arr : T[]) { println(arr) } // case 1 - ERROR testFunc() { someFunc($0) } // case 2 - no error testFunc() { println("whatever") someFunc($0) } // case 3 - no error testFunc() { someOtherFunc($0) } </code></pre> <p>It looks like in case 1, Swift is trying to implicitly return from the closure since the function <code>someFunc()</code> returns a value. It only does this if there is only one line in the closure (Implicit Returns from Single-Expression Closures) - this is why case 2 works. It does not do this if the function, as in case 3 is <code>Void</code>, i.e. it doesn't return a value.</p> <p>My question is whether there is a way to suppress this behavior so that I can have a function with a return value as a single-line expression in a closure that has no return value.</p>
<p>UPDATE: After Swift 1.2, this is no longer a problem</p> <p>This bug still exists in Xcode beta6, I hope it will be fixed in the 1.0 release, before that, this is a workaround</p> <pre><code>testFunc() { someFunc($0) // The explicit return statement corrects the wrong return type of the auto implicit return. // It makes more sense than printing nonsense strings return //TODO: remove after the bug is fixed } </code></pre>
<p>Besides the mentioned solutions:</p> <pre><code>testFunc { someFunc($0); return () } // returning Void explicitly (with or without parenthesis) testFunc { someFunc($0); 42 } // or, indeed, just adding a second expression </code></pre> <p>You can also consume the returned value:</p> <pre><code>testFunc { let x = someFunc($0) } </code></pre> <p>or simply: </p> <pre><code>testFunc { _ = someFunc($0) } </code></pre> <p>Returned value must always be of the type promised by the function signature, and the case of the implicit return is no different. This is no bug. It is simply that the implicit returns are so often such elegant syntax that the less frequent case of the mismatching types is breaking the spell a bit. This is not to say that a nice syntactic solution would not be welcomed, at least when <code>Void</code> is expected. Perhaps something as simple as:</p> <pre><code>testFunc { someFunc($0) ; } // with the trailing semicolon </code></pre> <p>When this irritates me the most is when my own function forces me to dance around it. I have a couple of times resorted to explicitly ignoring the return type:</p> <pre><code>func testFunc&lt;Ignored&gt;(someFunc: [Int] -&gt; Ignored) { someFunc([1, 2, 3]) } testFunc { someFunc($0) } </code></pre>