Assign value to optional dictionary in Swift
<p>I'm finding some surprising behavior with optional dictionaries in Swift.</p> <pre><code>var foo:Dictionary&lt;String, String&gt;? if (foo == nil) { foo = ["bar": "baz"] } else { // Following line errors with "'Dictionary&lt;String, String&gt;?' does // not have a member named 'subscript'" foo["qux"] = "quux" } </code></pre> <p>I've played with this a lot, trying to figure out what I might be missing, but nothing seems to make this code work as expected short of making the dictionary not optional. What am I missing?</p> <p>The closest I can get is the following, but of course it's ridiculous.</p> <pre><code>var foo:Dictionary&lt;String, String&gt;? if (foo == nil) { foo = ["bar": "baz"] } else if var foofoo = foo { foofoo["qux"] = "quux" foo = foofoo } </code></pre>
<p>you can use this code</p> <pre><code>if var foofoo = foo { foofoo["qux"] = "quux" foo = foofoo } else { foo = ["bar": "baz"] } </code></pre> <hr> <p>with this code</p> <pre><code>var foo:Dictionary&lt;String, String&gt;? = Dictionary() foo[""]="" error: 'Dictionary&lt;String, String&gt;?' does not have a member named 'subscript' foo[""]="" ^ </code></pre> <p>the error message makes sense to me that <code>Dictionary&lt;String, String&gt;?</code> does not implement <code>subscript</code> method, so you need to unwrap it before able to use <code>subscript</code>.</p> <p>one way to call method on optional is use <code>!</code> i.e. <code>foo![""]</code>, but...</p> <pre><code>var foo:Dictionary&lt;String, String&gt;? = Dictionary() foo![""]="" error: could not find member 'subscript' foo![""]="" ~~~~~~~~^~~ </code></pre> <p>whereas</p> <pre><code>var foo:Dictionary&lt;String, String&gt;? = Dictionary() foo![""] </code></pre> <p>works</p> <hr> <p>it is interesting these code failed to compile</p> <pre><code>var foo:Dictionary&lt;String, String&gt;! = Dictionary() // Implicitly unwrapped optional foo[""]="" error: could not find an overload for 'subscript' that accepts the supplied arguments foo[""]="" ~~~~~~~^~~ </code></pre> <hr> <pre><code>var foo:Dictionary&lt;String, String&gt;! = Dictionary() // Implicitly unwrapped optional foo.updateValue("", forKey: "") immutable value of type 'Dictionary&lt;String, String&gt;' only has mutating members named 'updateValue' foo.updateValue("", forKey: "") ^ ~~~~~~~~~~~ </code></pre> <p>the last error message is most interesting, it is saying the <code>Dictionary</code> is immutable, so <code>updateValue(forKey:)</code> (mutating method) can't be called on it</p> <p>so what happened is probably that the <code>Optional&lt;&gt;</code> store the <code>Dictionary</code> as immutable object (with <code>let</code>). So even <code>Optional&lt;&gt;</code> it is mutable, you can't modify the underlying <code>Dictionary</code> object directly (without reassign the <code>Optional</code> object)</p> <hr> <p>and this code works</p> <pre><code>class MyDict { var dict:Dictionary&lt;String, String&gt; = [:] subscript(s: String) -&gt; String? { get { return dict[s] } set { dict[s] = newValue } } } var foo:MyDict? = MyDict() foo!["a"] = "b" // this is how to call subscript of optional object </code></pre> <hr> <p>and this lead me to another question, why <code>Array</code> and <code>Dictionary</code> are value type (struct)? opposite to <code>NSArray</code> and <code>NSDictionary</code> which are reference type (class)</p>
<p>The lightbulb moment is when you realize that an Optional dictionary is not a Dictionary. An Optional anything is not that thing! It is an Optional!! And that's all it is. Optional is itself a type. An Optional is just an enum, wrapping the possible cases nil and some value. The wrapped value is a completely different object, stored inside.</p> <p>So an Optional <em>anything</em> does not act like the type of that thing. It is not that thing! It is just an Optional. The only way to get at the thing is to unwrap it.</p> <p>The same is true of an implicitly unwrapped Optional; the difference is just that the implicitly unwrapped Optional is willing to produce (expose) the wrapped value "automatically". But it is still, in fact, wrapped. And, as Bryan Chen has observed, it is wrapped immutably; the Optional is just holding it for you - it is not giving you a place to play with it.</p>