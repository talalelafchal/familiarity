How do I print the type or class of a variable in Swift?
<p>Is there a way to print the runtime type of a variable in swift? For example:</p> <pre><code>var now = NSDate() var soon = now.dateByAddingTimeInterval(5.0) println("\(now.dynamicType)") // Prints "(Metatype)" println("\(now.dynamicType.description()") // Prints "__NSDate" since objective-c Class objects have a "description" selector println("\(soon.dynamicType.description()") // Compile-time error since ImplicitlyUnwrappedOptional&lt;NSDate&gt; has no "description" method </code></pre> <p>In the example above, I'm looking for a way to show that the variable "soon" is of type <code>ImplicitlyUnwrappedOptional&lt;NSDate&gt;</code>, or at least <code>NSDate!</code>.</p>
<p>When using Cocoa (not CocoaTouch), you can use the <code>className</code> property for objects that are subclasses of NSObject. </p> <pre><code>println(now.className) </code></pre> <p>This property is not available for normal Swift objects, which aren't subclasses of NSObject (and in fact, there is no root id or object type in Swift).</p> <pre><code>class Person { var name: String? } var p = Person() println(person.className) // &lt;- Compiler error </code></pre> <p>In CocoaTouch, at this time there is not a way to get a string description of the type of a given variable. Similar functionality also does not exist for primitive types in either Cocoa or CocoaTouch.</p> <p>The Swift REPL is able to print out a summary of values including its type, so it is possible this manner of introspection will be possible via an API in the future.</p> <p><strong>EDIT</strong>: <strong><code>dump(object)</code> seems to do the trick.</strong></p>
<p>You can still access the class, through <code>className</code> (which returns a <code>String</code>).</p> <p>There are actually several ways to get the class, for example <code>classForArchiver</code>, <code>classForCoder</code>, <code>classForKeyedArchiver</code> (all return <code>AnyClass!</code>).</p> <p>You can't get the type of a primitive (a primitive is <strong>not</strong> a class).</p> <p>Example:</p> <pre><code>var ivar = [:] ivar.className // __NSDictionaryI var i = 1 i.className // error: 'Int' does not have a member named 'className' </code></pre> <p>If you want to get the type of a primitive, you have to use <code>bridgeToObjectiveC()</code>. Example:</p> <pre><code>var i = 1 i.bridgeToObjectiveC().className // __NSCFNumber </code></pre>
<p>There appears to be no generic way to print the type name of an arbitrary value's type. As others have noted, for <em>class</em> instances you can print <code>value.className</code> but for primitive values it appears that at runtime, the type information is gone. </p> <p>For instance, it looks as if there's not a way to type: <code>1.something()</code> and get out <code>Int</code> for any value of <code>something</code>. (You can, as another answer suggested, use <code>i.bridgeToObjectiveC().className</code> to give you a hint, but <code>__NSCFNumber</code> is <em>not</em> actually the type of <code>i</code> -- just what it will be converted to when it crosses the boundary of an Objective-C function call.)</p> <p>I would be happy to be proven wrong, but it looks like the type checking is all done at compile time, and like C++ (with RTTI disabled) much of the type information is gone at runtime.</p>
<p>Edit: <strong>A new <code>toString</code> function <a href="http://swiftdoc.org/func/toString/">has been introduced in Swift 1.2 (Xcode 6.3)</a>.</strong></p> <p>You can now print the demangled type of any type using <code>.self</code> and any instance using <code>.dynamicType</code>:</p> <pre><code>struct Box&lt;T&gt; {} toString("foo".dynamicType) // Swift.String toString([1, 23, 456].dynamicType) // Swift.Array&lt;Swift.Int&gt; toString((7 as NSNumber).dynamicType) // __NSCFNumber toString((Bool?).self) // Swift.Optional&lt;Swift.Bool&gt; toString(Box&lt;SinkOf&lt;Character&gt;&gt;.self) // __lldb_expr_1.Box&lt;Swift.SinkOf&lt;Swift.Character&gt;&gt; toString(NSStream.self) // NSStream </code></pre> <hr> <p>Try calling <code>YourClass.self</code> and <code>yourObject.dynamicType</code>.</p> <p>Reference: <a href="https://devforums.apple.com/thread/227425">https://devforums.apple.com/thread/227425</a>.</p>
<p>Is this what you're looking for?</p> <pre><code>println("\(object_getClassName(now))"); </code></pre> <p>It prints "__NSDate"</p> <p><strong>UPDATE</strong>: Please note this no longer seems to work as of Beta05</p>
<p>You can use reflect to get information about object.<br/> For example name of object class:</p> <pre> var classname = reflect(now).summary </pre>
<p>In lldb as of beta 5, you can see the class of an object with the command:</p> <pre><code>fr v -d r shipDate </code></pre> <p>which outputs something like:</p> <pre><code>(DBSalesOrderShipDate_DBSalesOrderShipDate_ *) shipDate = 0x7f859940 </code></pre> <p>The command expanded out means something like:</p> <p><code>Frame Variable</code> (print a frame variable) <code>-d run_target</code> (expand dynamic types)</p> <p>Something useful to know is that using "Frame Variable" to output variable values guarantees no code is executed.</p>
<p><strong>Update September 2016</strong></p> <p>Swift 3.0: The <code>dynamicType</code> keyword has been removed from Swift. In its place a new primitive function <code>type(of:)</code> has been added to the language: <a href="https://github.com/apple/swift/blob/master/CHANGELOG.md">Changelog</a></p> <p><strong>Update October 2015</strong>:</p> <p>I updated the examples below to the new Swift 2.0 syntax (e.g. <code>println</code> was replaced with <code>print</code>, <code>toString()</code> is now <code>String()</code>).</p> <p><strong>From the Xcode 6.3 release notes</strong>:</p> <p>@nschum points out in the comments that the <a href="https://developer.apple.com/library/ios/releasenotes/DeveloperTools/RN-Xcode/Xcode_Release_Notes.pdf">Xcode 6.3 release notes</a> show another way:</p> <blockquote> <p>Type values now print as the full demangled type name when used with println or string interpolation.</p> </blockquote> <pre><code>import Foundation class PureSwiftClass { } var myvar0 = NSString() // Objective-C class var myvar1 = PureSwiftClass() var myvar2 = 42 var myvar3 = "Hans" print( "String(myvar0.dynamicType) -&gt; \(myvar0.dynamicType)") print( "String(myvar1.dynamicType) -&gt; \(myvar1.dynamicType)") print( "String(myvar2.dynamicType) -&gt; \(myvar2.dynamicType)") print( "String(myvar3.dynamicType) -&gt; \(myvar3.dynamicType)") print( "String(Int.self) -&gt; \(Int.self)") print( "String((Int?).self -&gt; \((Int?).self)") print( "String(NSString.self) -&gt; \(NSString.self)") print( "String(Array&lt;String&gt;.self) -&gt; \(Array&lt;String&gt;.self)") </code></pre> <p>Which outputs:</p> <pre><code>String(myvar0.dynamicType) -&gt; __NSCFConstantString String(myvar1.dynamicType) -&gt; PureSwiftClass String(myvar2.dynamicType) -&gt; Int String(myvar3.dynamicType) -&gt; String String(Int.self) -&gt; Int String((Int?).self -&gt; Optional&lt;Int&gt; String(NSString.self) -&gt; NSString String(Array&lt;String&gt;.self) -&gt; Array&lt;String&gt; </code></pre> <p><strong>Update for Xcode 6.3:</strong></p> <p>You can use the <code>_stdlib_getDemangledTypeName()</code>:</p> <pre><code>print( "TypeName0 = \(_stdlib_getDemangledTypeName(myvar0))") print( "TypeName1 = \(_stdlib_getDemangledTypeName(myvar1))") print( "TypeName2 = \(_stdlib_getDemangledTypeName(myvar2))") print( "TypeName3 = \(_stdlib_getDemangledTypeName(myvar3))") </code></pre> <p>and get this as output:</p> <pre><code>TypeName0 = NSString TypeName1 = __lldb_expr_26.PureSwiftClass TypeName2 = Swift.Int TypeName3 = Swift.String </code></pre> <p><em>Original answer:</em></p> <p>Prior to Xcode 6.3 <code>_stdlib_getTypeName</code> got the mangled type name of a variable. <a href="http://www.eswick.com/2014/06/inside-swift/">Ewan Swick's blog entry</a> helps to decipher these strings: </p> <p>e.g. <code>_TtSi</code> stands for Swift's internal <code>Int</code> type.</p> <p><a href="https://www.mikeash.com/pyblog/friday-qa-2014-08-15-swift-name-mangling.html">Mike Ash has a great blog entry covering the same topic</a>.</p>
<p>I had luck with:</p> <pre><code>let className = NSStringFromClass(obj.dynamicType) </code></pre>
<p>My current Xcode is Version 6.0 (6A280e).</p> <pre><code>import Foundation class Person { var name: String; init(name: String) { self.name = name }} class Patient: Person {} class Doctor: Person {} var variables:[Any] = [ 5, 7.5, true, "maple", Person(name:"Sarah"), Patient(name:"Pat"), Doctor(name:"Sandy") ] for variable in variables { let typeLongName = _stdlib_getDemangledTypeName(variable) let tokens = split(typeLongName, { $0 == "." }) if let typeName = tokens.last { println("Variable \(variable) is of Type \(typeName).") } } </code></pre> <p>Output:</p> <pre><code>Variable 5 is of Type Int. Variable 7.5 is of Type Double. Variable true is of Type Bool. Variable maple is of Type String. Variable Swift001.Person is of Type Person. Variable Swift001.Patient is of Type Patient. Variable Swift001.Doctor is of Type Doctor. </code></pre>
<p>I've tried some of the other answers here but milage seems to very on what the underling object is.</p> <p>However I did found a way you can get the Object-C class name for an object by doing the following:</p> <pre><code>now?.superclass as AnyObject! //replace now with the object you are trying to get the class name for </code></pre> <p>Here is and example of how you would use it:</p> <pre><code>let now = NSDate() println("what is this = \(now?.superclass as AnyObject!)") </code></pre> <p>In this case it will print NSDate in the console.</p>
<p>I've found a <strong>solution for self-developed classes</strong> (or such you have access to).</p> <p>Place the following <strong>computed property</strong> within your objects class definition:</p> <pre><code>var className: String? { return __FILE__.lastPathComponent.stringByDeletingPathExtension } </code></pre> <p>Now you can simply call the class name on your object like so:</p> <pre><code>myObject.className </code></pre> <p>Please note that this will <strong>only work if</strong> your class definition is made within a file that is named <strong>exactly</strong> like the class you want the name of.</p> <p>As this is <em>commonly</em> the case <strong>the above answer should do it for most cases</strong>. But in <em>some</em> special cases you might need to figure out a different solution.</p> <hr> <p>If you need the class name <strong>within the class (file) itself</strong> you can simply use this line:</p> <pre><code>let className = __FILE__.lastPathComponent.stringByDeletingPathExtension </code></pre> <hr> <p>Maybe this method helps some people out there.</p>
<p>Based on the answers and comments given by Klass and Kevin Ballard above, I would go with:</p> <pre><code>println(_stdlib_getDemangledTypeName(now).componentsSeparatedByString(".").last!) println(_stdlib_getDemangledTypeName(soon).componentsSeparatedByString(".").last!) println(_stdlib_getDemangledTypeName(soon?).componentsSeparatedByString(".").last!) println(_stdlib_getDemangledTypeName(soon!).componentsSeparatedByString(".").last!) println(_stdlib_getDemangledTypeName(myvar0).componentsSeparatedByString(".").last!) println(_stdlib_getDemangledTypeName(myvar1).componentsSeparatedByString(".").last!) println(_stdlib_getDemangledTypeName(myvar2).componentsSeparatedByString(".").last!) println(_stdlib_getDemangledTypeName(myvar3).componentsSeparatedByString(".").last!) </code></pre> <p>which will print out:</p> <pre><code>"NSDate" "ImplicitlyUnwrappedOptional" "Optional" "NSDate" "NSString" "PureSwiftClass" "Int" "Double" </code></pre>
<pre><code>let i: Int = 20 func getTypeName(v: Any) -&gt; String { let fullName = _stdlib_demangleName(_stdlib_getTypeName(i)) if let range = fullName.rangeOfString(".") { return fullName.substringFromIndex(range.endIndex) } return fullName } println("Var type is \(getTypeName(i)) = \(i)") </code></pre>
<p>I found this solution which hopefully might work for someone else. I created a class method to access the value. Please bear in mind this will work for NSObject subclass only. But at least is a clean and tidy solution.</p> <pre><code>class var className: String!{ let classString : String = NSStringFromClass(self.classForCoder()) return classString.componentsSeparatedByString(".").last; } </code></pre>
<p>As of Xcode 6.3 with Swift 1.2, you can simply convert type values into the full demangled <code>String</code>.</p> <pre><code>toString(Int) // "Swift.Int" toString(Int.Type) // "Swift.Int.Type" toString((10).dynamicType) // "Swift.Int" println(Bool.self) // "Swift.Bool" println([UTF8].self) // "Swift.Array&lt;Swift.UTF8&gt;" println((Int, String).self) // "(Swift.Int, Swift.String)" println((String?()).dynamicType)// "Swift.Optional&lt;Swift.String&gt;" println(NSDate) // "NSDate" println(NSDate.Type) // "NSDate.Type" println(WKWebView) // "WKWebView" toString(MyClass) // "[Module Name].MyClass" toString(MyClass().dynamicType) // "[Module Name].MyClass" </code></pre>
<p><strong>SWIFT 2.2</strong></p> <p><em>With the latest release of Swift 2.2 we can get pretty descriptions of type names through the <code>String</code> initializer. Like, for example <code>print(String(object.dynamicType))</code>. Where <code>object</code> can be an array, a dictionary, an <code>Int</code>, a <code>NSDate</code>, an instance of a custom class, etc.</em></p> <p>Here is my complete answer: <a href="http://stackoverflow.com/questions/24494784/get-class-name-of-object-as-string-in-swift/28312977#28312977">Get class name of object as string in Swift</a></p> <p>That question is looking for a way to getting the class name of an object as string but, also i proposed another way to getting the class name of a variable that isn't subclass of <code>NSObject</code>. Here it is: </p> <pre><code>class Utility{ class func classNameAsString(obj: Any) -&gt; String { return String(obj.dynamicType).componentsSeparatedByString("__").last! } } </code></pre> <p>I made a static function which takes as parameter an object of type <code>Any</code> and returns its class name as <code>String</code> :) .</p> <p>I tested this function with some variables like: </p> <pre><code> let diccionary: [String: CGFloat] = [:] let array: [Int] = [] let numInt = 9 let numFloat: CGFloat = 3.0 let numDouble: Double = 1.0 let classOne = ClassOne() let classTwo: ClassTwo? = ClassTwo() let now = NSDate() let lbl = UILabel() </code></pre> <p>and the output was:</p> <ul> <li>diccionary is of type Dictionary</li> <li>array is of type Array</li> <li>numInt is of type Int</li> <li>numFloat is of type CGFloat</li> <li>numDouble is of type Double</li> <li>classOne is of type: ClassOne</li> <li>classTwo is of type: ClassTwo</li> <li>now is of type: NSDate</li> <li>lbl is of type: UILabel</li> </ul>
<p>In the latest XCode 6.3 with Swift 1.2, this is the only way I found:</p> <pre><code>if view.classForCoder.description() == "UISegment" { ... } </code></pre>
<p>Not exactly what you are after, but you can also check the type of the variable against Swift types like so:</p> <pre><code>let object: AnyObject = 1 if object is Int { } else if object is String { } </code></pre> <p>For example.</p>
<pre><code>self.className.componentsSeparatedByString(".").last </code></pre>
<p>Since Swift 2.0</p> <pre><code>let string = "Hello" let stringArray = ["one", "two"] let dictionary = ["key": 2] print(string.dynamicType) // "String" // Get type name as a string String(string.dynamicType) // "String" String(stringArray.dynamicType) // "Array&lt;String&gt;" String(dictionary.dynamicType) // "Dictionary&lt;String, Int&gt;" // Get full type as a string String(reflecting: string.dynamicType) // "Swift.String" String(reflecting: stringArray.dynamicType) // "Swift.Array&lt;Swift.String&gt;" String(reflecting: dictionary.dynamicType) // "Swift.Dictionary&lt;Swift.String, Swift.Int&gt;" </code></pre>
<p>Many of the answers here do not work with the latest Swift (Xcode 7.1.1 at time of writing).</p> <p>The current way of getting the information is to create a <code>Mirror</code> and interrogate that. For the classname it is as simple as:</p> <pre><code>let mirror = Mirror(reflecting: instanceToInspect) let classname:String = mirror.description </code></pre> <p>Additional information about the object can also be retrieved from the <code>Mirror</code>. See <a href="http://swiftdoc.org/v2.1/type/Mirror/" rel="nofollow">http://swiftdoc.org/v2.1/type/Mirror/</a> for details.</p>
<p>Xcode 7.3.1, Swift 2.2:</p> <p><code>String(instanceToPrint.self).componentsSeparatedByString(".").last</code></p>
<p>In Swift 3.0, you can use <code>type(of:)</code>, as <code>dynamicType</code> keyword has been removed.</p>
<p>Xcode 8 Swift 3.0 use type(of:)</p> <pre><code>let className = "\(type(of: instance))" </code></pre>
<h1>In Xcode 8, Swift 3.0</h1> <h2>Steps:</h2> <h2>1. Get the Type:</h2> <h3>Option 1:</h3> <pre><code>let type : Type = MyClass.self //Determines Type from Class </code></pre> <h3>Option 2:</h3> <pre><code>let type : Type = type(of:self) //Determines Type from self </code></pre> <h2>2. Convert Type to String:</h2> <pre><code>let string : String = "\(type)" //String </code></pre>
<p><strong>Swift 3.0, Xcode 8</strong></p> <p>With the following code you can ask an instance for its class. You can also compare two instances, wether having the same class.</p> <pre><code>// CREATE pure SWIFT class class MySwiftClass { var someString : String = "default" var someInt : Int = 5 } // CREATE instances let swiftClass : MySwiftClass = MySwiftClass() let secondSwift : MySwiftClass = MySwiftClass() secondSwift.someString = "Donald" secondSwift.someInt = 24 // INSPECT instances if type(of: swiftClass) === MySwiftClass.self { print("SUCCESS with ===") } else { print("PROBLEM with ===") } if type(of: swiftClass) == MySwiftClass.self { print("SUCCESS with ==") } else { print("PROBLEM with ==") } // COMPARE CLASS OF TWO INSTANCES if type(of: swiftClass) === type(of: secondSwift) { print("instances have equal class") } else { print("instances have NOT equal class") } </code></pre>