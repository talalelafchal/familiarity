Comparing objects in an Array extension causing error in Swift
<p>I'm trying to build an extension that adds some of the convenience functionality of NSArray/NSMutableArray to the Swift Array class, and I'm trying to add this function:</p> <pre><code>func indexOfObject(object:AnyObject) -&gt; Int? { if self.count &gt; 0 { for (idx, objectToCompare) in enumerate(self) { if object == objectToCompare { return idx } } } return nil } </code></pre> <p>But unfortunately, this line: </p> <pre><code>if object == objectToCompare { </code></pre> <p>Is giving the error: </p> <blockquote> <p>could not find an overload for '==' that accepts the supplied arguments</p> </blockquote> <h3> Question </h3> <p>What am I doing wrong to cause this error?</p> <h3> Example </h3> <pre><code>extension Array { func indexOfObject(object:AnyObject) -&gt; Int? { if self.count &gt; 0 { for (idx, objectToCompare) in enumerate(self) { if object == objectToCompare { return idx } } } return nil } } </code></pre>
<p>My guess is that you have to do something like this:</p> <pre><code>func indexOfObject&lt;T: Equatable&gt;(object: T) -&gt; Int? { </code></pre> <p>and so on.</p>
<p>You can always create an extension that uses NSArray's indexOfObject, e.g:</p> <pre><code>extension Array { func indexOfObject(object:AnyObject) -&gt; Int? { return (self as NSArray).indexOfObject(object) } } </code></pre> <p>You can specify that your array items can be compared with the <code>&lt;T : Equatable&gt;</code> constraint, then you can cast your object into <code>T</code> and compare them, e.g:</p> <pre><code>extension Array { func indexOfObject&lt;T : Equatable&gt;(o:T) -&gt; Int? { if self.count &gt; 0 { for (idx, objectToCompare) in enumerate(self) { let to = objectToCompare as T if o == to { return idx } } } return nil } } </code></pre>
<p>You were close. Here's a working extension:</p> <pre><code>extension Array { func indexOfObject&lt;T: Equatable&gt;(object:T) -&gt; Int? { if self.count &gt; 0 { for (idx, objectToCompare) in enumerate(self) { if object == objectToCompare as T { return idx } } } return nil } } </code></pre> <p>Swift had no way of knowing if <em>object</em> or <em>objectToCompare</em> were equatable. By adding generic information to the method, we're then in business.</p>
<p>Here's a relevant example from Apple's "The Swift Programming Language" in the "Generics" section:</p> <pre><code>func findIndex&lt;T: Equatable&gt;(array: T[], valueToFind: T) -&gt; Int? { for (index, value) in enumerate(array) { if value == valueToFind { return index } } return nil } </code></pre> <p>The key idea here is that both <code>value</code> and <code>valueToFind</code> must of a type that is guaranteed to have the <code>==</code> operator implemented/overloaded. The <code>&lt;T: Equatable&gt;</code> is a generic that allows only objects of a type that are, well, equatable.</p> <p>In your case, we would need to ensure that the array itself is composed only of objects that are equatable. The <code>Array</code> is declared as a struct with a generic <code>&lt;T&gt;</code> that does not require it to be equatable, however. I don't know whether it is possible to use extensions to change what kind of types an array can be composed of. I've tried some variations on the syntax and haven't found a way.</p>
<p>You can extract the compare part to another helper function, for example</p> <pre><code>extension Array { func indexOfObject(object: T, equal: (T, T) -&gt; Bool) -&gt; Int? { if self.count &gt; 0 { for (idx, objectToCompare) in enumerate(self) { if equal(object, objectToCompare) { return idx } } } return nil } } let arr = [1, 2, 3] arr.indexOfObject(3, ==) // which returns {Some 2} </code></pre>
<p>Actually there is no need to implement <code>indexOfObject:</code>; there is a global function <code>find(array, element)</code> already.</p>