Type constraint on AnyObject or Any (AnyObject or Any that conforms to a protocol)
<p>I'm trying to convert my Objective-C code to swift. In Objective-C I have the following protocol:</p> <pre><code>@protocol RWOverlaySelectionDelegate &lt;NSObject&gt; -(void)areaSelected:(UIView *)view allPoints:(NSArray *)points; @end </code></pre> <p>and following class has a weak property that reference the protocol (obviously it's defined as weak to prevent strong reference cycle).</p> <pre><code>@interface RWMapSelectionLayer : UIView @property(weak, nonatomic) id &lt;RWOverlaySelectionDelegate&gt; delegate; @end </code></pre> <p>Now the Swift equivalent:</p> <p>the protocol:</p> <pre><code>protocol RWOverlaySelectionDelegate { func areaSelected(view:UIView,points:CGPoint[]) } </code></pre> <p>and the class that has a property which conforms to that protocol:</p> <pre><code>class RWMapSelectionLayer:NSObject { weak var delegate:RWOverlaySelectionDelegate? } </code></pre> <p>But I'm getting <code>'weak' cannot be applied to non-class type 'RWOverlaySelectionDelegate'</code> compile time error in this line : <code>weak var delegate:RWOverlaySelectionDelegate?</code></p> <p>Then I tried to convert my property to an <code>AnyObject</code> that conforms to <code>RWOverlaySelectionDelegate</code> using following syntax:</p> <pre><code>weak var delegate: AnyObject&lt;RWOverlaySelectionDelegate&gt;? </code></pre> <p>Now I'm interfering with Generics and compiler showing: <code>Cannot specialize non-generic type 'AnyObject'</code> error.</p> <p>In another unsuccessful try I changed it to </p> <pre><code>weak var delegate: AnyObject:RWOverlaySelectionDelegate? </code></pre> <p>read it as "Delegate is on type AnyObject where AnyObject should conform to RWOverlaySelectionDelegate"</p> <p>This is again incorrect because of two colons(:) in a single statement.</p> <p>Would appreciate if someone can help me to <code>enforce conformance to a protocol on AnyObject or Any</code></p>
<p>Found the solution: I just need to declare my protocol as follow:</p> <pre><code>@objc protocol RWOverlaySelectionDelegate { func areaSelected(view:UIView,points:NSArray) } </code></pre> <p>and then the class just uses protocol name rather than an AnyObject that conforms to a protocol</p> <pre><code>class RWMapSelectionLayer:NSObject { weak var delegate: RWOverlaySelectionDelegate?; } </code></pre> <p>Protocol declaration which is <code>@objc protocol RWOverlaySelectionDelegate</code> require object of <code>RWOverlaySelectionDelegate</code> to be a class. Here is the reference from <code>The Swift Programing Language</code> guide provided by apple</p> <blockquote> <p>@objc protocols can be adopted only by classes</p> </blockquote>
<p>I have since found a better way of doing this in <a href="http://stackoverflow.com/a/24104371/2613662">this answer</a>.</p> <p><em>Updated for recent Swift versions</em></p> <p>As I mentioned in my comment on CjCoax's answer, prefixing the protocol with <code>@objc</code> prevents passing Swift object types (such as enums and structs) to delegate methods.</p> <p>However <strike>prefixing the protocol with <code>@class_protocol</code></strike> using <code>: class</code> will allow this behaviour while allowing the protocol to be used in a weak variable, though this method is not without it's limitations. You can only make classes conform to any protocol that is <strike>prefixed with <code>@class_protocol</code></strike> marked with <code>: class</code> (hence the name). I believe that this is a better trade-off than <code>@objc</code> provides.</p> <pre><code>protocol MyProtocol : class { ... } </code></pre>
<p>I believe the recommended solution would be a class-only protocol (only available in more recent Xcode 6 betas, I'm current using the GM release). From the <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html">Swift Programming Language</a> protocol page:</p> <blockquote> <p>You can limit protocol adoption to class types (and not structures or enumerations) by adding the class keyword to a protocol’s inheritance list. The class keyword must always appear first in a protocol’s inheritance list, before any inherited protocols:</p> </blockquote> <p>So in your example, your protocol definition would look like:</p> <pre><code>protocol RWOverlaySelectionDelegate: class { func areaSelected(view:UIView,points:NSArray) } </code></pre> <p>With the addition of the class keyword, the compiler should no longer complain.</p>