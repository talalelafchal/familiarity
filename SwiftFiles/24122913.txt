Overriding default value of instance var
<p>Given class <code>Obj</code>,</p> <pre><code>class Obj: NSObject { var x = "x" } </code></pre> <p>and its subclass, <code>Obj1</code>, how do you change the default value of <code>var x</code>?</p> <p>Simply setting a new value would make the most sense, but it seems to error out...</p> <pre><code>class Obj1: Obj { var x = "y" } </code></pre> <blockquote> <p>❗️ Cannot override with a stored property 'x'</p> </blockquote>
<p>Define an <code>init()</code> method as:</p> <pre><code>init () { super.init() x = "y" } </code></pre> <p>You'll want any other initializers in <code>Obj1</code> to invoke this as <code>self.init()</code>. The Apple documentation has a long discussion on <em>designated initializers</em> and inheritance vis-a-vis initializers.</p>
<p>In most cases, injecting these values via <code>init</code> is the preferred way.</p> <p>For example:</p> <pre><code>class Foo { var x : String convenience init() { self.init(x: "x") // 'x' by default } init(x: String) { self.x = x } } class Bar : Foo { convenience init() { self.init(x: "y") // now 'y' by default } init(x: String) { super.init(x: x) } } </code></pre> <p>However, there are some cases where you want to override a computed property or perhaps something that is not exactly initialized.</p> <p>In this case, you can use the <code>override var</code> syntax:</p> <pre><code>override var x : String { get { return super.x } // get super.x value set { super.x = newValue } // set super.x value } </code></pre> <p>The above code does not change the behavior, but illustrates the syntax that would allow you to do so.</p>
<p>This question has been marked answered, but there is also the safe-in-Swift <a href="http://en.wikipedia.org/wiki/Template_method_pattern">template method pattern</a> by way of delegation to a computed property:</p> <pre><code>class Foo { lazy var x : String = self.defaultX var defaultX:String { return "foo" } } class Bar : Foo { override var defaultX:String { return "bar" } } println(Foo().x) // foo println(Bar().x) // bar </code></pre> <p>By safer, I am referring to Swift's enforcement of the initialization sequence that prevents problems with "virtual" calls into a not-yet constructed sub class (ie, having a base class call a virtual method that is implemented in a sub class, but before that subclass has finished initializing). This was a danger in C++, for example.</p>