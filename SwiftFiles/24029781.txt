How do I import a Swift file from another Swift file?
<p>I simply want to include my Swift class from another file, like its test</p> <p><strong>PrimeNumberModel.swift</strong></p> <pre><code>import Foundation class PrimeNumberModel { } </code></pre> <p><strong>PrimeNumberModelTests.swift</strong></p> <pre><code>import XCTest import PrimeNumberModel // gives me "No such module 'PrimeNumberModel'" class PrimeNumberModelTests: XCTestCase { let testObject = PrimeNumberModel() // "Use of unresolved identifier 'PrimeNumberModel'" } </code></pre> <p>Both swift files are in the same directory.</p>
<p>In <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html" rel="nofollow noreferrer">Document said in to swift programming</a> There are no import statement</p> <p><img src="https://i.stack.imgur.com/RCAHA.png" alt="enter image description here"></p> <p>simply use:</p> <pre><code>let primNumber = PrimeNumberModel() </code></pre>
<p>According To Apple you don't need an import for swift files in the Same Target. I finally got it working by adding my swift file to both my regular target and test target. Then I used the bridging header for test to make sure my ObjC files that I referenced in my regular bridging header were available. Ran like a charm now.</p> <pre><code>import XCTest //Optionally you can import the whole Objc Module by doing #import ModuleName class HHASettings_Tests: XCTestCase { override func setUp() { let x : SettingsTableViewController = SettingsTableViewController() super.setUp() // Put setup code here. This method is called before the invocation of each test method in the class. } override func tearDown() { // Put teardown code here. This method is called after the invocation of each test method in the class. super.tearDown() } func testExample() { // This is an example of a functional test case. XCTAssert(true, "Pass") } func testPerformanceExample() { // This is an example of a performance test case. self.measureBlock() { // Put the code you want to measure the time of here. } } } </code></pre> <p>SO make sure PrimeNumberModel has a target of your test Target. Or High6 solution of importing your whole module will work</p>
<p>I had the same problem, also in my <code>XCTestCase</code> files, but not in the normal project files. </p> <p>To get rid of the </p> <blockquote> <p>Use of unresolved identifier 'PrimeNumberModel'</p> </blockquote> <p>i needed to <code>import</code> the base module in the test file. So in my case my <strong>target</strong> is called 'myproject' I added <code>import myproject</code> and the class was recognised.</p>
<p>Check target-membership of PrimeNumberModel.swift in your testing target.</p>
<p>Check your "PrimeNumberModelTests" Target Settings.</p> <p>If you can't see PrimeNumberModel.swift file in Build Phases/Compile Sources, add it.</p>
<p>In Objective-C, if you wanted to use a class in another file you had to import it:</p> <pre><code>#import "SomeClass.h" </code></pre> <p>However, in Swift, you don't have to import at all. Simply use it as if it was already imported.</p> <h2>Example</h2> <pre><code>// This is a file named SomeClass.swift class SomeClass : NSObject { } // This is a different file, named OtherClass.swift class OtherClass : NSObject { let object = SomeClass() } </code></pre> <p>As you can see, no import was needed. Hope this helps.</p>
<h2>UPDATE Swift 2.x and 3.x</h2> <p>Now you don't need to add the <code>public</code> to the methods to test then. On Swift 2 it's only necessary to add the <a href="https://developer.apple.com/library/prerelease/ios/documentation/DeveloperTools/Conceptual/WhatsNewXcode/Articles/xcode_7_0.html" rel="nofollow"><code>@testable</code></a> keyword.</p> <p><strong>PrimeNumberModelTests.swift</strong></p> <pre><code>import XCTest @testable import MyProject class PrimeNumberModelTests: XCTestCase { let testObject = PrimeNumberModel() } </code></pre> <p>And your internal methods can keep <code>Internal</code></p> <p><strong>PrimeNumberModel.swift</strong></p> <pre><code>import Foundation class PrimeNumberModel { init() { } } </code></pre> <p>Note that <code>private</code> (and <code>fileprivate</code>) symbols are not available even with using <code>@testable</code>.</p> <hr> <h2>Swift 1.x</h2> <p>There are two relevant concepts from Swift here (As Xcode 6 beta 6).</p> <ol> <li>You don't need to import Swift classes, but you need to import external modules (targets)</li> <li>The Default <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html#//apple_ref/doc/uid/TP40014097-CH41-XID_29" rel="nofollow">Access Control</a> level in Swift is <code>Internal access</code></li> </ol> <p>Considering that tests are on another target on <code>PrimeNumberModelTests.swift</code> you need to <code>import</code> the target that contains the class that you want to test, if your <strong>target</strong> is called <code>MyProject</code> will need to add <code>import MyProject</code> to the <code>PrimeNumberModelTests</code>:</p> <p><strong>PrimeNumberModelTests.swift</strong></p> <pre><code>import XCTest import MyProject class PrimeNumberModelTests: XCTestCase { let testObject = PrimeNumberModel() } </code></pre> <p>But this is not enough to test your class <code>PrimeNumberModel</code>, since the default Access Control level is <code>Internal Access</code>, your class won't be visible to the test bundle, so you need to make it <code>Public Access</code> and all the methods that you want to test:</p> <p><strong>PrimeNumberModel.swift</strong></p> <pre><code>import Foundation public class PrimeNumberModel { public init() { } } </code></pre>
<p>So, you need to </p> <ol> <li>Import external modules you want to use</li> <li>And make sure you have the right access modifiers on the class and methods you want to use.</li> </ol> <p>In my case I had a swift file I wanted to unit test, and the unit test file was also a swift class. I made sure the access modifiers were correct, but the statement</p> <pre><code>import stMobile </code></pre> <p>(let's say that stMobile is our target name)</p> <p>still did not work (I was still getting the 'No such module' error), I checked my target, and its name was indeed stMobile. So, I went to Build Settings, under packaging, and found the Product Module Name, and for some reason this was called St_Mobile, so I changed my import statement</p> <pre><code>import St_Mobile </code></pre> <p>(which is the <strong>Product Module Name</strong>), and everything worked.</p> <p>So, to sum up:</p> <ol> <li><p>Check your Product Module Name and use the import statement below in you unit test class</p> <pre><code>import myProductModuleName </code></pre></li> <li><p>Make sure your access modifiers are correct (class level and your methods).</p></li> </ol>
<p>Instead of requiring explicit imports, the Swift compiler implicitly searches for <code>.swiftmodule</code> files of dependency Swift libraries.</p> <p>Xcode can build swift modules for you, or refer to the <a href="http://railsware.com/blog/2014/06/26/creation-of-pure-swift-module/" rel="nofollow">railsware blog</a> for command line instructions for <code>swiftc</code>.</p>
<p>As @high6 and @erik-p-hansen pointed out in the answer given by @high6, this can be overcome by importing the target for the module where the PrimeNumberModel class is, which is probably the same name as your project in a simple project.</p> <p>While looking at this, I came across the article <a href="https://swiftcast.tv/articles/introduction-to-xctest" rel="nofollow">Write your first Unit Test in Swift</a> on swiftcast.tv by Clayton McIlrath. It discusses access modifiers, shows an example of the same problem you are having (but for a ViewController rather than a model file) and shows how to both import the target and solve the access modifier problem by including the destination file in the target, meaning you don't have to make the class you are trying to test public unless you actually want to do so.</p>
<p>I was able to solve this problem by cleaning my build.</p> <p>Top menu -> Product -> Clean Or keyboard shortcut: <kbd>Shift</kbd>+<kbd>Cmd</kbd>+<kbd>K</kbd></p>
<p>I had the same problem with one particular file (in XCode 6.3). It worked for all other files, but one file was stuck with the Source Control status showing as "A+" (after renaming) and the class inside this file won't get identified by other files. So, I knew the error WASN'T due to a missing <code>import</code> statement.</p> <p>This fix worked for me: </p> <ol> <li>Back up the file content into a separate file </li> <li>Deleted the file causing the trouble from the XCode Project </li> <li>Added a new swift file to the project </li> <li>Copied content from backed up file into new file.</li> </ol>
<p>As of Swift 2.0, best practice is:</p> <p>Add the line <code>@testable import MyApp</code> to the top of your tests file, where "MyApp" is the <strong>Product Module Name</strong> of your app target (viewable in your <strong>app target's</strong> build settings). That's it.</p> <p><em>(Note that the product module name will be the same as your app target's name unless your app target's name contains spaces, which will be replaced with underscores. For example, if my app target was called "Fun Game" I'd write <code>@testable import Fun_Game</code> at the top of my tests.)</em></p>
<p>You need to add a routine for the compiler to reference as an entry point, so add a main.swift file, which in this case simply creates an instance of your test file:</p> <p><strong>main.swift</strong></p> <pre><code>PrimeNumberModelTests() </code></pre> <p>Then compile on the command line (I am using El Capitan and Swift 2.2):</p> <pre><code>xcrun -sdk macosx swiftc -emit-executable -o PrimeNumberMain PrimeNumberModel.swift PrimeNumberModelTests.swift main.swift </code></pre> <p>In this case, you will get a warning: <em>result of initializer is unused</em>, but the program compiles and is executable:</p> <pre><code>./PrimeNumberMain </code></pre> <p>CAVEAT: I removed the import XCTest and XCTestCase type for simplicity.</p>