Swift Optional Type Syntax
<p>According to Apple's Swift guide, when you have the following Array and the following function to search through an Array:</p> <pre><code>let namesArray = ["John", "Lisa", "Bill", "Jennifer"] // Note this function is set-up to return an OPTIONAL Int: func findName (personName:String, arrayToSearchIn:String[]) -&gt; Int? { for (indexOfName, nameValue) in enumerate(arrayToSearchIn) { if nameValue == personName { return indexOfName } } return nil } </code></pre> <p>...so you can capture the Optional Int returned by this function - and then check to see if its <code>nil</code> or not - in the following manner:</p> <pre><code>let nameIndex: Int? = findName("Lisa", arrayToSearchIn: namesArray) if nameIndex { println("found \(namesArray[nameIndex!])") } else { println("NOT found") } </code></pre> <p>This is all good - but their next example, in which they streamline the code by collapsing the 2 statements into one - confuses me because they suddenly drop the Optional "?" and "!" from their syntax:</p> <pre><code>if let nameIndex = findName("Lisa", arrayToSearchIn: namesArray) { println("found \(namesArray[nameIndex])") } </code></pre> <p>And this works perfectly well.</p> <p>So why is it that in the first example <code>nameIndex</code> was declared with a "?" - like so:</p> <pre><code>nameIndex:Int? </code></pre> <p>and the forced-unwrapping occurs using a "!"</p> <pre><code>[nameIndex!] </code></pre> <p>but in the second example neither "?" or "!" one is used in the syntax?</p>
<p><code>?</code> is the operator to explicitly declare an optional type. <code>!</code> is the operator to force-unwrap an optional. The syntax in the example is a special Swift shorthand for checking and unwrapping in one concise line. It says, “assign <code>nameIndex</code> to the result of <code>findName(...)</code>, and if it is not <code>nil</code>, run the following code: ...”</p>
<p>The handling of the declaration in an <code>if let</code> is special; one should treat it as its own language construct (not as a simple combination of <code>if</code> and <code>let</code>). In</p> <pre><code>if let nameIndex = findName("Lisa", arrayToSearchIn: namesArray) { println("found \(namesArray[nameIndex]") } </code></pre> <p>the type of <code>nameIndex</code> does not need to be expressed because it can be inferred as the return type of <code>findName()</code> which is <code>Int?</code>. In the body of the <code>if let ...</code> the value of <code>nameIndex</code> is not bound to an <em>optional</em> and thus unwrapping is not needed - the value will be an <code>Int</code>.</p> <p>Here is an example of how the <code>if let</code> binding is treated. Notice that an explicit declaration of the type is essentially ignored:</p> <pre><code>&gt; func test () -&gt; Int? { return 111 } &gt; if let x : Int? = test () { return x } $R6: Int? = 111 &gt; if let x : Int = test () { return x } $R7: Int = 111 &gt; if let x = test () { return x } $R8: Int = 111 </code></pre> <p>but if you try to be so 'flexible' outside of an <code>if let</code>, you draw an error from the compiler:</p> <pre><code>&gt; let y : Int = test () &lt;REPL&gt;:33:15: error: value of optional type 'Int?' not unwrapped; did you mean to use '!' or '?'? </code></pre>