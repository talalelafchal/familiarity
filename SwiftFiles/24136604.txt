Is there no default(T) in Swift?
<p>I'm trying to port the Matrix example from Swift book to be generic.</p> <p>Here's what I got so far:</p> <pre><code>struct Matrix&lt;T&gt; { let rows: Int, columns: Int var grid: T[] init(rows: Int, columns: Int, repeatedValue: T) { self.rows = rows self.columns = columns grid = Array(count: rows * columns, repeatedValue: repeatedValue) } func indexIsValidForRow(row: Int, column: Int) -&gt; Bool { return row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; columns } subscript(row: Int, column: Int) -&gt; T { get { assert(indexIsValidForRow(row, column: column), "Index out of range") return grid[(row * columns) + column] } set { assert(indexIsValidForRow(row, column: column), "Index out of range") grid[(row * columns) + column] = newValue } } } </code></pre> <p>Note that I had to pass <code>repeatedValue: T</code> to the constructor.</p> <p>In C#, I would have just used <code>default(T)</code> which would be <code>0</code> for numbers, <code>false</code> for booleans and <code>null</code> for reference types. I understand that Swift doesn't allow <code>nil</code> on non-optional types but I'm still curious if passing an explicit parameter is the only way, or if I there is <em>some</em> equivalent of <code>default(T)</code> there.</p>
<p>There isn't. Swift forces you to specify the default value, just like then you handle variables and fields. The only case where Swift has a concept of default value is for optional types, where it's <code>nil</code> (<code>Optional.None</code>).</p>
<p>An iffy 'YES'. You can use protocol constraints to specify the requirement that your generic class or function will only work with types that implement the default init function (parameter-less). The ramifications of this will most likely be bad (it doesn't work the way you think it does), but it is the closest thing to what you were asking for, probably closer than the 'NO' answer.</p> <p>For me I found this personally to be helpful during development of a new generic class, and then eventually I remove the constraint and fix the remaining issues. Requiring only types that can take on a default value will limit the usefulness of your generic data type.</p> <pre><code>public protocol Defaultable { init() } struct Matrix&lt;Type: Defaultable&gt; { let rows: Int let columns: Int var grid: [Type] init(rows: Int, columns: Int) { self.rows = rows self.columns = columns grid = Array(count: rows * columns, repeatedValue: Type() ) } } </code></pre>
<p>There is a way to get the equivalent of <code>default(T)</code> in swift, but it's not free and it has an associated hazard:</p> <pre><code>public func defaultValue&lt;T&gt;() -&gt; T { let ptr = UnsafeMutablePointer&lt;T&gt;.alloc(1) let retval = ptr.memory ptr.dealloc(1) return retval; } </code></pre> <p>Now this is clearly a hack because we don't know if <code>alloc()</code> initializes to something knowable. Is it all 0's? Stuff left over in the heap? Who knows? Furthermore, what it is today could be something different tomorrow.</p> <p>In fact, using the return value for <strong>anything other than a placeholder</strong> is dangerous. Let's say that you have code like this:</p> <pre><code>public class Foo { /* implementation */ public struct Bar { public var x:Foo } var t = defaultValue&lt;Bar&gt;(); t = someFactoryThatReturnsBar(); // here's our problem </code></pre> <p>At the problem line, Swift thinks that <code>t</code> has been initialized because that's what Swift's semantics say: you cannot have a variable of a value type that is uninitialized. Except that it is because <code>default&lt;T&gt;</code> breaks those semantics. When you do the assignment, Swift emits a call into the value witness table to destroy the existing type. This will include code that will call <code>release</code> on the field <code>x</code>, because Swift semantics say that instances of objects are never <code>nil</code>. And then you get a runtime crash.</p> <p>However, I had cause to interoperate with Swift from another language and I had to pass in an optional type. Unfortunately, Swift doesn't provide me with a way to construct an optional at runtime because of reasons (at least I haven't found a way), and I can't easily mock one because optionals are implemented in terms of a generic enum and enums use a poorly documented 5 strategy implementation to pack the payload of an enum.</p> <p>I worked around this by passing a tuple that I'm going to call a Medusa tuple just for grins: <code>(value: T, present: Bool)</code> which has the contract that if <code>present</code> is <code>true</code>, then <code>value</code> is guaranteed to be valid, invalid otherwise. I can use this safely now to interop:</p> <pre><code>public func toOptional&lt;T&gt;(optTuple: (value:T, present:Bool)) -&gt; T? { if optTuple.present { return optTuple.value } else { return nil } } public func fromOptional&lt;T&gt;(opt: T?) -&gt; (T, Bool) { if opt != nil { return (opt!, true) } else { return (defaultValue(), false) } } </code></pre> <p>In this way, my calling code passes in a tuple instead of an optional and the receiving code and turn it into an optional (and the reverse).</p>