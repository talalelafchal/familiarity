Finding index of character in Swift String
<p>It's time to admit defeat...</p> <p>In Objective-C, I could use something like: </p> <pre><code>NSString* str = @"abcdefghi"; [str rangeOfString:@"c"].location; // 2 </code></pre> <p>In Swift, I see something similar: </p> <pre><code>var str = "abcdefghi" str.rangeOfString("c").startIndex </code></pre> <p>...but that just gives me a <code>String.Index</code>, which I can use to subscript back into the original string, but not extract a location from. </p> <p>FWIW, that <code>String.Index</code> has a private ivar called <code>_position</code> that has the correct value in it. I just don't see how it's exposed.</p> <p>I know I could easily add this to String myself. I'm more curious about what I'm missing in this new API.</p>
<p>If you want to use familiar NSString, you can declare it explicitly:</p> <pre><code>var someString: NSString = "abcdefghi" var someRange: NSRange = someString.rangeOfString("c") </code></pre> <p>I'm not sure yet how to do this in Swift.</p>
<p>I'm not sure how to extract the position from String.Index, but if you're willing to fall back on some Objective-C frameworks, you can bridge to objective-c and do it the same way you used to. </p> <pre><code>"abcdefghi".bridgeToObjectiveC().rangeOfString("c").location </code></pre> <p>It seems like some NSString methods haven't yet been (or maybe won't be) ported to String. Contains also comes to mind.</p>
<p>This worked for me,</p> <pre><code>var loc = "abcdefghi".rangeOfString("c").location NSLog("%d", loc); </code></pre> <p>this worked too,</p> <pre><code>var myRange: NSRange = "abcdefghi".rangeOfString("c") var loc = myRange.location NSLog("%d", loc); </code></pre>
<p>String is a bridge type for NSString, so add</p> <pre><code>import Cocoa </code></pre> <p>to your swift file and use all the "old" methods.</p>
<p>You are not the only one who couldn't find the solution.</p> <p><code>String</code> doesn't implement <code>RandomAccessIndexType</code>. Probably because they enable characters with different byte lengths. That's why we have to use <code>string.characters.count</code> (<code>count</code> or <code>countElements</code> in Swift 1.x) to get the number of characters. That also applies to positions. The <code>_position</code> is probably an index into the raw array of bytes and they don't want to expose that. The <code>String.Index</code> is meant to protect us from accessing bytes in the middle of characters.</p> <p>That means that any index you get must be created from <code>String.startIndex</code> or <code>String.endIndex</code> (<code>String.Index</code> implements <code>BidirectionalIndexType</code>). Any other indices can be created using <code>successor</code> or <code>predecessor</code> methods.</p> <p>Now to help us with indices, there is a set of methods (functions in Swift 1.x):</p> <p><em>Swift 3.0</em></p> <pre><code>let text = "abc" let index2 = text.index(text.startIndex, offsetBy: 2) //will call succ 2 times let lastChar: Character = text[index2] //now we can index! let characterIndex2 = text.characters.index(text.characters.startIndex, offsetBy: 2) let lastChar2 = text.characters[characterIndex2] //will do the same as above let range: Range&lt;String.Index&gt; = text.range(of: "b")! let index: Int = text.distance(from: text.startIndex, to: range.lowerBound) </code></pre> <p><em>Swift 2.x</em></p> <pre><code>let text = "abc" let index2 = text.startIndex.advancedBy(2) //will call succ 2 times let lastChar: Character = text[index2] //now we can index! let lastChar2 = text.characters[index2] //will do the same as above let range: Range&lt;String.Index&gt; = text.rangeOfString("b")! let index: Int = text.startIndex.distanceTo(range.startIndex) //will call successor/predecessor several times until the indices match </code></pre> <p><em>Swift 1.x</em></p> <pre><code>let text = "abc" let index2 = advance(text.startIndex, 2) //will call succ 2 times let lastChar: Character = text[index2] //now we can index! let range = text.rangeOfString("b") let index: Int = distance(text.startIndex, range.startIndex) //will call succ/pred several times </code></pre> <p>Working with <code>String.Index</code> is cumbersome but using a wrapper to index by integers (see <a href="http://stackoverflow.com/a/25152652/669586">http://stackoverflow.com/a/25152652/669586</a>) is dangerous because it hides the inefficiency of real indexing.</p> <p>Note that Swift indexing implementation has the problem that <b>indices/ranges created for one string cannot be reliably used for a different string</b>, for example:</p> <p><em>Swift 2.x</em></p> <pre><code>let text: String = "abc" let text2: String = "" let range = text.rangeOfString("b")! //can randomly return a bad substring or throw an exception let substring: String = text2[range] //the correct solution let intIndex: Int = text.startIndex.distanceTo(range.startIndex) let startIndex2 = text2.startIndex.advancedBy(intIndex) let range2 = startIndex2...startIndex2 let substring: String = text2[range2] </code></pre> <p><em>Swift 1.x</em></p> <pre><code>let text: String = "abc" let text2: String = "" let range = text.rangeOfString("b") //can randomly return nil or a bad substring let substring: String = text2[range] //the correct solution let intIndex: Int = distance(text.startIndex, range.startIndex) let startIndex2 = advance(text2.startIndex, intIndex) let range2 = startIndex2...startIndex2 let substring: String = text2[range2] </code></pre>
<pre><code>extension String { // MARK: - sub String func substringToIndex(index:Int) -&gt; String { return self.substringToIndex(advance(self.startIndex, index)) } func substringFromIndex(index:Int) -&gt; String { return self.substringFromIndex(advance(self.startIndex, index)) } func substringWithRange(range:Range&lt;Int&gt;) -&gt; String { let start = advance(self.startIndex, range.startIndex) let end = advance(self.startIndex, range.endIndex) return self.substringWithRange(start..&lt;end) } subscript(index:Int) -&gt; Character{ return self[advance(self.startIndex, index)] } subscript(range:Range&lt;Int&gt;) -&gt; String { let start = advance(self.startIndex, range.startIndex) let end = advance(self.startIndex, range.endIndex) return self[start..&lt;end] } // MARK: - replace func replaceCharactersInRange(range:Range&lt;Int&gt;, withString: String!) -&gt; String { var result:NSMutableString = NSMutableString(string: self) result.replaceCharactersInRange(NSRange(range), withString: withString) return result } } </code></pre>
<p>If you are looking for easy way to get index of Character or String checkout this library <a href="http://www.dollarswift.org/#indexof-char-character-int" rel="nofollow">http://www.dollarswift.org/#indexof-char-character-int</a></p> <p>You can get the indexOf from a string using another string as well or regex pattern</p>
<p>Variable type String in Swift contains different functions compared to NSString in Objective-C . And as Sulthan mentioned, </p> <blockquote> <p>Swift String doesn't implement RandomAccessIndex</p> </blockquote> <p>What you can do is downcast your variable of type String to NSString (this is valid in Swift). This will give you access to the functions in NSString. </p> <pre><code>var str = "abcdefghi" as NSString str.rangeOfString("c").locationx // returns 2 </code></pre>
<p><strong>Swift 3.0</strong> makes this a bit more verbose:</p> <pre><code>let string = "Hello.World" let needle: Character = "." if let idx = string.characters.index(of: needle) { let pos = string.characters.distance(from: string.startIndex, to: idx) print("Found \(needle) at position \(pos)") } else { print("Not found") } </code></pre> <p>Extension:</p> <pre><code>extension String { public func indexOfCharacter(char: Character) -&gt; Int? { if let idx = characters.index(of: char) { return characters.distance(from: startIndex, to: idx) } return nil } } </code></pre> <hr> <p>In <strong>Swift 2.0</strong> this has become easier:</p> <pre><code>let string = "Hello.World" let needle: Character = "." if let idx = string.characters.indexOf(needle) { let pos = string.startIndex.distanceTo(idx) print("Found \(needle) at position \(pos)") } else { print("Not found") } </code></pre> <p>Extension:</p> <pre><code>extension String { public func indexOfCharacter(char: Character) -&gt; Int? { if let idx = self.characters.indexOf(char) { return self.startIndex.distanceTo(idx) } return nil } } </code></pre> <hr> <p><em>Swift 1.x implementation:</em></p> <p>For a pure Swift solution one can use:</p> <pre><code>let string = "Hello.World" let needle: Character = "." if let idx = find(string, needle) { let pos = distance(string.startIndex, idx) println("Found \(needle) at position \(pos)") } else { println("Not found") } </code></pre> <p>As an extension to <code>String</code>:</p> <pre><code>extension String { public func indexOfCharacter(char: Character) -&gt; Int? { if let idx = find(self, char) { return distance(self.startIndex, idx) } return nil } } </code></pre>
<p>If you think about it, you actually don't really need the exact Int version of the location. The Range or even the String.Index is enough to get the substring out again if needed: </p> <pre><code>let myString = "hello" let rangeOfE = myString.rangeOfString("e") if let rangeOfE = rangeOfE { myString.substringWithRange(rangeOfE) // e myString[rangeOfE] // e // if you do want to create your own range // you can keep the index as a String.Index type let index = rangeOfE.startIndex myString.substringWithRange(Range&lt;String.Index&gt;(start: index, end: advance(index, 1))) // e // if you really really need the // Int version of the index: let numericIndex = distance(index, advance(index, 1)) // 1 (type Int) } </code></pre>
<p>I know this is old and an answer has been accepted, but you can find the index of the string in a couple lines of code using:</p> <pre><code>var str : String = "abcdefghi" let characterToFind: Character = "c" let characterIndex = find(str, characterToFind) //returns 2 </code></pre> <p>Some other great information about Swift strings here <a href="http://oleb.net/blog/2014/07/swift-strings/" rel="nofollow" title="Strings in Swift">Strings in Swift</a></p>
<p>I have found this solution for swift2: </p> <pre><code>var str = "abcdefghi" let indexForCharacterInString = str.characters.indexOf("c") //returns 2 </code></pre>
<p>Index Of for Swift 2.0 with extension :</p> <pre><code>extension String { var length:Int { return self.characters.count } func indexOf(target: String) -&gt; Int? { let range = (self as NSString).rangeOfString(target) guard range.toRange() != nil else { return nil } return range.location } func lastIndexOf(target: String) -&gt; Int? { let range = (self as NSString).rangeOfString(target, options: NSStringCompareOptions.BackwardsSearch) guard range.toRange() != nil else { return nil } return self.length - range.location - 1 } func contains(s: String) -&gt; Bool { return (self.rangeOfString(s) != nil) ? true : false } } </code></pre>
<p>To get index of a substring in a string with Swift 2:</p> <pre><code>let text = "abc" if let range = text.rangeOfString("b") { var index: Int = text.startIndex.distanceTo(range.startIndex) ... } </code></pre>
<p>In swift 2.0</p> <pre><code>var stringMe="Something In this.World" var needle="." if let idx = stringMe.characters.indexOf(needle) { let pos=stringMe.substringFromIndex(idx) print("Found \(needle) at position \(pos)") } else { print("Not found") } </code></pre>
<p>In <code>Swift 2.0</code>, the following function returns a substring before a given character. Basically the <code>let range = self.rangeOfString(sub), let index: Int = self.startIndex.distanceTo(range.startIndex)</code> part does the trick.</p> <p><code> func sub_before(sub: String) -&gt; String { if let range = self.rangeOfString(sub), let index: Int = self.startIndex.distanceTo(range.startIndex) { return sub_range(0, index) } return "" } </code></p>
<pre><code>let mystring:String = "indeep"; let findCharacter:Character = "d"; if (mystring.characters.contains(findCharacter)) { let position = mystring.characters.indexOf(findCharacter); NSLog("Position of c is \(mystring.startIndex.distanceTo(position!))") } else { NSLog("Position of c is not found"); } </code></pre>
<p>In terms of thinking this might be called an INVERSION. You discover the world is round instead of flat. "You don't really need to know the INDEX of the character to do things with it." And as a C programmer I found that hard to take too! Your line "let index = letters.characters.indexOf("c")!" is enough by itself. For example to remove the c you could use...(playground paste in)</p> <pre><code> var letters = "abcdefg" //let index = letters.rangeOfString("c")!.startIndex //is the same as let index = letters.characters.indexOf("c")! range = letters.characters.indexOf("c")!...letters.characters.indexOf("c")! letters.removeRange(range) letters </code></pre> <p>However, if you want an index you need to return an actual INDEX not an Int as an Int value would require additional steps for any practical use. These extensions return an index, a count of a specific character, and a range which this playground plug-in-able code will demonstrate.</p> <pre><code>extension String { public func firstIndexOfCharacter(aCharacter: Character) -&gt; String.CharacterView.Index? { for index in self.characters.indices { if self[index] == aCharacter { return index } } return nil } public func returnCountOfThisCharacterInString(aCharacter: Character) -&gt; Int? { var count = 0 for letters in self.characters{ if aCharacter == letters{ count++ } } return count } public func rangeToCharacterFromStart(aCharacter: Character) -&gt; Range&lt;Index&gt;? { for index in self.characters.indices { if self[index] == aCharacter { let range = self.startIndex...index return range } } return nil } } var MyLittleString = "MyVery:important String" var theIndex = MyLittleString.firstIndexOfCharacter(":") var countOfColons = MyLittleString.returnCountOfThisCharacterInString(":") var theCharacterAtIndex:Character = MyLittleString[theIndex!] var theRange = MyLittleString.rangeToCharacterFromStart(":") MyLittleString.removeRange(theRange!) </code></pre>
<p>I play with following </p> <pre><code>extension String { func allCharactes() -&gt; [Character] { var result: [Character] = [] for c in self.characters { result.append(c) } return } } </code></pre> <p>until I understand the provided one's now it's just Character array</p> <p>and with</p> <pre><code>let c = Array(str.characters) </code></pre>
<p>If you only need the index of a character the most simple, quick solution (as already pointed out by Pascal) is:</p> <pre><code>let index = string.characters.index(of: ".") let intIndex = string.distance(from: string.startIndex, to: index) </code></pre>
<p>The Simplest Way is:</p> <p>In <strong>Swift 3</strong>: </p> <pre><code> var textViewString:String = "HelloWorld2016" guard let index = textViewString.characters.index(of: "W") else { return } let mentionPosition = textViewString.distance(from: index, to: textViewString.endIndex) print(mentionPosition) </code></pre>