Set value of read-only stored property during initializing in Swift
<p>I want to implement my custom MKAnnotation. I took a look at MKAnnotation protocol(MKAnnotation.h). It's as follow:</p> <pre><code>// // MKAnnotation.h // MapKit // // Copyright (c) 2009-2014, Apple Inc. All rights reserved. // protocol MKAnnotation : NSObjectProtocol { // Center latitude and longitude of the annotation view. // The implementation of this property must be KVO compliant. var coordinate: CLLocationCoordinate2D { get } // Title and subtitle for use by selection UI. @optional var title: String! { get } @optional var subtitle: String! { get } // Called as a result of dragging an annotation view. @optional func setCoordinate(newCoordinate: CLLocationCoordinate2D) } </code></pre> <p>Please note the coordinate property (which is a read-only stored property). And here is how I've implemented this protocol:</p> <pre><code>class RWDefaultPin: NSObject, MKAnnotation { var title:String = "" var subtitle:String = "" var groupTag:String = "" var coordinate: CLLocationCoordinate2D { get { return self.coordinate // this is obviously wrong because property's trying to return itself } }; init(coordinate:CLLocationCoordinate2D) { super.init() self.coordinate = coordinate } } </code></pre> <p>But obviously compiler complaints on my <code>init</code> method where I'm trying to assign to my coordinate property <code>Cannot assign to 'coordinate' in 'self'</code> obviously because it's a read-only property.</p> <p>Previously in Objective-C we could overcome this issue as properties were backed by ivars.</p> <p>I wish there was access modifier in Swift so I could define a private property in my class and set its value on init, and returning its value on get action of coordinate, but there is no such thing!</p> <p>I don't quiet know how to fix this issue in Swift, or maybe I need to make it wide open and change my coordinate to be readable/writable? </p>
<p>You should be able to just add a <code>setter</code> to it and store the information in an inner coordinate value. Since you have a getter it is still conforming to the protocol:</p> <pre><code>var innerCoordinate: CLLocationCoordinate2D var coordinate: CLLocationCoordinate2D { get { return self.innerCoordinate } set { self.innerCoordinate = newValue } }; init(coordinate:CLLocationCoordinate2D) { super.init() self.innerCoordinate = coordinate } </code></pre> <p>This is actually how I implement readonly and private properties (with protocols and the factory pattern). I setup protocols with the public interface and classes with private variables and setters. It is actually super clean way to setup your code (and gets around the lack of protected/private properties in Swift).</p> <hr> <p>Here is a abstracted example of what I am talking about (if you care):</p> <pre><code>// this is your MKAnnotation in this example protocol SomeProtocol { var getterProperty: String { get } var setterProperty: String { set get } func publicFunction(someStirng: String) -&gt; (); } // setup a function that returns a class conforming to your needed protocol func SomeClassMaker() -&gt; SomeProtocol { // your internal class that no one can access unless by calling the maker function class SomeClassInternal: NSObject, SomeProtocol { // private and no one can get to me! var innerSetterProperty = "default setter"; var getterProperty = "default getter" var setterProperty: String { get { return self.innerSetterProperty; } set { "hit" self.innerSetterProperty = newValue } } func publicFunction(someString: String) -&gt; () { // anyone get me self.getterProperty = someString; } func privateFunction() -&gt; () { // no one can get me except internal functions } } return SomeClassInternal(); } // create the class var classInstance = SomeClassMaker(); // totally fine! classInstance.setterProperty = "secret string" // prints "secret string" classInstance.setterProperty; // error! no public setter for "getter" classInstance.getterProperty = "another secret" classInstance.publicFunction("try secret again") // prints "try secret again" let blahed = classInstance.getterProperty // error! classInstance.privateFunction() </code></pre>
<p>Even though the property is <code>{ get }</code> in the protocol, that is just establishing a minimum criteria. It's perfectly acceptable to define it as read-write:</p> <pre><code>class MyAnnotation:NSObject, MKAnnotation { var coordinate:CLLocationCoordinate2D init(coordinate:CLLocationCoordinate2D) { self.coordinate = coordinate } } </code></pre> <p>Or, if you really want to keep it as read-only, you can use let:</p> <pre><code>class MyAnnotation:NSObject, MKAnnotation { let coordinate:CLLocationCoordinate2D init(coordinate:CLLocationCoordinate2D) { self.coordinate = coordinate } } </code></pre>