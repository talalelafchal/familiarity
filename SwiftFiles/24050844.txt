Swift : missing argument label 'xxx' in call
<pre><code>func say(name:String, msg:String) { println("\(name) say \(msg)") } say("Henry","Hi,Swift") &lt;---- error because missing argument label 'msg' in call </code></pre> <p>I need to use </p> <pre><code> say("Henry",msg:"Hi,Swift") </code></pre> <p>Why ? If I put more than two var in func so that I need to write var name instead of first var when I call this func<br> It's really trouble, and I don't see any explain in iBook Swift tutorial.</p>
<p>One possible reason is that it is actually a method. Methods are very sneaky, they look just like regular functions, but they don't act the same way, let's look at this:</p> <pre><code>func funFunction(someArg: Int, someOtherArg: Int) { println("funFunction: \(someArg) : \(someOtherArg)") } // No external parameter funFunction(1, 4) func externalParamFunction(externalOne internalOne: Int, externalTwo internalTwo: Int) { println("externalParamFunction: \(internalOne) : \(internalTwo)") } // Requires external parameters externalParamFunction(externalOne: 1, externalTwo: 4) func externalInternalShared(#paramOne: Int, #paramTwo: Int) { println("externalInternalShared: \(paramOne) : \(paramTwo)") } // The '#' basically says, you want your internal and external names to be the same // Note that there's been an update in Swift 2 and the above function would have to be written as: func externalInternalShared(paramOne paramOne: Int, #paramTwo: Int) { print("externalInternalShared: \(paramOne) : \(paramTwo)") } externalInternalShared(paramOne: 1, paramTwo: 4) </code></pre> <p>Now here's the fun part, declare a function inside of a class and it's no longer a function ... it's a method</p> <pre><code>class SomeClass { func someClassFunctionWithParamOne(paramOne: Int, paramTwo: Int) { println("someClassFunction: \(paramOne) : \(paramTwo)") } } var someInstance = SomeClass() someInstance.someClassFunctionWithParamOne(1, paramTwo: 4) </code></pre> <p>This is part of the design of behavior for methods</p> <p>Apple Docs:</p> <blockquote> <p>Specifically, Swift gives the first parameter name in a method a local parameter name by default, and gives the second and subsequent parameter names both local and external parameter names by default. This convention matches the typical naming and calling convention you will be familiar with from writing Objective-C methods, and makes for expressive method calls without the need to qualify your parameter names.</p> </blockquote> <p>Notice the autocomplete: <img src="https://i.stack.imgur.com/gyT4m.png" alt="enter image description here"></p>
<p>This is simply an influence of the Objective-C language. When calling a method, the first parameter of a method does not need to be explicitly labelled (as in Objective-C it is effectively 'labelled' by the name of the method). However all following parameters DO need a name to identify them. They may also take an (optional) local name for use inside the method itself (see Jiaaro's link in the comments above).</p>
<p>This is a quirk in the compiler. Functions (which are not members of a class) and class methods have different default behavior with regards to named parameters. This is consistent with the behavior of named parameters in objective-C (but makes no sense for someone new to swift with no experience with objective-C).</p> <p>Here's what the language reference has to say about named parameters for <em>functions</em> (specifically parameters where an external name for the parameter is not given, and the parameter does not have a default value)</p> <blockquote> <p>However, these parameter names are only used within the body of the function itself, and <strong><em>cannot</em></strong> be used when calling the function. These kinds of parameter names are known as local parameter names, because they are only available for use within the functionâ€™s body.</p> </blockquote> <p>For information about class methods, see Logan's answer.</p>