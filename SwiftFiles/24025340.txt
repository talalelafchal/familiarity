Property getters and setters
<p>With this simple class I am getting the compiler warning "Attempting to modify/access 'x' within its own setter/getter" and when I use it like this:</p> <pre><code>var p:point = point() p.x = 12 </code></pre> <p>I get an EXC_BAD_ACCESS. How can I do this without explicit backing ivars?</p> <pre><code>class point { var x:Int { set { x = newValue * 2 //Error } get { return x / 2 //Error } } ... </code></pre>
<p><strong>EDIT</strong>: Since this answer is getting a few upvotes, I would like to clarify that setters/getters in Swift are quite different than ObjC. The property becomes a <em>computed property</em> which means it does <strong>not</strong> have a backing variable such as <code>_x</code> as it would in ObjC. In the solution code below you can see the <code>xTimesTwo</code> does <strong>not</strong> store anything, but simply <em>computes</em> the result from <code>x</code>.</p> <p>See <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID259">Official docs on computed properties</a>.</p> <p>The functionality you want might also be <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID262">Property Observers</a>.</p> <p>Setters/getters are different than they were in Objective-C.</p> <p>What you need is:</p> <pre><code>var x:Int var xTimesTwo:Int { set { x = newValue / 2 } get { return x * 2 } } </code></pre> <p>You can modify other properties within the setter/getters, which is what they are meant for.</p>
<p>Setters and Getters apply to <code>computed properties</code>; such properties do not have storage in the instance - the value from the getter is meant to be computed from other instance properties. In your case, there is no <code>x</code> to be assigned.</p> <p>Explicitly: "How can I do this without explicit backing ivars". You can't - you'll need <em>something</em> to backup the computed property. Try this:</p> <pre><code>class Point { private var _x : Int = 0 // _x -&gt; backingX var x : Int { set { _x = 2 * newValue } get { return _x / 2 } } } </code></pre> <p>Specifically, in the Swift REPL:</p> <pre><code> 15&gt; var pt = Point() pt: Point = { _x = 0 } 16&gt; pt.x = 10 17&gt; pt $R3: Point = { _x = 20 } 18&gt; pt.x $R4: Int = 10 </code></pre>
<p>Setters and getters in Swift apply to computed properties/variables. These properties/variables are not actually stored in memory, but rather computed based on the value of stored properties/variables.</p> <p>See Apple's Swift documentation on the subject: <a href="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-XID_512" rel="nofollow" title="Swift Variable Declarations">Swift Variable Declarations</a>.</p>
<p>You can customise the set value using property observer. To do this use 'didSet' instead of 'set'.</p> <pre><code>class point { var x:Int { didSet { x = x * 2 } } ... </code></pre> <p>As for getter ...</p> <pre><code>class point { var doubleX:Int { get { return x / 2 } } ... </code></pre>
<p>To elaborate on GoZoner's answer:</p> <p>Your real issue here is that you are recursively calling your getter.</p> <pre><code>var x:Int { set { x = newValue * 2 // This isn't a problem } get { return x / 2 // Here is your real issue, you are recursively calling // your x property's getter } } </code></pre> <p>Like the code comment suggests above, you are infinitely calling the x property's getter, which will continue to execute until you get a EXC_BAD_ACCESS code (you can see the spinner in the bottom right corner of your Xcode's playground environment).</p> <p>Consider the example from the <a href="https://developer.apple.com/library/prerelease/mac/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-XID_370">Swift documentation</a>:</p> <pre><code>struct Point { var x = 0.0, y = 0.0 } struct Size { var width = 0.0, height = 0.0 } struct AlternativeRect { var origin = Point() var size = Size() var center: Point { get { let centerX = origin.x + (size.width / 2) let centerY = origin.y + (size.height / 2) return Point(x: centerX, y: centerY) } set { origin.x = newValue.x - (size.width / 2) origin.y = newValue.y - (size.height / 2) } } } </code></pre> <p>Notice how the center computed property never modifies or returns itself in the variable's declaration.</p>
<p>Try using this: </p> <pre><code>var x:Int! var xTimesTwo:Int { get { return x * 2 } set { x = newValue / 2 } } </code></pre> <p>This is basically Jack Wu's answer, but the difference is that in Jack Wu's answer his x variable is <code>var x: Int</code>, in mine, my x variable is like this: <code>var x: Int!</code>, so all I did was make it an optional type. </p>
<p>In order to override <code>setter</code> and <code>getter</code> for swift variables use the below given code </p> <pre><code>var temX : Int? var x: Int?{ set(newX){ temX = newX } get{ return temX } } </code></pre> <p>We need to keep the value of variable in a temporary variable, since trying to access the same variable whose getter/setter is being overridden will result in infinite loops.</p> <p>We can invoke the setter simply like this </p> <pre><code>x = 10 </code></pre> <p>Getter will be invoked on firing below given line of code </p> <pre><code>var newVar = x </code></pre>
<p>You are <strong>recursively</strong> defining <code>x</code> with <code>x</code>. As if someone asks you how old are you? And you answer "I am twice my age". Which is meaningless. </p> <p>You must say I am twice John's age or any other variable <em>but</em> yourself.</p> <p>computed variables are always dependent on another variable.</p>