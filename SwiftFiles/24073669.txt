Why is optional chaining required in an “if let” statement?
<p>Why would the Swift compiler expect me to write</p> <pre><code>if let addressNumber = paul.residence?.address?.buildingNumber?.toInt() { } </code></pre> <p>instead of just writing:</p> <pre><code>if let addressNumber = paul.residence.address.buildingNumber.toInt() { } </code></pre> <p>The compiler clearly has the static type information to handle the conditional statement for the first dereference of the optional value and each following value. </p> <p>Why would it not continue to do so for the following statements?</p>
<p>Each of those properties is an optional property. It could be valid, or it could be 'not there' (nil). Unlike ObjC, Swift treats nil-references as crashes unless you make them conditional. I would imagine this is for both hygienic and performance reasons, but, regardless, it's a restriction imposed by the language.</p>
<p>The second statement you posted would be possible if the declaration of the property of each object wasn't optional.</p> <p>For example:</p> <pre><code>class Person { var residence: Residence? } class Residence { var address: Address? } class Address { var buildingNumber:String? var streetName:String? var apptNumber:UInt? } </code></pre> <p>This code would require you to add the conditional markers to make sure that the wrapped property you are trying to access isn't <code>nil</code>.</p> <p>Note that there are no initial values set to those optional types as the <code>?</code> infers that the default value is <code>nil</code>.</p> <pre><code>class Person { var residence: Residence init(residence: Residence) { self.residence = residence } } class Residence { var address: Address init(address: Address) { self.address = address } } class Address { var buildingNumber:String var streetName:String var apptNumber:UInt init(buildingNumber: String, streetName: String, apptNumber: UInt) { self.buildingNumber = buildingNumber self.streetName = streetName self.apptNumber = apptNumber } } </code></pre> <p>In this second version, the initializer forces you to set a non-nil value to each properties. For an object to be initialized, all its properties need to be initialized as well. Optionals have the convenience of being pre-initialized to nil.</p> <p>Also, note that all the <code>?</code> are gone from the properties declarations for <code>Person</code>, <code>Residence</code> and <code>Address</code>.</p> <p>If your code was structured that way, your second <code>if let</code> statement would work without a problem. But then again, in the second case, there's no need to unwrap your optionals (you don't have any). You could simply call:</p> <pre><code>paul.residence.address.buildingNumber.toInt() </code></pre> <p>And get your value.</p> <p>I might add that it's way safer to use optionals, as it doesn't force you to use every properties of a class.</p>
<p>One way to look at it is that <code>if let</code> is a simple way to absolve from checking for nils , and without an optional it's pointless.</p>