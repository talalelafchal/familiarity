How to use background thread in swift?
<p>Hey there anyone know how to use threading in swift </p> <pre><code>dispatchOnMainThread:^{ NSLog(@"Block Executed On %s", dispatch_queue_get_label(dispatch_get_current_queue())); }]; </code></pre>
<p>From <a href="http://jamesonquave.com/blog/developing-ios-apps-using-swift-part-5-async-image-loading-and-caching/" rel="nofollow"><strong>Jameson Quave's</strong> tutorial</a></p> <p><strong>Swift 2</strong></p> <pre><code>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), { //All stuff here }) </code></pre>
<h3>Swift 3.0</h3> <p>A lot has been <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md">modernized</a> in Swift 3.0. Running something on the background thread looks like this:</p> <pre><code>DispatchQueue.global(qos: .background).async { print("This is run on the background queue") DispatchQueue.main.async { print("This is run on the main queue, after the previous code in outer block") } } </code></pre> <h3>Swift 1.2 through 2.3</h3> <pre><code>let qualityOfServiceClass = QOS_CLASS_BACKGROUND let backgroundQueue = dispatch_get_global_queue(qualityOfServiceClass, 0) dispatch_async(backgroundQueue, { print("This is run on the background queue") dispatch_async(dispatch_get_main_queue(), { () -&gt; Void in print("This is run on the main queue, after the previous code in outer block") }) }) </code></pre> <h3>Pre Swift 1.2 – Known issue</h3> <p>As of Swift 1.1 Apple didn't support the above syntax without some modifications. Passing <code>QOS_CLASS_BACKGROUND</code> didn't actually work, instead use <code>Int(QOS_CLASS_BACKGROUND.value)</code>.</p> <p>For more information see <a href="https://developer.apple.com/library/prerelease/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html">Apples documentation</a> </p>
<p>The best practice is to define a reusable function that can be accessed multiple times.</p> <h2><strong>REUSABLE FUNCTION:</strong></h2> <p>e.g. somewhere like AppDelegate.swift as a Global Function.</p> <pre><code>func backgroundThread(delay: Double = 0.0, background: (() -&gt; Void)? = nil, completion: (() -&gt; Void)? = nil) { dispatch_async(dispatch_get_global_queue(Int(QOS_CLASS_USER_INITIATED.value), 0)) { if(background != nil){ background!(); } let popTime = dispatch_time(DISPATCH_TIME_NOW, Int64(delay * Double(NSEC_PER_SEC))) dispatch_after(popTime, dispatch_get_main_queue()) { if(completion != nil){ completion!(); } } } } </code></pre> <p>Note: in Swift 2.0, replace <strong>QOS_CLASS_USER_INITIATED.value</strong> above with <strong>QOS_CLASS_USER_INITIATED.rawValue</strong> instead</p> <h2><strong>USAGE:</strong></h2> <p>A. To run a process in the background with a delay of 3 seconds:</p> <pre><code> backgroundThread(3.0, background: { // Your background function here }) </code></pre> <p>B. To run a process in the background then run a completion in the foreground:</p> <pre><code> backgroundThread(background: { // Your function here to run in the background }, completion: { // A function to run in the foreground when the background thread is complete }) </code></pre> <p>C. To delay by 3 seconds - note use of completion parameter without background parameter:</p> <pre><code> backgroundThread(3.0, completion: { // Your delayed function here to be run in the foreground }) </code></pre>
<p>You have to separate out the changes that you want to run in the background from the updates you want to run on the UI:</p> <pre><code>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) { // do your task dispatch_async(dispatch_get_main_queue()) { // update some UI } } </code></pre>
<pre><code>dispatch_async(dispatch_get_global_queue(QOS_CLASS_BACKGROUND, 0), { // Conversion into base64 string self.uploadImageString = uploadPhotoDataJPEG.base64EncodedStringWithOptions(NSDataBase64EncodingOptions.EncodingEndLineWithCarriageReturn) }) </code></pre>
<p>Good answers though, anyway I want to share my Object Oriented solution <strong>Updated for swift 3</strong>.</p> <p>please check it out: <a href="http://pastebin.com/0HSd3jAE" rel="nofollow noreferrer">AsyncTask</a></p> <p>Conceptually inspired by android's AsyncTask, I've wrote my own class in Swift </p> <p><strong>AsyncTask</strong> enables proper and easy use of the UI thread. This class allows to perform background operations and publish results on the UI thread.</p> <p>Here are few usage examples</p> <p>Example 1 - </p> <pre><code>AsyncTask(backgroundTask: {(p:String)-&gt;Void in//set BGParam to String and BGResult to Void print(p);//print the value in background thread }).execute("Hello async");//execute with value 'Hello async' </code></pre> <p>Example 2 - </p> <pre><code>let task2=AsyncTask(beforeTask: { print("pre execution");//print 'pre execution' before backgroundTask },backgroundTask:{(p:Int)-&gt;String in//set BGParam to Int &amp; BGResult to String if p&gt;0{//check if execution value is bigger than zero return "positive"//pass String "poitive" to afterTask } return "negative";//otherwise pass String "negative" }, afterTask: {(p:String) in print(p);//print background task result }); task2.execute(1);//execute with value 1 </code></pre> <p>It has 2 generic types:</p> <ul> <li><code>BGParam</code> - the type of the parameter sent to the task upon execution.</li> <li><p><code>BGResult</code> - the type of the result of the background computation.</p> <p>When you create an AsyncTask you can those types to whatever you need to pass in and out of the background task, but if you don't need those types, you can mark it as unused with just setting it to: <code>Void</code> or with shorter syntax: <code>()</code> </p></li> </ul> <p>When an asynchronous task is executed, it goes through 3 steps:</p> <ol> <li><code>beforeTask:()-&gt;Void</code> invoked on the UI thread just before the task is executed.</li> <li><code>backgroundTask: (param:BGParam)-&gt;BGResult</code> invoked on the background thread immediately after</li> <li><code>afterTask:(param:BGResult)-&gt;Void</code> invoked on the UI thread with result from the background task</li> </ol>
<p>I really like Dan Beaulieu's answer, but it doesn't work with Swift 2.2 and I think we can avoid those nasty forced unwraps!</p> <pre><code>func backgroundThread(delay: Double = 0.0, background: (() -&gt; Void)? = nil, completion: (() -&gt; Void)? = nil) { dispatch_async(dispatch_get_global_queue(QOS_CLASS_USER_INITIATED, 0)) { background?() if let completion = completion{ let popTime = dispatch_time(DISPATCH_TIME_NOW, Int64(delay * Double(NSEC_PER_SEC))) dispatch_after(popTime, dispatch_get_main_queue()) { completion() } } } } </code></pre>
<h1>Swift 3 version</h1> <p>Swift 3 utilizes new <code>DispatchQueue</code> class to manage queues and threads. To run something on the background thread you would use:</p> <pre><code>let backgroundQueue = DispatchQueue(label: "com.app.queue", qos: .background, target: nil) backgroundQueue.async { print("Run on background thread") } </code></pre> <p>Or if you want something in two lines of code:</p> <pre><code>DispatchQueue.global(qos: .background).async { print("Run on background thread") } </code></pre> <p>You can also get some in-depth info about GDC in Swift 3 in <a href="http://swiftable.io/2016/06/dispatch-queues-swift-3/">this tutorial</a>.</p>
<p>Dan Beaulieu's answer in swift3.</p> <h1>Swift 3.0.1</h1> <pre><code>extension DispatchQueue { static func background(delay: Double = 0.0, background: (()-&gt;Void)? = nil, completion: (() -&gt; Void)? = nil) { DispatchQueue.global(qos: .background).async { background?() if let completion = completion { DispatchQueue.main.asyncAfter(deadline: .now() + delay, execute: { completion() }) } } } } </code></pre> <h1>Usage</h1> <pre><code>DispatchQueue.background(delay: 3.0, background: { // do something in background }, completion: { // when background job finishes, wait 3 seconds and do something in main thread }) DispatchQueue.background(background: { // do something in background }, completion:{ // when background job finished, do something in main thread }) DispatchQueue.background(delay: 3.0, completion:{ // do something in main thread after 3 seconds }) </code></pre>