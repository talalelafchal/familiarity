Swift - IBOutletCollection equivalent
<p>I'm trying to replicate the Stanford Matchismo game from "Developing ios7 apps for iphone and ipad" in iTunesU in Swift.</p> <p>On page 77 of the 3rd lecture <a href="https://itunes.apple.com/us/course/developing-ios-7-apps-for/id733644550#">slides</a>, it shows using an <code>IBOutletCollection</code> which isn't an option on Swift. The Swift doc example shows one example that has an array of <code>IBOutlet</code>, but I can't figure out how to make Interface Builder connect multiple outlets to the same <code>IBOutlet</code>/<code>IBOutlet</code> Array.</p> <p>Has anyone figured out how to do this yet? I know that I can create 12 outlets and deal with it that way, but I'd like to make this work as closely as possible to the example in the lecture slides.</p>
<p><strong>Update:</strong> This works properly in Xcode now - "Outlet Collection" is one of the connection options in Interface Builder, which creates something that looks like:</p> <pre><code>@IBOutlet var labelCollection: [UILabel]! </code></pre> <hr> <p>While we're waiting for a fix, you can approximate this using a computed property. Let's say my view has five <code>UILabels</code> that I want in a collection. I still have to declare each one, but then I also declare a computed property that collects them:</p> <pre><code>class MyViewController { @IBOutlet var label1 : UILabel @IBOutlet var label2 : UILabel @IBOutlet var label3 : UILabel @IBOutlet var label4 : UILabel @IBOutlet var label5 : UILabel var labels: UILabel![] { return [label1, label2, label3, label4, label5] } </code></pre> <p>Kind of annoying, but from then on we can treat the <code>labels</code> property as if it were an <code>IBOutletCollection</code>, and won't have to change the rest of our code once the bug is fixed:</p> <pre><code>override func viewDidLoad() { super.viewDidLoad() for (index, item) in enumerate(self.labels) { item.text = "Label #\(index)" } } </code></pre>
<p>EDIT</p> <blockquote> <p>This was fixed in a later Beta release of Swift - there's now in IBCollection option in the interface builder.</p> </blockquote> <hr> <p><strong>For early Beta releases of Swift:</strong></p> <p>I came across the same problem: in the release notes of Beta 2 you find the following statement:</p> <blockquote> <p>Interface Builder does not support declaring outlet collections in Swift classes</p> </blockquote> <p>I solved this the following way (easy to customize):</p> <pre><code>class CardGameViewController: UIViewController { @lazy var cardButtons : UIButton[] = { var tempBtn: UIButton[] = [] for v:AnyObject in self.view.subviews { if v is UIButton { tempBtn.append(v as UIButton) } } return tempBtn }() ... </code></pre> <p>Basically, it loops through all the subviews and checks if one is a UIButton. In that case it gets added to a temporary array. This temporary array is then used to lazy instantiate the cardButtons array. For all details, check: <a href="http://alexpotrykus.com/blog/2014/06/20/stanfords-matchismo-in-swift/" rel="nofollow">Matchismo: Objective-C to Swift</a></p>
<p>I got this working in Xcode seed 3 using this syntax</p> <pre><code>@IBOutlet strong var views: NSArray? </code></pre> <p>See my discussion here: <a href="http://stackoverflow.com/a/24686602/341994">http://stackoverflow.com/a/24686602/341994</a></p>
<p>Use:</p> <pre><code>@IBOutlet var lineFileds : [UITextField]! </code></pre> <p>Then control-drag from TextField elements to <code>lineFileds</code> in order.</p>
<pre><code>@IBOutlet var buttons : [UIView]! </code></pre> <p>then drag it from the connections inspector in the interface builder or whatever metod you usually use for that</p>
<p>What @machine said seems to be the current state (XCode 7.1) with iOS 9 bindings. The key is to drag them all in order. Use the first item to control+drag into the controller code and then change the Outlet type to collection. After the from the controller code file drag the outlet point onto each of the screen controls one by one in order (as @machine says) </p>