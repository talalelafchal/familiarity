Swift - How to convert String to Double
<p>I'm trying to write a BMI program in swift language. And I got this problem: how to convert a String to a Double?</p> <p>In Objective-C, I can do like this:</p> <p><code>double myDouble = [myString doubleValue];</code></p> <p>But how can I achieve this in Swift language?</p>
<p>Try this:</p> <pre><code> var myDouble = myString.bridgeToObjectiveC().doubleValue println(myDouble) </code></pre> <p><strong>NOTE</strong></p> <p>Removed in Beta 5. This no longer works ?</p>
<p>Another option here is converting this to an <code>NSString</code> and using that:</p> <pre><code>let string = NSString(string: mySwiftString) string.doubleValue </code></pre>
<p>Here's an extension method that allows you to simply call doubleValue() on a Swift string and get a double back (example output comes first)</p> <pre><code>println("543.29".doubleValue()) println("543".doubleValue()) println(".29".doubleValue()) println("0.29".doubleValue()) println("-543.29".doubleValue()) println("-543".doubleValue()) println("-.29".doubleValue()) println("-0.29".doubleValue()) //prints 543.29 543.0 0.29 0.29 -543.29 -543.0 -0.29 -0.29 </code></pre> <p>Here's the extension method:</p> <pre><code>extension String { func doubleValue() -&gt; Double { let minusAscii: UInt8 = 45 let dotAscii: UInt8 = 46 let zeroAscii: UInt8 = 48 var res = 0.0 let ascii = self.utf8 var whole = [Double]() var current = ascii.startIndex let negative = current != ascii.endIndex &amp;&amp; ascii[current] == minusAscii if (negative) { current = current.successor() } while current != ascii.endIndex &amp;&amp; ascii[current] != dotAscii { whole.append(Double(ascii[current] - zeroAscii)) current = current.successor() } //whole number var factor: Double = 1 for var i = countElements(whole) - 1; i &gt;= 0; i-- { res += Double(whole[i]) * factor factor *= 10 } //mantissa if current != ascii.endIndex { factor = 0.1 current = current.successor() while current != ascii.endIndex { res += Double(ascii[current] - zeroAscii) * factor factor *= 0.1 current = current.successor() } } if (negative) { res *= -1; } return res } } </code></pre> <p>No error checking, but you can add it if you need it.</p>
<p>we can use CDouble value which will be obtained by myString.doubleValue</p>
<p>Or you could do:</p> <pre><code>var myDouble = Double((mySwiftString.text as NSString).doubleValue) </code></pre>
<p>For a little more Swift feeling, using <code>NSFormatter()</code> avoids casting to <code>NSString</code>, and returns <code>nil</code> when the string does not contain a <code>Double</code> value (e.g. "test" will not return <code>0.0</code>).</p> <pre><code>let double = NSNumberFormatter().numberFromString(myString)?.doubleValue </code></pre> <p>Alternatively, extending Swift's <code>String</code> type:</p> <pre><code>extension String { func toDouble() -&gt; Double? { return NSNumberFormatter().numberFromString(self)?.doubleValue } } </code></pre> <p>and use it like <code>toInt()</code>:</p> <pre><code>var myString = "4.2" var myDouble = myString.toDouble() </code></pre> <p>This returns an optional <code>Double?</code> which has to be unwrapped.</p> <p>Either with forced unwrapping:</p> <pre><code>println("The value is \(myDouble!)") // prints: The value is 4.2 </code></pre> <p>or with an if let statement:</p> <pre><code>if let myDouble = myDouble { println("The value is \(myDouble)") // prints: The value is 4.2 } </code></pre> <p><strong>Update:</strong> For localization, it is very easy to apply locales to the NSFormatter as follows:</p> <pre><code>let formatter = NSNumberFormatter() formatter.locale = NSLocale(localeIdentifier: "fr_FR") let double = formatter.numberFromString("100,25") </code></pre> <p>Finally, you can use <code>NSNumberFormatterCurrencyStyle</code> on the formatter if you are working with currencies where the string contains the currency symbol.</p>
<p>You don't need to use the NSString constructor like the accepted answer proposes. You can simply bridge it like this:</p> <pre><code>(swiftString as NSString).doubleValue </code></pre> <p><strong>Swift 2 Update</strong> There are new failable initializers that allow you to do this in more idiomatic and safe way (as many answers have noted, NSString's double value is not very safe because it returns 0 for non number values. This means that the <code>doubleValue</code> of <code>"foo"</code> and <code>"0"</code> are the same.)</p> <pre><code>let myDouble = Double(myString) </code></pre> <p>This returns an optional, so in cases like passing in <code>"foo"</code> where <code>doubleValue</code> would have returned 0, the failable intializer will return <code>nil</code>. You can use a <code>guard</code>, <code>if-let</code>, or <code>map</code> to handle the <code>Optional&lt;Float&gt;</code></p>
<p>You can use <a href="https://github.com/artemkin/StringEx.swift" rel="nofollow">StringEx</a>. It extends <code>String</code> with string-to-number conversions including <code>toDouble()</code>.</p> <pre><code>extension String { func toDouble() -&gt; Double? } </code></pre> <p>It verifies the string and fails if it can't be converted to double.</p> <p>Example:</p> <pre><code>import StringEx let str = "123.45678" if let num = str.toDouble() { println("Number: \(num)") } else { println("Invalid string") } </code></pre>
<p>As of Swift 1.1, you can directly pass <code>String</code> to <code>const char *</code> parameter.</p> <pre><code>import Foundation let str = "123.4567" let num = atof(str) // -&gt; 123.4567 atof("123.4567fubar") // -&gt; 123.4567 </code></pre> <p>If you don't like deprecated <code>atof</code>:</p> <pre><code>strtod("765.4321", nil) // -&gt; 765.4321 </code></pre> <p>One caveat: the behavior of conversion is different from <code>NSString.doubleValue</code>.</p> <p><code>atof</code> and <code>strtod</code> accept <code>0x</code> prefixed hex string:</p> <pre><code>atof("0xffp-2") // -&gt; 63.75 atof("12.3456e+2") // -&gt; 1,234.56 atof("nan") // -&gt; (not a number) atof("inf") // -&gt; (+infinity) </code></pre> <p>If you prefer <code>.doubleValue</code> behavior, we can still use <code>CFString</code> bridging:</p> <pre><code>let str = "0xff" atof(str) // -&gt; 255.0 strtod(str, nil) // -&gt; 255.0 CFStringGetDoubleValue(str) // -&gt; 0.0 (str as NSString).doubleValue // -&gt; 0.0 </code></pre>
<pre><code>var stringValue = "55" var convertToDouble = Double((stringValue as NSString).doubleValue) </code></pre>
<p>1.</p> <pre><code>let strswift = "12" let double = (strswift as NSString).doubleValue </code></pre> <p>2.</p> <pre><code>var strswift= "10.6" var double : Double = NSString(string: strswift).doubleValue </code></pre> <p>May be this help for you.</p>
<p>Please check it on playground!</p> <pre><code>let sString = "236.86" var dNumber = NSNumberFormatter().numberFromString(sString) var nDouble = dNumber! var eNumber = Double(nDouble) * 3.7 </code></pre> <p>By the way in my Xcode</p> <p>.toDouble() - doesn't exist</p> <p>.doubleValue create value 0.0 from not numerical strings...</p>
<p>As already pointed out, the best way to achieve this is with direct casting:</p> <pre><code>(myString as NSString).doubleValue </code></pre> <p>Building from that, you can make a slick native Swift String extension:</p> <pre><code>extension String { var doubleValue: Double { return (self as NSString).doubleValue } } </code></pre> <p>This allows you to directly use:</p> <pre><code>myString.doubleValue </code></pre> <p>Which will perform the casting for you. If Apple does add a <code>doubleValue</code> to the native String you just need to remove the extension and the rest of your code will automatically compile fine!</p>
<p>This is building upon the answer by @Ryu</p> <p>His solution is great as long as you're in a country where dots are used as separators. By default <code>NSNumberFormatter</code> uses the devices locale. Therefore this will fail in all countries where a comma is used as the default separator (including France as @PeterK. mentioned) if the number uses dots as separators (which is normally the case). To set the locale of this NSNumberFormatter to be US and thus use dots as separators replace the line</p> <pre><code>return NSNumberFormatter().numberFromString(self)?.doubleValue </code></pre> <p>with</p> <pre><code>let numberFormatter = NSNumberFormatter() numberFormatter.locale = NSLocale(localeIdentifier: "en_US_POSIX") return numberFormatter.numberFromString(self)?.doubleValue </code></pre> <p>Therefore the full code becomes</p> <pre><code>extension String { func toDouble() -&gt; Double? { let numberFormatter = NSNumberFormatter() numberFormatter.locale = NSLocale(localeIdentifier: "en_US_POSIX") return numberFormatter.numberFromString(self)?.doubleValue } } </code></pre> <p>To use this, just call <code>"Your text goes here".toDouble()</code></p> <p>This will return an optional <code>Double?</code></p> <p>As @Ryu mentioned you can either force unwrap:</p> <pre><code>println("The value is \(myDouble!)") // prints: The value is 4.2 </code></pre> <p>or use an <code>if let</code> statement:</p> <pre><code>if let myDouble = myDouble { println("The value is \(myDouble)") // prints: The value is 4.2 } </code></pre>
<p>I find more readable to add an extension to String as follow:</p> <pre><code>extension String { var doubleValue: Double { return (self as NSString).doubleValue } } </code></pre> <p>and then you just could write your code:</p> <pre><code>myDouble = myString.doubleValue </code></pre>
<p>What also works:</p> <pre><code>// Init default Double variable var scanned: Double() let scanner = NSScanner(string: "String to Scan") scanner.scanDouble(&amp;scanned) // scanned has now the scanned value if something was found. </code></pre>
<p><strong>Swift 2 String to Double</strong></p> <p>You should use the new type initializers to convert between String and numeric types (Double, Float, Int). It'll return an Optional type (Double?) which will have the correct value or nil if the String was not a number.</p> <p><strong>Note:</strong> The NSString doubleValue property is not recommended because it returns 0 if the value cannot be converted (i.e.: bad user input).</p> <p><strong>Use the Swift 2 method</strong></p> <pre><code>let lessPrecisePI = Float("3.14") let morePrecisePI = Double("3.1415926536") let invalidNumber = Float("alphabet") // nil, not a valid number </code></pre> <p><strong>Unwrap the values to use them using if/let</strong></p> <pre><code>if let cost = Double(textField.text!) { print("The user entered a value price of \(cost)") } else { print("Not a valid number: \(textField.text!)") } </code></pre> <p>Read more on my <a href="http://iphonedev.tv/blog/2015/9/28/how-to-convert-strings-into-double-and-float-values-using-swift-2">blog post about converting String to Double types</a>.</p>
<p>In Swift 2.0 the best way is to avoid thinking like an Objective-C developer. So you should not "convert a String to a Double" but you should "initialize a Double from a String". Apple doc over here: <a href="https://developer.apple.com/library/ios//documentation/Swift/Reference/Swift_Double_Structure/index.html#//apple_ref/swift/structctr/Double/s:FSdcFMSdFSSGSqSd_" rel="nofollow">https://developer.apple.com/library/ios//documentation/Swift/Reference/Swift_Double_Structure/index.html#//apple_ref/swift/structctr/Double/s:FSdcFMSdFSSGSqSd_</a></p> <p>It's an optional init so you can use the nil coalescing operator (??) to set a default value. Example:</p> <pre><code>let myDouble = Double("1.1") ?? 0.0 </code></pre>
<p>Use this code in Swift 2.0</p> <p><code>let strWithFloat = "78.65" let floatFromString = Double(strWithFloat) </code></p>
<p>Extension with optional locale</p> <pre><code>extension String { func toDouble(locale: NSLocale? = nil) -&gt; Double? { let formatter = NSNumberFormatter() if let locale = locale { formatter.locale = locale } return formatter.numberFromString(self)?.doubleValue } } </code></pre>