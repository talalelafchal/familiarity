What is the purpose of willSet and didSet in Swift?
<p>Swift has a property declaration syntax very similar to C#'s:</p> <pre><code>var foo : int { get { return getFoo() } set { setFoo(newValue) } } </code></pre> <p>However, it also has <code>willSet</code> and <code>didSet</code> actions. These are called before and after the setter is called, respectively. What is their purpose, considering that you could just have the same code inside the setter?</p>
<p>The point seems to be that sometimes, you need a property that has automatic storage <em>and</em> some behavior, for instance to notify other objects that the property just changed. When all you have is <code>get</code>/<code>set</code>, you need another field to hold the value. With <code>willSet</code> and <code>didSet</code>, you can take action when the value is modified without needing another field. For instance, in that example:</p> <pre><code>class Foo { var myProperty: Int = 0 { didSet { print("The value of myProperty changed from \(oldValue) to \(myProperty)") } } } </code></pre> <p><code>myProperty</code> prints its old and new value every time it is modified. With just getters and setters, I would need this instead:</p> <pre><code>class Foo { var myPropertyValue: Int = 0 var myProperty: Int { get { return myPropertyValue } set { myPropertyValue = value print("The value of myProperty changed from \(oldValue) to \(myProperty)") } } } </code></pre> <p>So <code>willSet</code> and <code>didSet</code> represent an economy of a couple of lines, and less noise in the field list.</p>
<p>These are called <em>Property Observers</em>:</p> <blockquote> <p>Property observers observe and respond to changes in a property’s value. Property observers are called every time a property’s value is set, even if the new value is the same as the property’s current value.</p> </blockquote> <p>Excerpt From: Apple Inc. “The Swift Programming Language.” iBooks. <a href="https://itun.es/ca/jEUH0.l">https://itun.es/ca/jEUH0.l</a></p> <p>I suspect it's to allow for things we would traditionally do with <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html">KVO</a> such as data binding with UI elements, or triggering side effects of changing a property, triggering a sync process, background processing, etc, etc.</p>
<p>Getter and setter are sometimes too heavy to implement just to observe proper value changes. Usually this needs extra temporary variable handling and extra checks, and you will want to avoid even those tiny labour if you write hundreds of getters and setters. These stuffs are for the situation.</p>
<p>I do not know C#, but with a little guesswork I think I understand what </p> <pre><code>foo : int { get { return getFoo(); } set { setFoo(newValue); } } </code></pre> <p>does. It looks very similar to what you have in Swift, but it's not the same: in Swift you do not have the <code>getFoo</code> and <code>setFoo</code>. That is not a little difference: it means you do not have any underlying storage for your value.</p> <p>Swift has stored and computed properties.</p> <p>A computed property has <code>get</code> and may have <code>set</code> (if it's writable). But the code in the getter and setter, if they need to actually store some data, must do it in <strong>other</strong> properties. There is no backing storage.</p> <p>A stored property, on the other hand, does have backing storage. But it does <strong>not</strong> have <code>get</code> and <code>set</code>. Instead it has <code>willSet</code> and <code>didSet</code> which you can use to observe variable changes and, eventually, trigger side effects and/or modify the stored value. You do not have <code>willSet</code> and <code>didSet</code> for computed properties, and you do not need them because for computed properties you can use the code in <code>set</code> to control changes.</p>
<p>My understanding is that set and get are for <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID259" rel="nofollow">computed properties</a> (no backing from <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID255" rel="nofollow">stored properties</a>)</p> <p><sub>if you are coming from an Objective-C bare in mind that the naming conventions have changed. In Swift an iVar or instance variable is named <em>stored property</em></sub></p> <h1>Example 1 (read only property) - with warning:</h1> <pre><code>var test : Int { get { return test } } </code></pre> <p>This will result in a warning because this results in a recursive function call (the getter calls itself).The warning in this case is "Attempting to modify 'test' within its own getter". </p> <h1>Example 2. Conditional read/write - with warning</h1> <pre><code>var test : Int { get { return test } set (aNewValue) { //I've contrived some condition on which this property can be set //(prevents same value being set) if (aNewValue != test) { test = aNewValue } } } </code></pre> <p>Similar problem - <B>you cannot do this</B> as it's recursively calling the setter. Also, note this code will not complain about no initialisers as <B>there is no stored property to initialise</B>.</p> <h1>Example 3. read/write computed property - with backing store</h1> <p>Here is a pattern that allows conditional setting of an actual stored property</p> <pre><code>//True model data var _test : Int = 0 var test : Int { get { return _test } set (aNewValue) { //I've contrived some condition on which this property can be set if (aNewValue != test) { _test = aNewValue } } } </code></pre> <p><B>Note</B> The actual data is called _test (although it could be any data or combination of data) Note also the need to provide an initial value (alternatively you need to use an init method) because _test is actually an instance variable</p> <h1>Example 4. Using will and did set</h1> <pre><code>//True model data var _test : Int = 0 { //First this willSet { println("Old value is \(_test), new value is \(newValue)") } //value is set //Finaly this didSet { println("Old value is \(oldValue), new value is \(_test)") } } var test : Int { get { return _test } set (aNewValue) { //I've contrived some condition on which this property can be set if (aNewValue != test) { _test = aNewValue } } } </code></pre> <p>Here we see willSet and didSet intercepting a change in an actual stored property. This is useful for sending notifications, synchronisation etc... (see example below)</p> <h1>Example 5. Concrete Example - ViewController Container</h1> <pre><code>//Underlying instance variable (would ideally be private) var _childVC : UIViewController? { willSet { //REMOVE OLD VC println("Property will set") if (_childVC != nil) { _childVC!.willMoveToParentViewController(nil) self.setOverrideTraitCollection(nil, forChildViewController: _childVC) _childVC!.view.removeFromSuperview() _childVC!.removeFromParentViewController() } if (newValue) { self.addChildViewController(newValue) } } //I can't see a way to 'stop' the value being set to the same controller - hence the computed property didSet { //ADD NEW VC println("Property did set") if (_childVC) { // var views = NSDictionaryOfVariableBindings(self.view) .. NOT YET SUPPORTED (NSDictionary bridging not yet available) //Add subviews + constraints _childVC!.view.setTranslatesAutoresizingMaskIntoConstraints(false) //For now - until I add my own constraints self.view.addSubview(_childVC!.view) let views = ["view" : _childVC!.view] as NSMutableDictionary let layoutOpts = NSLayoutFormatOptions(0) let lc1 : AnyObject[] = NSLayoutConstraint.constraintsWithVisualFormat("|[view]|", options: layoutOpts, metrics: NSDictionary(), views: views) let lc2 : AnyObject[] = NSLayoutConstraint.constraintsWithVisualFormat("V:|[view]|", options: layoutOpts, metrics: NSDictionary(), views: views) self.view.addConstraints(lc1) self.view.addConstraints(lc2) //Forward messages to child _childVC!.didMoveToParentViewController(self) } } } //Computed property - this is the property that must be used to prevent setting the same value twice //unless there is another way of doing this? var childVC : UIViewController? { get { return _childVC } set(suggestedVC) { if (suggestedVC != _childVC) { _childVC = suggestedVC } } } </code></pre> <p>Note the use of BOTH computed and stored properties. I've used a computed property to prevent setting the same value twice (to avoid bad things happening!); I've used willSet and didSet to forward notifications to viewControllers (see UIViewController documentation and info on viewController containers)</p> <p>I hope this helps, and please someone shout if I've made a mistake anywhere here!</p>
<blockquote> <p>The willSet and didSet observers for the properties whenever the property is assigned a new value. This is true even if the new value is the same as the current value.</p> </blockquote> <p>And note that <code>willSet</code> needs a parameter name to work around, on the other hand, <code>didSet</code> does not.</p> <blockquote> <p>The didSet observer is called after the value of property is updated. It compares against the old value. If the total number of steps has increased, a message is printed to indicate how many new steps have been taken. <em>The didSet observer does not provide a custom parameter name for the old value, and the default name of oldValue is used instead.</em></p> </blockquote>
<p>In your own (base) class, <code>willSet</code> and <code>didSet</code> are quite <em>reduntant</em> , as you could instead define a calculated property (i.e get- and set- methods) that access a <code>_propertyVariable</code> and does the <em>desired pre- and post- prosessing</em>.</p> <p>If, <em>however</em>, you override a class where the property is <em>already defined</em>, <em>then</em> the <code>willSet</code> and <code>didSet</code> are <em>useful and not redundant!</em></p>
<blockquote> <p>NOTE</p> <p><code>willSet</code> and <code>didSet</code> observers are not called when a property is set in an initializer before delegation takes place</p> </blockquote>
<p>You can also use the <code>didSet</code> to set the variable to a different value. This does not cause the observer to be called again as stated in <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html">Properties guide</a>. For example, it is useful when you want to limit the value as below:</p> <pre><code>let minValue = 1 var value = 1 { didSet { if value &lt; minValue { value = minValue } } } value = -10 // value is minValue now. </code></pre>
<p>The many well-written existing answers cover the question well, but I'll mention, in some detail, an addition that I believe is worth covering.</p> <hr> <p>The <code>willSet</code> and <code>didSet</code> property observers can be used to call delegates, e.g., for class properties that are only ever updated by user interaction, but where you want to avoid calling the delegate at object initialization.</p> <p>I'll cite Klaas up-voted comment to the accepted answer:</p> <blockquote> <p>willSet and didSet observers are not called when a property is first initialized. They are only called when the property’s value is set outside of an initialization context.</p> </blockquote> <p>This is a quite neat as it means e.g. the <code>didSet</code> property is a good choice of launch point for delegate callbacks &amp; functions, for your own custom classes. </p> <p>As an example, consider some custom user control object, with some key property <code>value</code> (e.g. position in rating control), implemented as a subclass of <code>UIView</code>:</p> <pre><code>// CustomUserControl.swift protocol CustomUserControlDelegate { func didChangeValue(value: Int) // func didChangeValue(newValue: Int, oldValue: Int) // func didChangeValue(customUserControl: CustomUserControl) // ... other more sophisticated delegate functions } class CustomUserControl: UIView { // Properties // ... private var value = 0 { didSet { // Possibly do something ... // Call delegate. delegate?.didChangeValue(value) // delegate?.didChangeValue(value, oldValue: oldValue) // delegate?.didChangeValue(self) } } var delegate: CustomUserControlDelegate? // Initialization required init?(...) { // Initialise something ... // E.g. 'value = 1' would not call didSet at this point } // ... some methods/actions associated with your user control. } </code></pre> <p>After which your delegate functions can be used in, say, some view controller to observe key changes in the model for <code>CustomViewController</code>, much like you'd use the inherent delegate functions of the <code>UITextFieldDelegate</code> for <code>UITextField</code> objects (e.g. <code>textFieldDidEndEditing(...)</code>). </p> <p>For this simple example, use a delegate callback from the <code>didSet</code> of the class property <code>value</code> to tell a view controller that one of it's outlets have had associated model update:</p> <pre><code>// ViewController.swift Import UIKit // ... class ViewController: UIViewController, CustomUserControlDelegate { // Properties // ... @IBOutlet weak var customUserControl: CustomUserControl! override func viewDidLoad() { super.viewDidLoad() // ... // Custom user control, handle through delegate callbacks. customUserControl = self } // ... // CustomUserControlDelegate func didChangeValue(value: Int) { // do some stuff with 'value' ... } // func didChangeValue(newValue: Int, oldValue: Int) { // do some stuff with new as well as old 'value' ... // custom transitions? :) //} //func didChangeValue(customUserControl: CustomUserControl) { // // Do more advanced stuff ... //} } </code></pre> <p>Here, the <code>value</code> property has been encapsulated, but generally: in situations like these, be careful not to update the <code>value</code> property of the <code>customUserControl</code> object in the scope of the associated delegate function (here: <code>didChangeValue()</code>) in the view controller, or you'll end up with infinite recursion.</p>