Could not find an overload for '/' that accepts the supplied arguments
<pre><code>// Playground - noun: a place where people can play func getAverage(numbers: Int...) -&gt; Double{ var total = 0 var average:Double = 0 for number in numbers{ total = total + number } average = total / numbers.count return average } getAverage(3, 6) </code></pre> <p>I get an error on <code>average = total / numbers.count</code></p> <blockquote> <p>Could not find an overload for '/' that accepts the supplied arguments</p> </blockquote> <p>I tried to fix by doing:</p> <pre><code>average = Double(total/numbers.count) </code></pre> <p>but then the getAverage was set to <code>4</code> instead of <code>4.5</code></p>
<p>There are no such implicit conversions in Swift, so you'll have to explicitly convert that yourself:</p> <pre><code>average = Double(total) / Double(numbers.count) </code></pre> <p>From <a href="https://itunes.apple.com/us/book/swift-programming-language/id881256329?mt=11"><strong><em>The Swift Programming Language</em></strong></a>: “Values are never implicitly converted to another type.” (Section: A Swift Tour)</p> <p>But you're now using Swift, not Objective-C, so try to think in a more functional oriented way. Your function can be written like this:</p> <pre><code>func getAverage(numbers: Int...) -&gt; Double { let total = numbers.reduce(0, combine: {$0 + $1}) return Double(total) / Double(numbers.count) } </code></pre> <p><code>reduce</code> takes a first parameter as an initial value for an accumulator variable, then applies the <code>combine</code> function to the accumulator variable and each element in the array. Here, we pass an anonymous function that uses <code>$0</code> and <code>$1</code> to denote the first and second parameters it gets passed and adds them up.</p> <p>Even more concisely, you can write this: <code>numbers.reduce(0, +)</code>.</p> <p>Note how type inference does a nice job of still finding out that <code>total</code> is an <code>Int</code>.</p>
<p>The compiler picks an implementation of the <code>/</code> operator based on your input and output parameters. In your case the input parameters are two <code>Int</code> values and the output parameter is <code>Double</code>. This is what the compiler is looking for:</p> <pre><code>func / (left: Int, right: Int) -&gt; Double </code></pre> <p>However, there is no such implementation of the <code>/</code> operator which is why you get the error. When you do <code>Double(total/numbers.count)</code>, your output parameter changes to <code>Int</code> which is why the compiler picks the following implementation for the <code>/</code> operator which exists:</p> <pre><code>func / (left: Int, right: Int) -&gt; Int </code></pre> <p>This is why you get <code>4</code>instead of <code>4.5</code> as a result, even though you convert the result into a <code>Double</code> afterwards.</p> <p>Your can provide your <strong>own implementation</strong> of the <code>/</code> operator which first converts your numbers into <code>Double</code>s:</p> <pre><code>func / (left: Int, right: Int) -&gt; Double { return Double(left) / Double(right) } </code></pre> <p>Then you can do the following:</p> <pre><code>let a: Int = 3 let b: Int = 2 let c: Double = a/b // -&gt; 1.5 </code></pre>