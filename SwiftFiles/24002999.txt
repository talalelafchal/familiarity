How exactly does the &quot;let&quot; keyword work in Swift?
<p>I've read this simple explanation in the guide: </p> <blockquote> <p>The value of a constant doesn’t need to be known at compile time, but you must assign it a value exactly once.</p> </blockquote> <p>But I want a little more detail than this. If the constant references an object, can I still modify its properties? If it references a collection, can I add or remove elements from it? I come from a C# background; is it similar to how <code>readonly</code> works (apart from being able to use it in method bodies), and if it's not, how is it different?</p>
<p><code>let</code> is a little bit like a <code>const</code> pointer in C. If you reference an object with a <code>let</code>, you can change the object's properties or call methods on it, but you cannot assign a different object to that identifier. </p> <p><code>let</code> also has implications for collections and non-object types. If you reference a <code>struct</code> with a <code>let</code>, you cannot change its properties or call any of its <code>mutating func</code> methods.</p> <p>Using <code>let</code>/<code>var</code> with collections works much like mutable/immutable Foundation collections: If you assign an array to a <code>let</code>, you can't change its contents. If you reference a dictionary with <code>let</code>, you can't add/remove key/value pairs or assign a new value for a key — it's truly immutable. If you want to assign to subscripts in, append to, or otherwise mutate an array or dictionary, you must declare it with <code>var</code>.</p> <p>(Prior to Xcode 6 beta 3, Swift arrays had a weird mix of value and reference semantics, and were partially mutable when assigned to a <code>let</code> -- that's gone now.)</p>
<p>F# users will feel right at home with Swift's let keyword. :)</p> <p>In C# terms, you can think of "let" as "readonly var", if that construct was allowed, i.e.: an identifier that can only be bound at the point of declaration.</p>
<p>It's best to think of <code>let</code> in terms of <em>Static Single Assignment</em> (SSA) -- every SSA variable is assigned to <em>exactly</em> once. In functional languages like lisp you don't use an assignment operator -- names are bound to a value exactly once. For example, the names <code>y</code> and <code>z</code> below are bound to a value exactly once (per invocation):</p> <pre><code>func pow(x: Float, n : Int) -&gt; Float { if n == 0 {return 1} if n == 1 {return x} let y = pow(x, n/2) let z = y*y if n &amp; 1 == 0 { return z } return z*x } </code></pre> <p>This lends itself to more correct code since it enforces invariance and is side-effect free. </p> <p>Here is how an imperative-style programmer might compute the first 6 powers of 5:</p> <pre><code>var powersOfFive = Int[]() for n in [1, 2, 3, 4, 5, 6] { var n2 = n*n powersOfFive += n2*n2*n } </code></pre> <p>Obviously <code>n2</code> is is a loop invariant so we could use <code>let</code> instead:</p> <pre><code>var powersOfFive = Int[]() for n in [1, 2, 3, 4, 5, 6] { let n2 = n*n powersOfFive += n2*n2*n } </code></pre> <p>But a truly functional programmer would avoid all the side-effects and mutations:</p> <pre><code>let powersOfFive = [1, 2, 3, 4, 5, 6].map( {(num: Int) -&gt; Int in let num2 = num*num return num2*num2*num}) </code></pre>
<h3><em>Let</em></h3> <hr> <p>Swift uses two basic techniques to store values for a programmer to access by using a name: <em>let</em> and <em>var</em>. Use <em>let</em> if you're never going to change the value associated with that name. Use <em>var</em> if you expect for that name to refer to a changing set of values.</p> <pre><code>let a = 5 // This is now a constant. "a" can never be changed. var b = 2 // This is now a variable. Change "b" when you like. </code></pre> <p>The value that a constant refers to can never be changed, however the thing that a constant refers to can change if it is an instance of a class.</p> <pre><code>let a = 5 let b = someClass() a = 6 // Nope. b = someOtherClass() // Nope. b.setCookies( newNumberOfCookies: 5 ) // Ok, sure. </code></pre> <h3><em>Let</em> and Collections</h3> <hr> <p>When you assign an array to a constant, elements can no longer be added or removed from that array. However, the value of any of that array's elements may still be changed.</p> <pre><code>let a = [1, 2, 3] a.append(4) // This is NOT OK. You may not add a new value. a[0] = 0 // This is OK. You can change an existing value. </code></pre> <p>A dictionary assigned to a constant can not be changed in any way.</p> <pre><code>let a = [1: "Awesome", 2: "Not Awesome"] a[3] = "Bogus" // This is NOT OK. You may not add new key:value pairs. a[1] = "Totally Awesome" // This is NOT OK. You may not change a value. </code></pre> <hr> <p>That is my understanding of this topic. Please correct me where needed. Excuse me if the question is already answered, I am doing this in part to help myself learn.</p>
<p>Swift properties:</p> <p><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html" rel="nofollow">Swift Properties official documentation</a></p> <blockquote> <p>In its simplest form, a stored property is a constant or variable that is stored as part of an instance of a particular class or structure. Stored properties can be either variable stored properties (introduced by the <code>var</code>keyword) or constant stored properties (introduced by the <code>let</code> keyword).</p> </blockquote> <p>Example: </p> <blockquote> <p>The example below defines a structure called FixedLengthRange, which describes a range of integers whose range length cannot be changed once it is created:</p> </blockquote> <pre><code>struct FixedLengthRange { var firstValue: Int let length: Int } </code></pre> <blockquote> <p>Instances of <code>FixedLengthRange</code> have a variable stored property called <code>firstValue</code> and a constant stored property called <code>length</code>. In the example above, <code>length</code> is initialized when the new range is created and <strong>cannot be changed thereafter, because it is a constant property</strong>.</p> </blockquote>