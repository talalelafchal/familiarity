iOS crash: MTLRenderPassDescriptor null after rotation
I'm writing a iOS app using Metal. At some point during the MTKViewDelegate draw, I create a render pass descriptor and render things on screen, let encoder = commandBuffer.makeRenderCommandEncoder(descriptor: renderPassDescriptor) encoder.setViewport(camera.viewport) encoder.setScissorRect(camera.scissorRect) At the beginning of my draw function, I have a semaphore, the same code found in the Metal game template found in Xcode, and then a check to verify that the view hasn't changed size. If it has, I recreate my buffers,  let w = _gBuffer?.width ?? 0 let h = _gBuffer?.height ?? 0 if let metalLayer = view.layer as? CAMetalLayer { let size = metalLayer.drawableSize if w != Int(size.width) || h != Int(size.height ){ _gBuffer = GBuffer(device: device, size: size) } } Everything works fine, and rotation was working fine on my iPhone6. However, when I tried on an iPad Pro, it always generate a SIGABRT when I try to rotate the device. The debugger tells me the encoder is null. I also get this exception in the console, MTLDebugRenderCommandEncoder.mm:2028: failed assertion `(rect.x(1024) + rect.width(1024))(2048) must be <= 1536' The exception must occur because I'm updating "camera" inside mtkView, func mtkView(_ view: MTKView, drawableSizeWillChange size: CGSize) { camera.setBounds(view.bounds) } When I run without the debugger attached, it doesn't crash. I guess mtkView is called asynchronously and I should do something to stop the rendering midway through when mtkView is called, but the mutex should be in the library, not in my code? Although both draw and mtkView are being called from the same thread (Thread 1 in the debugger)... If I step-debug putting breakpoints in draw and mtkView, it seems I manually sync'ing and it doesn't crash. I'm a bit lost... The full source code is here: https://github.com/endavid/VidEngine Any ideas?
The exception message was the hint. I got distracted by the encoder being null. I guess it becomes null once the exception is thrown, but the problem wasn't in the encoder. The code in camera.setBounds(view.bounds) wasn't updating the scissorRect... I have a CADisplayLink that updates the CPU objects at a different rate, and the scissorRect was being updated there when it detected a change. I've added a call to the full camera update inside mtkView() and the crash is gone now :)