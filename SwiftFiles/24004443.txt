Reason for assigning optional to new variable in conditional statement in Swift
<p>I'm going through the swift docs, and in the optional segment, it talks about using the question mark -- <code>?</code> -- to signify variables that might be nil. This can be used in an if statement to check for nil, but in the docs they assign the optional to a new variable in the conditional. Is there a reason for this?</p> <p>For Example, it is presented in <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/GuidedTour.html#//apple_ref/doc/uid/TP40014097-CH2-XID_1">the docs</a> similar to this:</p> <pre><code>// Declare an optional string (might be nil) var optionalString: String? = "Hello" // Assigns optionalString to new variable before checking if nil if let string = optionalString { println("\(optionalString) is not nil!") } else { println("\(optionalString) is nil") } </code></pre> <p>However, this runs just fine for me in tests:</p> <pre><code>var optionalString: String? = "Hello" // Assigns optionalString to new variable before checking if nil if optionalString { println("\(optionalString) is not nil!") } else { println("\(optionalString) is nil") } </code></pre> <h3> Question </h3> <p>Is there a reason to assign <code>optionalString</code> to a new variable <code>string</code> in the conditional statement?</p>
<p>I think the purpose of that assignment was to demonstrate the use of "let" within the if conditional clause. I don't see a meaningful difference between the provided code and your own.</p> <p>From: Apple Inc. “The Swift Programming Language.” iBooks. <a href="https://itun.es/il/jEUH0.l" rel="nofollow">https://itun.es/il/jEUH0.l</a></p> <blockquote> <p>“If the optional value is nil, the conditional is false and the code in braces is skipped. Otherwise, the optional value is unwrapped and assigned to the constant after let, which makes the unwrapped value available inside the block of code.”</p> </blockquote>
<p>Take a look at the section on <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html#//apple_ref/doc/uid/TP40014097-CH21-XID_312" rel="nofollow">Optional Chaining</a> in the docs. In the example you cite, there's not much difference. But in other cases, an <code>if-let</code> construction lets you get at an unwrapped value that comes from a series of optional references and method calls, without using implicit unwraps that can crash your app if you haven't considered all the possible bindings for a value in a chain.</p> <p>It's also useful if you want to avoid recomputing a value. You can use it in a lot of the same ways you'd use an assignment in a conditional in (Obj)C (remember <code>if (self = [super init])</code>).</p> <p>For example, if the optional being tested comes from a computed property:</p> <pre><code>var optionalName: String? { get { if checkTouchID() { return "John Appleseed" } else { return nil } } } var greeting = "Hello!" if optionalName != nil { greeting = "Hello, \(optionalName)" } </code></pre> <p>Paste that into a playground, along with a stub implementation of <code>checkTouchID()</code> that returns <code>true</code>, and you'll immediately see in the results area that the <code>optionalName</code> getter is executing twice. (This would be a problem in a more realistic scenario, because you probably don't want code like this to implicitly <code>checkTouchID()</code> or <code>downloadFromServer()</code> or <code>billApplePay()</code> twice.) If you use an <code>if-let</code> construction instead, you'll only execute the getter once.</p> <p>In a series of chained optionals (like <code>if let johnsStreet = john.residence?.address?.street</code> in the docs linked above), you don't want to rewrite the whole chain in the body of the <code>if</code> statement, much less recompute it.</p>