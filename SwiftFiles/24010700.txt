How do I do indexOfObject or a proper containsObject
<p>With an array: How do I do <code>indexOfObject</code> or a proper <code>containsObject</code>?</p> <p>I mean I know I could just bridge the Array to <code>NSArray</code> and do it there ^^<br/> But there must be a 'native' way of doing this</p> <p>P.S. for the <code>containsObject</code> I guess I could filter the array too but for <em>indexOf</em>?</p>
<p>You can't. That's why <code>NSArray</code> is still there. However, the Apple documentation reads as follows about <code>String</code> and <code>NSString</code>:</p> <blockquote> <p>Swift’s String type is bridged seamlessly to Foundation’s NSString class. If you are working with the Foundation framework in Cocoa or Cocoa Touch, the entire NSString API is available to call on any String value you create, in addition to the String features described in this chapter. You can also use a String value with any API that requires an NSString instance.</p> </blockquote> <p>Following that approach, the <code>NSArray</code> API <em>should</em> be available on <code>Array</code>, but it isn't because the native Swift <code>Array</code> is a primitive (most likely a struct or similar), so you have to <em>"convert"</em> it to an <code>NSArray</code>.</p>
<p>It appears that not all of the toll-free bridging from NS/CF space is in place. However, if you declare your array as an NSArray, it works fine:</p> <pre><code>let fruits: NSArray = [ "apple", "orange", "tomato (really?)" ] let index = fruits.indexOfObject("orange") println("Index of Orange: \(index)") </code></pre>
<p>As I was told, this isn't available yet / I have to bridge it to NSArray </p> <p>I don't like this and it feels dirty so I went and did this in an extension. that way it hides the usage of NSArray and allows apple to provide it later</p> <pre><code>import Foundation extension Array { func contains(object:AnyObject!) -&gt; Bool { if(self.isEmpty) { return false } let array: NSArray = self.bridgeToObjectiveC(); return array.containsObject(object) } func indexOf(object:AnyObject!) -&gt; Int? { var index = NSNotFound if(!self.isEmpty) { let array: NSArray = self.bridgeToObjectiveC(); index = array.indexOfObject(object) } if(index == NSNotFound) { return Optional.None; } return index } //#pragma mark KVC func getKeyPath(keyPath: String!) -&gt; AnyObject! { return self.bridgeToObjectiveC().valueForKeyPath(keyPath); } } </code></pre> <p><a href="https://gist.github.com/Daij-Djan/9d1c4b1233b4017f3b67" rel="nofollow">https://gist.github.com/Daij-Djan/9d1c4b1233b4017f3b67</a></p>
<p>Its actually able to be done in Swift. To get the index use <code>find(YourArray, ObjectToFind)</code></p>
<p>You can use the built-in <code>find</code>, and thus avoid bridging to Objective-C — but only if your element type is <a href="https://developer.apple.com/library/ios/documentation/General/Reference/SwiftStandardLibraryReference/Equatable.html">Equatable</a>. (If it isn't Equatable, you can make it so with a comparison function and an extension.)</p> <p>Example:</p> <pre><code>func == (lhs:Piece,rhs:Piece) -&gt; Bool { return lhs.val == rhs.val } class Piece:Equatable,Printable { var val : Int var description : String { return String(val) } init (_ v:Int) { val = v } } </code></pre> <p>Now you can call <code>find(arr,p)</code> where <code>arr</code> is an <code>Array&lt;Piece&gt;</code> and <code>p</code> is a <code>Piece</code>.</p> <p>Once you have this, you can develop utilities based on it. For example, here's a global function to remove an object from an array without bridging to Objective-C:</p> <pre><code>func removeObject&lt;T:Equatable&gt;(inout arr:Array&lt;T&gt;, object:T) -&gt; T? { if let found = find(arr,object) { return arr.removeAtIndex(found) } return nil } </code></pre> <p>And test it like this:</p> <pre><code>var arr = [Piece(1), Piece(2), Piece(3)] removeObject(&amp;arr,Piece(2)) println(arr) </code></pre> <hr> <p>You can do this for NSObject subclasses too. Example:</p> <pre><code>func == (v1:UIView, v2:UIView) -&gt; Bool { return v1.isEqual(v2) } extension UIView : Equatable {} </code></pre> <p>Now you can call <code>find</code> on an Array of UIView. It's sort of a pain in the butt, though, having to do this for every single class where you want to be able to use <code>find</code> on an Array of that class. I have filed an enhancement request with Apple requesting that all NSObject subclasses be considered Equatable and that <code>==</code> should fall back on <code>isEqual:</code> <em>automatically</em>.</p> <p><strong>EDIT</strong> Starting in Seed 3, this <em>is</em> automatic for UIView and other NSObject classes. So <code>find</code> now just works for them.</p> <p><strong>EDIT 2</strong> Starting in Swift 2.0, <code>indexOf</code> will exist as a method:</p> <pre><code>let s = ["Manny", "Moe", "Jack"] let ix = s.indexOf("Moe") // 1 </code></pre> <p>Alternatively, it takes a function that returns Bool:</p> <pre><code>let ix2 = s.indexOf {$0.hasPrefix("J")} // 2 </code></pre> <p>Again, this works only on collections of Equatable, since obviously you cannot locate a needle in a haystack unless you have a way of identifying a needle when you come to it.</p> <p><strong>EDIT 3</strong> Swift 2.0 also introduces protocol extensions. This means I can rewrite my global function <code>removeObject</code> as a method!</p> <p>For example:</p> <pre><code>extension RangeReplaceableCollectionType where Generator.Element : Equatable { mutating func removeObject(object:Self.Generator.Element) { if let found = self.indexOf(object) { self.removeAtIndex(found) } } } </code></pre> <p>Since Array adopts RangeReplaceableCollectionType, now I can write code like this:</p> <pre><code>var arr = [Piece(1), Piece(2), Piece(3)] arr.removeObject(Piece(2)) </code></pre> <p>Oh, happy day!</p>
<p>Apple provide an example of exactly this in the <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-XID_275" rel="nofollow">The Swift Programming Language</a> book. Specifically, see the section on Type Constraints in Action (<em>p621 in the iBook</em>).</p> <pre><code>func findIndex&lt;T: Equatable&gt;(array: [T], valueToFind: T) -&gt; Int? { for (index, value) in enumerate(array) { if value == valueToFind { return index } } return nil } </code></pre> <p>Everything depends upon your type implementing <a href="https://developer.apple.com/library/ios/documentation/General/Reference/SwiftStandardLibraryReference/Equatable.html" rel="nofollow">Equatable</a>.</p> <p>The Swift Programming Language covers that and explains how to implement that protocol:</p> <blockquote> <p>“The Swift standard library defines a protocol called Equatable, which requires any conforming type to implement the equal to operator (==) and the not equal to operator (!=) to compare any two values of that type. ”</p> </blockquote> <p><a href="http://nshipster.com" rel="nofollow">NSHipster</a> has a couple of relevant posts on this subject:</p> <p><a href="http://nshipster.com/swift-default-protocol-implementations/" rel="nofollow">Swift Default Protocol Implementations</a> <a href="http://nshipster.com/swift-comparison-protocols/" rel="nofollow">Swift Comparison Protocols</a></p> <p>I also found this answer very useful in implementing Equatable:</p> <p><a href="http://stackoverflow.com/questions/24334684/how-do-i-implement-swifts-comparable-protocol">How do I implement Swift&#39;s Comparable protocol?</a></p> <p>Alhough it mentions Comparable, Equatable is a subset and the explanation is good.</p> <p>Excerpts above from: Apple Inc. “The Swift Programming Language.” iBooks. <a href="https://itun.es/gb/jEUH0.l" rel="nofollow">https://itun.es/gb/jEUH0.l</a></p>
<p>If your array elements are objects and you want to find an identical object in that array, you can use this function:</p> <pre><code>func findObject&lt;C: CollectionType where C.Generator.Element: AnyObject&gt;(domain: C, value: C.Generator.Element) -&gt; Int? { for (index, element) in enumerate(domain) { if element === value { return index } } return nil } </code></pre>
<p>One other option is to use filter:</p> <pre><code>haystack.filter({$0 == needle}).count &gt; 0 </code></pre> <p>This checks to see if array haystack contains object needle.</p>