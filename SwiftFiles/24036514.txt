Correct way to find max in an Array in Swift
<p>I've so far got a simple (but potentially expensive) way:</p> <pre><code>var myMax = sort(myArray,&gt;)[0] </code></pre> <p>And how I was taught to do it at school:</p> <pre><code>var myMax = 0 for i in 0..myArray.count { if (myArray[i] &gt; myMax){myMax = myArray[i]} } </code></pre> <p>Is there a better way to get the maximum value from an integer Array in Swift? Ideally something that's one line such as Ruby's <code>.max</code></p>
<p>The other answers are all correct, but don't forget you could also use collection operators, as follows:</p> <pre><code>var list = [1, 2, 3, 4] var max: Int = (list as AnyObject).valueForKeyPath("@max.self") as Int </code></pre> <p>you can also find the average in the same way:</p> <pre><code>var avg: Double = (list as AnyObject).valueForKeyPath("@avg.self") as Double </code></pre> <p>This syntax might be less clear than some of the other solutions, but it's interesting to see that <code>-valueForKeyPath:</code> can still be used :)</p>
<p><strong>Update:</strong> <a href="http://stackoverflow.com/a/24161004/390581">This</a> should probably be the accepted answer since <code>maxElement</code> appeared in Swift.</p> <hr> <p>Use the almighty <code>reduce</code>:</p> <pre><code>let nums = [1, 6, 3, 9, 4, 6]; let numMax = nums.reduce(Int.min, { max($0, $1) }) </code></pre> <p>Similarly:</p> <pre><code>let numMin = nums.reduce(Int.max, { min($0, $1) }) </code></pre> <p><code>reduce</code> takes a first value that is the initial value for an internal accumulator variable, then applies the passed function (here, it's anonymous) to the accumulator and each element of the array successively, and stores the new value in the accumulator. The last accumulator value is then returned.</p>
<pre><code>var numbers = [1, 2, 7, 5]; var val = sort(numbers){$0 &gt; $1}[0]; </code></pre>
<p>Given:</p> <pre><code>let numbers = [1, 6, 3, 9, 4, 6] </code></pre> <p>Swift 3:</p> <pre><code>numbers.min() numbers.max() </code></pre> <p>Swift 2:</p> <pre><code>numbers.minElement() numbers.maxElement() </code></pre>
<p>With Swift 1.2 (and maybe earlier) you now need to use: </p> <pre><code>let nums = [1, 6, 3, 9, 4, 6]; let numMax = nums.reduce(Int.min, combine: { max($0, $1) }) </code></pre> <p>For working with Double values I used something like this:</p> <pre><code>let nums = [1.3, 6.2, 3.6, 9.7, 4.9, 6.3]; let numMax = nums.reduce(-Double.infinity, combine: { max($0, $1) }) </code></pre>
<p>You can also sort your array and then use <code>array.first</code> or <code>array.last</code></p>
<p>In Swift 2.0, the <code>minElement</code> and <code>maxElement</code> become methods of <code>SequenceType</code> protocol, you should call them like:</p> <pre><code>let a = [1, 2, 3] print(a.maxElement()) //3 print(a.minElement()) //1 </code></pre> <p>Using <code>maxElement</code> as a function like <strong><code>maxElement(a)</code></strong> is <strong>unavailable</strong> now.</p> <p>The syntax of Swift is in flux, so I can just confirm this in <strong>Xcode version7 beta6</strong>.</p> <p>It may be modified in the future, so I suggest that you'd better check the doc before you use these methods.</p>
<p>With Swift 2, <code>Array</code>, like other <code>SequenceType</code> Protocol conforming objects (<code>Dictionary</code>, <code>Set</code>, etc), has two methods called <code>maxElement()</code> and <code>maxElement(_:)</code> that return the maximum element in the sequence or <code>nil</code> if the sequence is empty.</p> <hr> <h2><code>maxElement()</code></h2> <p>If the element type inside your sequence conforms to <code>Comparable</code> protocol (may it be <code>String</code>, <code>Float</code>, <code>Character</code> or one of your custom class or struct), you will be able to use <code>maxElement()</code> that has the following <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Reference/Swift_SequenceType_Protocol/index.html#//apple_ref/swift/intfm/SequenceType/s:FeRq_Ss12SequenceTypeqqq_S_9GeneratorSs13GeneratorType7ElementSs10Comparable_SsS_10maxElementuRq_S_qqq_S_9GeneratorS0_7ElementS1__Fq_FT_GSqqqq_S_9GeneratorS0_7Element_">declaration</a>:</p> <pre><code>func maxElement() -&gt; Self.Generator.Element? </code></pre> <p>Usage #1:</p> <pre><code>let intMax = [12, 15, 6].maxElement() let stringMax = ["bike", "boat", "car"].maxElement() print(intMax) // prints Optional(15) print(stringMax) // prints Optional("car") (alphabetical order) </code></pre> <p>Usage #2:</p> <pre><code>class Route: Comparable, CustomStringConvertible { let distance: Int var description: String { return "Route with distance: \(distance)" } init(distance: Int) { self.distance = distance } } func ==(lhs: Route, rhs: Route) -&gt; Bool { return lhs.distance == rhs.distance } func &lt;(lhs: Route, rhs: Route) -&gt; Bool { return lhs.distance &lt; rhs.distance } let routes = [ Route(distance: 20), Route(distance: 30), Route(distance: 10) ] let maxRoute = routes.maxElement() print(maxRoute) // prints Optional(Route with distance: 30) </code></pre> <hr> <h2><code>maxElement(_:)</code></h2> <p>If the element type inside your sequence DOES NOT conform to <code>Comparable</code> protocol, you will have to use <code>maxElement(_:)</code> that has the following <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Reference/Swift_SequenceType_Protocol/index.html#//apple_ref/swift/intfm/SequenceType/s:FeRq_Ss12SequenceType_SsS_10maxElementuRq_S__Fq_FzFzTqqq_S_9GeneratorSs13GeneratorType7Elementqqq_S_9GeneratorS0_7Element_SbGSqqqq_S_9GeneratorS0_7Element_">declaration</a>:</p> <pre><code>func maxElement(@noescape _ isOrderedBefore: (Self.Generator.Element, Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; Self.Generator.Element? </code></pre> <p>Usage #1:</p> <pre><code>let dictionary = ["Boat" : 15, "Car" : 20, "Bike" : 40] let keyMaxElement = dictionary.maxElement({ (a, b) -&gt; Bool in return a.0 &lt; b.0 }) let valueMaxElement = dictionary.maxElement({ (a, b) -&gt; Bool in return a.1 &lt; b.1 }) print(keyMaxElement) // prints Optional(("Car", 20)) print(valueMaxElement) // prints Optional(("Bike", 40)) </code></pre> <p>Usage #2:</p> <pre><code>class Route: CustomStringConvertible { let distance: Int var description: String { return "Route with distance: \(distance)" } init(distance: Int) { self.distance = distance } } let routes = [ Route(distance: 20), Route(distance: 30), Route(distance: 10) ] let maxRoute = routes.maxElement ({ (a, b) -&gt; Bool in return a.distance &lt; b.distance }) print(maxRoute) // prints Optional(Route with distance: 30) </code></pre>
<p>You can use with <code>reduce</code>:</p> <pre><code>let randomNumbers = [4, 7, 1, 9, 6, 5, 6, 9] let maxNumber = randomNumbers.reduce(randomNumbers[0]) { $0 &gt; $1 ? $0 : $1 } //result is 9 </code></pre>