Why do curried functions require external parameter names?
<p>Given this simple currying function:</p> <pre><code>func foo(x:Int)(y:Int)-&gt;String{ return "\(x) with \(y)" } </code></pre> <p>I'd expect to be able to do something like this:</p> <pre><code>let bar = foo(1) bar(2) //&lt;- error: Missing argument label 'y:' in call </code></pre> <p>If I label the call to <code>bar</code> (as in <code>bar(y:2)</code>) everything works fine. But I don't understand why the parameter name is necessary. Is there any way to avoid it?</p> <p>The obvious thing:</p> <p><code>func foo(x:Int)(_ y:Int)-&gt;String ...</code></p> <p>does not seem to work.</p>
<p>I am not sure I fully understand your currying. Here is my take on it. I have a function foo as follows:</p> <pre><code>func foo(x:Int, y:Int) -&gt; String{ return "\(x) with \(y)" } let bar = foo(1, 2) // gives "1 with 2" </code></pre> <p>I wish to curry this function to 'fix' the value for <code>x</code>, so do so as follows:</p> <pre><code>func fooCurry(x:Int) -&gt; (Int -&gt; String) { func curry(y:Int) -&gt; String { return foo(x, y) } return curry } </code></pre> <p>The above returns a new function which can be used as follows:</p> <pre><code>let curriedFoo = fooCurry(1) let barWithCurry = curriedFoo(2) // gives "1 with 2" </code></pre> <p>The function returned by <code>fooCurry</code> has the signature <code>(Int -&gt; String)</code>, which means that the parameter does not have an external name.</p>
<p>I believe it is a compiler bug, your example should work as described in The Swift Programming Language book where they mention declaring curried functions:</p> <pre><code>func addTwoNumbers(a: Int)(b: Int) -&gt; Int { return a + b } addTwoNumbers(4)(5) // Returns 9 </code></pre> <p><a href="https://bugreport.apple.com" rel="nofollow">https://bugreport.apple.com</a></p> <p>good find!</p>
<p>It's a bug, you should file a radar at <a href="http://bugreport.apple.com">bugreport.apple.com</a></p> <p>As a confirmation, if you place an underscore, like this</p> <pre><code>func foo(x: Int)(_ y: Int) -&gt; String </code></pre> <p>you get a warning</p> <blockquote> <p>Extraneous '_' in parameter: 'y' has no keyword argument name</p> </blockquote> <p>So it explicitly says that <code>y</code> has no external name, but it still requires one when called, which is clearly against the language specification.</p>
<p>Not the best syntax, but if you want to get around it for now, you can use the following for basic curried functions:</p> <pre><code>func foo(x:Int) -&gt; Int -&gt; String { return { return "\(x) with \($0)" } } </code></pre> <p>Then you can just do:</p> <pre><code>let bar = foo(1) bar(2) //-&gt; 1 with 2 </code></pre> <p>Now obviously the problem with this becomes obvious when you want to write a curried function for piping four <code>Int</code>s for example:</p> <pre><code>func makerAdders(a:Int)(b:Int)(c:Int)(d:Int) {...} </code></pre> <p>becomes like this:</p> <pre><code>func add(a:Int) -&gt; Int -&gt; Int -&gt; Int -&gt; Int { return { b in return { c in return { d in return a + b + c + d } } } } </code></pre> <p>The inner closures make it a bit better than using inner functions, but again it defeats the purpose of the nice <code>func add(a:Int)(b:Int)(c:Int)(d:Int) {return a+b+c+d}</code> syntax.</p>
<p>Definitely a bug in the compiler as far as I can tell. Until it's fixed you can get a properly curried version of any function using these functions (note that I've included cases for two and three arguments, extend at your leisure:</p> <pre><code>func curry&lt;A,B,C&gt;(f: (A, B) -&gt; C) -&gt; A -&gt; B -&gt; C { return { a in { b in return f(a,b) } } } func curry&lt;A,B,C,D&gt;(f: (A, B, C) -&gt; D) -&gt; A -&gt; B -&gt; C -&gt; D { return { a in { b in { c in return f(a,b,c) } } } } </code></pre> <p>Just use:</p> <pre><code>curry(addTwoNumbers)(1)(2) </code></pre>