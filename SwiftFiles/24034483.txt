What is an &quot;unwrapped value&quot; in Swift?
<p>I'm learning Swift for iOS 8 / OSX 10.10 by following <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/GuidedTour.html#//apple_ref/doc/uid/TP40014097-CH2" rel="nofollow noreferrer">this tutorial</a>, and the term "<strong>unwrapped value</strong>" is used several times, as in this paragraph (under <em>Objects and Class</em>):</p> <blockquote> <p>When working with optional values, you can write ? before operations like methods, properties, and subscripting. If the value before the ? is nil, everything after the ? is ignored and the value of the whole expression is nil. Otherwise, <strong>the optional value is unwrapped</strong>, and everything after the ? acts on the <strong>unwrapped value</strong>. In both cases, the value of the whole expression is an optional value.</p> </blockquote> <pre><code>let optionalSquare: Square? = Square(sideLength: 2.5, name: "optional square") let sideLength = optionalSquare?.sideLength </code></pre> <p>I don't get it, and searched on the web without luck.</p> <p>What does this means?</p> <hr> <h2>Edit</h2> <p>From Cezary's answer, there's a slight difference between the output of the original code and the final solution (tested on playground) :</p> <h3>Original code</h3> <p><img src="https://i.stack.imgur.com/Ns3my.png" alt="Original code"></p> <h3>Cezary's solution</h3> <p><img src="https://i.stack.imgur.com/RsvFp.png" alt="Cezary&#39;s solution"></p> <p>The superclass' properties are shown in the output in the second case, while there's an empty object in the first case.</p> <p>Isn't the result supposed to be identical in both case?</p> <p><strong>Related Q&amp;A : <a href="http://stackoverflow.com/a/24026093/1437016">What is an optional value in Swift?</a></strong></p>
<p>First, you have to understand what an Optional type is. An optional type basically means that the variable <em>can be</em> <code>nil</code>.</p> <p>Example:</p> <pre><code>var canBeNil : Int? = 4 canBeNil = nil </code></pre> <p>The question mark indicates the fact that <code>canBeNil</code> can be <code>nil</code>.</p> <p>This would not work:</p> <pre><code>var cantBeNil : Int = 4 cantBeNil = nil // can't do this </code></pre> <p>To get the value from your variable if it is optional, you have to <strong><em>unwrap it</em></strong>. This just means putting an exclamation point at the end.</p> <pre><code>var canBeNil : Int? = 4 println(canBeNil!) </code></pre> <p>Your code should look like this:</p> <pre><code>let optionalSquare: Square? = Square(sideLength: 2.5, name: "optional square") let sideLength = optionalSquare!.sideLength </code></pre> <p>A sidenote:</p> <p>You can also declare optionals to automatically unwrap by using an exclamation mark instead of a question mark. </p> <p>Example:</p> <pre><code>var canBeNil : Int! = 4 print(canBeNil) // no unwrapping needed </code></pre> <p>So an alternative way to fix your code is:</p> <pre><code>let optionalSquare: Square! = Square(sideLength: 2.5, name: "optional square") let sideLength = optionalSquare.sideLength </code></pre> <h2>EDIT:</h2> <p>The difference that you're seeing is exactly the symptom of the fact that the optional value is <strong>wrapped</strong>. There is another layer on top of it. The <strong>unwrapped</strong> version just shows the straight object because it is, well, unwrapped.</p> <p>A quick playground comparison:</p> <p><img src="https://i.stack.imgur.com/ClB78.png" alt="playground"></p> <p>In the first and second cases, the object is not being automatically unwrapped, so you see two "layers" (<code>{{...}}</code>), whereas in the third case, you see only one layer (<code>{...}</code>) because the object is being automatically unwrapped.</p> <p>The difference between the first case and the second two cases is that the second two cases will give you a runtime error if <code>optionalSquare</code> is set to <code>nil</code>. Using the syntax in the first case, you can do something like this:</p> <pre><code>if let sideLength = optionalSquare?.sideLength { println("sideLength is not nil") } else { println("sidelength is nil") } </code></pre>
<p>The existing correct answer is great, but I found that for me to understand this fully, I needed a good analogy, since this is a very abstract and weird concept.</p> <p>So, let me help those fellow "right-brained" (visual thinking) developers out by giving a different perspective in addition to the correct answer. Here is a good analogy that helped me a lot.</p> <p><strong>Birthday Present Wrapping Analogy</strong></p> <p>Think of optionals as being like birthday presents that come in stiff, hard, colored wrapping. </p> <p>You don't know if there's anything inside the wrapping until you unwrap the present â€” maybe there is nothing at all inside! If there is something inside, it could be yet another present, which is also wrapped, and which also <em>might contain nothing</em>. You might even unwrap 100 nested presents to finally discover there was <em>nothing but wrapping</em>. </p> <p>If the value of the optional is not <code>nil</code>, now you have revealed a box containing <em>something</em>. But, especially if the value is not explicitly typed and is a variable and not a predefined constant, then you may still need to <em>open the box</em> before you can know anything specific about what's in the box, like <em>what type</em> it is, or what the actual <em>value</em> is. </p> <p><strong><em>What's In The Box?!</em> Analogy</strong></p> <p>Even after you unwrap the variable, you are still like Brad Pitt in the <a href="https://m.youtube.com/watch?v=1giVzxyoclE">last scene in SE7EN</a> (<em>warning</em>: spoilers and very R-rated foul language and violence), because even after you have unwrapped the present, you are in the following situation: <strong>you now have <code>nil</code>, or a box containing <em>something</em> (but you don't know what).</strong> </p> <p>You might know the type of the <em>something</em>. For example, if you declared the variable as being type, <code>[Int:Any?]</code>, then you'd know you had a (potentially empty) Dictionary with integer subscripts that yield wrapped contents of any old type.</p> <p>That is why dealing with collection types (Dictionaries and Arrays) in Swift can get kind of hairy.</p> <p>Case in point: </p> <pre><code>typealias presentType = [Int:Any?] func wrap(i:Int, gift:Any?) -&gt; presentType? { if(i != 0) { let box : presentType = [i:wrap(i-1,gift:gift)] return box } else { let box = [i:gift] return box } } func getGift() -&gt; String? { return "foobar" } let f00 = wrap(10,gift:getGift()) //Now we have to unwrap f00, unwrap its entry, then force cast it into the type we hope it is, and then repeat this in nested fashion until we get to the final value. var b4r = (((((((((((f00![10]! as! [Int:Any?])[9]! as! [Int:Any?])[8]! as! [Int:Any?])[7]! as! [Int:Any?])[6]! as! [Int:Any?])[5]! as! [Int:Any?])[4]! as! [Int:Any?])[3]! as! [Int:Any?])[2]! as! [Int:Any?])[1]! as! [Int:Any?])[0]) //Now we have to DOUBLE UNWRAP the final value (because, remember, getGift returns an optional) AND force cast it to the type we hope it is let asdf : String = b4r!! as! String print(asdf) </code></pre>