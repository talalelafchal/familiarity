NSNotificationCenter addObserver in Swift
<p>How do you add an observer in Swift to the default notification center? I'm trying to port this line of code that sends a notification when the battery level changes.</p> <pre><code>[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(batteryLevelChanged:) name:UIDeviceBatteryLevelDidChangeNotification object:nil]; </code></pre>
<p>It's the same as the Objective-C API, but uses Swift's syntax.</p> <pre><code>NSNotificationCenter.defaultCenter().addObserver( self, selector: #selector(batteryLevelChanged), name: UIDeviceBatteryLevelDidChangeNotification, object: nil) </code></pre> <p>If your observer does not inherit from an Objective-C object, you must prefix your method with <code>@objc</code> in order to use it as a selector.</p> <pre><code>@objc func batteryLevelChanged(notification: NSNotification){ //do stuff } </code></pre> <p>See <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSNotificationCenter_Class/">NSNotificationCenter Class Reference</a>, <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-XID_36">Interacting with Objective-C APIs</a></p>
<h1>Swift 3.0 &amp; Xcode 8.0+:</h1> <p><strong>Send(Post) Notification:</strong></p> <pre><code>NotificationCenter.default.post(name: Notification.Name("NotificationIdentifier"), object: nil) </code></pre> <p><strong>Receive(Get) Notification</strong></p> <pre><code>NotificationCenter.default.addObserver(self, selector: #selector(YourClassName.methodOfReceivedNotification(notification:)), name: Notification.Name("NotificationIdentifier"), object: nil) </code></pre> <p><strong>Method handler for received Notification</strong></p> <pre><code>func methodOfReceivedNotification(notification: Notification){ //Take Action on Notification } </code></pre> <h1>Swift 2.3 &amp; Xcode 7:</h1> <p><strong>Send(Post) Notification</strong></p> <pre><code> NSNotificationCenter.defaultCenter().postNotificationName("NotificationIdentifier", object: nil) </code></pre> <p><strong>Receive(Get) Notification</strong></p> <pre><code> NSNotificationCenter.defaultCenter().addObserver(self, selector: #selector(YourClassName.methodOfReceivedNotification(_:)), name:"NotificationIdentifier", object: nil) </code></pre> <p><strong>Method handler for received Notification</strong></p> <pre><code>func methodOfReceivedNotification(notification: NSNotification){ //Take Action on Notification } </code></pre> <hr> <hr> <p><strong><em>For historic Xcode versions...</em></strong></p> <hr> <hr> <p><strong>Send(Post) Notification</strong></p> <pre><code>NSNotificationCenter.defaultCenter().postNotificationName("NotificationIdentifier", object: nil) </code></pre> <p><strong>Receive(Get) Notification</strong></p> <pre><code>NSNotificationCenter.defaultCenter().addObserver(self, selector: "methodOfReceivedNotification:", name:"NotificationIdentifier", object: nil) </code></pre> <p><strong>Remove Notification</strong></p> <pre><code>NSNotificationCenter.defaultCenter().removeObserver(self, name: "NotificationIdentifier", object: nil) NSNotificationCenter.defaultCenter().removeObserver(self) // Remove from all notifications being observed </code></pre> <p><strong>Method handler for received Notification</strong></p> <pre><code>func methodOfReceivedNotification(notification: NSNotification){ //Take Action on Notification } </code></pre> <p><strong>Annotate either the class or the target method with @objc</strong></p> <pre><code>@objc private func methodOfReceivedNotification(notification: NSNotification){ //Take Action on Notification } //Or dynamic private func methodOfReceivedNotification(notification: NSNotification){ //Take Action on Notification } </code></pre>
<p>I'm able to do one of the following to successfully use a selector - <strong>without</strong> annotating anything with @objc:</p> <pre><code>NSNotificationCenter.defaultCenter().addObserver(self, selector:"batteryLevelChanged:" as Selector, name:"UIDeviceBatteryLevelDidChangeNotification", object:nil) </code></pre> <p>OR</p> <pre><code>let notificationSelector: Selector = "batteryLevelChanged:" NSNotificationCenter.defaultCenter().addObserver(self, selector: notificationSelector, name:"UIDeviceBatteryLevelDidChangeNotification", object:nil) </code></pre> <p>My xcrun version shows Swift 1.2, and this works on Xcode 6.4 and Xcode 7 beta 2 (which I thought would be using Swift 2.0):</p> <pre><code>$xcrun swift --version Apple Swift version 1.2 (swiftlang-602.0.53.1 clang-602.0.53) </code></pre>
<p>A nice way of doing this is to use the <a href="https://developer.apple.com/reference/foundation/notificationcenter/1411723-addobserver" rel="nofollow"><code>addObserver(forName:object:queue:using:)</code></a> method rather than the <a href="https://developer.apple.com/reference/foundation/notificationcenter/1415360-addobserver" rel="nofollow"><code>addObserver(_:selector:name:object:)</code></a> method that is often used from Objective-C code. The advantage of the first variant is that you don't have to use the <code>@objc</code> attribute on your method:</p> <pre><code> func batteryLevelChanged(notification: Notification) { // do something useful with this information } let observer = NotificationCenter.default.addObserver( forName: NSNotification.Name.UIDeviceBatteryLevelDidChange, object: nil, queue: nil, using: batteryLevelChanged) </code></pre> <p>and you can even just use a closure instead of a method if you want:</p> <pre><code> let observer = NotificationCenter.default.addObserver( forName: NSNotification.Name.UIDeviceBatteryLevelDidChange, object: nil, queue: nil) { _ in print("") } </code></pre> <p>You can use the returned value to stop listening for the notification later:</p> <pre><code> NotificationCenter.default.removeObserver(observer) </code></pre> <p>There used to be another advantage in using this method, which was that it doesn't require you to use selector strings which couldn't be statically checked by the compiler and so were fragile to breaking if the method is renamed, but Swift 2.2 and later include <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0022-objc-selectors.md" rel="nofollow"><code>#selector</code> expressions</a> that fix that problem.</p>
<p>In swift 2.2 - XCode 7.3, we use <code>#selector</code> for <code>NSNotificationCenter</code></p> <pre><code> NSNotificationCenter.defaultCenter().addObserver(self, selector: #selector(rotate), name: UIDeviceOrientationDidChangeNotification, object: nil) </code></pre>
<h1>Swift 3.0 in Xcode 8</h1> <p>Swift 3.0 has replaced many "stringly-typed" APIs with <code>struct</code> "wrapper types", as is the case with NotificationCenter. Notifications are now identified by a <code>struct Notfication.Name</code> rather than by <code>String</code>. See the <a href="https://swift.org/migration-guide/#sdk-1">Migrating to Swift 3 guide</a>.</p> <p><strong>Previous</strong> usage:</p> <pre><code>// Define identifier let notificationIdentifier: String = "NotificationIdentifier" // Register to receive notification NSNotificationCenter.defaultCenter().addObserver(self, selector: #selector(YourClassName.methodOfReceivedNotification(_:)), name: notificationIdentifier, object: nil) // Post a notification NSNotificationCenter.defaultCenter().postNotificationName(notificationIdentifier, object: nil) </code></pre> <p>New Swift 3.0 usage:</p> <pre><code>// Define identifier let notificationName = Notification.Name("NotificationIdentifier") // Register to receive notification NotificationCenter.default.addObserver(self, selector: #selector(YourClassName.methodOfReceivedNotification), name: notificationName, object: nil) // Post notification NotificationCenter.default.post(name: notificationName, object: nil) </code></pre> <p>All of the system notification types are now defined as static constants on <code>Notification.Name</code>; i.e. <code>.UIDeviceBatteryLevelDidChange</code>, <code>.UIApplicationDidFinishLaunching</code>, <code>.UITextFieldTextDidChange</code>, etc.</p> <p>You can extend <code>Notification.Name</code> with your own custom notifications in order to stay consistent with the system notifications:</p> <pre><code>// Definition: extension Notification.Name { static let yourCustomNotificationName = Notification.Name("yourCustomNotificationName") } // Usage: NotificationCenter.default.post(name: .yourCustomNotificationName, object: nil) </code></pre>