what are the benefit of using implicitly defined type for constants in swift programming language?
<p>In swift Programming language constants can expressed with let keyword like this</p> <pre><code>let MyConstant = 100 </code></pre> <p>and implicitly defined with type name like below</p> <pre><code>let MyConstant: Int = 100 </code></pre> <p>what are the benefit of using second method?</p>
<p>The compiler infers the type to save you - the developer - time. Why specify it when it's obvious from the value? Assuming it <em>is obvious</em>. I'll come to that shortly.</p> <p>So if you can if you want to, what's the point? (<em>no pun intended</em>)</p> <p>Perhaps for clarity; you wish to make it absolutely clear that the type of the variable is to be <code>Int</code>. The other purpose is that - in some cases, e.g. floating point types - the compiler's inferred default may not be what you desired. For example:</p> <pre><code>let MyConstant = 100.0 </code></pre> <p>Double or Float? It assumes Double. If you want Float, you must be explicit:</p> <pre><code>let MyConstant: Float = 100.0 </code></pre> <p>See <a href="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Types.html#//apple_ref/doc/uid/TP40014097-CH31-XID_988" rel="nofollow">The Swift Programming Language: Types</a>:</p> <blockquote> <p>In Swift, type information can also flow in the opposite directionâ€”from the root down to the leaves. In the following example, for instance, the explicit type annotation (: Float) on the constant eFloat causes the numeric literal 2.71828 to have type Float instead of type Double.</p> </blockquote> <pre><code> let e = 2.71828 // The type of e is inferred to be Double. let eFloat: Float = 2.71828 // The type of eFloat is Float. </code></pre> <blockquote> <p>Type inference in Swift operates at the level of a single expression or statement. This means that all of the information needed to infer an omitted type or part of a type in an expression must be accessible from type-checking the expression or one of its subexpressions.</p> </blockquote>