appearanceWhenContainedIn in Swift
<p>I'm trying to convert my app to the Swift language.</p> <p>I have this line of code:</p> <pre><code>[[UIBarButtonItem appearanceWhenContainedIn:[UINavigationBar class], nil] setTitleTextAttributes:textDictionary forState:UIControlStateNormal]; </code></pre> <p>How to convert it to Swift?</p> <p>In <a href="https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIAppearance_Protocol/index.html#//apple_ref/occ/intfcm/UIAppearance">Apple's docs</a>, there is no such method.</p>
<p>You should be able to just translate the <code>Objective-C</code> syntax into <code>Swift</code> syntax.</p> <p>In swift the methods should be declared like this:</p> <pre><code>func appearanceWhenContainedIn(containerClass : &lt;UIAppearanceContainer&gt;) func setTitleTextAttributes(_ attributes: NSDictionary!, forState state: UIControlState) </code></pre> <p>So you can try this:</p> <pre><code>UIBarButtonItem.appearanceWhenContainedIn(UINavigationBar).setTitleTextAttributes(textDictionary, forState: UIControlStateNormal) </code></pre> <p>I still have to figure out if this is the clean way to call a class method in <code>Swift</code> though.</p> <p>Hope this helps,</p>
<p>You can use this:</p> <pre><code>UIBarButtonItem.appearance().setTitleTextAttributes(textDictionary, forState: UIControlState.Normal) </code></pre> <p>Edit: appearanceWhenContainedIn was removed in Swift. This answer was for the Beta 5 to change the appearance of the text of all bar buttons.</p>
<p>It seems Swift (at least as of Beta5) isn't able to support it for reasons unknown to me. Perhaps the language feature required is still in progress, as I can only assume they left it out of the interface for a good reason. Like you said, according to the docs it's still available in ObjC. Really disappointing.</p>
<p>Here's an ugly workaround solution I used....</p> <p>Just make an Objective-C Cocoa Touch Class (UIViewController), named whatever you want.</p> <p>I named mine <code>WorkaroundViewController</code>...</p> <p>Now in (<code>WorkaroundViewController.m</code>):</p> <pre><code>-(id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil </code></pre> <p>Run the Objective-C appearance code for <code>.appearanceWhenContainedIn()</code> (here's my example):</p> <pre><code>[[UITextField appearanceWhenContainedIn:[UISearchBar class], nil] setDefaultTextAttributes:@{NSFontAttributeName: [UIFont fontWithName:@"Avenir-Light" size:16.0f]}]; </code></pre> <p>Then <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html" rel="nofollow">create a bridging header</a> for your Swift project and then initialize your Objective-C ViewController in your Swift code, like this (again, just my example):</p> <pre><code>var work : WorkaroundViewController = WorkaroundViewController() </code></pre> <p>Then you're done! Let me know if it works for you... Like I said, it's ugly, but works!</p>
<p>Here's a less ugly, but still ugly, workaround inspired by @tdun.</p> <ol> <li>Create a class to hold your Objective-C appearance. For the purposes of this example, let's call it <code>AppearanceBridger</code>.</li> <li>Add this class to your bridging header. If you don't have a bridging header, <a href="https://developer.apple.com/LIBRARY/PRERELEASE/IOS/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_78">create one</a>. </li> <li>Create a class method in <code>AppearanceBridger</code> named <code>+(void)setAppearance</code> and put the Objective-C appearance code in this method. For example:</li> </ol> <p><pre><code> + (void)setAppearance { [[UIView appearanceWhenContainedIn:[UITableViewHeaderFooterView class], nil] setBackgroundColor:[UIColor whiteColor]]; } </pre></code></p> <ol start="4"> <li>In your Swift code where you set the appearance, call <code>AppearanceBridger.setAppearance()</code> and you should be good to go!</li> </ol> <p>Hope this works well for people who see it.</p>
<h2>Update for iOS 9:</h2> <p>If you're targeting iOS 9+ (as of Xcode 7 b1), there is a new method in the <code>UIAppearance</code> protocol which does not use varargs:</p> <pre><code>static func appearanceWhenContainedInInstancesOfClasses(containerTypes: [AnyObject.Type]) -&gt; Self </code></pre> <p>Which can be used like so:</p> <pre><code>UITextField.appearanceWhenContainedInInstancesOfClasses([MyViewController.self]).keyboardAppearance = .Light </code></pre> <p>If you still need to support iOS 8 or earlier, use the following original answer to this question.</p> <h2>For iOS 8 &amp; 7:</h2> <p>These methods are not available to Swift because Obj-C varargs methods are not compatible with Swift (see <a href="http://www.openradar.me/17302764" rel="nofollow noreferrer">http://www.openradar.me/17302764</a>).</p> <p>I wrote a non-variadic workaround which works in Swift (I repeated the same method for <code>UIBarItem</code>, which doesn't descend from <code>UIView</code>):</p> <pre><code>// UIAppearance+Swift.h #import &lt;UIKit/UIKit.h&gt; NS_ASSUME_NONNULL_BEGIN @interface UIView (UIViewAppearance_Swift) // appearanceWhenContainedIn: is not available in Swift. This fixes that. + (instancetype)my_appearanceWhenContainedIn:(Class&lt;UIAppearanceContainer&gt;)containerClass; @end NS_ASSUME_NONNULL_END </code></pre> <p>â€”</p> <pre><code>// UIAppearance+Swift.m #import "UIAppearance+Swift.h" @implementation UIView (UIViewAppearance_Swift) + (instancetype)my_appearanceWhenContainedIn:(Class&lt;UIAppearanceContainer&gt;)containerClass { return [self appearanceWhenContainedIn:containerClass, nil]; } @end </code></pre> <p>Just be sure to <code>#import "UIAppearance+Swift.h"</code> in your bridging header.</p> <p>Then, to call from Swift (for example):</p> <pre><code># Swift 2.x: UITextField.my_appearanceWhenContainedIn(MyViewController.self).keyboardAppearance = .Light # Swift 3.x: UITextField.my_appearanceWhenContained(in: MyViewController.self).keyboardAppearance = .light </code></pre>
<h1>For iOS 8 &amp; 7:</h1> <p>I use a category based on Alex's answer to specify multiple containers. This is a workaround until Apple officially supports <code>appearanceWhenContainedIn</code> in Swift.</p> <p><strong>UIAppearance+Swift.h</strong></p> <pre><code>@interface UIView (UIAppearance_Swift) /// @param containers An array of Class&lt;UIAppearanceContainer&gt; + (instancetype)appearanceWhenContainedWithin: (NSArray *)containers; @end </code></pre> <p><strong>UIAppearance+Swift.m</strong></p> <pre><code>@implementation UIView (UIAppearance_Swift) + (instancetype)appearanceWhenContainedWithin: (NSArray *)containers { NSUInteger count = containers.count; NSAssert(count &lt;= 10, @"The count of containers greater than 10 is not supported."); return [self appearanceWhenContainedIn: count &gt; 0 ? containers[0] : nil, count &gt; 1 ? containers[1] : nil, count &gt; 2 ? containers[2] : nil, count &gt; 3 ? containers[3] : nil, count &gt; 4 ? containers[4] : nil, count &gt; 5 ? containers[5] : nil, count &gt; 6 ? containers[6] : nil, count &gt; 7 ? containers[7] : nil, count &gt; 8 ? containers[8] : nil, count &gt; 9 ? containers[9] : nil, nil]; } @end </code></pre> <p>Then add <code>#import "UIAppearance+Swift.h"</code> to your bridging header.</p> <p><strong>To use from Swift</strong>:</p> <pre><code>TextField.appearanceWhenContainedWithin([MyViewController.self, TableViewController.self]).keyboardAppearance = .Light </code></pre> <p>It was good if I could find a way using <a href="http://swiftdoc.org/protocol/CVarArgType/" rel="nofollow">CVarArgType</a>, but I found no clean solution.</p>
<p>I have created a repo for you guys who wanna use <code>CocoaPods</code>:</p> <ol> <li><p>Add this into your <code>Podfile</code>:</p> <pre><code>pod 'UIViewAppearanceSwift' </code></pre></li> <li><p>Import in your class:</p> <pre><code>import UIViewAppearanceSwift func layout() { UINavigationBar.appearanceWhenContainedWithin(MFMailComposeViewController.self).barStyle = .Black UIBarButtonItem.appearanceWhenContainedWithin(UISearchBar.self).setTitleTextAttributes([NSFontAttributeName: UIFont.systemFontOfSize(15)], forState: UIControlState.Normal) } </code></pre></li> <li><p>Reference: <a href="https://github.com/levantAJ/UIViewAppearanceSwift" rel="nofollow noreferrer">https://github.com/levantAJ/UIViewAppearanceSwift</a></p></li> </ol>
<p>This can be extended to any class that conforms to the UIAppearance protocol -- not just UIViews. So here's a more generic version:</p> <p><strong>UIAppearance+Swift.h</strong></p> <pre><code>#import &lt;UIKit/UIKit.h&gt; @interface NSObject (UIAppearance_Swift) + (instancetype)appearanceWhenContainedWithin:(Class&lt;UIAppearanceContainer&gt;)containerClass; @end </code></pre> <p><strong>UIAppearance+Swift.m</strong></p> <pre><code>#import "UIAppearance+Swift.h" @implementation NSObject (UIAppearance_Swift) + (instancetype)appearanceWhenContainedWithin:(Class&lt;UIAppearanceContainer&gt;)containerClass { if ([self conformsToProtocol:@protocol(UIAppearance)]) { return [(id&lt;UIAppearance&gt;)self appearanceWhenContainedIn:containerClass, nil]; } return nil; } @end </code></pre>
<p><strong><code>ios 10 swift 3</code></strong> </p> <p>UIBarButtonItem.appearance(whenContainedInInstancesOf: [UISearchBar.self]).title = "Kapat"</p>