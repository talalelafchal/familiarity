Does Swift implement tail call optimization? and in mutual recursion case?
<p>In particular if I have the following code:</p> <pre><code>func sum(n: Int, acc: Int) -&gt; Int { if n == 0 { return acc } else { return sum(n - 1, acc + n) } } </code></pre> <p>Will Swift compiler optimize it to a loop? And does it so in a more interesting case below?</p> <pre><code>func isOdd(n: Int) -&gt; Bool { if n == 0 { return false; } else { return isEven(n - 1) } } func isEven(n: Int) -&gt; Bool { if n == 0 { return true } else { return isOdd(n - 1) } } </code></pre>
<p>Yes, the swift compiler performs tail call optimisation in some cases:</p> <pre><code>func sum(n: Int, acc: Int) -&gt; Int { if n == 0 { return acc } else { return sum(n - 1, acc: acc + 1) } } </code></pre> <p>As a global function, this will use constant stack space on the "Fastest" optimisation level (<code>-O</code>).</p> <p>If it is inside a struct it will still use constant stack space. Within a class however, the compiler does not perform tco because the method might be overridden at runtime.</p> <p>Clang also supports tco for Objective-C but often ARC calls <code>release</code> after the recursive call, thus preventing this optimisation, see <a href="http://devetc.org/code/2014/05/24/tail-recursion-objc-and-arc.html">this article by Jonathon Mah</a> for more details.</p> <p>ARC also seems to prevent TCO in Swift:</p> <pre><code>func sum(n: Int, acc: Int, s: String?) -&gt; Int { if n == 0 { return acc } else { return sum(n - 1, acc + 1, s) } } </code></pre> <p>No TCO was performed in my tests.</p>
<p>The best way to check is to examine the assembly language code generated by the compiler. I took the code above and compiled it with:</p> <pre><code>swift -O3 -S tco.swift &gt;tco.asm </code></pre> <p>The relevant part of the output</p> <pre><code>.globl __TF3tco3sumFTSiSi_Si .align 4, 0x90 __TF3tco3sumFTSiSi_Si: pushq %rbp movq %rsp, %rbp testq %rdi, %rdi je LBB0_4 .align 4, 0x90 LBB0_1: movq %rdi, %rax decq %rax jo LBB0_5 addq %rdi, %rsi jo LBB0_5 testq %rax, %rax movq %rax, %rdi jne LBB0_1 LBB0_4: movq %rsi, %rax popq %rbp retq LBB0_5: ud2 .globl __TF3tco5isOddFSiSb .align 4, 0x90 __TF3tco5isOddFSiSb: pushq %rbp movq %rsp, %rbp testq %rdi, %rdi je LBB1_1 decq %rdi jo LBB1_9 movb $1, %al LBB1_5: testq %rdi, %rdi je LBB1_2 decq %rdi jo LBB1_9 testq %rdi, %rdi je LBB1_1 decq %rdi jno LBB1_5 LBB1_9: ud2 LBB1_1: xorl %eax, %eax LBB1_2: popq %rbp retq .globl __TF3tco6isEvenFSiSb .align 4, 0x90 __TF3tco6isEvenFSiSb: pushq %rbp movq %rsp, %rbp movb $1, %al LBB2_1: testq %rdi, %rdi je LBB2_5 decq %rdi jo LBB2_7 testq %rdi, %rdi je LBB2_4 decq %rdi jno LBB2_1 LBB2_7: ud2 LBB2_4: xorl %eax, %eax LBB2_5: popq %rbp retq </code></pre> <p>This clearly demonstrates that swift does do tail call optimizations in <em>both</em> cases.</p> <p>In addition, the <code>isOdd</code>/<code>isEven</code> functions are interesting in that the compiler not only seems to perform TCO, but also inlines the other function in each case.</p>