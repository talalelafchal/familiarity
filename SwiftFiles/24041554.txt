How can I output to STDERR with Swift?
<p>I'm trying to make a command line tool for OS X with Xcode 6 and the new Swift language. How can I send output to stderr? Is this done with println?</p>
<p>May be a better way to do it, but you can use <code>NSFileHandle</code>:</p> <pre><code>import Foundation // Create a file handle to work with let stderr = NSFileHandle.fileHandleWithStandardError() // Build up a string; whatever you want let stuff = "something" let something = "I'm a string with \(stuff) in it\n" // Write it stderr.writeData(something.dataUsingEncoding(NSUTF8StringEncoding)) </code></pre>
<p>Not really a separate answer, but building on top of Rob Napier's answer, we can create a stderr like object so that there is not much to change when Apple comes around to providing stderr as an <code>OutputStreamType</code>:</p> <pre><code>import Foundation class StandardErrorOutputStream: OutputStreamType { func write(string: String) { let stderr = NSFileHandle.fileHandleWithStandardError() stderr.writeData(string.dataUsingEncoding(NSUTF8StringEncoding)) } } var mx_stderr = StandardErrorOutputStream() println("on-stdout") println("on-stderr", &amp;mx_stderr) </code></pre> <p>EDIT: As of 8/26/2015, Xcode 7 Beta 6, you need the <code>toStream:</code> parameter name, like so:</p> <pre><code>println("on-stderr", toStream:&amp;mx_stderr) </code></pre>
<pre><code>import Darwin fputs("hello from libc\n", __stderrp) </code></pre> <p>Note that stderr is not supported in Playgrounds or the REPL and will crash in both of those places (as of Swift 1.1).</p>
<p>Here are three different methods of increasing complexity:</p> <p>Compliments of Erica Sadun at <a href="http://ericasadun.com/2015/06/09/swift-2-0-how-to-print/" rel="nofollow">http://ericasadun.com/2015/06/09/swift-2-0-how-to-print/</a>:</p> <pre><code>public struct StderrOutputStream: OutputStreamType { public mutating func write(string: String) { fputs(string, stderr) } } public var errStream = StderrOutputStream() debugPrint("Hello", toStream: &amp;errStream) // prints with new line </code></pre> <p>For a slightly different method using NSFileHandle.fileHandleWithStandardError, see: <a href="http://crunchybagel.com/building-command-line-tools-with-swift/" rel="nofollow">http://crunchybagel.com/building-command-line-tools-with-swift/</a> in the section titled: <strong>Writing to stdout / stderr</strong>, but this method does not use Swift's print library function.</p> <p>And for a really crazy ride, check out the method offered by rosettacode.org using NSOutputStream at <a href="https://www.rosettacode.org/wiki/Hello_world/Standard_error#Swift" rel="nofollow">https://www.rosettacode.org/wiki/Hello_world/Standard_error#Swift</a>:</p> <pre><code>let out = NSOutputStream(toFileAtPath: "/dev/stderr", append: true) let err = "Goodbye, World!".dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false) out?.open() let success = out?.write(UnsafePointer&lt;UInt8&gt;(err!.bytes), maxLength: err!.length) out?.close() if let bytes = success { print("\nWrote \(bytes) bytes") } </code></pre>