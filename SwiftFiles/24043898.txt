Combine generics and extensions in Swift?
<p>Looking at:</p> <p><a href="http://stackoverflow.com/questions/24024549/dispatch-once-singleton-model-in-swift">dispatch_once singleton model in swift</a></p> <p>I see a very generic pattern for creating a shared singleton instance of my class. What I'd like to be able to do is create an extension for "all classes" that implements this sharedInstance method with generics.</p> <p>I don't see any syntax for doing this; anybody want to take a crack at it?</p>
<p>I don't think this is possible.</p> <p>Even if it was possible to extend <code>Any</code> / <code>AnyObject</code>, every object would share the same implementation of the <code>sharedInstance</code> singleton getter, and therefore the same static <code>instance</code> variable. Thus, <code>instance</code> would get set to an instance of the first class on which <code>sharedInstance</code> was called.</p> <pre><code>extension Any { class var sharedInstance:TPScopeManager { get { struct Static { static var instance : TPScopeManager? = nil } if !Static.instance { Static.instance = TPScopeManager() } return Static.instance! } } } ... NSString.sharedInstance() // Returns an NSString NSArray.sharedInstance() // Returns the same NSString object! </code></pre>
<p>As others have pointed out, Swift offers a simpler way to create singletons.</p> <p>As an example: let's say we have a class called <code>Model</code>, and we want to have a single instance, visible throughout our app. All we need to write in the <em>global scope</em> is:</p> <pre><code>let modelSingleton = Model() </code></pre> <p>This will create an instance of the <code>Model</code> class, visible everywhere, and that cannot be replaced by another instance (Hmmm, that's pretty much what one would expect from a singleton, isn't it?).</p> <p>Now, this way of doing would, on the other hand, still allow you to create <em>other</em> <code>Model</code> instances, apart from the singleton. While this departs from the official definition of singletons in other languages, this approach would have the interesting advantage of allowing the creation of other instances for <em>testing purposes</em> (singletons have bad press in the unit testing world :) ).</p> <p>Swift will soon offer everything needed to create real <code>Singleton&lt;T&gt;</code> classes (it's hard now because <em>class vars</em> aren't allowed yet). But that being said, the approach described above will probably be more than enough for many Swift programmers.</p>
<p>In Swift you can make an extension to NSObject, but you can't extend Any/AnyObject</p>