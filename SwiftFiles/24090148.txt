C-style uninitialized pointer passing in Apple Swift?
<p>I am attempting to implement some AES256 crypto routines in Apple Swift to kinda toy around with the interoperability between ObjC, C, and Swift code and data types, and have run into a bit of an issue and am hoping someone has some suggestions on something I've overlooked.</p> <p>As most are familiar, common C-style pattern is to declare an uninitialized pointer and then pass that into a function, wherein the function call malloc()s an object and points the pointer to it; after the function call completes the pointer points to the newly-created object. The Common Crypto libraries use this in some places; most notably when creating a new CCCryptor object (really a struct behind the scenes, it looks like, typedef'ed to CCCryptorRef for an opaque reference) - the final argument to the call to CCCryptorCreate() is such a pointer and should, at the conclusion of the function call, contain a pointer to the CCCryptorRef.</p> <p>Swift puts a wrinkle into this - variables cannot be uninitialized, they always either have a value or are nil(/optional), and thus I've run into a bit of a bump here. The following doesn't work because CCCryptorCreate (rightfully) acts as though I'm just passing nil as the last argument, which I am:</p> <pre><code>var myCryptorRef: CMutablePointer&lt;Unmanaged&lt;CCCryptorRef&gt;?&gt; = nil CCCryptorCreate(CCOperation(kCCEncrypt), CCAlgorithm(kCCAlgorithmAES128), CCOptions(kCCOptionECBMode), seedData.bytes(), UInt(kCCKeySizeAES256), nil, myCryptorRef) </code></pre> <p>But neither can you declare it as an optional, like so:</p> <pre><code>var myCryptorRef: CMutablePointer&lt;Unmanaged&lt;CCCryptorRef&gt;?&gt;? </code></pre> <p>Or as a non-pointer type:</p> <pre><code>var myCryptoRef: Unmanaged&lt;CCCryptorRef&gt;? CCCryptorCreate(CCOperation(kCCEncrypt), CCAlgorithm(kCCAlgorithmAES128), CCOptions(kCCOptionECBMode), seedData.bytes(), UInt(kCCKeySizeAES256), nil, &amp;myCryptorRef) </code></pre> <p>Since what CCCryptorCreate expects is either an uninitialized pointer to a CCCryptorRef or an already-malloc()'ed CCCryptorRef, attempting to pass it the address of a not-yet-initialized object doesn't go very well as you might expect.</p> <p>So, it comes down to this: can anyone come up with a way to initialize that CCCryptor struct before the call to CCCryptorCreate (the Swift-standard method of struct init by naming all variables inside the struct does not seem to work), or some alternate construction that would allow me to preserve the C concept of the uninitialized pointer for use in this way? Thank you for any suggestions you may have.</p> <p>Adding for clarity from the comments: Swift interprets the call to CCCryptorCreate() as the following:</p> <pre><code>CCCryptorCreate(op: CCOperation, alg: CCAlgorithm, options: CCOptions, key: CConstVoidPointer, keyLength: UInt, iv: CConstVoidPointer, cryptorRef: CMutablePointer&lt;Unmanaged&lt;CCCryptor&gt;?&gt;) </code></pre> <p>An additional edit for some other things I've tried: Just to be truly absurd, I tried the following, but it also did not work (EXC_BAD_ACCESS on the call to fromOpaque):</p> <pre><code>var someMem = malloc(UInt(sizeof(CCCryptor))) var crashTime = Unmanaged&lt;CCCryptor&gt;.fromOpaque(someMem) </code></pre> <p>Also, every place CCCryptor or CCCryptorRef is mentioned, I have tried either one - in CommonCrypto/CommonCryptor.h, CCCryptorRef is defined thusly:</p> <pre><code>typedef struct _CCCryptor *CCCryptorRef </code></pre> <p>So while existing Objective-C code examples use CCCryptorRef, I've been trying either.</p>
<p>Try this:</p> <pre><code>var myCryptor: Unmanaged&lt;CCCryptor&gt;? CCCryptorCreate( .... , &amp;myCryptor ) </code></pre> <p>From <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-XID_13" rel="nofollow">Using Swift with Cocoa and Objective-C</a></p> <blockquote> <p>If you have declared a function like this one:</p> <pre><code>func takesAMutablePointer(x: CMutablePointer&lt;Float&gt;) { /*...*/ } </code></pre> <p>You can call it in any of the following ways:</p> <pre><code>var x: Float = 0.0 var p: CMutablePointer&lt;Float&gt; = nil var a: Float[] = [1.0, 2.0, 3.0] takesAMutablePointer(nil) takesAMutablePointer(p) takesAMutablePointer(&amp;x) takesAMutablePointer(&amp;a) </code></pre> </blockquote> <p>You should also check out <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-XID_13" rel="nofollow">this</a> and convert the <code>Unmanaged</code> reference into something that is managed.</p>
<p>Here's an example that works on beta 3, using a type from <code>librabbitmq</code>:</p> <pre><code>let envelopePtr = UnsafePointer&lt;amqp_envelope_t&gt;.alloc(1) reply = amqp_consume_message(connection, envelopePtr, nil, 0) let envelope = envelopePtr.memory </code></pre>