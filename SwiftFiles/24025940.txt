How should I reason when I have to choose between a class, struct and enum in Swift?
<p>Since classes, structs and enums all has constructors, properties and computed properties, how should I reason when choosing between them?</p>
<p>For starters, Classes are pass-by-reference and Structs are pass-by-copy.</p> <p><code>enums</code> are still a special type to specify, well, enumerations. They should be used just like before.</p> <p>In general, the choice of Class vs Structs shouldn't be much different than before. Classes are still fit for larger/complex objects and Structs are good for small, isolated model objects. The fact that structs have protocols and such now should just serve to simplify your code and make it more efficient.</p>
<p><a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13-XID_94" rel="nofollow">Structures have memberwise initializers</a> (class instances do not receive a default memberwise initializer)</p> <blockquote> <p>All structures have an automatically-generated memberwise initializer, which you can use to initialize the member properties of new structure instances. Initial values for the properties of the new instance can be passed to the memberwise initializer by name:</p> </blockquote> <pre><code>let vga = Resolution(width: 640, height: 480) </code></pre> <p>which makes perfect sense since they are value types (and thus <code>immutable</code>).</p> <p>Enumerations are value types too. Classes are reference types. No real surprises here.</p>
<p>ChristopheD's and Jack Wu's answers are good, but I feel they don't touch on enums, or miss their importance. Swift enums are (meant to be) a full implementation of algebraic data types. Classes and structs are traditionally used to model data in object-oriented languages, but enums are usually limited to being used as a convenient way to limit the value of a variable to a limited number of possibilities. E.g. (C++):</p> <pre><code>enum MaritalStatus { Unmarried, Married, Divorced, WidowedOrWidowered }; MaritalStatus m = Unmarried; </code></pre> <p>Swift enums can do the above but they can do a lot more. Of course the Language Guide has a pretty good <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html#//apple_ref/doc/uid/TP40014097-CH12-XID_189">barcode modelling example</a> but the best example I know of that really drives home the point of modelling data with algebraic data types is Scott Wlaschin's presentation: <a href="http://www.slideshare.net/ScottWlaschin/ddd-with-fsharptypesystemlondonndc2013">http://www.slideshare.net/ScottWlaschin/ddd-with-fsharptypesystemlondonndc2013</a></p> <p>You would probably benefit from going through the whole presentation but really to 'get' the point all you need to see is slide 60 where he shows how to model a 'payment method' in a typical line-of-business app.</p> <p>The examples in the presentation are in F# but F# isn't <em>that</em> far off from Swift and you can pretty easily map between them. E.g., the payment methods enum in Swift would look like:</p> <pre><code>enum PaymentMethod { case Cash // No extra data needed. case Cheque(Int) // Cheque #. case Card(CardType, CardNumber) // 2 pieces of extra data. } </code></pre> <p>The point of the above is that each order's payment method can be only one of the above three methods. Anything else will not be allowed by the compiler. This is a very succinct alternative to building entire class hierarchies to model these almost trivial things.</p> <p>The presentation really takes off from there and the best part is Swift can do almost everything that F# can in terms of data modelling, using optional types, etc.</p>
<p>The most important difference between classes and other named types (structs/enums) is:</p> <p>Structs cannot be subclasses (or substructs, so to speak) of anything. Nor can they be subclassed themselves. Inheritance is completely out of picture with structs. Same goes for enums.</p>
<p>I think it's quite a refined discussion! I like the thoughts expressed here: <a href="http://www.swift-studies.com/blog/2014/7/1/struct-enum-or-class">http://www.swift-studies.com/blog/2014/7/1/struct-enum-or-class</a> </p> <p>There's quite a lot of details, and their recommendations. I've copied their summary here, but it's a whole article</p> <ul> <li><strong>enums</strong> are initialised by one of a finite number of cases, are completely defined by their case, and should always be valid instances of that case when instantiated </li> <li><strong>structs</strong> should be used when there is not a finite number of valid instances (e.g. enum cases) and the struct also does not form a complete definition of an object, but rather an attribute of an object </li> <li>A <strong>class</strong> completely defines a primary actor in your object model, both its attributes and its interactions.</li> </ul>
<p>Besides the advice on the practical usage of class, struct and enum, here is the comparison that clarifies the abilities among them <a href="http://tetontech.wordpress.com/2014/06/10/swift-classes-structs-enums-and-tuples-compared/" rel="nofollow noreferrer">Swift Classes, Structs, Enums, and Tuples compared</a></p> <p><img src="https://i.stack.imgur.com/MpfHt.png" alt="enter image description here"></p>
<p>Generally, you would make use of structures over classes when the data you are defining is relatively simple, you don’t need to worry about referencing, or you don’t need to inherit another data structure’s properties and methods.</p> <p>If you have data that should not be changed after initialization we can ensure that at compile time when using structs.</p> <p>Use classes for situations where you know that the identity of the object is going to be important. In other words, use classes where you want multiple regions of code to be pointing at the very same instance of the the object.</p> <p>Use structs for situations where you know that the value of the object matters. In other words, structs are great for situations where it doesn’t matter if two different regions of code are referring to the very same instance of to copy of the instance</p> <p>If you need to share mutable state between parts of you program you should use a class.</p> <p>If you need inheritance or you know you want to pass references to an object around, use a class.</p>