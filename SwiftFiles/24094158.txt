Overriding superclass property with different type in Swift
<p>In Swift, can someone explain how to override a property on a superclass's with another object subclassed from the original property?</p> <p>Take this simple example:</p> <pre><code>class Chassis {} class RacingChassis : Chassis {} class Car { let chassis = Chassis() } class RaceCar: Car { override let chassis = RacingChassis() //Error here } </code></pre> <p>This gives the error:</p> <pre><code>Cannot override with a stored property 'chassis' </code></pre> <p>If I have chassis as 'var' instead, I get the error:</p> <pre><code>Cannot override mutable property 'chassis' of type 'Chassis' with covariant type 'RacingChassis' </code></pre> <p>The only thing I could find in the guide under "Overriding Properties" indicates that we have to override the getter and setter, which may work for changing the value of the property (if it's 'var'), but what about changing the property class?</p>
<p>Swift does not allow you to change the class type of any variables or properties. Instead you can create an extra variable in the subclass that handles the new class type:</p> <pre><code>class Chassis {} class RacingChassis : Chassis {} class Car { var chassis = Chassis() } class RaceCar: Car { var racingChassis = RacingChassis() override var chassis: Chassis { get { return racingChassis } set { if newValue is RacingChassis { racingChassis = newValue as RacingChassis } else { println("incorrect chassis type for racecar") } } } } </code></pre> <p>It seems one cannot declare a property with the let syntax and override it with var in it’s subclass or vice-versa, which may be because the superclass implementation might not be expecting that property to change once initialized. So in this case the property needs to be declared with ‘var’ in the superclass as well to match the subclass (as shown in the snippet above). If one cannot change the source code in the superclass then its probably best to destroy the current RaceCar and create a new RaceCar every time the chassis needs to be mutated.</p>
<p>You can simply create another variable of RacingChassis. </p> <pre><code>class Chassis {} class RacingChassis : Chassis {} class Car { let chassis: Chassis init(){ chassis = Chassis() }} class RaceCar: Car { let raceChassis: RacingChassis init(){ raceChassis = RacingChassis() }} </code></pre>
<p>This seems to work</p> <pre><code>class Chassis { func description() -&gt; String { return "Chassis" } } class RacingChassis : Chassis { override func description() -&gt; String { return "Racing Chassis" } func racingChassisMethod() -&gt; String { return "Wrooom" } } class Car { let chassis = Chassis() } class RaceCar: Car { override var chassis: RacingChassis { get { return self.chassis } set { self.chassis = newValue } } } var car = Car() car.chassis.description() var raceCar = RaceCar() raceCar.chassis.description() raceCar.chassis.racingChassisMethod() </code></pre>
<p>Theoretically, you're allowed to do it this way...</p> <pre><code>class ViewController { var view: UIView! { return _view } private var _view: UIView! } class ScrollView : UIView {} class ScrollViewController : ViewController { override var view: ScrollView! { return super.view as ScrollView! } } class HomeView : ScrollView {} class HomeViewController : ScrollViewController { override var view: HomeView! { return super.view as HomeView! } } </code></pre> <p>This works perfectly in an Xcode playground.</p> <p><strong>But</strong>, if you try this in a real project, a compiler error tells you:</p> <blockquote> <p>Declaration 'view' cannot override more than one superclass declaration</p> </blockquote> <p>I've only checked Xcode 6.0 GM as of now.</p> <p>Unfortunately, you'll have to wait until Apple fixes this.</p> <p>I've submitted a bug report too. <strong>18518795</strong></p>
<p>The Solution Dash provided works well except that the super class has to be declared with the let keyword rather than var. Here is a solution that is possible but NOT RECOMENDED!</p> <p>The solution below will compile with Xcode 6.2, SWIFT 1.1 (if all the classes are in different swift files) but should be avoided because IT CAN LEAD TO UNEXPECTED BEHAVIORS(INCLUDING A CRASH, especially when using non-optional types). NOTE: THIS DOES NOT WORK WITH XCODE 6.3 BETA 3, SWIFT 1.2</p> <pre><code>class Chassis {} class RacingChassis : Chassis {} class Car { var chassis:Chassis? = Chassis() } class RaceCar: Car { override var chassis: RacingChassis? { get { return super.chassis as? RacingChassis } set { super.chassis = newValue } } } </code></pre>
<p>I've seen a lot of reasons why designing an API using variables instead of functions is problematic and to me using computed properties feels like a workaround. There are good reasons to keep your instance variables encapsulated. Here I've created a protocol Automobile that Car conforms to. This protocol has an accessor method that returns a Chassis object. Since Car conforms to it the RaceCar subclass can override it and return a different Chassis subclass. This allows the Car class to program to an interface (Automobile) and the RaceCar class that knows about RacingChassis can access the _racingChassis variable directly.</p> <pre><code>class Chassis {} class RacingChassis: Chassis {} protocol Automobile { func chassis() -&gt; Chassis } class Car: Automobile { private var _chassis: Chassis init () { _chassis = Chassis() } func chassis() -&gt; Chassis { return _chassis } } class RaceCar: Car { private var _racingChassis: RacingChassis override init () { _racingChassis = RacingChassis() super.init() } override func chassis() -&gt; Chassis { return _racingChassis } } </code></pre> <p>Another example of why designing an API using variables breaks down is when you have variables in a protocol. If you'd like to break out all of the protocol functions into an extensions you can, except stored properties cannot be placed in extensions and have to be defined in the class (to get this to compile you'd have to uncomment the code in AdaptableViewController class and remove the mode variable from the extension):</p> <pre><code>protocol Adaptable { var mode: Int { get set } func adapt() } class AdaptableViewController: UIViewController { // var mode = 0 } extension AdaptableViewController: Adaptable { var mode = 0 // compiler error func adapt() { //TODO: add adapt code } } </code></pre> <p>The above code will have this compiler error: "Extensions may not have stored properties". Here's how you can re-write the example above so that everything in the protocol can be separated out in the extension by using functions instead:</p> <pre><code>protocol Adaptable { func mode() -&gt; Int func adapt() } class AdaptableViewController: UIViewController { } extension AdaptableViewController: Adaptable { func mode() -&gt; Int { return 0 } func adapt() { // adapt code } } </code></pre>
<p>Try this:</p> <pre><code>class Chassis {} class RacingChassis : Chassis {} class SuperChassis : RacingChassis {} class Car { private var chassis: Chassis? = nil func getChassis() -&gt; Chassis? { return chassis } func setChassis(chassis: Chassis) { self.chassis = chassis } } class RaceCar: Car { private var chassis: RacingChassis { get { return getChassis() as! RacingChassis } set { setChassis(chassis: newValue) } } override init() { super.init() chassis = RacingChassis() } } class SuperCar: RaceCar { private var chassis: SuperChassis { get { return getChassis() as! SuperChassis } set { setChassis(chassis: newValue) } } override init() { super.init() chassis = SuperChassis() } } </code></pre>