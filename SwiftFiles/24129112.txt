Usage of closures with multiple arguments in swift
<p>This question is largely based on this one:</p> <p><a href="http://stackoverflow.com/questions/24031084/closures-return-value-previously-completionblock"><strong>Link</strong></a></p> <p>The main difference being that I want to pass in arguments to the closure as well. Say I have something like this:</p> <pre><code>func someFunctionThatTakesAClosure(completionClosure: (venues: Dictionary&lt;String, AnyObject&gt;, error: NSError) -&gt; ()) { // function body goes here var error: NSError? let responseDictionary: Dictionary&lt;String, AnyObject&gt; = ["test" : "test2"] completionClosure(venues: responseDictionary, error: error!) } </code></pre> <p>No error here. But when I call this function in my main view controller I have tried several ways but all of the result in different errors:</p> <pre><code>venueService.someFunctionThatTakesAClosure(completionClosure(venues: Dictionary&lt;String, AnyObject&gt;, error: NSError){ }) </code></pre> <p>or like this:</p> <pre><code>venueService.someFunctionThatTakesAClosure((venues: Dictionary&lt;String, AnyObject&gt;, error: NSError){ }) </code></pre> <p>or even like this:</p> <pre><code>venueService.someFunctionThatTakesAClosure(completionClosure: (venues: Dictionary&lt;String, AnyObject&gt;, error: NSError) -&gt; (){ }); </code></pre> <p>I'm probably just way tired, but any help would be greatly appreciated!</p>
<p>The syntax for passing in parameters to closures revolve around the <code>in</code> keyword.</p> <p>Sorry for the link url...but check out <a href="http://fuckingclosuresyntax.com/" rel="nofollow">http://fuckingclosuresyntax.com/</a> and notice in the options where <code>in</code> appears.</p> <p>see <code>array.sort({ (item1, item2) in return item1 &lt; item2 })</code></p> <p>Which takes in <code>item1</code> and <code>item2</code> as 2 inputs</p>
<pre><code>venueService.someFunctionThatTakesAClosure({ venues, error in // do stuff }) </code></pre> <p>you can optionally specify the types (but since the compiler knows what types the closure is supposed to provide, you don't strictly have to:</p> <pre><code>venueService.someFunctionThatTakesAClosure({ (venues: Dictionary&lt;String, AnyObject&gt;, error: NSError) -&gt; () in // do stuff }) </code></pre> <p>But I see another issue in your calling code:</p> <pre><code>completionClosure(venues: responseDictionary, error: error!) // No Bueno. What if there's no error? ^^^^^^ </code></pre> <p>You shouldn't force unwrap the error since it's entirely possible that it's still nil. Force unwrapping nil will cause an error. So you want this:</p> <pre><code>completionClosure(venues: responseDictionary, error: error) </code></pre> <p>AND you want to change your closure to take an optional error. In total:</p> <pre><code>func someFunctionThatTakesAClosure(completionClosure: (venues: Dictionary&lt;String, AnyObject&gt;, error: NSError?) -&gt; ()) { â€¦ completionClosure(venues: responseDictionary, error: error) } // when calling: venueService.someFunctionThatTakesAClosure({ (venues: Dictionary&lt;String, AnyObject&gt;, error: NSError?) -&gt; () in // do stuff }) </code></pre> <p>If you'd like to pass additional arguments, keep in mind swift is optimized for closures to be passed as the last argument (and it's a widely followed convention in objective-c APIs):</p> <pre><code>// in venueService: func someArgAndClosureFunction(arg1: String, arg2: Int, completionClosure: (venues: Dictionary&lt;String, AnyObject&gt;, error: NSError?) -&gt; ()) { // do stuff } // When calling: venueService.someArgAndClosureFunction("string arg 1", arg2: 10) { (venues: Dictionary&lt;String, AnyObject&gt;, error: NSError?) -&gt; () in // do stuff } </code></pre> <p>In this example I've used the <a href="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-XID_126" rel="nofollow">trailing closure syntax</a> which allows you pass the closure <strong>outside</strong> the function call parens (but it is still passed as the last argument).</p>
<p>As your error is optional, I would make it an optional argument of the passed function:</p> <pre><code>func someFunctionThatTakesAClosure(completionClosure: (venues: Dictionary&lt;String, AnyObject&gt;, error: NSError?) -&gt; ()) { // function body goes here var error: NSError? = nil let responseDictionary: Dictionary&lt;String, AnyObject&gt; = ["test" : "test2"] completionClosure(venues: responseDictionary, error: error) } </code></pre> <p>It can then be invoked, passing a closure as follows:</p> <pre><code>someFunctionThatTakesAClosure { println($0); println($1) } </code></pre> <p>Note, the above is one of the shorthand syntax variants for creating closures.</p>
<p>I think you were probably just tired :)</p> <p>You're saying that the difficulty you are having is in calling the method, right? None of the examples you gave are passing a valid argument, which should be a closure of type:</p> <p><code>(Dictionary&lt;String, AnyObject&gt;, NSError) -&gt; ()</code></p> <p>So there are a couple of things you could do...</p> <p>(a) assign a conforming closure to a variable and pass the variable as the argument to the method:</p> <pre><code>let myClosure: (Dictionary&lt;String, AnyObject&gt;, NSError?) -&gt; () = { venues, error in for (key, _) in venues { println(key) } } venueService.someFunctionThatTakesAClosure(myClosure) </code></pre> <p>(b) pass a trailing closure as the argument to the method call:</p> <pre><code>venueService.someFunctionThatTakesAClosure { venues, error in for (key, _) in venues { println(key) } } </code></pre>