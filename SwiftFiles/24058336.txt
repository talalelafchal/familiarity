How do I run Asynchronous callbacks in Playground
<p>Many Cocoa and CocoaTouch methods have completion callbacks implemented as blocks in Objective-C and Closures in Swift. However, when trying these out in Playground, the completion is never called. For example:</p> <pre><code>// Playground - noun: a place where people can play import Cocoa import XCPlayground let url = NSURL(string: "http://stackoverflow.com") let request = NSURLRequest(URL: url) NSURLConnection.sendAsynchronousRequest(request, queue:NSOperationQueue.currentQueue() { response, maybeData, error in // This block never gets called? if let data = maybeData { let contents = NSString(data:data, encoding:NSUTF8StringEncoding) println(contents) } else { println(error.localizedDescription) } } </code></pre> <p>I can see the console output in my Playground timeline, but the <code>println</code> in my completion block are never called... </p>
<p>The reason the callbacks are not called is because the RunLoop isn't running in Playground (or in REPL mode for that matter).</p> <p>A somewhat janky, but effective, way to make the callbacks operate is with a flag and then manually iterating on the runloop:</p> <pre><code>// Playground - noun: a place where people can play import Cocoa import XCPlayground let url = NSURL(string: "http://stackoverflow.com") let request = NSURLRequest(URL: url) var waiting = true NSURLConnection.sendAsynchronousRequest(request, queue:NSOperationQueue.currentQueue() { response, maybeData, error in waiting = false if let data = maybeData { let contents = NSString(data:data, encoding:NSUTF8StringEncoding) println(contents) } else { println(error.localizedDescription) } } while(waiting) { NSRunLoop.currentRunLoop().runMode(NSDefaultRunLoopMode, beforeDate: NSDate()) usleep(10) } </code></pre> <p>This pattern has often been used in Unit Tests which need to test async callbacks, for example: <a href="http://stackoverflow.com/questions/7817605/pattern-for-unit-testing-async-queue-that-calls-main-queue-on-completion">Pattern for unit testing async queue that calls main queue on completion</a></p>
<p>While you can run a run loop manually (or, for asynchronous code that doesn't require a run loop, use other waiting methods like dispatch semaphores), the "built-in" way we provide in playgrounds to wait for asynchronous work is to import the <code>XCPlayground</code> framework and set <code>XCPlaygroundPage.currentPage.needsIndefiniteExecution = true</code>. If this property has been set, when your top level playground source finishes, instead of stopping the playground there we will continue to spin the main run loop, so asynchronous code has a chance to run. We will eventually terminate the playground after a timeout which defaults to 30 seconds, but which can be configured if you open the assistant editor and show the timeline assistant; the timeout is in the lower-right.</p> <p>Unfortunately, this developer preview does not include <code>XCPlayground</code> for iOS; only for OSX.</p> <p><strong>Working example using the code in question</strong></p> <pre><code>import UIKit import XCPlayground let url = NSURL(string: "http://stackoverflow.com") let request = NSURLRequest(URL: url!) NSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue.currentQueue()) { response, maybeData, error in if let data = maybeData { let contents = NSString(data:data, encoding:NSUTF8StringEncoding) println(contents) } else { println(error.localizedDescription) } } XCPlaygroundPage.currentPage.needsIndefiniteExecution = true </code></pre>
<pre><code>NSURLConnection.sendAsynchronousRequest(...) NSRunLoop.currentRunLoop().run() </code></pre>
<p>As of XCode 7.1, <code>XCPSetExecutionShouldContinueIndefinitely()</code> is deprecated. The correct way to do this now is to first request indefinite execution as a property of the current page:</p> <pre><code>import XCPlayground XCPlaygroundPage.currentPage.needsIndefiniteExecution = true </code></pre> <p>â€¦then indicate when execution has finished with:</p> <pre><code>XCPlaygroundPage.currentPage.finishExecution() </code></pre> <p>For example:</p> <pre><code>import Foundation import XCPlayground XCPlaygroundPage.currentPage.needsIndefiniteExecution = true NSURLSession.sharedSession().dataTaskWithURL(NSURL(string: "http://stackoverflow.com")!) { result in print("Got result: \(result)") XCPlaygroundPage.currentPage.finishExecution() }.resume() </code></pre>
<p>This API changed again in Xcode 8 and it was moved to the <code>PlaygroundSupport</code>:</p> <pre><code>import PlaygroundSupport PlaygroundPage.current.needsIndefiniteExecution = true </code></pre> <p>This change was mentioned in <a href="https://developer.apple.com/videos/play/wwdc2016/213/">Session 213 at WWDC 2016</a>.</p>
<p>The new APIs as for XCode8, Swift3 and iOS 10 are,</p> <pre><code>// import the module import PlaygroundSupport // write this at the beginning PlaygroundPage.current.needsIndefiniteExecution = true // To finish execution PlaygroundPage.current.finishExecution() </code></pre>