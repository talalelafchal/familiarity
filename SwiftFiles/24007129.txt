How does one generate a random number in Apple's Swift language?
<p>I realize the Swift book provided an implementation of a random number generator. Is the best practice to copy and paste this implementation in one's own program? Or is there a library that does this that we can use now?</p>
<p>I've been able to just use <code>rand()</code> to get a random CInt. You can make it an Int by using something like this: </p> <pre><code>let myVar: Int = Int(rand()) </code></pre> <p>You can use your favourite C random function, and just convert to value to Int if needed.</p>
<p>You can do it the same way that you would in C:</p> <pre><code>let randomNumber = arc4random() </code></pre> <p><code>randomNumber</code> is inferred to be of type <code>UInt32</code> (a 32-bit unsigned integer)</p>
<p>Use the standard library functions for high quality random numbers: <code>arc4random()</code> or <code>arc4random_uniform()</code>, just as in Objective-C.</p> <p>They are in the <code>Darwin</code> module, so if you haven't imported <code>AppKit</code>, <code>UIKit</code>, or <code>Foundation</code> (which import it for you), you will need to <code>import Darwin</code>.</p>
<p>Use arc4random_uniform(n) for a random integer between 0 and n-1 </p> <pre><code> let diceRoll = Int(arc4random_uniform(6) + 1) </code></pre> <p>Cast the result to Int so you don't have to explicitly type your vars as UInt32 (which seems un-Swifty)</p>
<p>This method will generate a random <code>Int</code> value between the given minimum and maximum</p> <pre><code>func randomInt(min: Int, max:Int) -&gt; Int { return min + Int(arc4random_uniform(UInt32(max - min + 1))) } </code></pre>
<p><strong>Edit:</strong> <a href="https://gist.github.com/jstn/f9d5437316879c9c448a">Updated for Swift 3.0</a></p> <p><code>arc4random</code> works well in Swift, but the base functions are limited to 32-bit integer types (<code>Int</code> is 64-bit on iPhone 5S and modern Macs). Here's a generic function for a random number of a type expressible by an integer literal:</p> <pre><code>public func arc4random&lt;T: ExpressibleByIntegerLiteral&gt;(_ type: T.Type) -&gt; T { var r: T = 0 arc4random_buf(&amp;r, MemoryLayout&lt;T&gt;.size) return r } </code></pre> <p>We can use this new generic function to extend <code>UInt64</code>, adding boundary arguments and mitigating modulo bias. (This is lifted straight from <a href="http://www.opensource.apple.com/source/Libc/Libc-997.90.3/gen/FreeBSD/arc4random.c">arc4random.c</a>)</p> <pre><code>public extension UInt64 { public static func random(lower: UInt64 = min, upper: UInt64 = max) -&gt; UInt64 { var m: UInt64 let u = upper - lower var r = arc4random(UInt64.self) if u &gt; UInt64(Int64.max) { m = 1 + ~u } else { m = ((max - (u * 2)) + 1) % u } while r &lt; m { r = arc4random(UInt64.self) } return (r % u) + lower } } </code></pre> <p>With that we can extend <code>Int64</code> for the same arguments, dealing with overflow:</p> <pre><code>public extension Int64 { public static func random(lower: Int64 = min, upper: Int64 = max) -&gt; Int64 { let (s, overflow) = Int64.subtractWithOverflow(upper, lower) let u = overflow ? UInt64.max - UInt64(~s) : UInt64(s) let r = UInt64.random(upper: u) if r &gt; UInt64(Int64.max) { return Int64(r - (UInt64(~lower) + 1)) } else { return Int64(r) + lower } } } </code></pre> <p>To complete the family...</p> <pre><code>private let _wordSize = __WORDSIZE public extension UInt32 { public static func random(lower: UInt32 = min, upper: UInt32 = max) -&gt; UInt32 { return arc4random_uniform(upper - lower) + lower } } public extension Int32 { public static func random(lower: Int32 = min, upper: Int32 = max) -&gt; Int32 { let r = arc4random_uniform(UInt32(Int64(upper) - Int64(lower))) return Int32(Int64(r) + Int64(lower)) } } public extension UInt { public static func random(lower: UInt = min, upper: UInt = max) -&gt; UInt { switch (_wordSize) { case 32: return UInt(UInt32.random(UInt32(lower), upper: UInt32(upper))) case 64: return UInt(UInt64.random(UInt64(lower), upper: UInt64(upper))) default: return lower } } } public extension Int { public static func random(lower: Int = min, upper: Int = max) -&gt; Int { switch (_wordSize) { case 32: return Int(Int32.random(Int32(lower), upper: Int32(upper))) case 64: return Int(Int64.random(Int64(lower), upper: Int64(upper))) default: return lower } } } </code></pre> <p>After all that, we can finally do something like this:</p> <pre><code>let diceRoll = UInt64.random(lower: 1, upper: 7) </code></pre>
<p>I used this code:</p> <pre><code>var k: Int = random() % 10; </code></pre>
<pre><code>var randomNumber = Int(arc4random_uniform(UInt32(**5**))) </code></pre> <p>Here 5 will make sure that the random number is generated though zero to five. You can set the value accordingly. </p>
<p>You can use <code>GeneratorOf</code> like this:</p> <pre><code>var fibs = ArraySlice([1, 1]) var fibGenerator = GeneratorOf{ _ -&gt; Int? in fibs.append(fibs.reduce(0, combine:+)) return fibs.removeAtIndex(0) } println(fibGenerator.next()) println(fibGenerator.next()) println(fibGenerator.next()) println(fibGenerator.next()) println(fibGenerator.next()) println(fibGenerator.next()) </code></pre>
<p>I would like to add to existing answers that the random number generator example in the Swift book is a Linear Congruence Generator (LCG), it is a severely limited one and shouldn't be except for the must trivial examples, where quality of randomness doesn't matter at all. And <strong>a LCG should never be used for cryptographic purposes</strong>. </p> <p><code>arc4random()</code> is much better and can be used for most purposes, but again <strong>should not be used for cryptographic purposes.</strong></p> <p>If you want something that is guaranteed to be cryptographically secure, use <code>SecCopyRandomBytes()</code>. Note that if you build a random number generator into something, someone else might end up (mis)-using it for cryptographic purposes (such as password, key or salt generation), then you should consider using <code>SecCopyRandomBytes()</code> anyway, even if your need doesn't quite require that.</p>
<p>As of iOS 9, you can use the new GameplayKit classes to generate random numbers in a variety of ways.</p> <p>You have four source types to choose from: a general random source (unnamed, down to the system to choose what it does), linear congruential, ARC4 and Mersenne Twister. These can generate random ints, floats and bools.</p> <p>At the simplest level, you can generate a random number from the system's built-in random source like this:</p> <pre><code>GKRandomSource.sharedRandom().nextInt() </code></pre> <p>That generates a number between -2,147,483,648 and 2,147,483,647. If you want a number between 0 and an upper bound (exclusive) you'd use this:</p> <pre><code>GKRandomSource.sharedRandom().nextIntWithUpperBound(6) </code></pre> <p>GameplayKit has some convenience constructors built in to work with dice. For example, you can roll a six-sided die like this:</p> <pre><code>let d6 = GKRandomDistribution.d6() d6.nextInt() </code></pre> <p>Plus you can shape the random distribution by using things like GKShuffledDistribution. That takes a little more explaining, but if you're interested you can <a href="http://www.hackingwithswift.com/read/35/overview">read my tutorial on GameplayKit random numbers</a>.</p>
<pre><code>func randomNumForSwift2() throws -&gt; Int{ enum RandomError:ErrorType{ case Error } let bytes :UnsafeMutablePointer&lt;UInt8&gt; = UnsafeMutablePointer&lt;UInt8&gt;.alloc(1024) guard SecRandomCopyBytes(kSecRandomDefault, 1024, bytes) == 0 else{ throw RandomError.Error } return bytes.hashValue } try randomNumForSwift2() </code></pre>
<h1>Use <code>arc4random_uniform()</code></h1> <p><strong>Usage:</strong></p> <p><code>arc4random_uniform(someNumber: UInt32) -&gt; UInt32</code></p> <p>This gives you random integers in the range <code>0</code> to <code>someNumber - 1</code>. </p> <p>The maximum value for <code>UInt32</code> is 4,294,967,295 (that is, <code>2^32 - 1</code>).</p> <p><strong>Examples:</strong></p> <ul> <li><p>Coin flip</p> <pre><code>let flip = arc4random_uniform(2) // 0 or 1 </code></pre></li> <li><p>Dice roll</p> <pre><code>let roll = arc4random_uniform(6) + 1 // 1...6 </code></pre></li> <li><p>Random day in October</p> <pre><code>let day = arc4random_uniform(31) + 1 // 1...31 </code></pre></li> <li><p>Random year in the 1990s</p> <pre><code>let year = 1990 + arc4random_uniform(10) </code></pre></li> </ul> <p><strong>General form:</strong></p> <pre><code>let number = min + arc4random_uniform(max - min + 1) </code></pre> <p>where <code>number</code>, <code>max</code>, and <code>min</code> are <code>UInt32</code>.</p> <h1>What about...</h1> <p><strong>arc4random()</strong></p> <p>You can also get a random number by using <code>arc4random()</code>, which produces a <code>UInt32</code> between 0 and 2^32-1. Thus to get a random number between <code>0</code> and <code>x-1</code>, you can divide it by <code>x</code> and take the remainder. Or in other words, use the <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html">Remainder Operator (%)</a>:</p> <pre><code>let number = arc4random() % 5 // 0...4 </code></pre> <p>However, this produces the slight <a href="http://stackoverflow.com/questions/10984974/why-do-people-say-there-is-modulo-bias-when-using-a-random-number-generator">modulo bias</a> (see also <a href="http://stackoverflow.com/a/29956021/3681880">here</a> and <a href="http://stackoverflow.com/a/17640956/3681880">here</a>), so that is why <code>arc4random_uniform()</code> is recommended.</p> <p><strong>Converting to and from <code>Int</code></strong></p> <p>Normally it would be fine to do something like this in order to convert back and forth between <code>Int</code> and <code>UInt32</code>:</p> <pre><code>let number: Int = 10 let random = Int(arc4random_uniform(UInt32(number))) </code></pre> <p>The problem, though, is that <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html"><code>Int</code></a> has a range of <code>-2,147,483,648...2,147,483,647</code> on 32 bit systems and a range of <code>-9,223,372,036,854,775,808...9,223,372,036,854,775,807</code> on 64 bit systems. Compare this to the <code>UInt32</code> range of <code>0...4,294,967,295</code>. The <code>U</code> of <code>UInt32</code> means <em>unsigned</em>.</p> <p>Consider the following errors:</p> <pre><code>UInt32(-1) // negative numbers cause integer overflow error UInt32(4294967296) // numbers greater than 4,294,967,295 cause integer overflow error </code></pre> <p>So you just need to be sure that your input parameters are within the <code>UInt32</code> range and that you don't need an output that is outside of that range either.</p>
<p>Here is a library that does the job well <a href="https://github.com/thellimist/SwiftRandom">https://github.com/thellimist/SwiftRandom</a></p> <pre><code>public extension Int { /// SwiftRandom extension public static func random(lower: Int = 0, _ upper: Int = 100) -&gt; Int { return lower + Int(arc4random_uniform(UInt32(upper - lower + 1))) } } public extension Double { /// SwiftRandom extension public static func random(lower: Double = 0, _ upper: Double = 100) -&gt; Double { return (Double(arc4random()) / 0xFFFFFFFF) * (upper - lower) + lower } } public extension Float { /// SwiftRandom extension public static func random(lower: Float = 0, _ upper: Float = 100) -&gt; Float { return (Float(arc4random()) / 0xFFFFFFFF) * (upper - lower) + lower } } public extension CGFloat { /// SwiftRandom extension public static func random(lower: CGFloat = 0, _ upper: CGFloat = 1) -&gt; CGFloat { return CGFloat(Float(arc4random()) / Float(UINT32_MAX)) * (upper - lower) + lower } } </code></pre>
<p>Without arc4Random_uniform() in some versions of Xcode(in 7.1 it runs but doesn't autocomplete for me). You can do this instead. </p> <p>To generate a random number from 0-5. First</p> <pre><code>import GameplayKit </code></pre> <p>Then</p> <pre><code>let diceRoll = GKRandomSource.sharedRandom().nextIntWithUpperBound(6) </code></pre>
<p>Example for random number in between 10 (0-9);</p> <pre><code>import UIKit let randomNumber = Int(arc4random_uniform(10)) </code></pre> <p>Very easy code - simple and short.</p>
<pre><code> let MAX : UInt32 = 9 let MIN : UInt32 = 1 func randomNumber() { var random_number = Int(arc4random_uniform(MAX) + MIN) print ("random = ", random_number); } </code></pre>
<p>I use this code to generate a random number: </p> <pre><code>// // FactModel.swift // Collection // // Created by Ahmadreza Shamimi on 6/11/16. // Copyright Â© 2016 Ahmadreza Shamimi. All rights reserved. // import GameKit struct FactModel { let fun = ["I love swift","My name is Ahmadreza","I love coding" ,"I love PHP","My name is ALireza","I love Coding too"] func getRandomNumber() -&gt; String { let randomNumber = GKRandomSource.sharedRandom().nextIntWithUpperBound(fun.count) return fun[randomNumber] } } </code></pre>