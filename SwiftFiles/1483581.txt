Get notified when UITableView has finished asking for data?
<p>Is there some way to find out when a <code>UITableView</code> has finished asking for data from its data source?</p> <p>None of the <code>viewDidLoad</code>/<code>viewWillAppear</code>/<code>viewDidAppear</code> methods of the associated view controller (<code>UITableViewController</code>) are of useÂ here, as they all fire too early. None of them (entirely understandably) guarantee that queries to the data source have finished for the time being (eg, until the view is scrolled).</p> <p>One workaround I have found is to call <code>reloadData</code> in <code>viewDidAppear</code>, since, when <code>reloadData</code> returns, the table view <em>is</em> guaranteed to have finished querying the data source as much as it needs to for the time being.</p> <p>However, this seems rather nasty, as I assume it is causing the data source to be asked for the same information twice (once automatically, and once because of the <code>reloadData</code> call) when it is first loaded.</p> <p>The reason I want to do this at all is that I want to preserve the scroll position of the <code>UITableView</code> - but right down to the pixel level, not just to the nearest row.</p> <p>When restoring the scroll position (using <code>scrollRectToVisible:animated:</code>), I need the table view to already have sufficient data in it, or else the <code>scrollRectToVisible:animated:</code> method call does nothing (which is what happens if you place the call on its own in any of <code>viewDidLoad</code>, <code>viewWillAppear</code> or <code>viewDidAppear</code>).</p>
<p>I had something similar I believe. I added a BOOL as instance variable which tells me if the offset has been restored and check that in <code>-viewWillAppear:</code>. When it has not been restored, I restore it in that method and set the BOOL to indicate that I did recover the offset.</p> <p>It's kind of a hack and it probably can be done better, but this works for me at the moment.</p>
<p>Isn't <code>UITableView</code> <code>layoutSubviews</code> called just before the table view displays it content? I've noticed that it is called once the table view has finished load its data, maybe you should investigate in that direction.</p>
<p><strong>This answer doesn't seem to be working anymore, due to some changes made to UITableView implementation since the answer was written. See this comment : <a href="http://stackoverflow.com/questions/1483581/get-notified-when-uitableview-has-finished-asking-for-data/3060232#comment21063172_3060232">Get notified when UITableView has finished asking for data?</a></strong></p> <p>I've been playing with this problem for a couple of days and think that subclassing <code>UITableView</code>'s <code>reloadData</code> is the best approach :</p> <pre><code>- (void)reloadData { NSLog(@"BEGIN reloadData"); [super reloadData]; NSLog(@"END reloadData"); } </code></pre> <p><code>reloadData</code> doesn't end before the table has finish reload its data. So, when the second <code>NSLog</code> is fired, the table view has actually finish asking for data.</p> <p>I've subclassed <code>UITableView</code> to send methods to the delegate before and after <code>reloadData</code>. It works like a charm.</p>
<p>finally i have made my code work with this - </p> <pre><code>[tableView scrollToRowAtIndexPath:scrollToIndex atScrollPosition:UITableViewScrollPositionTop animated:YES]; </code></pre> <p>there were few things which needed to be taken care of -</p> <ol> <li>call it within "<code>- (UITableViewCell *)MyTableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath</code>" </li> <li>just ensure that "scrollToRowAtIndexPath" message is sent to relevant instance of UITableView, which is definitely MyTableview in this case. </li> <li>In my case UIView is the view which contains instance of UITableView</li> <li>Also, this will be called for every cell load. Therefore, put up a logic inside "cellForRowAtIndexPath" to avoid calling "scrollToRowAtIndexPath" more than once.</li> </ol>
<p>reloadData just asking for data for the visible cells. Says, to be notified when specify portion of your table is loaded, please hook the <code>tableView: willDisplayCell:</code> method. </p> <pre><code>- (void) reloadDisplayData { isLoading = YES; NSLog(@"Reload display with last index %d", lastIndex); [_tableView reloadData]; if(lastIndex &lt;= 0){ isLoading = YES; //Notify completed } - (void) tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath { if(indexPath.row &gt;= lastIndex){ isLoading = NO; //Notify completed } </code></pre>
<p><strong>EDIT: This answer is actually not a solution. It probably appears to work at first because reloading can happen pretty fast, but in fact the completion block doesn't necessarily get called after the data has fully finished reloading - because reloadData doesn't block. You should probably search for a better solution.</strong></p> <p>To expand on @Eric MORAND's answer, lets put a completion block in. Who doesn't love a block?</p> <pre><code>@interface DUTableView : UITableView - (void) reloadDataWithCompletion:( void (^) (void) )completionBlock; @end </code></pre> <p>and...</p> <pre><code>#import "DUTableView.h" @implementation DUTableView - (void) reloadDataWithCompletion:( void (^) (void) )completionBlock { [super reloadData]; if(completionBlock) { completionBlock(); } } @end </code></pre> <p>Usage:</p> <pre><code>[self.tableView reloadDataWithCompletion:^{ //do your stuff here }]; </code></pre>
<p>This is an answer to a slightly different question: I needed to know when <code>UITableView</code> had also finished calling <code>cellForRowAtIndexPath()</code>. I subclassed <code>layoutSubviews()</code> (thanks @Eric MORAND) and added a delegate callback:</p> <p><strong>SDTableView.h:</strong></p> <pre><code>@protocol SDTableViewDelegate &lt;NSObject, UITableViewDelegate&gt; @required - (void)willReloadData; - (void)didReloadData; - (void)willLayoutSubviews; - (void)didLayoutSubviews; @end @interface SDTableView : UITableView @property(nonatomic,assign) id &lt;SDTableViewDelegate&gt; delegate; @end; </code></pre> <p><strong>SDTableView.m:</strong></p> <pre><code>#import "SDTableView.h" @implementation SDTableView @dynamic delegate; - (void) reloadData { [self.delegate willReloadData]; [super reloadData]; [self.delegate didReloadData]; } - (void) layoutSubviews { [self.delegate willLayoutSubviews]; [super layoutSubviews]; [self.delegate didLayoutSubviews]; } @end </code></pre> <p><strong>Usage:</strong></p> <p><strong>MyTableViewController.h:</strong></p> <pre><code>#import "SDTableView.h" @interface MyTableViewController : UITableViewController &lt;SDTableViewDelegate&gt; @property (nonatomic) BOOL reloadInProgress; </code></pre> <p><strong>MyTableViewController.m:</strong></p> <pre><code>#import "MyTableViewController.h" @implementation MyTableViewController @synthesize reloadInProgress; - (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView { if ( ! reloadInProgress) { NSLog(@"---- numberOfSectionsInTableView(): reloadInProgress=TRUE"); reloadInProgress = TRUE; } return 1; } - (void)willReloadData {} - (void)didReloadData {} - (void)willLayoutSubviews {} - (void)didLayoutSubviews { if (reloadInProgress) { NSLog(@"---- layoutSubviewsEnd(): reloadInProgress=FALSE"); reloadInProgress = FALSE; } } </code></pre> <p><strong>NOTES:</strong> Since this is a subclass of <code>UITableView</code> which already has a delegate property pointing to <code>MyTableViewController</code> there's no need to add another one. The "@dynamic delegate" tells the compiler to use this property. (Here's a link describing this: <a href="http://farhadnoorzay.com/2012/01/20/objective-c-how-to-add-delegate-methods-in-a-subclass/" rel="nofollow">http://farhadnoorzay.com/2012/01/20/objective-c-how-to-add-delegate-methods-in-a-subclass/</a>)</p> <p>The <code>UITableView</code> property in <code>MyTableViewController</code> must be changed to use the new <code>SDTableView</code> class. This is done in the Interface Builder Identity Inspector. Select the <code>UITableView</code> inside of the <code>UITableViewController</code> and set its "Custom Class" to <code>SDTableView</code>.</p>
<p>Here's a possible solution, though it's a hack:</p> <pre><code>[self.tableView reloadData]; [self performSelector:@selector(scrollTableView) withObject:nil afterDelay:0.3]; </code></pre> <p>Where your <code>-scrollTableView</code> method scrolls the table view with <code>-scrollRectToVisible:animated:</code>. And, of course, you could configure the delay in the code above from 0.3 to whatever seems to work for you. Yeah, it's ridiculously hacky, but it works for me on my iPhone 5 and 4S...</p>
<p>You can resize your tableview or set it content size in this method when all data loaded:</p> <pre><code>- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath { tableView.frame =CGRectMake(tableView.frame.origin.x, tableView.frame.origin.y, tableView.frame.size.width, tableView.contentSize.height); } </code></pre>
<p>I had found something similar to get notification for change in <code>contentSize</code> of <code>TableView</code>. I think that should work here as well since contentSize also changes with loading data.</p> <p>Try this:</p> <p>In <code>viewDidLoad</code> write,</p> <pre><code>[self.tableView addObserver:self forKeyPath:@"contentSize" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld | NSKeyValueObservingOptionPrior context:NULL]; </code></pre> <p>and add this method to your viewController:</p> <pre><code>- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context { if ([keyPath isEqualToString:@"contentSize"]) { DLog(@"change = %@", change.description) NSValue *new = [change valueForKey:@"new"]; NSValue *old = [change valueForKey:@"old"]; if (new &amp;&amp; old) { if (![old isEqualToValue:new]) { // do your stuff } } } } </code></pre> <p>You might need slight modifications in the check for change. This had worked for me though.</p> <p>Cheers! :)</p>
<p>That is my solution. 100% works and used in many projects. It's a simple UITableView subclass.</p> <pre><code>@protocol MyTableViewDelegate&lt;NSObject, UITableViewDelegate&gt; @optional - (void)tableViewWillReloadData:(UITableView *)tableView; - (void)tableViewDidReloadData:(UITableView *)tableView; @end @interface MyTableView : UITableView { struct { unsigned int delegateWillReloadData:1; unsigned int delegateDidReloadData:1; unsigned int reloading:1; } _flags; } @end @implementation MyTableView - (id&lt;MyTableViewDelegate&gt;)delegate { return (id&lt;MyTableViewDelegate&gt;)[super delegate]; } - (void)setDelegate:(id&lt;MyTableViewDelegate&gt;)delegate { [super setDelegate:delegate]; _flags.delegateWillReloadData = [delegate respondsToSelector:@selector(tableViewWillReloadData:)]; _flags.delegateDidReloadData = [delegate respondsToSelector:@selector(tableViewDidReloadData:)]; } - (void)reloadData { [super reloadData]; if (_flags.reloading == NO) { _flags.reloading = YES; if (_flags.delegateWillReloadData) { [(id&lt;MyTableViewDelegate&gt;)self.delegate tableViewWillReloadData:self]; } [self performSelector:@selector(finishReload) withObject:nil afterDelay:0.0f]; } } - (void)finishReload { _flags.reloading = NO; if (_flags.delegateDidReloadData) { [(id&lt;MyTableViewDelegate&gt;)self.delegate tableViewDidReloadData:self]; } } @end </code></pre> <p>It's similar to <a href="http://stackoverflow.com/a/14879593/347339">Josh Brown's solution</a> with one exception. No delay is needed in performSelector method. <strong>No matter how long <code>reloadData</code> takes. <code>tableViewDidLoadData:</code> always fires when <code>tableView</code> finishes asking <code>dataSource</code> <code>cellForRowAtIndexPath</code>.</strong> </p> <p>Even if you do not want to subclass <code>UITableView</code> you can simply call <code>[performSelector:@selector(finishReload) withObject:nil afterDelay:0.0f]</code> and your selector will be called right after the table finishes reloading. But you should ensure that selector is called only once per call to <code>reloadData</code>:</p> <pre><code>[self.tableView reloadData]; [self performSelector:@selector(finishReload) withObject:nil afterDelay:0.0f]; </code></pre> <p>Enjoy. :)</p>
<p>You can try the following logic:</p> <pre><code>-(UITableViewCell *) tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"MyIdentifier"]; if (cell == nil) { cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:@"MyIdentifier"]; cell.selectionStyle = UITableViewCellSelectionStyleNone; } if ( [self chkIfLastCellIndexToCreate:tableView :indexPath]){ NSLog(@"Created Last Cell. IndexPath = %@", indexPath); //[self.activityIndicator hide]; //Do the task for TableView Loading Finished } prevIndexPath = indexPath; return cell; } -(BOOL) chkIfLastCellIndexToCreate:(UITableView*)tableView : (NSIndexPath *)indexPath{ BOOL bRetVal = NO; NSArray *visibleIndices = [tableView indexPathsForVisibleRows]; if (!visibleIndices || ![visibleIndices count]) bRetVal = YES; NSIndexPath *firstVisibleIP = [visibleIndices objectAtIndex:0]; NSIndexPath *lastVisibleIP = [visibleIndices objectAtIndex:[visibleIndices count]-1]; if ((indexPath.row &gt; prevIndexPath.row) &amp;&amp; (indexPath.section &gt;= prevIndexPath.section)){ //Ascending - scrolling up if ([indexPath isEqual:lastVisibleIP]) { bRetVal = YES; //NSLog(@"Last Loading Cell :: %@", indexPath); } } else if ((indexPath.row &lt; prevIndexPath.row) &amp;&amp; (indexPath.section &lt;= prevIndexPath.section)) { //Descending - scrolling down if ([indexPath isEqual:firstVisibleIP]) { bRetVal = YES; //NSLog(@"Last Loading Cell :: %@", indexPath); } } return bRetVal; } </code></pre> <p>And before you call reloadData, set prevIndexPath to nil. Like:</p> <pre><code>prevIndexPath = nil; [mainTableView reloadData]; </code></pre> <p>I tested with NSLogs, and this logic seems ok. You may customise/improve as needed.</p>
<p>It sounds like you want to update cell content, but without the sudden jumps that can accompany cell insertions and deletions.</p> <p>There are several articles on doing that. <a href="http://stackoverflow.com/questions/4279730/keep-uitableview-static-when-inserting-rows-at-the-top/9121544#9121544">This is one.</a></p> <p>I suggest using setContentOffset:animated: instead of scrollRectToVisible:animated: for pixel-perfect settings of a scroll view.</p>
<p>I just run repeating scheduled timer and invalidate it only when table's contentSize is bigger when tableHeaderView height (means there is rows content in the table). The code in C# (monotouch), but I hope the idea is clear:</p> <pre><code> public override void ReloadTableData() { base.ReloadTableData(); // don't do anything if there is no data if (ItemsSource != null &amp;&amp; ItemsSource.Length &gt; 0) { _timer = NSTimer.CreateRepeatingScheduledTimer(TimeSpan.MinValue, new NSAction(() =&gt; { // make sure that table has header view and content size is big enought if (TableView.TableHeaderView != null &amp;&amp; TableView.ContentSize.Height &gt; TableView.TableHeaderView.Frame.Height) { TableView.SetContentOffset( new PointF(0, TableView.TableHeaderView.Frame.Height), false); _timer.Invalidate(); _timer = null; } })); } } </code></pre>
<p>Why no just extend?</p> <pre><code>@interface UITableView(reloadComplete) - (void) reloadDataWithCompletion:( void (^) (void) )completionBlock; @end @implementation UITableView(reloadComplete) - (void) reloadDataWithCompletion:( void (^) (void) )completionBlock { [self reloadData]; if(completionBlock) { completionBlock(); } } @end </code></pre> <p>scroll to the end:</p> <pre><code>[self.table reloadDataWithCompletion:^{ NSInteger numberOfRows = [self.table numberOfRowsInSection:0]; if (numberOfRows &gt; 0) { NSIndexPath *indexPath = [NSIndexPath indexPathForRow:numberOfRows-1 inSection:0]; [self.table scrollToRowAtIndexPath:indexPath atScrollPosition:UITableViewScrollPositionTop animated:NO]; } }]; </code></pre> <p>Not tested with a lot of data</p>
<p>I did have a same scenario in my app and thought would post my answer to you guys as other answers mentioned here does not work for me for iOS7 and later</p> <p>Finally this is the only thing that worked out for me.</p> <pre><code>[yourTableview reloadData]; dispatch_async(dispatch_get_main_queue(),^{ NSIndexPath *path = [NSIndexPath indexPathForRow:yourRow inSection:yourSection]; //Basically maintain your logic to get the indexpath [yourTableview scrollToRowAtIndexPath:path atScrollPosition:UITableViewScrollPositionTop animated:YES]; }); </code></pre> <p><strong>Swift Update:</strong></p> <pre><code>yourTableview.reloadData() dispatch_async(dispatch_get_main_queue(), { () -&gt; Void in let path : NSIndexPath = NSIndexPath(forRow: myRowValue, inSection: mySectionValue) //Basically maintain your logic to get the indexpath yourTableview.scrollToRowAtIndexPath(path, atScrollPosition: UITableViewScrollPosition.Top, animated: true) }) </code></pre> <p>So how this works.</p> <p>Basically when you do a reload the main thread becomes busy so at that time when we do a dispatch async thread, the block will wait till the main thread gets finished. So once the tableview has been loaded completely the main thread will gets finish and so it will dispatch our method block</p> <p><strong>Tested in iOS7 and iOS8</strong> and it works awesome;)</p> <p><strong>Update for iOS9:</strong> This just works fine is iOS9 also. I have created a sample project in github as a POC. <a href="https://github.com/ipraba/TableReloadingNotifier" rel="nofollow noreferrer">https://github.com/ipraba/TableReloadingNotifier</a></p> <p>I am attaching the screenshot of my test here.</p> <p>Tested Environment: iOS9 iPhone6 simulator from Xcode7</p> <p><a href="https://i.stack.imgur.com/P7D1t.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/P7D1t.png" alt="enter image description here"></a></p>
<p>Since iOS 6 onwards, the <code>UITableview</code> delegate method called:</p> <pre><code>-(void)tableView:(UITableView *)tableView willDisplayHeaderView:(UIView *)view forSection:(NSInteger)section </code></pre> <p>will execute once your table reloads successfully. You can do customisation as required in this method.</p>
<p>The best solution I've found in Swift</p> <pre><code>extension UITableView { func reloadData(completion: ()-&gt;()) { self.reloadData() dispatch_async(dispatch_get_main_queue()) { completion() } } } </code></pre>