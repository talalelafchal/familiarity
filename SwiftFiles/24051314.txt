Precision String Format Specifier In Swift
<p>Below is how I would have previously truncated a float to two decimal places</p> <pre><code>NSLog(@" %.02f %.02f %.02f", r, g, b); </code></pre> <p>I checked the docs and the eBook but haven't been able to figure it out. Thanks!</p>
<p>You can't do it (yet) with string interpolation. Your best bet is still going to be NSString formatting:</p> <pre><code>println(NSString(format:"%.2f", sqrt(2.0))) </code></pre> <p>Extrapolating from python, it seems like a reasonable syntax might be:</p> <pre><code>@infix func % (value:Double, format:String) -&gt; String { return NSString(format:format, value) } </code></pre> <p>Which then allows you to use them as:</p> <pre><code>M_PI % "%5.3f" // "3.142" </code></pre> <p>You can define similar operators for all of the numeric types, unfortunately I haven't found a way to do it with generics.</p>
<p>My best solution so far, following from <a href="http://stackoverflow.com/a/24052438/1519522">David's response</a>:</p> <pre><code>import Foundation extension Int { func format(f: String) -&gt; String { return String(format: "%\(f)d", self) } } extension Double { func format(f: String) -&gt; String { return String(format: "%\(f)f", self) } } let someInt = 4, someIntFormat = "03" println("The integer number \(someInt) formatted with \"\(someIntFormat)\" looks like \(someInt.format(someIntFormat))") // The integer number 4 formatted with "03" looks like 004 let someDouble = 3.14159265359, someDoubleFormat = ".3" println("The floating point number \(someDouble) formatted with \"\(someDoubleFormat)\" looks like \(someDouble.format(someDoubleFormat))") // The floating point number 3.14159265359 formatted with ".3" looks like 3.142 </code></pre> <p>I think this is the most Swift-like solution, tying the formatting operations directly to the data type. It may well be that there is a built-in library of formatting operations somewhere, or maybe it will be released soon. Keep in mind that the language is still in beta.</p>
<p>The answers given so far that have received the most votes are relying on NSString methods and are going to require that you have imported Foundation.</p> <p>Having done that, though, you <em>still</em> have access to NSLog.</p> <p>So I think the answer to the question, if you are asking how to continue using NSLog in Swift, is simply:</p> <p><code>import Foundation</code></p>
<p>a simple way is:</p> <pre><code>println(String(format: "hex string: %X", 123456)) println(String(format: "a float number: %.5f", 1.0321)) </code></pre>
<p>A more elegant and generic solution is to rewrite ruby / python <code>%</code> operator:</p> <pre><code>// Updated for beta 5 func %(format:String, args:[CVarArgType]) -&gt; String { return NSString(format:format, arguments:getVaList(args)) } "Hello %@, This is pi : %.2f" % ["World", M_PI] </code></pre>
<p>here a "pure" swift solution</p> <pre><code> var d = 1.234567 operator infix ~&gt; {} @infix func ~&gt; (left: Double, right: Int) -&gt; String { if right == 0 { return "\(Int(left))" } var k = 1.0 for i in 1..right+1 { k = 10.0 * k } let n = Double(Int(left*k)) / Double(k) return "\(n)" } println("\(d~&gt;2)") println("\(d~&gt;1)") println("\(d~&gt;0)") </code></pre>
<p>You can still use NSLog in Swift as in Objective-C just without the @ sign.</p> <pre><code>NSLog("%.02f %.02f %.02f", r, g, b) </code></pre> <p><strong>Edit:</strong> After working with Swift since a while I would like to add also this variation</p> <pre><code> var r=1.2 var g=1.3 var b=1.4 NSLog("\(r) \(g) \(b)") </code></pre> <p>Output:</p> <pre><code>2014-12-07 21:00:42.128 MyApp[1626:60b] 1.2 1.3 1.4 </code></pre>
<pre><code>@infix func ^(left:Double, right: Int) -&gt; NSNumber { let nf = NSNumberFormatter() nf.maximumSignificantDigits = Int(right) return nf.numberFromString(nf.stringFromNumber(left)) } let r = 0.52264 let g = 0.22643 let b = 0.94837 println("this is a color: \(r^3) \(g^3) \(b^3)") // this is a color: 0.523 0.226 0.948 </code></pre>
<p>You can also create an operator in this way </p> <pre><code>operator infix &lt;- {} func &lt;- (format: String, args:[CVarArg]) -&gt; String { return String(format: format, arguments: args) } let str = "%d %.1f" &lt;- [1453, 1.123] </code></pre>
<p>I found <code>String.localizedStringWithFormat</code> to work quite well:</p> <p>Example:</p> <pre><code>let value: Float = 0.33333 let unit: String = "mph" yourUILabel.text = String.localizedStringWithFormat("%.2f %@", value, unit) </code></pre>
<p>Also with rounding:</p> <pre><code>extension Float { func format(f: String) -&gt; String { return NSString(format: "%\(f)f", self) } mutating func roundTo(f: String) { self = NSString(format: "%\(f)f", self).floatValue } } extension Double { func format(f: String) -&gt; String { return NSString(format: "%\(f)f", self) } mutating func roundTo(f: String) { self = NSString(format: "%\(f)f", self).doubleValue } } x = 0.90695652173913 x.roundTo(".2") println(x) //0.91 </code></pre>
<p>Most answers here are valid. However, in case you will format the number often, consider extending the Float class to add a method that returns a formatted string. See example code below. This one achieves the same goal by using a number formatter and extension.</p> <pre><code>extension Float { func string(fractionDigits:Int) -&gt; String { let formatter = NSNumberFormatter() formatter.minimumFractionDigits = fractionDigits formatter.maximumFractionDigits = fractionDigits return formatter.stringFromNumber(self) ?? "\(self)" } } let myVelocity:Float = 12.32982342034 println("The velocity is \(myVelocity.string(2))") println("The velocity is \(myVelocity.string(1))") </code></pre> <p>The console shows:</p> <pre><code>The velocity is 12.33 The velocity is 12.3 </code></pre>
<p>I don't know about <em>two</em> decimal places, but here's how you can print floats with zero decimal places, so I'd imagine that can be 2 place, 3, places ... (Note: you <em>must</em> convert CGFloat to Double to pass to String(format:) or it will see a value of zero)</p> <pre><code>func logRect(r: CGRect, _ title: String = "") { println(String(format: "[ (%.0f, %.0f), (%.0f, %.0f) ] %@", Double(r.origin.x), Double(r.origin.y), Double(r.size.width), Double(r.size.height), title)) } </code></pre>
<p>@Christian Dietrich:</p> <p>instead of:</p> <pre><code>var k = 1.0 for i in 1...right+1 { k = 10.0 * k } let n = Double(Int(left*k)) / Double(k) return "\(n)" </code></pre> <p>it could also be:</p> <pre><code>let k = pow(10.0, Double(right)) let n = Double(Int(left*k)) / k return "\(n)" </code></pre> <p><em>[correction:]</em> Sorry for confusion* - Of course this works with Doubles. I think, most practical (if you want digits to be rounded, not cut off) it would be something like that:</p> <pre><code>infix operator ~&gt; {} func ~&gt; (left: Double, right: Int) -&gt; Double { if right &lt;= 0 { return round(left) } let k = pow(10.0, Double(right)) return round(left*k) / k } </code></pre> <p><em>For Float only, simply replace Double with Float, pow with powf and round with roundf.</em><br> <strong>Update:</strong> I found that it is most practical to use return type Double instead of String. It works the same for String output, i.e.: </p> <pre><code>println("Pi is roughly \(3.1415926 ~&gt; 3)") </code></pre> <p>prints: Pi is roughly 3.142<br> So you can use it the same way for Strings (you can even still write: println(d ~> 2)), but additionally you can also use it to round values directly, i.e.: </p> <pre><code>d = Double(slider.value) ~&gt; 2 </code></pre> <p>or whatever you need â€¦</p>
<p>Why make it so complicated? You can use this instead:</p> <pre><code>import UIKit let PI = 3.14159265359 round( PI ) // 3.0 rounded to the nearest decimal round( PI * 100 ) / 100 //3.14 rounded to the nearest hundredth round( PI * 1000 ) / 1000 // 3.142 rounded to the nearest thousandth </code></pre> <p>See it work in Playground.</p> <p><strong>PS:</strong> Solution from: <a href="http://rrike.sh/xcode/rounding-various-decimal-places-swift/">http://rrike.sh/xcode/rounding-various-decimal-places-swift/</a></p>
<p>use below method</p> <pre><code>let output = String.localizedStringWithFormat(" %.02f %.02f %.02f", r, g, b) println(output) </code></pre>
<p>Swift2 example: Screen width of iOS device formatting the Float removing the decimal</p> <pre><code>print(NSString(format: "Screen width = %.0f pixels", CGRectGetWidth(self.view.frame))) </code></pre>
<p>A version of Vincent Guerci's ruby / python % operator, updated for Swift 2.1:</p> <pre><code>func %(format:String, args:[CVarArgType]) -&gt; String { return String(format:format, arguments:args) } "Hello %@, This is pi : %.2f" % ["World", M_PI] </code></pre>
<p>This is a <strong>very fast</strong> and <strong>simple</strong> way who doesn't need complex solution.</p> <pre><code>let duration = String(format: "%.01f", 3.32323242) // result = 3.3 </code></pre>
<p>Power of extension</p> <pre><code>extension Double { var asNumber:String { if self &gt;= 0 { var formatter = NSNumberFormatter() formatter.numberStyle = .NoStyle formatter.percentSymbol = "" formatter.maximumFractionDigits = 1 return "\(formatter.stringFromNumber(self)!)" } return "" } } let velocity:Float = 12.32982342034 println("The velocity is \(velocity.toNumber)") </code></pre> <p>Output: The velocity is 12.3</p>
<pre><code>extension Double { func formatWithDecimalPlaces(decimalPlaces: Int) -&gt; Double { let formattedString = NSString(format: "%.\(decimalPlaces)f", self) as String return Double(formattedString)! } } 1.3333.formatWithDecimalPlaces(2) </code></pre>
<p>less typing way:</p> <pre><code>func fprint(format: String, _ args: CVarArgType...) { print(NSString(format: format, arguments: getVaList(args))) } </code></pre>
<pre><code>import Foundation extension CGFloat { var string1: String { return String(format: "%.1f", self) } var string2: String { return String(format: "%.2f", self) } } </code></pre> <h1>Usage</h1> <pre><code>let offset = CGPoint(1.23, 4.56) print("offset: \(offset.x.string1) x \(offset.y.string1)") // offset: 1.2 x 4.6 </code></pre>