Crash when casting the result of arc4random() to Int
<p>I've written a simple Bag class. A Bag is filled with a fixed ratio of Temperature enums. It allows you to grab one at random and automatically refills itself when empty. It looks like this:</p> <pre><code>class Bag { var items = Temperature[]() init () { refill() } func grab()-&gt; Temperature { if items.isEmpty { refill() } var i = Int(arc4random()) % items.count return items.removeAtIndex(i) } func refill() { items.append(.Normal) items.append(.Hot) items.append(.Hot) items.append(.Cold) items.append(.Cold) } } </code></pre> <p>The Temperature enum looks like this:</p> <pre><code>enum Temperature: Int { case Normal, Hot, Cold } </code></pre> <p>My <code>GameScene:SKScene</code> has a constant instance property <code>bag:Bag</code>. (I've tried with a variable as well.) When I need a new temperature I call <code>bag.grab()</code>, once in <code>didMoveToView</code> and when appropriate in <code>touchesEnded</code>. </p> <p>Randomly this call crashes on the <code>if items.isEmpty</code> line in <code>Bag.grab()</code>. The error is <code>EXC_BAD_INSTRUCTION</code>. Checking the debugger shows items is <code>size=1</code> and <code>[0] = (AppName.Temperature) &lt;invalid&gt; (0x10)</code>.</p> <p><strong>Edit</strong> Looks like I don't understand the debugger info. Even valid arrays show <code>size=1</code> and unrelated values for <code>[0] =</code>. So no help there.</p> <p>I can't get it to crash isolated in a Playground. It's probably something obvious but I'm stumped.</p>
<p>I found that the best way to solve this is by using rand() instead of arc4random()</p> <p>the code, in your case, could be:</p> <pre><code>var i = Int(rand()) % items.count </code></pre>
<p>Function <code>arc4random</code> returns an <code>UInt32</code>. If you get a value higher than <code>Int.max</code>, the <code>Int(...)</code> cast will crash.</p> <p>Using</p> <pre><code>Int(arc4random_uniform(UInt32(items.count))) </code></pre> <p>should be a better solution.</p> <p>(Blame the strange crash messages in the Alpha version...)</p>
<p>This method will generate a random <code>Int</code> value between the given minimum and maximum</p> <pre><code>func randomInt(min: Int, max:Int) -&gt; Int { return min + Int(arc4random_uniform(UInt32(max - min + 1))) } </code></pre> <p>The crash that you were experiencing is due to the fact that Swift detected a type inconsistency at runtime. Since Int != UInt32 you will have to first type cast the input argument of arc4random_uniform before you can compute the random number.</p>
<p>This will automatically create a random Int for you: </p> <pre><code>var i = random() % items.count </code></pre> <p>i is of Int type, so no conversion necessary!</p>
<p>You can use</p> <pre><code>Int(rand()) </code></pre> <p>To prevent same random numbers when the app starts, you can call <strong>srand()</strong></p> <pre><code>srand(UInt32(NSDate().timeIntervalSinceReferenceDate)) let randomNumber: Int = Int(rand()) % items.count </code></pre>
<p>Swift doesn't allow to cast from one integer type to another if the result of the cast doesn't fit. E.g. the following code will work okay:</p> <pre><code>let x = 32 let y = UInt8(x) </code></pre> <p>Why? Because 32 is a possible value for an int of type <code>UInt8</code>. But the following code will fail:</p> <pre><code>let x = 332 let y = UInt8(x) </code></pre> <p>That's because you cannot assign 332 to an unsigned 8 bit int type, it can only take values 0 to 255 and nothing else.</p> <p>When you do casts in C, the int is simply truncated, which may be unexpected or undesired, as the programmer may not be aware that truncation may take place. So Swift handles things a bit different here. It will allow such kind of casts as long as no truncation takes place but if there is truncation, you get a runtime exception. If you think truncation is okay, then you must do the truncation yourself to let Swift know that this is intended behavior, otherwise Swift must assume that is accidental behavior.</p> <p>This is even documented (documentation of <code>UnsignedInteger</code>):</p> <blockquote> <p>Convert from Swift's widest unsigned integer type, <em>trapping on overflow.</em></p> </blockquote> <p>And what you see is the "overflow trapping", which is poorly done as, of course, one could have made that trap actually explain what's going on.</p> <p>Assuming that <code>items</code> never has more than 2^32 elements (a bit more than 4 billion), the following code is safe:</p> <pre><code>var i = Int(arc4random() % UInt32(items.count)) </code></pre> <p>If it can have more than 2^32 elements, you get another problem anyway as then you need a different random number function that produces random numbers beyond 2^32.</p>