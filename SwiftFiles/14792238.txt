UIView's border color in Interface builder doesn't work?
<p>I am trying to set up a view's layer properties via IB. Everything works except for color of the border (property <code>layer.borderColor</code>):</p> <p><img src="https://i.stack.imgur.com/97wu2.png" alt="enter image description here"></p> <p>I remember running into this problem a year ago and I ended up doing it programatically. And still, I can do this programmatically, but I am curious why the <code>layer.borderColor</code>property never works via interface builder. I don't want to import <code>QuartzCore</code>, and then write extra line of code just because of this, seems like an overkill. </p>
<p>I think it may be because you have masksToBounds set to YES. I don't think the border is drawn within the bounds of the layer, so it won't be drawn since you're hiding everything outside of its bounds. </p>
<p>It's possible to do this, but it's not a built-in feature. This is because the <code>Color</code> type in the User Defined Runtime Attributes panel creates a <code>UIColor</code>, but <code>layer.borderColor</code> holds a <code>CGColorRef</code> type. Unfortunately, there's no way to assign a <code>CGColorRef</code> type in Interface Builder.</p> <p>However, this is possible through a proxy property. See <a href="http://stackoverflow.com/a/17993890/770938">Peter DeWeese's answer</a> to a different question for a possible solution to this problem. His answer defines a category that allows a proxy color to be set through Interface Builder.</p>
<p>Here's a quick way to overcome this. Categories...</p> <pre><code>@interface UIView (IBAppearance) @property (nonatomic, strong) UIColor *borderColor; @end </code></pre> <p>You don't have to store it, it's just nice so you can query later. The important thing is taking the value and assigning the UIColor's CGColor to the layer.</p> <pre><code>#import &lt;objc/runtime.h&gt; #define BORDER_COLOR_KEYPATH @"borderColor" @implementation UIView (IBAppearance) - (void)setBorderColor:(UIColor *)borderColor { UIColor *bc = objc_getAssociatedObject(self, BORDER_COLOR_KEYPATH); if(bc == borderColor) return; else { objc_setAssociatedObject(self, BORDER_COLOR_KEYPATH, borderColor, OBJC_ASSOCIATION_RETAIN_NONATOMIC); self.layer.borderColor = [borderColor CGColor]; } } - (UIColor *)borderColor { return objc_getAssociatedObject(self, BORDER_COLOR_KEYPATH); } @end </code></pre> <p>Of course, in the Interface Builder you're not setting the value on <code>layer.borderColor</code>, rather just on <code>borderColor</code>.</p>
<p>In order to make CALayer KVC-compliant for the property borderColorFromUIColor, simply implement the </p> <pre><code>layer.borderColorFromUIColor=[UIColor red]; </code></pre> <p><a href="http://ios-blog.co.uk/tutorials/user-defined-runtime-attributes/" rel="nofollow">This link have awnser</a></p>
<p>You have to create Category for CALayer:</p> <p><strong>CALayer+UIColor.h</strong></p> <pre><code>#import &lt;QuartzCore/QuartzCore.h&gt; #import &lt;UIKit/UIKit.h&gt; @interface CALayer(UIColor) // This assigns a CGColor to borderColor. @property(nonatomic, assign) UIColor* borderUIColor; @end </code></pre> <p><strong>CALayer+UIColor.m</strong></p> <pre><code>#import "CALayer+UIColor.h" @implementation CALayer(UIColor) - (void)setBorderUIColor:(UIColor*)color { self.borderColor = color.CGColor; } - (UIColor*)borderUIColor { return [UIColor colorWithCGColor:self.borderColor]; } @end </code></pre> <p>And then in <strong>User Defined Runtime attributes</strong> You can use it as it is on image below:</p> <p><img src="https://i.stack.imgur.com/6V9s4.png" alt="enter image description here"></p> <p>For <strong>Swift</strong> it is much more simple:</p> <pre><code>@IBInspectable var borderColor: UIColor? { didSet { layer.borderColor = borderColor?.CGColor layer.borderWidth = 1 } } </code></pre> <p>Then in Xcode you can use it like this:</p> <p><img src="https://i.stack.imgur.com/mZ4zv.png" alt="enter image description here"></p> <p>Once you choose sth it is automatically added to your <strong>runtime attributes</strong>:</p>
<p>My two cents for porting Bartłomiej Semańczyk's answer to Swift:</p> <p>Create an extension for CALayer in your view controller:</p> <pre><code>import UIKit extension CALayer { func borderUIColor() -&gt; UIColor? { return borderColor != nil ? UIColor(CGColor: borderColor!) : nil } func setBorderUIColor(color: UIColor) { borderColor = color.CGColor } } </code></pre>
<p>In Swift, you can extend the <code>UIButton</code> class and add an <code>@IBInspectable</code> that will enable you to select a color from storyboard and set it's color (with width of 1 which can be changed). Add this at the end of your view controller:</p> <pre><code>extension UIButton{ @IBInspectable var borderColor: UIColor? { get { return UIColor(CGColor: layer.borderColor!) } set { layer.borderColor = newValue?.CGColor layer.borderWidth = 1 } } } </code></pre>
<p>Use IBDesignable instead of Runtime Attributes it is more clear.</p> <p>Put this code in any class and edit the properties direct on the storyboard.</p> <pre><code>import UIKit @IBDesignable extension UIView { @IBInspectable var borderColor:UIColor? { set { layer.borderColor = newValue!.CGColor } get { if let color = layer.borderColor { return UIColor(CGColor:color) } else { return nil } } } @IBInspectable var borderWidth:CGFloat { set { layer.borderWidth = newValue } get { return layer.borderWidth } } @IBInspectable var cornerRadius:CGFloat { set { layer.cornerRadius = newValue clipsToBounds = newValue &gt; 0 } get { return layer.cornerRadius } } } </code></pre>
<p>I met the same issue, I worked around it by creating a custom button class:</p> <pre><code>class UIButtonWithRoundBorder: UIButton { required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) self.layer.cornerRadius = 6 self.layer.borderWidth = 1 self.layer.borderColor = UIColor.whiteColor().CGColor self.clipsToBounds = true } } </code></pre> <p>Then in IB, change the type from "UIButton" to "UIButtonWithRoundBorder".</p> <p>Simple and handy too. :)</p>
<p>Cut and Paste this class:</p> <pre><code>import UIKit @IBDesignable class CustomView : UIView { @IBInspectable var borderColor: UIColor = UIColor.clearColor() { didSet { layer.borderColor = borderColor.CGColor } } @IBInspectable var borderWidth: CGFloat = 0 { didSet { layer.borderWidth = borderWidth } } @IBInspectable var cornerRadius: CGFloat = 0 { didSet { layer.cornerRadius = cornerRadius } } } </code></pre> <p>Now in Interface Builder, go to the Identity inspector and set your view as a CustomView class.</p> <p>Now checkout out your Attributes Inspector: <a href="https://i.stack.imgur.com/O2ICM.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/O2ICM.png" alt="enter image description here"></a></p> <p>No need to mess around with user defined runtime attributes anymore. And your changes will also show up on the canvas!!!</p>