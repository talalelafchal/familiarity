Running into compiler errors when using generics
<p>While trying to work on a small Swift project, I often ran into the following compiler error:</p> <pre><code>var item : T? ^ LLVM ERROR: unimplemented IRGen feature! non-fixed class layout </code></pre> <p>The code producing such an error is utterly simple:</p> <pre><code>class Foo&lt;T&gt; { var item : T? } </code></pre> <p>Interestingly, if you change from a <code>class</code> to a <code>struct</code>, everything compiles fine. </p> <p>Can anyone else verify this, so I can get back to blame it on a not-yet-complete compiler and not some strange mixup in my compiler toolchains?</p> <p><strong>Update:</strong></p> <p>Trying to outsmart the obviously buggy compiler with the following alternative implementation results in even more hilarious compiler errors. For example the following</p> <pre><code>class Foo&lt;T&gt; { // Let's try with an inner struct struct OptionalWrapper { var item: T? } var item : OptionalWrapper init(item: T?) { self.item = OptionalWrapper(item: item) } } </code></pre> <p>gives</p> <pre><code>0 swift 0x000000011075a608 llvm::sys::PrintStackTrace(__sFILE*) + 40 1 swift 0x000000011075aaf4 SignalHandler(int) + 452 2 libsystem_platform.dylib 0x00007fff901095aa _sigtramp + 26 3 libsystem_platform.dylib 0x0000000111b5ba00 _sigtramp + 2175083632 4 swift 0x0000000110a54a67 swift::BoundGenericType::getSubstitutions(swift::Module*, swift::LazyResolver*) + 55 5 swift 0x000000010fb696a9 emitNominalMetadataRef(swift::irgen::IRGenFunction&amp;, swift::NominalTypeDecl*, swift::CanType) + 537 6 swift 0x000000010fb5841c llvm::Value* swift::CanTypeVisitor&lt;(anonymous namespace)::EmitTypeMetadataRef, llvm::Value*&gt;::visit&lt;&gt;(swift::CanType) + 124 7 swift 0x000000010fb58395 swift::irgen::IRGenFunction::emitTypeMetadataRef(swift::CanType) + 21 8 swift 0x000000010fb9b7e9 swift::irgen::WitnessSizedTypeInfo&lt;(anonymous namespace)::NonFixedStructTypeInfo&gt;::allocateStack(swift::irgen::IRGenFunction&amp;, swift::CanType, llvm::Twine const&amp;) const + 89 9 swift 0x000000010fbc81a2 swift::SILVisitor&lt;(anonymous namespace)::IRGenSILFunction, void&gt;::visit(swift::ValueBase*) + 34626 10 swift 0x000000010fbbf266 swift::irgen::IRGenModule::emitSILFunction(swift::SILFunction*) + 8678 11 swift 0x000000010fb406f8 swift::irgen::IRGenModule::emitGlobalTopLevel() + 184 12 swift 0x000000010fbac6e3 performIRGeneration(swift::IRGenOptions&amp;, swift::Module*, swift::SILModule*, llvm::StringRef, llvm::LLVMContext&amp;, swift::SourceFile*, unsigned int) + 1859 13 swift 0x000000010fbad033 swift::performIRGeneration(swift::IRGenOptions&amp;, swift::SourceFile&amp;, swift::SILModule*, llvm::StringRef, llvm::LLVMContext&amp;, unsigned int) + 51 14 swift 0x000000010fb1f65a frontend_main(llvm::ArrayRef&lt;char const*&gt;, char const*, void*) + 4842 15 swift 0x000000010fb1e35d main + 1533 16 libdyld.dylib 0x00007fff8b2d05fd start + 1 17 libdyld.dylib 0x0000000000000040 start + 1959983684 </code></pre> <p>and changing <code>struct OptionalWrapper</code> to <code>struct OptionalWrapper&lt;T&gt;</code> even makes the swift compiler being seemingly stuck in an endless loop (you still can cancel it with the stop button in XCode for example).</p> <p>So my current recommendation is: <em>stay clear of Swift generics in <code>class</code>es for now, this seems to be highly unstable terrainâ€¦</em></p>
<p>I was able to get it to stop crashing and actually work by adding <code>NSObject</code> constraint to <code>T</code>:</p> <pre><code>class Widget&lt;T:NSObject&gt; { var value : T? init(value:T?) { self.value = value } func description() -&gt; String { let valueType = value?.self return "Widget is a \(valueType?.className)" } } let stringWidget = Widget(value:"Hello") let numericWidget = Widget(value:9001) let doubleWidget = Widget(value:3.14159) let arrayWidget = Widget(value:[0xFEED, 0xBEEF, 0xCAFE]) stringWidget.description() numericWidget.description() doubleWidget.description() arrayWidget.description() </code></pre> <p>That said, I do believe the playground and compiler have many bugs including the behavior you are experiencing. </p> <p>I was also unable to make 'widgetception' by creating a <code>Widget(value:Widget(value:x))</code>.</p>
<p>I prefer the constraint <code>: AnyObject</code> (no import required), but B <strong>must</strong> refer to a class.</p> <pre><code>// import Foundation class A &lt;B: AnyObject&gt; { let it: B; init(_ b: B) { it = b } } class C { let DCI = 601 } println( A(C()).it.DCI ) // 601 </code></pre>