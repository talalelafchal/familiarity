Printing a variable memory address in swift
<p>Is there anyway to simulate the <code>[NSString stringWithFormat:@"%p", myVar]</code> code in the new swift language ?</p> <p>For example:</p> <pre><code>let str = "A String" println(" str value \(str) has address: ?") </code></pre>
<p>Note that this answer was quite old. Many of the methods it describes no longer work. Specifically <code>.core</code> cannot be accessed anymore. </p> <p>However @drew's answer is correct and simple:</p> <blockquote> <p>This is now part of the standard library: unsafeAddressOf.</p> </blockquote> <p>So the answer to your questions is:</p> <pre><code>println(" str value \(str) has address: \(unsafeAddressOf(str))") </code></pre> <hr> <p>Here is the original answer that was marked correct (for posterity/politeness):</p> <p>Swift "hides" pointers, but they still exists under the hood. (because the runtime needs it, and for compatibility reasons with Objc and C)</p> <p>There are few things to know however, but first how to print the memory address of a Swift String?</p> <pre><code> var aString : String = "THIS IS A STRING" NSLog("%p", aString.core._baseAddress) // _baseAddress is a COpaquePointer // example printed address 0x100006db0 </code></pre> <p>This prints the memory address of the string, if you open XCode -> Debug Workflow -> View Memory and go to the printed address, you will see the raw data of the string. Since this is a string literal, this is a memory address inside the storage of the binary (not stack or heap).</p> <p>However, if you do</p> <pre><code> var aString : String = "THIS IS A STRING" + "This is another String" NSLog("%p", aString.core._baseAddress) // example printed address 0x103f30020 </code></pre> <p>This will be on the stack, because the string is created at runtime</p> <p><strong>NOTE: .core._baseAddress is not documented, I found it looking in the variable inspector, and it may be hidden in the future</strong></p> <p>_baseAddress is not available on all types, here another example with a CInt</p> <pre><code> var testNumber : CInt = 289 takesInt(&amp;testNumber) </code></pre> <p>Where <code>takesInt</code> is a C helper function like this</p> <pre><code>void takesInt(int *intptr) { printf("%p", intptr); } </code></pre> <p>On the Swift side, this function is <code>takesInt(intptr: CMutablePointer&lt;CInt&gt;)</code>, so it takes a CMutablePointer to a CInt, and you can obtain it with &amp;varname </p> <p>The function prints <code>0x7fff5fbfed98</code>, an at this memory address you will find 289 (in hexadecimal notation). You can change its content with <code>*intptr = 123456</code></p> <p>Now, some other things to know.</p> <p>String, in swift, is a primitive type, not an object.<br> CInt is a Swift type mapped to the C int Type.<br> If you want the memory address of an object, you have to do something different.<br> Swift has some Pointer Types that can be used when interacting with C, and you can read about them here: <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-XID_13">Swift Pointer Types</a><br> Moreover, you can understand more about them exploring their declaration (cmd+click on the type), to understand how to convert a type of pointer into another</p> <pre><code> var aString : NSString = "This is a string" // create an NSString var anUnmanaged = Unmanaged&lt;NSString&gt;.passUnretained(aString) // take an unmanaged pointer var opaque : COpaquePointer = anUnmanaged.toOpaque() // convert it to a COpaquePointer var mut : CMutablePointer = &amp;opaque // this is a CMutablePointer&lt;COpaquePointer&gt; printptr(mut) // pass the pointer to an helper function written in C </code></pre> <p><code>printptr</code> is a C helper function I created, with this implementation</p> <pre><code>void printptr(void ** ptr) { printf("%p", *ptr); } </code></pre> <p>Again, an example of the address printed: <code>0x6000000530b0</code> , and if you go through memory inspector you will find your NSString</p> <p>One thing you can do with pointers in Swift (this can even be done with inout parameters)</p> <pre><code> func playWithPointer (stringa :AutoreleasingUnsafePointer&lt;NSString&gt;) { stringa.memory = "String Updated"; } var testString : NSString = "test string" println(testString) playWithPointer(&amp;testString) println(testString) </code></pre> <p>Or, interacting with Objc / c</p> <pre><code>// objc side + (void)writeString:(void **)var { NSMutableString *aString = [[NSMutableString alloc] initWithFormat:@"pippo %@", @"pluto"]; *var = (void *)CFBridgingRetain(aString); // Retain! } // swift side var opaque = COpaquePointer.null() // create a new opaque pointer pointing to null TestClass.writeString(&amp;opaque) var string = Unmanaged&lt;NSString&gt;.fromOpaque(opaque).takeRetainedValue() println(string) // this prints pippo pluto </code></pre>
<h3>To get the (heap) address of an object</h3> <pre><code>func address&lt;T: AnyObject&gt;(o: T) -&gt; Int { return unsafeBitCast(o, Int.self) } class Test {} var o = Test() println(NSString(format: "%p", address(o))) // -&gt; 0x7fd5c8700970 </code></pre> <p>(<strong>Edit:</strong> Swift 1.2 now includes a similar function called <code>unsafeAddressOf</code>.)</p> <p>In Objective-C this would be <code>[NSString stringWithFormat:@"%p", o]</code>.</p> <p><code>o</code> is a reference to the instance. So if <code>o</code> is assigned to another variable <code>o2</code>, the returned address for <code>o2</code> will be the same.</p> <p>This doesn't apply to structs (including <code>String</code>) and primitive types (like <code>Int</code>), because those live directly on the stack. But we can retrieve the location on the stack.</p> <h3>To get the (stack) address of a struct, build-in type or object reference</h3> <pre><code>func address(o: UnsafePointer&lt;Void&gt;) -&gt; Int { return unsafeBitCast(o, Int.self) } println(NSString(format: "%p", address(&amp;o))) // -&gt; 0x10de02ce0 var s = "A String" println(NSString(format: "%p", address(&amp;s))) // -&gt; 0x10de02ce8 var i = 55 println(NSString(format: "%p", address(&amp;i))) // -&gt; 0x10de02d00 </code></pre> <p>In Objective-C this would be <code>[NSString stringWithFormat:@"%p", &amp;o]</code> or <code>[NSString stringWithFormat:@"%p", &amp;i]</code>.</p> <p><code>s</code> is struct. So if <code>s</code> is assigned to another variable <code>s2</code>, the value will be copied and the returned address for <code>s2</code> will be different.</p> <h3>How it fits together (pointer recap)</h3> <p>Like in Objective-C, there are two different addresses associated with <code>o</code>. The first is the location of the object, the second is the location of the reference (or pointer) to the object.</p> <p>Yes, this means that the content of address 0x7fff5fbfe658 is the number 0x6100000011d0 as the debugger can tell us:</p> <pre><code>(lldb) x/g 0x7fff5fbfe658 0x7fff5fbfe658: 0x00006100000011d0 </code></pre> <p>So, except for strings being structs, internally this all pretty much works the same as in (Objective-)C.</p> <p><sub>(Current as of Xcode 6.3)</sub></p>
<h1>Swift 2</h1> <p>This is now part of the standard library: <code>unsafeAddressOf</code>. </p> <pre><code>/// Return an UnsafePointer to the storage used for `object`. There's /// not much you can do with this other than use it to identify the /// object </code></pre> <h1>Swift 3</h1> <p>For Swift 3, use <code>withUnsafePointer</code>:</p> <pre><code>var str = "A String" withUnsafePointer(to: &amp;str) { print(" str value \(str) has address: \($0)") } </code></pre>
<p>The other answers are fine, though I was looking for a way to get the pointer address as an integer:</p> <pre><code>let ptr = unsafeAddressOf(obj) let nullPtr = UnsafePointer&lt;Void&gt;(bitPattern: 0) /// This gets the address of pointer let address = nullPtr.distanceTo(ptr) // This is Int </code></pre> <p>Just a little follow-up.</p>
<p>The answer @Drew provide can only be used for class type.<br> The answer @nschum provide can only be for struct type.</p> <p>However if you use the second method to get address of a array with value type element. Swift will copy the whole array because in Swift array is copy-on-write and Swift can't make sure it behave this way once it pass control over to C/C++ (Which is trigger by using <code>&amp;</code> to get address). And if you use first method instead , it will automatically convert <code>Array</code> to <code>NSArray</code> which is surely something we don't want.</p> <p><strong>So the most simple and unified way I found is using lldb instruction <code>frame variable -L yourVariableName</code>.</strong></p> <p>Or you can combine their answers:</p> <pre><code>func address(o: UnsafePointer&lt;Void&gt;) { let addr = unsafeBitCast(o, Int.self) print(NSString(format: "%p", addr)) } func address&lt;T: AnyObject&gt;(o: T) -&gt; String{ let addr = unsafeBitCast(o, Int.self) return NSString(format: "%p", addr) as String } </code></pre>
<p>For my purposes, I usually just need to see this in the debugger. Thus, this works just fine for me:</p> <pre class="lang-swift prettyprint-override"><code>public extension NSObject { // Extension syntax is cleaner for my use. If your needs stem outside NSObject, you may change the classname or place the logic in a global function public var pointerString: String { return NSString(format: "%p", self) as String } } </code></pre> <p>Example usage:</p> <pre><code>print(self.pointerAddress, "Doing something...") // Prints like: 0x7fd190d0f270 Doing something... </code></pre> <p>Additionally, remember that simply printing <code>self</code> without overriding its <code>description</code> will show its pointer address alongside more descriptive (if oft cryptic) text.</p> <pre><code>print(self, "Doing something else...") // Prints like: &lt;MyModule.MyClass: 0x7fd190d0f270&gt; Doing something else... // Sometimes like: &lt;_TtCC14__lldb_expr_668MyModule7MyClass: 0x7fd190d0f270&gt; Doing something else... </code></pre>