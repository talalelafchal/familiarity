Pick a random element from an array
<p>Suppose I have an array and I want to pick one element at random.</p> <p>What would be the simplest way to do this?</p> <p>The obvious way would be <code>array[random index]</code>. But perhaps there is something like ruby's <code>array.sample</code>? Or if not could such a method be created by using an extension?</p>
<p>Just to answer your question, you can do this to achieve random array selection:</p> <pre><code>let array = ["Frodo", "sam", "wise", "gamgee"] let randomIndex = Int(arc4random_uniform(UInt32(array.count))) print(array[randomIndex]) </code></pre> <p>The castings are ugly, but I believe they're required unless someone else has another way.</p>
<p>Riffing on what Lucas said, you could create an extension to the Array class like this:</p> <pre><code>extension Array { func randomItem() -&gt; Element { let index = Int(arc4random_uniform(UInt32(self.count))) return self[index] } } </code></pre> <p>For example: </p> <pre><code>let myArray = [1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16] let myItem = myArray.randomItem() </code></pre>
<p>You can use Swift's built-in random() function as well for the extension: </p> <pre><code>extension Array { func sample() -&gt; Element { let randomIndex = Int(rand()) % count return self[randomIndex] } } let array = [1, 2, 3, 4] array.sample() // 2 array.sample() // 2 array.sample() // 3 array.sample() // 3 array.sample() // 1 array.sample() // 1 array.sample() // 3 array.sample() // 1 </code></pre>
<p>An alternative functional implementation with check for empty array.</p> <pre><code>func randomArrayItem&lt;T&gt;(array: [T]) -&gt; T? { if array.isEmpty { return nil } let randomIndex = Int(arc4random_uniform(UInt32(array.count))) return array[randomIndex] } randomArrayItem([1,2,3]) </code></pre>
<p>In <strong>Swift 2.2</strong> this can be generalised so that we have:</p> <pre><code>UInt.random UInt8.random UInt16.random UInt32.random UInt64.random UIntMax.random // closed intervals: (-3...3).random (Int.min...Int.max).random // and collections, which return optionals since they can be empty: (1..&lt;4).sample [1,2,3].sample "abc".characters.sample ["a": 1, "b": 2, "c": 3].sample </code></pre> <p>First, implementing static <code>random</code> property for <code>UnsignedIntegerType</code>s:</p> <pre><code>import Darwin func sizeof &lt;T&gt; (_: () -&gt; T) -&gt; Int { // sizeof return type without calling return sizeof(T.self) } let ARC4Foot: Int = sizeof(arc4random) extension UnsignedIntegerType { static var max: Self { // sadly `max` is not required by the protocol return ~0 } static var random: Self { let foot = sizeof(Self) guard foot &gt; ARC4Foot else { return numericCast(arc4random() &amp; numericCast(max)) } var r = UIntMax(arc4random()) for i in 1..&lt;(foot / ARC4Foot) { r |= UIntMax(arc4random()) &lt;&lt; UIntMax(8 * ARC4Foot * i) } return numericCast(r) } } </code></pre> <p>Then, for <code>ClosedInterval</code>s with <code>UnsignedIntegerType</code> bounds:</p> <pre><code>extension ClosedInterval where Bound : UnsignedIntegerType { var random: Bound { guard start &gt; 0 || end &lt; Bound.max else { return Bound.random } return start + (Bound.random % (end - start + 1)) } } </code></pre> <p>Then (a little more involved), for <code>ClosedInterval</code>s with <code>SignedIntegerType</code> bounds (using helper methods described further below):</p> <pre><code>extension ClosedInterval where Bound : SignedIntegerType { var random: Bound { let foot = sizeof(Bound) let distance = start.unsignedDistanceTo(end) guard foot &gt; 4 else { // optimisation: use UInt32.random if sufficient let off: UInt32 if distance &lt; numericCast(UInt32.max) { off = UInt32.random % numericCast(distance + 1) } else { off = UInt32.random } return numericCast(start.toIntMax() + numericCast(off)) } guard distance &lt; UIntMax.max else { return numericCast(IntMax(bitPattern: UIntMax.random)) } let off = UIntMax.random % (distance + 1) let x = (off + start.unsignedDistanceFromMin).plusMinIntMax return numericCast(x) } } </code></pre> <p>... where <code>unsignedDistanceTo</code>, <code>unsignedDistanceFromMin</code> and <code>plusMinIntMax</code> helper methods can be implemented as follows:</p> <pre><code>extension SignedIntegerType { func unsignedDistanceTo(other: Self) -&gt; UIntMax { let _self = self.toIntMax() let other = other.toIntMax() let (start, end) = _self &lt; other ? (_self, other) : (other, _self) if start == IntMax.min &amp;&amp; end == IntMax.max { return UIntMax.max } if start &lt; 0 &amp;&amp; end &gt;= 0 { let s = start == IntMax.min ? UIntMax(Int.max) + 1 : UIntMax(-start) return s + UIntMax(end) } return UIntMax(end - start) } var unsignedDistanceFromMin: UIntMax { return IntMax.min.unsignedDistanceTo(self.toIntMax()) } } extension UIntMax { var plusMinIntMax: IntMax { if self &gt; UIntMax(IntMax.max) { return IntMax(self - UIntMax(IntMax.max) - 1) } else { return IntMax.min + IntMax(self) } } } </code></pre> <p>Finally, for all collections where <code>Index.Distance == Int</code>:</p> <pre><code>extension CollectionType where Index.Distance == Int { var sample: Generator.Element? { if isEmpty { return nil } let end = UInt(count) - 1 let add = (0...end).random let idx = startIndex.advancedBy(Int(add)) return self[idx] } } </code></pre> <p>... which can be optimised a little for integer <code>Range</code>s:</p> <pre><code>extension Range where Element : SignedIntegerType { var sample: Element? { guard startIndex &lt; endIndex else { return nil } let i: ClosedInterval = startIndex...endIndex.predecessor() return i.random } } extension Range where Element : UnsignedIntegerType { var sample: Element? { guard startIndex &lt; endIndex else { return nil } let i: ClosedInterval = startIndex...endIndex.predecessor() return i.random } } </code></pre>
<p>Following others answer but with Swift 2 support.</p> <h2>Swift 1.x</h2> <pre><code>extension Array { func sample() -&gt; T { let index = Int(arc4random_uniform(UInt32(self.count))) return self[index] } } </code></pre> <h2>Swift 2.x</h2> <pre><code>extension Array { func sample() -&gt; Element { let index = Int(arc4random_uniform(UInt32(self.count))) return self[index] } } </code></pre> <p>E.g.: </p> <pre><code>let arr = [2, 3, 5, 7, 9, 11, 13, 17, 19, 23, 29, 31] let randomSample = arr.sample() </code></pre>
<p>Here's an <strong>extension on Arrays</strong> with an <strong>empty array check</strong> for more safety:</p> <pre><code>extension Array { func sample() -&gt; Element? { if self.isEmpty { return nil } let randomInt = Int(arc4random_uniform(UInt32(self.count))) return self[randomInt] } } </code></pre> <p>You can use it <strong>as simple as this</strong>:</p> <pre><code>let digits = Array(0...9) digits.sample() // =&gt; 6 </code></pre> <hr> <p>If you prefer a <strong>Framework</strong> that also has some more handy features then checkout <strong><a href="https://github.com/Flinesoft/HandySwift" rel="nofollow">HandySwift</a></strong>. You can add it to your project <strong>via Carthage</strong> then use it exactly like in the example above:</p> <pre><code>import HandySwift let digits = Array(0...9) digits.sample() // =&gt; 8 </code></pre> <p>Additionally it also includes an option to get <strong>multiple random elements at once</strong>:</p> <pre><code>digits.sample(size: 3) // =&gt; [8, 0, 7] </code></pre>
<p>I find using GameKit's GKRandomSource.sharedRandom() works best for me.</p> <pre><code>import GameKit let array = ["random1", "random2", "random3"] func getRandomIndex() -&gt; Int { let randomNumber = GKRandomSource.sharedRandom().nextIntWithUpperBound(array.count) return randomNumber </code></pre> <p>or you could return the object at the random index selected. Make sure the function returns a String first, and then return the index of the array.</p> <pre><code> return array[randomNumber] </code></pre> <p>Short and to the point.</p>
<p><strong>Swift 3</strong> version:</p> <pre><code>extension Collection where Index == Int { /** Picks a random element of the collection. - returns: A random element of the collection. */ func randomElement() -&gt; Iterator.Element? { return isEmpty ? nil : self[Int(arc4random_uniform(UInt32(endIndex)))] } } </code></pre>
<p>Another Swift 3 suggestion</p> <pre><code>private extension Array { var randomElement: Element { let index = Int(arc4random_uniform(UInt32(count))) return self[index] } } </code></pre>