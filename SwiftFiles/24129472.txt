When are objects that hold unowned references deallocated?
<p>I was playing with unowned references. As I understood from the WWDC videos, unowned references can't be <code>nil</code>, and they do not increase the retain count of whatever object they reference. I thought that if an unowned reference is deallocated, then the object that held the unowned reference is also deallocated.</p> <p>Consider the following code:</p> <pre><code>class Parent { var child : Child? func foo() { println("Hello") } } class Child { unowned let parent : Parent init(parent: Parent) { self.parent = parent } } var parent : Parent? = Parent() parent!.child = Child(parent: parent!) weak var child = parent!.child parent = nil child!.parent.foo() </code></pre> <p>This code works! How come <code>child</code> exists, and moreover, how come <code>parent</code> apparently still exists? I had thought that after setting <code>parent = nil</code>, <code>child</code> would also be <code>nil</code>. It seems as if the unowned reference is acting as if it were a strong reference.</p> <p>Any ideas as to why this code works?</p>
<p>Your code will most likely only work in the playground, where the memory management is a little... fuzzy.</p> <p>When I ran this in Xcode, it crashes as you'd expect. The playground is meant to make it easy to test the syntax, play with some classes, etc. It's not the best place to play around with weak/unretained variables.</p> <p>I haven't found any documented sources describing how exactly the memory is managed in a playground, but it's definitely different from how it will be in an actual runtime.</p>