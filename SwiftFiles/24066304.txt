How can I make a weak protocol reference in 'pure' Swift (w/o @objc)
<p><code>weak</code> references don't seem to work in Swift unless a <code>protocol</code> is declared as <code>@objc</code>, which I don't want in a pure Swift app.</p> <p>This code gives a compile error (<code>weak</code> cannot be applied to non-class type <code>MyClassDelegate</code>):</p> <pre><code>class MyClass { weak var delegate: MyClassDelegate? } protocol MyClassDelegate { } </code></pre> <p>I need to prefix the protocol with <code>@objc</code>, then it works.</p> <p>Question: What is the 'pure' Swift way to accomplish a <code>weak</code> <code>delegate</code>?</p>
<p>You need to declare the type of the protocol as <code>class</code>.</p> <pre><code>protocol ProtocolNameDelegate: class { // Protocol stuff goes here } class SomeClass { weak var delegate: ProtocolNameDelegate? } </code></pre> <p>My understanding is that using <code>class</code>, you guarantee that this protocol will be used only on classes and no other stuff like enums or structs. </p>
<p><strong>Update:</strong> It looks like the manual has been updated and the example I was referring to has been removed. See the edit to @flainez's answer above.</p> <p><strong>Original:</strong> Using @objc is the right way to do it even if you're not interoperating with Obj-C. It ensures that your protocol is being applied to a class and not an enum or struct. See "Checking for Protocol Conformance" in the manual.</p>
<h1>Supplemental Answer</h1> <p>I was always confused about whether delegates should be weak or not. Recently I've learned more about delegates and when to use weak references, so let me add some supplemental points here for the sake of future viewers.</p> <ul> <li><p>The purpose of using the <code>weak</code> keyword is to avoid strong reference cycles (retain cycles). Strong reference cycles happen when two class instances have strong references to each other. Their reference counts never go to zero so they never get deallocated. </p></li> <li><p>You only need to use <code>weak</code> if the delegate is a class. Swift structs and enums are value types (their values are copied when a new instance is made), not reference types, so they don't make strong <em>reference</em> cycles.</p></li> <li><p><code>weak</code> references are always optional (otherwise you would used <code>unowned</code>) and always use <code>var</code> (not <code>let</code>) so that the optional can be set to <code>nil</code> when it is deallocated.</p></li> <li><p>A parent class should naturally have a strong reference to its child classes and thus not use the <code>weak</code> keyword. When a child wants a reference to its parent, though, it should make it a weak reference by using the <code>weak</code> keyword.</p></li> <li><p><code>weak</code> should be used when you want a reference to a class that you don't own, not just for a child referencing its parent. When two non-hierarchical classes need to reference each other, choose one to be weak. The one you choose depends on the situation. See the answers to <a href="http://stackoverflow.com/questions/34565760/two-weak-variables-referencing-each-other-in-swift">this question</a> for more on this.</p></li> <li><p><strong>As a general rule, delegates should be marked as <code>weak</code></strong> because most delegates are referencing classes that they do not own. This is definitely true when a child is using a delegate to communicate with a parent. However, there are still <a href="http://stackoverflow.com/questions/17348523/is-it-ever-ok-to-have-a-strong-reference-for-a-delegate">some situations</a> where a delegate can and should use a strong reference.</p></li> <li><p>Protocols can be used for both reference types (classes) and non-reference types (structs, enums). So in the likely case that you need to make a delegate weak, you have to add the <code>class</code> keyword to the protocol so that it knows it is only to be used with reference types.</p> <pre><code>protocol MyClassDelegate: class { // ... } class SomeClass { weak var delegate: MyClassDelegate? } </code></pre></li> </ul> <h1>Further Study</h1> <p>Reading the following articles is what helped me to understand this much better. They also discuss related issues like the <code>unowned</code> keyword and the strong reference cycles that happen with closures.</p> <ul> <li>Swift documentation: <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html">Automatic Reference Counting</a></li> <li><a href="http://krakendev.io/blog/weak-and-unowned-references-in-swift">"Weak, Strong, Unowned, Oh My!" - A Guide to References in Swift</a></li> <li><a href="http://www.andrewcbancroft.com/2015/05/08/strong-weak-and-unowned-sorting-out-arc-and-swift/">Strong, Weak, and Unowned â€“ Sorting out ARC and Swift</a></li> </ul> <h1>Related</h1> <ul> <li><a href="http://stackoverflow.com/a/33549729/3681880">How to make delegates in Swift</a></li> <li><a href="http://natashatherobot.com/ios-weak-delegates-swift/">iOS: How To Make Weak Delegates In Swift</a></li> <li><a href="http://stackoverflow.com/questions/30056526/swift-delegation-when-to-use-weak-pointer-on-delegate">Swift delegation - when to use weak pointer on delegate</a></li> </ul>
<p>Apple uses "NSObjectProtocol" instead of "class". </p> <pre><code>public protocol UIScrollViewDelegate : NSObjectProtocol { ... } </code></pre> <p>This also works for me and removed the errors I was seeing when trying to implement my own delegate pattern.</p>