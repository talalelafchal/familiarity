Building a rich chat messaging function in a social app
I'm building a social app with rich messaging functionality and I'm fairly new to the coding scene. Is there a possible way to query two different classes, in my case (User) and (Message) in order to get the correct profile pictures associated with the usernames and the corresponding conversations? Oh, and Im using parse server. They also have a live query feature that I'd like to implement as well to give the chat more of a real time experience, but Im a noob and don't really know where to start. User Class "ava" is where the userprofile pictures are stored Message Class If the question is too vague please let me know and i'll do my best to provide more information. Here is my code. class DialogsVC: UITableViewController, UITextViewDelegate, UISearchBarDelegate { var refresher = UIRefreshControl() // values for reseting UI to default var tableViewHeight : CGFloat = 0 var messageY : CGFloat = 0 var messageHeight : CGFloat = 0 // arrays to hold server data var usernameArray = [String]() var avaArray = [PFFile]() var messageArray = [String]() var dateArray = [Date?]() var uuidArray = [String]() var ownerArray = [String]() // variable to hold keybarod frame var keyboard = CGRect() // page size var page : Int32 = 15 // default func override func viewDidLoad() { super.viewDidLoad() // dynamic tableView height - dynamic cell // tableView.rowHeight = UITableViewAutomaticDimension tableView.estimatedRowHeight = 79 // title at the top self.navigationItem.title = "MAIL" // request Messages var date = NSDate() let calendar = NSCalendar(calendarIdentifier: NSCalendar.Identifier.gregorian) let today = calendar!.startOfDay(for: date as Date) let predicate = NSPredicate(format: "username != '"+userName+"'") var userInfoQuery = PFQuery(className: "_User", predicate: predicate) userInfoQuery.whereKey("isVendor", equalTo: true) print (predicate) userInfoQuery.findObjectsInBackground (block: { (objects:[PFObject]?, error:Error?) -> Void in if error == nil { self.usernameArray.removeAll(keepingCapacity: false) self.avaArray.removeAll(keepingCapacity: false) }else{ for object in objects! { self.usernameArray.append(object["username"] as! String) self.avaArray.append(object.object(forKey: "ava") as! PFFile) } self.tableView.reloadData() } }) var messageQuery = PFQuery(className: "Message") messageQuery.order(byAscending: "createdAt") messageQuery.whereKey("other", equalTo: PFUser.current()!.username!) messageQuery.limit = 1 messageQuery.whereKey("sender", equalTo: PFUser.current()!.username!) messageQuery.limit = 30 messageQuery.findObjectsInBackground (block: { (objects:[PFObject]?, error:Error?) -> Void in if error == nil { // clean up self.messageArray.removeAll(keepingCapacity: false) self.dateArray.removeAll(keepingCapacity: false) self.ownerArray.removeAll(keepingCapacity: false) // found related objects for object in objects! { self.usernameArray.append(object.object(forKey: "sender") as! String) self.messageArray.append(object.object(forKey: "message") as! String) self.dateArray.append(object.createdAt) self.ownerArray.append(object.object(forKey: "sender") as! String) // save notifications as checked object["checked"] = "yes" object.saveEventually() } // reload tableView to show received data self.tableView.reloadData() } }) } // cell numb override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int { return messageArray.count } // cell config override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell { // declare cell let cell = self.tableView.dequeueReusableCell(withIdentifier: "Cell") as! messageCell // connect cell objects with received data from server cell.usernameLbl.text = usernameArray[(indexPath as NSIndexPath).row] avaArray[(indexPath as NSIndexPath).row].getDataInBackground { (data:Data?, error:Error?) -> Void in if error == nil { cell.avaImg.image = UIImage(data: data!) } else { print(error!.localizedDescription) } }