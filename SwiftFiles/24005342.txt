Swift and CoreData / Data Storage
<p>I'm just learning Objective-C / Cocoa Touch and Core Data. So, what are the new possibilities to implement data storage in iOS App Projects that are written in pure Swift? I really like the language, but as far as I know all core data methods are written in Objective-C. So will the core data classes/methods converted to Swift-Code automatically or will we have to mix up Objective-C Code for Core data and Swift-Code for everything else? </p>
<p>All Objective-C frameworks are swift-ready. Swift-friendly headers are automatically generated (on-demand, it appears), and you can access anything from Swift that you can from ObjC.</p>
<p>I had tested use swift to access coredata, please visit the demo code : <a href="https://github.com/iascchen/SwiftCoreDataSimpleDemo" rel="nofollow">https://github.com/iascchen/SwiftCoreDataSimpleDemo</a> . </p>
<p>This is how I implemented core data.</p> <p>A couple of really important notes:</p> <ul> <li><p>You have to add this to your NSManagedObject class:</p> <p>@objc(MyObject)</p></li> <li><p>You have to add the entity name to your default configuration class in the .xcdatamodel (picture included)</p></li> </ul> <p><img src="https://i.stack.imgur.com/mwHGT.png" alt="xcdatamodel"></p> <ul> <li><p>You can't simply make an NSManagedObject.</p> <pre><code>var myObject : MyObject = MyObject() </code></pre></li> </ul> <p>You have to do this:</p> <pre><code>let appDelegate: AppDelegate = UIApplication.sharedApplication().delegate as AppDelegate let context: NSManagedObjectContext = appDelegate.managedObjectContext let entityName: String = "MyObject" let myEntityDescription = NSEntityDescription.entityForName(entityName, inManagedObjectContext: context) var myObject = MyObject(entity: myEntityDescription, insertIntoManagedObjectContext: context) </code></pre> <p>Here is my NSManagedObject. I included two fetch methods as well as a class method for object construction. You may notice that I am taking advantage of the new enum system so that I can easily access my entity names and entity attributes</p> <pre><code>import UIKit import CoreData enum MyObjectPropertyList { case name func description() -&gt; String { switch self { case .name: return "name" } } } @objc(MyObject) class MyObject: NSManagedObject { @NSManaged var name: String // //// CREATE CLASS OBJECT // class func createMyObject (propertyName:MyObjectPropertyList, value:String, context: NSManagedObjectContext) -&gt; MyObject? { if !value.isEmpty { let propertyType = propertyName.description() let entityName = "MyObject" let request : NSFetchRequest = NSFetchRequest(entityName: entityName) request.returnsObjectsAsFaults = false request.predicate = NSPredicate(format: "\(propertyType) = %@", value) var error: NSError? = nil var matches: NSArray = context.executeFetchRequest(request, error: &amp;error) if (matches.count &gt; 1) { // handle error return matches[0] as? MyObject } else if matches.count == 0 { let entityDescription = NSEntityDescription.entityForName(entityName, inManagedObjectContext: context) var myObject : MyObject = MyObject(entity: entityDescription, insertIntoManagedObjectContext: context) myObject.name = value return myObject } else { println(matches[0]) return matches[0] as? MyObject } } return nil } } // //// FETCH REQUESTS // func myGeneralFetchRequest (entity : CoreDataEntities, property : MyObjectPropertyList, context : NSManagedObjectContext) -&gt; AnyObject[]?{ let entityName = entity.description() let propertyName = property.description() let request :NSFetchRequest = NSFetchRequest(entityName: entityName) request.returnsObjectsAsFaults = false let sortDescriptor : NSSortDescriptor = NSSortDescriptor(key: propertyName, ascending: true) request.sortDescriptors = [sortDescriptor] var error: NSError? = nil var matches: NSArray = context.executeFetchRequest(request, error: &amp;error) if matches.count &gt; 0 { return matches } else { return nil } } func myNameFetchRequest (entity : CoreDataEntities, property : MyObjectPropertyList, value : String, context : NSManagedObjectContext) -&gt; AnyObject[]? { let entityName = entity.description() let propertyName = property.description() let request :NSFetchRequest = NSFetchRequest(entityName: entityName) request.returnsObjectsAsFaults = false request.predicate = NSPredicate(format: "\(propertyName) = %@", value) let sortDescriptor :NSSortDescriptor = NSSortDescriptor(key: propertyName, ascending: true) request.sortDescriptors = [sortDescriptor] var error: NSError? = nil var matches: NSArray = context.executeFetchRequest(request, error: &amp;error) if matches.count &gt; 0 { return matches } else { return nil } } // //// PRINT FETCH REQUEST // func printFetchedArrayList (myarray:AnyObject[]) { if myarray.count &gt; 0 { println("Has \(myarray.count) object") for myobject : AnyObject in myarray { var anObject = myobject as MyObject var thename = anObject.name println(thename) } } else { println("empty fetch") } } </code></pre> <p>Here is my view controller</p> <pre><code>import UIKit import CoreData enum CoreDataEntities { case MyObject func description() -&gt; String { switch self { case .MyObject: return "MyObject" } } } class ViewController: UIViewController { // //// MOC // var managedObjectContext : NSManagedObjectContext = NSManagedObjectContext() // //// Text Field // @IBOutlet var myTextField : UITextField // //// BUTTONS // @IBAction func saveButtonPress(sender : UIButton) { makeEntityAction() } @IBAction func fetchButtonPress(sender : UIButton) { fetchObjectAction() } // //// ACTIONS // func makeEntityAction () { println("-- Make action --") let value:String = self.myTextField.text var myObject : MyObject = MyObject.createMyObject(MyObjectPropertyList.name, value : value, context: self.managedObjectContext)! saveContext(self.managedObjectContext) } func fetchObjectAction () { println("-- Fetch action --") if let myTotalarray = myGeneralFetchRequest(CoreDataEntities.MyObject, MyObjectPropertyList.name, self.managedObjectContext) { printFetchedArrayList(myTotalarray) } if let mySinglearray: AnyObject[] = myNameFetchRequest(CoreDataEntities.MyObject, MyObjectPropertyList.name, "Bill", self.managedObjectContext) { println("(-- --)") printFetchedArrayList(mySinglearray) } } // //// LOAD &amp; SAVE // func loadContext () { let appDelegate: AppDelegate = UIApplication.sharedApplication().delegate as AppDelegate let context: NSManagedObjectContext = appDelegate.managedObjectContext self.managedObjectContext = context } func saveContext (context: NSManagedObjectContext) { var error: NSError? = nil context.save(&amp;error) } // //// LOAD // func myLoad () { loadContext () println("Loaded Context") } // //// Life Cycle // override func viewDidLoad() { super.viewDidLoad() myLoad () } } </code></pre>
<p>XCode 6 Beta 4 now lets you choose either Objective C or Swift when you generate NSManagedObject subclasses from your data model.</p>
<p>If you wanna have a play around with Swift and CoreData, I've written a framework thats an Active Record style assistant to CoreData. </p> <p><a href="http://github.com/michaelarmstrong/SuperRecord" rel="nofollow">SuperRecord Swift Framework</a></p> <p>(note: not a shameless plug :) i actually thought this would be useful for the user).</p>
<p>Here is another approach to adding CoreData to your Swift app. This approach hides the CoreData implementation details from the rest of the app. In the app, you use queries/updates like these:</p> <pre><code>Query("Order").sort("date").fetch() </code></pre> <p>or:</p> <pre><code>let newClient = Query("Client").create() as? Client </code></pre> <p>See Gist: <a href="https://gist.github.com/gk11/438c3f2883c5d7c0b0d8" rel="nofollow">https://gist.github.com/gk11/438c3f2883c5d7c0b0d8</a></p>