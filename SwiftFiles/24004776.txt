Input from the keyboard in command line application
<p>I am attempting to get the keyboard input for a command line app for the new Apple programming language Swift.</p> <p>I've scanned the docs to no avail.</p> <pre><code>import Foundation println("What is your name?") ??? </code></pre> <p>Any ideas?</p>
<p>It's actually not that easy, you have to interact with the C API. There is no alternative to <code>scanf</code>. I've build a little example:</p> <p><strong>main.swift</strong></p> <pre><code>import Foundation var output: CInt = 0 getInput(&amp;output) println(output) </code></pre> <p><br /> <strong>UserInput.c</strong></p> <pre><code>#include &lt;stdio.h&gt; void getInput(int *output) { scanf("%i", output); } </code></pre> <p><br /> <strong>cliinput-Bridging-Header.h</strong></p> <pre><code>void getInput(int *output); </code></pre>
<p>I managed to figure it out without dropping down in to C:</p> <p>My solution is as follows:</p> <pre><code>func input() -&gt; String { var keyboard = NSFileHandle.fileHandleWithStandardInput() var inputData = keyboard.availableData return NSString(data: inputData, encoding:NSUTF8StringEncoding) } </code></pre> <p>More recent versions of Xcode need an explicit typecast (works in Xcode 6.4):</p> <pre><code>func input() -&gt; String { var keyboard = NSFileHandle.fileHandleWithStandardInput() var inputData = keyboard.availableData return NSString(data: inputData, encoding:NSUTF8StringEncoding) as! String } </code></pre>
<p>Another alternative is to link <a href="http://thrysoee.dk/editline/" rel="nofollow" title="libedit">libedit</a> for proper line editing (arrow keys, etc.) and optional history support. I wanted this for a project I'm starting and put together a <a href="https://github.com/neilpa/swift-libedit" rel="nofollow" title="swift-libedit">basic example for how I set it up</a>.</p> <p>Usage from swift</p> <pre><code>let prompt: Prompt = Prompt(argv0: C_ARGV[0]) while (true) { if let line = prompt.gets() { print("You typed \(line)") } } </code></pre> <p>ObjC wrapper to expose libedit</p> <pre><code>#import &lt;histedit.h&gt; char* prompt(EditLine *e) { return "&gt; "; } @implementation Prompt EditLine* _el; History* _hist; HistEvent _ev; - (instancetype) initWithArgv0:(const char*)argv0 { if (self = [super init]) { // Setup the editor _el = el_init(argv0, stdin, stdout, stderr); el_set(_el, EL_PROMPT, &amp;prompt); el_set(_el, EL_EDITOR, "emacs"); // With support for history _hist = history_init(); history(_hist, &amp;_ev, H_SETSIZE, 800); el_set(_el, EL_HIST, history, _hist); } return self; } - (void) dealloc { if (_hist != NULL) { history_end(_hist); _hist = NULL; } if (_el != NULL) { el_end(_el); _el = NULL; } } - (NSString*) gets { // line includes the trailing newline int count; const char* line = el_gets(_el, &amp;count); if (count &gt; 0) { history(_hist, &amp;_ev, H_ENTER, line); return [NSString stringWithCString:line encoding:NSUTF8StringEncoding]; } return nil; } @end </code></pre>
<p><strong>edit</strong> As of Swift 2.2 the standard library includes <code>readLine</code>. I'll also note Swift switched to markdown doc comments. Leaving my original answer for historical context. </p> <p>Just for completeness, here is a Swift implementation of <code>readln</code> I've been using. It has an optional parameter to indicate the maximum number of bytes you want to read (which may or may not be the length of the String).</p> <p>This also demonstrates the proper use of swiftdoc comments - Swift will generate a &lt;project&gt;.swiftdoc file and Xcode will use it.</p> <pre><code>///reads a line from standard input /// ///:param: max specifies the number of bytes to read /// ///:returns: the string, or nil if an error was encountered trying to read Stdin public func readln(max:Int = 8192) -&gt; String? { assert(max &gt; 0, "max must be between 1 and Int.max") var buf:Array&lt;CChar&gt; = [] var c = getchar() while c != EOF &amp;&amp; c != 10 &amp;&amp; buf.count &lt; max { buf.append(CChar(c)) c = getchar() } //always null terminate buf.append(CChar(0)) return buf.withUnsafeBufferPointer { String.fromCString($0.baseAddress) } } </code></pre>
<p>I swear to God.. the solution to this <em>utterly basic</em> problem eluded me for YEARS. It's <strong>SO simple</strong>.. but there is so much vague / bad information out there; hopefully I can save <em>someone</em> from <em>some</em> of the bottomless <a href="http://en.wikipedia.org/wiki/Rabbit_hole" rel="nofollow">rabbit holes</a> that I ended up in...</p> <p>So then, lets's get a "string" from "the user" via "the console", via <code>stdin</code>, <em>shall we</em>?</p> <pre><code>[NSString.alloc initWithData: [NSFileHandle.fileHandleWithStandardInput availableData] encoding:NSUTF8StringEncoding]; </code></pre> <p>if you want it <em>WITHOUT</em> the trailing newline, just add...</p> <pre><code>[ ... stringByTrimmingCharactersInSet: NSCharacterSet.newlineCharacterSet]; </code></pre> <p><strong><em><code>Ta Da!</code></em></strong> ♥ ⱥᏪℯⅩ</p>
<p>I just wanted to comment (I have not enough reps) on xenadu's implementation, because <code>CChar</code> in OS X is <code>Int8</code>, and Swift does not like at all when you add to the array when <code>getchar()</code> returns parts of UTF-8, or anything else above 7 bit.</p> <p>I am using an array of <code>UInt8</code> instead, and it works great and <code>String.fromCString</code> converts the <code>UInt8</code> into UTF-8 just fine. </p> <p>However this is how I done it</p> <pre><code>func readln() -&gt; (str: String?, hadError: Bool) { var cstr: [UInt8] = [] var c: Int32 = 0 while c != EOF { c = getchar() if (c == 10 || c == 13) || c &gt; 255 { break } cstr.append(UInt8(c)) } cstr.append(0) return String.fromCStringRepairingIllFormedUTF8(UnsafePointer&lt;CChar&gt;(cstr)) } while true { if let mystring = readln().str { println(" &gt; \(mystring)") } } </code></pre>
<p>I have now been able to get Keyboard input in Swift by using the following:</p> <p>In my main.swift file I declared a variable i and assigned to it the function GetInt() which I defined in Objective C. Through a so called Bridging Header where I declared the function prototype for GetInt I could link to main.swift. Here are the files:</p> <p>main.swift:</p> <pre><code>var i: CInt = GetInt() println("Your input is \(i) "); </code></pre> <p>Bridging Header:</p> <pre><code>#include "obj.m" int GetInt(); </code></pre> <p>obj.m:</p> <pre><code>#import &lt;Foundation/Foundation.h&gt; #import &lt;stdio.h&gt; #import &lt;stdlib.h&gt; int GetInt() { int i; scanf("%i", &amp;i); return i; } </code></pre> <p>In obj.m it is possible to include the c standard output and input, stdio.h, as well as the c standard library stdlib.h which enables you to program in C in Objective-C, which means there is no need for including a real swift file like user.c or something like that.</p> <p>Hope I could help,</p> <p>Edit: It is not possible to get String input through C because here I am using the CInt -> the integer type of C and not of Swift. There is no equivalent Swift type for the C char*. Therefore String is not convertible to string. But there are fairly enough solutions around here to get String input.</p> <p>Raul</p>
<p>Since there were no fancy solutions to this problem, I made a tiny class to read and parse the standard input in Swift. You can find it <a href="https://github.com/shoumikhin/StreamScanner" rel="nofollow">here</a>.</p> <p><strong>Example</strong></p> <p>To parse:</p> <pre><code>+42 st_ring! -0.987654321 12345678900 .42 </code></pre> <p>You do:</p> <pre><code>let stdin = StreamScanner.standardInput if let i: Int = stdin.read(), let s: String = stdin.read(), let d: Double = stdin.read(), let i64: Int64 = stdin.read(), let f: Float = stdin.read() { print("\(i) \(s) \(d) \(i64) \(f)") //prints "42 st_ring! -0.987654321 12345678900 0.42" } </code></pre>
<p>The correct way to do this is to use <a href="https://developer.apple.com/reference/swift/1641199-readline" rel="nofollow"><code>readLine</code></a>, from the Swift Standard Library.</p> <p>Example:</p> <pre><code>let response = readLine(strippingNewline: true) </code></pre> <p>Will give you an Optional value containing the entered text.</p>
<p>Here is simple example of taking input from user on console based application: You can use readLine(). Take input from console for first number then press enter. After that take input for second number as shown in the image below:</p> <pre><code>func solveMefirst(firstNo: Int , secondNo: Int) -&gt; Int { return firstNo + secondNo } let num1 = readLine() let num2 = readLine() var IntNum1 = Int(num1!) var IntNum2 = Int(num2!) let sum = solveMefirst(IntNum1!, secondNo: IntNum2!) print(sum) </code></pre> <p><a href="https://i.stack.imgur.com/62x8I.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/62x8I.png" alt="Output"></a></p>
<p><strong>Before</strong></p> <p><a href="https://i.stack.imgur.com/Irv0R.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/Irv0R.png" alt="enter image description here"></a></p> <p>*******************.</p> <p><strong>Correction</strong></p> <p><a href="https://i.stack.imgur.com/LlGgz.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/LlGgz.png" alt="enter image description here"></a></p>
<p>This works in xCode v6.2, I think that's Swift v1.2</p> <pre><code>func input() -&gt; String { var keyboard = NSFileHandle.fileHandleWithStandardInput() var inputData = keyboard.availableData return NSString(data: inputData, encoding:NSUTF8StringEncoding)! as String } </code></pre>
<p>If you want to read space separated string, and immediately split the string into an array, you can do this:</p> <p><code>var arr = readLine()!.characters.split(" ").map(String.init)</code></p> <p>eg.</p> <pre><code>print("What is your full name?") var arr = readLine()!.characters.split(" ").map(String.init) var firstName = "" var middleName = "" var lastName = "" if arr.count &gt; 0 { firstName = arr[0] } if arr.count &gt; 2 { middleName = arr[1] lastName = arr[2] } else if arr.count &gt; 1 { lastName = arr[1] } print("First Name: \(firstName)") print("Middle Name: \(middleName)") print("Last Name: \(lastName)") </code></pre>