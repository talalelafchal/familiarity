Extension of constructed generic type in Swift
<p>Is it possible to extend an generic class for a specialised/constructed generic type? I would like to extend Int Arrays with a method to calculate the sum of its elements.</p> <p>e.g. </p> <pre><code>extension Array&lt;Int&gt; { func sum() -&gt; Int { return reduce(0) { $0 + $1 } } } </code></pre>
<p>Looks like you can't. The closest we can get is the function</p> <pre><code>func sum(a:Array&lt;Int&gt;) -&gt; Int { return a.reduce(0) {$0 + $1} } </code></pre> <p>Swift will allow you to add extension on the Array class but not specifically to a specialized version of the class.</p> <p><code>error: &lt;REPL&gt;:108:1: error: non-nominal type 'Array&lt;Int&gt;' cannot be extended</code></p> <p>You can extend the Array class.</p> <pre><code>extension Array { func sum() -&gt; Int { return reduce(0) { $0 + $1 } } } </code></pre> <p>The problem is now with the <code>+</code> operator</p> <pre><code>error: &lt;REPL&gt;:102:16: error: could not find an overload for '+' that accepts the supplied arguments return reduce(0) { $0 + $1 } </code></pre> <p>This is somewhat expected since we cannot be sure that the <code>+</code> operator will be will be overloaded for all the possible types that could be used in an array.</p> <p>So we could try to constraint the operation only on certain classes. Something like</p> <pre><code>class Dummy { } extension Array { func someFunc&lt;T:Dummy&gt;() -&gt; Int { return 0 } } var l = [Dummy()] var r = l.someFunc() // Expect 0 </code></pre> <p>Conceptually this should work (currently it seems that there is a bug, Xcode crashes when evaluating a playground using this code). In the eventually that it works, we cannot use this trick since the type <code>Int</code> is not a class.</p> <pre><code>extension Array { func sum&lt;T:Int&gt;() -&gt; T { return reduce(0) { $0 + $1 } } } error: &lt;REPL&gt;:101:14: error: inheritance from non-protocol, non-class type 'Int' func sum&lt;T:Int&gt;() -&gt; T { </code></pre> <p>I also looked at extending the Array class with a protocol but again <code>Int</code> not being a class makes it impossible. If the numeric types were classes, it would be nice if we could have a protocol to define that a class can be added just like <code>Comparable</code> or <code>Equatable</code> but my understanding is that protocol cannot define generic function which would be needed to create a <code>Addable</code> protocol.</p> <p>Edit:</p> <p>As stated by other answers, you can make it work for Int by explicitly checking and casting to Int in the closure. I guess I missed it will investigating. But it would still be nice if we could have a generic way of working with numeric types.</p>
<p>It is possible to return a real sum-value after you have tested for the int-type in <code>sum()</code>. Doing so I would solve the problem as follows:</p> <pre><code>import Cocoa extension Array { func sum() -&gt; Int { if !(self[0] is Int) { return 0; } var sum = 0; for value in self { sum += value as Int } return sum; } } let array = [1,2,3,4,5] array.sum() // =15 let otherArray = ["StringValue"] otherArray.sum() // =0 </code></pre>
<p>Alexander,</p> <p>Here's how you can do it:</p> <pre><code>extension Array { func sum() -&gt; Int { return reduce(0) { ($0 as Int) + ($1 as Int) } } } </code></pre> <p>Works like a charm, tested in the playground. However, you might get into trouble if you call this function on different types of arrays.</p>
<p>Managed to get something working in an extensible, generic fashion without abusing the type system too badly, however it has some limitations. </p> <pre><code>protocol Addable { func +(lhs: Self, rhs: Self) -&gt; Self class var identity: Self { get } } extension Int : Addable { static var identity: Int { get { return 0 } } } extension String : Addable { static var identity: String { get { return "" } } } extension Array { func sum&lt;U : Addable&gt;() -&gt; U? { let s: U? = U.identity return self.sum(s) } func sum&lt;U : Addable&gt;(start: U?) -&gt; U? { return reduce(start) { lhs, rhs in switch (lhs, rhs) { case (.Some(let left), let right as U): return left + right default: return nil } } } } </code></pre> <p>Specifically: with this solution, type inferencing won't work on the no-parameter <code>sum()</code> method, so you have to either annotate the expected return type or give it a starting value (from which it can infer the type).</p> <p>Note also that this returns a value of Optional type: if for any reason a sum of the expected type cannot be computed from the array, it returns nil.</p> <p>To illustrate:</p> <pre><code>let int_array = Array(1...10) let x: Int? = int_array.sum() // result: {Some 55} let x2 = int_array.sum(0) // result: {Some 55} let x3 = int_array.sum() // Compiler error because it can't infer type let string_array = ["a", "b", "c"] let y: String? = string_array.sum() // result: {Some "abc"} let y2 = string_array.sum("") // result: {Some "abc"} let y3: Int? = string_array.sum() // result: nil (can't cast String to Int) let y4 = string_array.sum(0) // result: nil (can't cast String to Int) let double_array = [1.3, 4.2, 2.1] let z = double_array.sum(0.0) // Compiler error because we haven't extended Double to be Addable </code></pre>
<p>With Swift 2 this can be achieved using protocol extensions (See <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html" rel="nofollow">The Swift Programming Language: Protocols</a> for more information). </p> <p>To sum just <code>Int</code>s you could do:</p> <pre><code>extension SequenceType where Generator.Element == Int { var sum: Int { return reduce(0, combine: +) } } </code></pre> <p>Usage:</p> <pre><code>let nums = [1, 2, 3, 4] print(nums.sum) // Prints: "10" </code></pre> <p>Or, for something more generic you could what @Wes Campaigne suggested and create an <code>Addable</code> protocol:</p> <pre><code>protocol Addable { init() func + (lhs: Self, rhs: Self) -&gt; Self } extension Int : Addable {} extension Double: Addable {} extension String: Addable {} // ... </code></pre> <p>Next, extend <code>SequenceType</code> to add sequences of <code>Addable</code> elements:</p> <pre><code>extension SequenceType where Generator.Element: Addable { var sum: Generator.Element { return reduce(Generator.Element(), combine: +) } } </code></pre> <p>Usage:</p> <pre><code>let doubles = [1.0, 2.0, 3.0, 4.0] print(doubles.sum) // Prints: "10.0" let strings = ["a", "b", "c"] print(strings.sum) // Prints: "abc" </code></pre>
<p>you can do it as well</p> <pre><code>extension Array { func sum () -&gt; Int? { guard self.count &gt; 0 &amp;&amp; self.first is Int else { return nil } var s = 0 forEach { s += $0 as! Int } return s } } </code></pre>