Swift dictionary bug?
<p>So I started a project in Swift, and I've come to this problem:</p> <p>this code works:</p> <pre><code>var dictionary = ["a":"valueOfA","b":"valueOfB","c":"valueOfC"] println(dictionary) dictionary["c"] = "newValOfC" println(dictionary) </code></pre> <p>and this doesn't:</p> <pre><code>var dictionary = [:] dictionary = ["a":"valueOfA","b":"valueOfB","c":"valueOfC"] println(dictionary) dictionary["c"] = "newValOfC" println(dictionary) </code></pre> <p>Gives an error:</p> <pre><code>Playground execution failed: error: &lt;REPL&gt;:35:17: error: cannot assign to the result of this expression dictionary["c"] = "newValC" ~~~~~~~~~~~~~~~ ^ </code></pre> <p>Notice that this is not a constant value</p> <p>So why doesn't the line</p> <pre><code>dictionary = ["a":"valueOfA","b":"valueOfB","c":"valueOfC"] </code></pre> <p>give an error?</p>
<p>The <code>[:]</code> syntax only works if the current context has enough information to be able to infer what the types are. Here are a few ways where the context is known...</p> <p>As has been mentioned already, the code below works because it can be inferred that the keys and values are strings:</p> <pre><code>var dictionary = [ "a" : "valueOfA" , "b" : "valueOfB" , "c" : "valueOfC" ] </code></pre> <p>A dictionary passed into a function has a known context:</p> <pre><code>func dictionaryFunc(var dictionary : Dictionary&lt;String, String&gt;) { // Do stuff with the dictionary } </code></pre> <p>In both cases, the key/value types for the dictionary are now known, so you could do this to create a new dictionary with the same variable name...</p> <pre><code>dictionary = [:] </code></pre> <p>In the first case, if you used the <code>[:]</code> syntax after the declaration you would be erasing the contents of the original dictionary. In the second case, dictionaries get copied when they get passed into functions, so using <code>[:]</code> would only be erasing the copy.</p>
<p>Okay, I found it, the problem is that by initializing an empty dictionary, the type inference gets a little crazy.</p> <p>You'll need this code:</p> <pre><code>var dictionary = Dictionary&lt;String, String&gt;() </code></pre> <p>instead of</p> <pre><code>var dictionary = [:] </code></pre> <p>but that still does not explain why the line</p> <pre><code>dictionary = ["a":"valueOfA","b":"valueOfB","c":"valueOfC"] </code></pre> <p>does not give an error</p>
<p>The big difference is that</p> <pre><code>var dictionary = [:] </code></pre> <p>doesn't give any chance the compiler to infer the right type, whereas</p> <pre><code>var dictionary = ["a":"valueOfA","b":"valueOfB","c":"valueOfC"] </code></pre> <p>does.</p> <p>Actually it looks like the first line produces a <code>__NSDictionaryI</code> instance, whereas the second one produces a <code>Dictionary&lt;String,String</code> as expected.</p> <p>From <em>The Swift Programming Language</em> book</p> <blockquote> <p>If the context already provides type information, create an empty dictionary with an empty dictionary literal, which is written as [:] (a colon inside a pair of square brackets):</p> </blockquote> <p>which means the first line is ambiguous.</p>
<p>And referring to Swift Language Guide, the</p> <pre><code>dictionary = [:] </code></pre> <p>syntax is correct "if the context already provides type information".</p>
<p>Since the context does not provide enough information to infer the type, you'll need to explicitly name it as a dictionary, otherwise swift assumes it is an <code>NSDictionary</code> (I'm not clear on why though. I assume for better obj-c compatibility):</p> <p>The following code all works:</p> <pre><code>// Playground import UIKit var str:NSString = "Hello, playground" var d0 = [:] var d1: Dictionary = [:] d0.setValue(UIWebView(), forKey: "asdf") d1["asdf"] = 1 d1["qwer"] = "qwer" </code></pre>
<p>In Swift 2.0 I'm using this:</p> <pre><code>var dictionary = [String:String]() dictionary["key1"] = "value1" </code></pre>