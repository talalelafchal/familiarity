Why is there no universal base class in Swift?
<p>The documentation says</p> <blockquote> <p>NOTE</p> <p>Swift classes do not inherit from a universal base class. Classes you define without specifying a superclass automatically become base classes for you to build upon.”</p> <p>Excerpt From: Apple Inc. “<a href="https://itun.es/at/jEUH0.l">The Swift Programming Language.</a>” iBooks.</p> </blockquote> <p>It doesn't make much sense to me. There is a reason why Objective-C has a universal base class, and the same reason should apply to Swift, does it? <code>NSObject</code> manages retain/release semantics, a default implementation for <code>isEqual:</code>, <code>hash</code> and <code>description</code>. All this functionality is available in Swift too.</p> <p>(Objective-C and Swift use the same runtime...)</p> <p>So, what's up with that? Are Swift classes with no defined superclasses just <code>NSObject</code>s that pose as proper root classes under the hood? Or is the default object-behaviour duplicated for each new root-class? Or have they created another Swift-baseclass? The implementation of <code>retain</code> and <code>release</code> is really complex, because it needs to take multithreading and weak references into account at the same time.</p> <p>Is there maybe a universal base class in Swift (despite what the documentation says)? It would be really handy, because in Objective-C I can e.g. write extensions that let me coalesce method invocations to the main runloop like <code>[obj.eventually updateCounter]</code> which can be read as "call <code>-updateCounter</code> the next time the main runloop gets in control. If, in the meantime, I call this method again, it should be called only once anyways. With this extension one could implement <code>-[UIView setNeedsDisplay]</code> as <code>[self.eventually display];</code> This is no longer possible in Swift if there is no universal base class (or maybe it is, who knows?)</p>
<p>This is mainly a <b>design decision</b>, there are languages which have a root class (e.g. Java) and languages which don't (e.g. C++).</p> <p>Note that in Obj-C a root class is not enforced. You can easily create an object which doesn't inherit from any class. You can also create your own root classes, there are at least 3 in the Apple API (<code>NSObject</code>, <code>NSProxy</code> and deprecated <code>Object</code>).</p> <p>The reason to have a root class is mostly historical - the root class ensures that all objects have some common interface, some common methods (e.g. <code>isEqualTo:</code>, <code>hash()</code> etc.) which are necessary for collection classes to work.</p> <p>Once you have generics (or templates in C++), having a root class is not so important any more.</p> <p><code>retain</code> and <code>release</code> in <code>NSObject</code> are not important anymore since ARC. With MRC, you were still required to call them. With ARC you never call the methods explicitly and they can be implemented more efficiently behind the scenes.</p> <p>In Swift, the methods from <code>NSObject</code> have been divided into protocols - <code>Equatable</code>, <code>Hashable</code>, <code>Printable</code> and <code>DebugPrintable</code>. That has the advantage that objects can share interfaces with structs.</p> <p>However, there is nothing stopping you from inheriting every class from <code>NSObject</code>. The class is still there and it is especially useful if you are dealing with Obj-C APIs. In pure Swift, a root class is not necessary though.</p> <p>One more note:</p> <p>Swift classes doesn't run on top of Obj-C; they are not translated into Obj-C behind the scenes. They are just compiled by the same compiler which allows them to interoperate with each other. That's really important to understand. That's why <code>@objc</code> must be sometimes added to provide consistency with Obj-C protocols/classes.</p>
<p>There are several object-oriented languages where one can define new root classes, including C++, PHP, and Objective-C, and they work fine, so this is definitely not a special thing.</p> <blockquote> <p>There is a reason why Objective-C has a universal base class</p> </blockquote> <p>As Sulthan mentioned, this is not true. There are multiple root classes in Objective-C, and you can define a new root class by simply not specifying a superclass. As Sulthan also mentioned, Cocoa itself has several root classes, <code>NSObject</code>, <code>NSProxy</code>, and <code>Object</code> (the root class of <code>Protocol</code> in ObjC 1.0).</p> <p>The original Objective-C language was very flexible and someone could in theory come along and create his own root class and create his own framework that is completely different from Foundation, and uses methods completely different from <code>retain</code>, <code>release</code>, <code>alloc</code>, <code>dealloc</code>, etc., and could even implement a completely different way of memory management if he wanted. This flexibility is one of the things so amazing about the bare Objective-C language -- it simply provides a thin layer, all the other things like how objects are created and destroyed, memory management, etc., can all be determined by the user frameworks sitting on top.</p> <p>However, with Apple's Objective-C 2.0 and modern runtime, <a href="https://stackoverflow.com/questions/3582209/whats-required-to-implement-root-class-of-objective-c">more work</a> needed to be done to make your own root class. And with the addition of ARC, in order to use your objects in ARC, you must implement Cocoa's memory management methods like <code>retain</code> and <code>release</code>. Also, to use your objects in Cocoa collections, your class must also implement things like <code>isEqual:</code> and <code>hash</code>.</p> <p>So in modern Cocoa/Cocoa Touch development, objects generally must at least implement a basic set of methods, which are the methods in the <code>NSObject</code> protocol. All the root classes in Cocoa (<code>NSObject</code>, <code>NSProxy</code>) implement the <code>NSObject</code> protocol. </p> <blockquote> <p>So, what's up with that? Are Swift classes with no defined superclasses just NSObjects that pose as proper root classes under the hood? Or is the default object-behaviour duplicated for each new root-class? Or have they created another Swift-baseclass?</p> </blockquote> <p>This is a good question, and you can find out by introspection with the Objective-C runtime. All objects in Swift are, in a sense, also Objective-C objects, in that they can be used with the Objective-C runtime just like objects from Objective-C. Some members of the class (the ones not marked <code>@objc</code> or <code>dynamic</code>) may not be visible to Objective-C, but otherwise all the introspection features of the Objective-C runtime work fully on objects of pure Swift classes. Classes defined in Swift look like any other class to the Objective-C runtime, except the name is mangled.</p> <p>Using the Objective-C runtime, you can discover that for a class that is a root class in Swift, from the point of view of Objective-C, it actually has a superclass named <code>SwiftObject</code>. And this <code>SwiftObject</code> class implements the methods of the <code>NSObject</code> protocol like <code>retain</code>, <code>release</code>, <code>isEqual:</code>, <code>respondsToSelector:</code>, etc. (though it does not actually conform to the <code>NSObject</code> protocol). This is how you can use pure Swift objects with Cocoa APIs without problem.</p> <p>From inside Swift itself, however, the compiler does not believe that a Swift root class implements these methods. So if you define a root class <code>Foo</code>, then if you try to call <code>Foo().isKindOfClass(Foo.self)</code>, it will not compile it complaining that this method does not exist. But we can still use it with a trick -- recall that the compiler will let us call any Objective-C method (which the compiler has heard of) on a variable of type <code>AnyObject</code>, and the method lookup produces an implicitly-unwrapped optional function that succeeds or fails at runtime. So what we can do is cast to <code>AnyObject</code>, make sure to import <code>Foundation</code> or <code>ObjectiveC</code> (so the declaration is visible to the compiler), we can then call it, and it will work at runtime:</p> <pre><code>(Foo() as AnyObject).isKindOfClass(Foo.self) </code></pre> <p>So basically, from the Objective-C point of view, a Swift class either has an existing Objective-C class as root class (if it inherited from an Objective-C class), or has <code>SwiftObject</code> as root class.</p>