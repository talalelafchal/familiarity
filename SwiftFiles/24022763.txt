UITableView in Swift
<p>I'm struggling to figure out what's wrong with this code snippet. This would work in Objective C, but in Swift this just crashes on the first line of the method. It doesn't give an error message, only <code>Bad_Instruction</code>.</p> <pre><code>func tableView(tableView: UITableView!, cellForRowAtIndexPath indexPath: NSIndexPath!) -&gt; UITableViewCell! { var cell : UITableViewCell = tableView.dequeueReusableCellWithIdentifier("Cell") as UITableViewCell if (cell == nil) { cell = UITableViewCell(style: UITableViewCellStyle.Value1, reuseIdentifier: "Cell") } cell.textLabel.text = "TEXT" cell.detailTextLabel.text = "DETAIL TEXT" return cell } </code></pre>
<p>Here is what I wrote to get it working...</p> <p>First Register the table view cell with the table view</p> <pre><code>self.tableView.registerClass(MyTableViewCell.self, forCellReuseIdentifier: "Cell") </code></pre> <p>Then configure cellForRowAtIndexPath</p> <pre><code>func tableView(tableView: UITableView!, cellForRowAtIndexPath indexPath: NSIndexPath!) -&gt; UITableViewCell! { var cell = tableView.dequeueReusableCellWithIdentifier("Cell", forIndexPath: indexPath) as MyTableViewCell cell.textLabel.text = "Cell Text" cell.detailTextLabel.text = "Cell Detail Text in Value 1 Style" return cell } </code></pre> <p>I then defined a custom cell subclass write at the bottom of the file (since its so much easier now)</p> <pre><code>class MyTableViewCell : UITableViewCell { init(style: UITableViewCellStyle, reuseIdentifier: String!) { super.init(style: UITableViewCellStyle.Value1, reuseIdentifier: reuseIdentifier) } } </code></pre>
<p>For cell template: </p> <pre>func tableView(tableView: UITableView!, cellForRowAtIndexPath indexPath: NSIndexPath!) -> UITableViewCell! { let myCell : youCell = youCell(style: UITableViewCellStyle.Subtitle, reuseIdentifier: "cell") return myCell } </pre>
<p><em>Also see <a href="http://stackoverflow.com/a/24913017/669586">matt's answer</a> which contains the second half of the solution</em></p> <p>Let's find a solution without creating custom subclasses or nibs</p> <p>The real problem is in the fact that Swift distinguishes between objects that can be empty (<code>nil</code>) and objects that can't be empty. If you don't register a nib for your identifier, then <code>dequeueReusableCellWithIdentifier</code> can return <code>nil</code>.</p> <p>That means we have to declare the variable as optional:</p> <pre><code>var cell : UITableViewCell? </code></pre> <p>and we have to cast using <code>as?</code> not <code>as</code></p> <pre><code>//variable type is inferred var cell = tableView.dequeueReusableCellWithIdentifier("CELL") as? UITableViewCell if cell == nil { cell = UITableViewCell(style: UITableViewCellStyle.Value1, reuseIdentifier: "CELL") } // we know that cell is not empty now so we use ! to force unwrapping but you could also define cell as // let cell = (tableView.dequeue... as? UITableViewCell) ?? UITableViewCell(style: ...) cell!.textLabel.text = "Baking Soda" cell!.detailTextLabel.text = "1/2 cup" cell!.textLabel.text = "Hello World" return cell </code></pre>
<p>Try this:</p> <pre><code>func tableView(tableView: UITableView!, cellForRowAtIndexPath indexPath: NSIndexPath!) -&gt; UITableViewCell! { let cell = tableView.dequeueReusableCellWithIdentifier("Cell", forIndexPath: indexPath) as UITableViewCell cell.textLabel.text = "\(indexPath.row)" return cell } </code></pre> <p>Note that you should register you <code>UITableViewCell</code> and ID when creating instantiating your <code>UITableView</code>:</p> <pre><code>tableView.delegate = self tableView.dataSource = self tableView.registerClass(UITableViewCell.classForCoder(), forCellReuseIdentifier: "Cell") </code></pre>
<p>bro, please take a look at the sample <a href="https://github.com/brotchie/SwiftTableView" rel="nofollow">https://github.com/brotchie/SwiftTableView</a></p>
<p>@Sulthan's answer is spot on. One possible convenience modification would be to cast the cell as a UITableViewCell!, rather than a UITableViewCell.</p> <pre><code>func tableView(tableView: UITableView!, cellForRowAtIndexPath indexPath: NSIndexPath!) -&gt; UITableViewCell! { var cell = tableView.dequeueReusableCellWithIdentifier("CELL") as UITableViewCell! if !cell { cell = UITableViewCell(style:.Default, reuseIdentifier: "CELL") } // setup cell without force unwrapping it cell.textLabel.text = "Swift" return cell } </code></pre> <p>Now, you can modify the cell variable without force unwrapping it each time. Use caution when using implicitly unwrapped optionals. You must be certain that the value you are accessing has a value.</p> <p>For more information, refer to the "Implicitly Unwrapped Optionals" section of <em>The Swift Programming Language</em>.</p>
<p>Sulthan's answer is clever, but the real solution is: <em>don't call <code>dequeueReusableCellWithIdentifier</code></em>. That was your mistake at the outset.</p> <p>This method is completely outmoded, and I'm surprised it has not been formally deprecated; no system that can accommodate Swift (iOS 7 or iOS 8) needs it for any purpose whatever.</p> <p>Instead, call the modern method, <code>dequeueReusableCellWithIdentifier:forIndexPath:</code>. This has the advantage that <em>no optionals are involved</em>; you are <strong><em>guaranteed</em></strong> that a cell will be returned. All the question marks and exclamation marks fall away, you can use <code>let</code> instead of <code>var</code> because the cell's existence is guaranteed, and you're living in a convenient, modern world.</p> <p>You must, if you're not using a storyboard, register the table for this identifier beforehand, registering either a class or a nib. The conventional place to do that is <code>viewDidLoad</code>, which is as early as the table view exists at all.</p> <p>Here's an example using a custom cell class:</p> <pre><code>override func viewDidLoad() { super.viewDidLoad() self.tableView.registerClass(MyCell.self, forCellReuseIdentifier: "Cell") } // ... override func tableView(tableView: UITableView!, cellForRowAtIndexPath indexPath: NSIndexPath!) -&gt; UITableViewCell! { let cell = tableView.dequeueReusableCellWithIdentifier("Cell", forIndexPath:indexPath) as MyCell // no "if" - the cell is guaranteed to exist // ... do stuff to the cell here ... cell.textLabel.text = // ... whatever // ... return cell } </code></pre> <p>But if you're using a storyboard (which most people do), you don't even need to register the table view in <code>viewDidLoad</code>! Just enter the cell identifier in the storyboard and you're good to go with <code>dequeueReusableCellWithIdentifier:forIndexPath:</code>.</p>
<p>Try this code </p> <pre><code>var cell:CustomTableViewCell = tableView.dequeueReusableCellWithIdentifier("CustomTableViewCell") as CustomTableViewCell cell.cellTitle.text="vijay" </code></pre> <p><a href="https://github.com/iappvk/TableView-Swift" rel="nofollow">https://github.com/iappvk/TableView-Swift</a></p>
<p>Actually in the Apple's TableView Guide document and Sample Code you will find the sentence below:</p> <blockquote> <p>If the dequeueReusableCellWithIdentifier: method asks for a cell thatâ€™s defined in a storyboard, the method always returns a valid cell. If there is not a recycled cell waiting to be reused, the method creates a new one using the information in the storyboard itself. This eliminates the need to check the return value for nil and create a cell manually.</p> </blockquote> <p>So,we could just code like this:</p> <pre><code>var identifer: String = "myCell" var cell = tableView.dequeueReusableCellWithIdentifier(identifer) as UITableViewCell cell.textLabel.text = a[indexPath.row].name cell.detailTextLabel.text = "detail" </code></pre> <p>I think this is a suitable way to use tableView</p>
<p>Why not this?</p> <p>(please delete if i am not in the goal...)</p> <pre><code>func tableView(tableView: UITableView!, cellForRowAtIndexPath indexPath: NSIndexPath!) -&gt; UITableViewCell! { if let cell: UITableViewCell = theTableView.dequeueReusableCellWithIdentifier("myCell", forIndexPath: indexPath) as? UITableViewCell { // cell ok }else{ // not ok } } </code></pre>
<p>There's a few answers here, but I don't think any of them are ideal, because after the declaration you're ending up with an optional UITableViewCell, which then needs a <code>cell!...</code> in any declarations. I think this is a better approach (I can confirm this compiles on Xcode 6.1):</p> <pre><code>var cell:UITableViewCell if let c = tableView.dequeueReusableCellWithIdentifier("cell") as? UITableViewCell { cell = c } else { cell = UITableViewCell() } </code></pre>
<p>Using "as" keyword would do the following two steps:<br> 1.creating a optional value which wrap a variable of UITableViewCell;<br> 2.unwrapping the optional value.</p> <p>So,by doing this</p> <pre><code>var cell : UITableViewCell = tableView.dequeueReusableCellWithIdentifier("Component") as UITableViewCell </code></pre> <p>you would get a "plain" UITableViewCell type variable: cell.Theoretically speaking, it's ok to do this.But the next line</p> <pre><code>if (cell == nil) {} </code></pre> <p>makes trouble, because in swift, only the optional value can be assigned with nil. </p> <p>So, to solve this problem, you have to make cell a variable of Optional type. just like this:</p> <pre><code>var cell = tableView.dequeueReusableCellWithIdentifier("Component") as? UITableViewCell </code></pre> <p>using the keyword "as?" would create a Optional variable, and this, undoubtedly, can be assigned with nil.</p>
<p>I have done in following way: to show detailTextLabel. text value</p> <pre><code> func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell { let CellIdentifier: String = "cell" var cell = tableView.dequeueReusableCellWithIdentifier(CellIdentifier) as? UITableViewCell if cell == nil { cell = UITableViewCell(style: UITableViewCellStyle.Value1, reuseIdentifier: CellIdentifier) } //cell.accessoryType = UITableViewCellAccessoryType.DisclosureIndicator // parse the value of records let dataRecord = self.paymentData[indexPath.row] as! NSDictionary let receiverName = dataRecord["receiver_name"] as! String let profession = dataRecord["profession"] as! String let dateCreated = dataRecord["date_created"] as! String let payAmount = dataRecord["pay_amount"] as! String println("payment \(payAmount)") cell!.textLabel?.text = "\(receiverName)\n\(profession)\n\(dateCreated)" cell!.detailTextLabel?.text = "$\(payAmount)" cell!.textLabel?.numberOfLines = 4 return cell! }// end tableview </code></pre>
<p>Well, I have done this way:</p> <p>Steps for <strong>UITableView</strong> using <strong>Swift</strong>:</p> <ul> <li>Take <strong>UITableView</strong> in <strong>ViewController</strong></li> <li>Give <strong>Referencing Outlets</strong> in <strong>ViewController.swift</strong> class </li> <li>Give Outlets <strong>dataSource</strong> &amp; <strong>delegate</strong> to <strong>ViewController</strong></li> </ul> <p>Now <strong>Swift</strong> code in <strong>ViewController.swift</strong> class:</p> <pre><code>class ViewController: UIViewController, UITableViewDelegate, UITableViewDataSource { @IBOutlet weak var mTableView: UITableView! var items: [String] = ["Item 1","Item 2","Item 3", "Item 4", "Item 5"] override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. self.mTableView.registerClass(UITableViewCell.self, forCellReuseIdentifier: "cell") } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. } func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { return self.items.count; } func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell { var cell:UITableViewCell = self.mTableView.dequeueReusableCellWithIdentifier("cell") as! UITableViewCell cell.textLabel?.text = self.items[indexPath.row] println(self.items[indexPath.row]) return cell } func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) { println("You have selected cell #\(indexPath.row)!") } } </code></pre> <p>Now it's time to <strong>Run your program</strong>.</p> <p><strong>Done</strong></p>
<p>Here is what I think the most simple way to define basic table cell in swift 2:</p> <pre><code>func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell { let identifier = "cell" let cell = tableView.dequeueReusableCellWithIdentifier(identifier) ?? UITableViewCell.init(style: UITableViewCellStyle.Default, reuseIdentifier: identifier) cell.textLabel!.text = "my text" return cell } </code></pre>