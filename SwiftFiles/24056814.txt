Swift: detecting bodyAtPoint. Always nil
<p>I'm struggling to discover why I cannot detect a bodyAtPoint with SpriteKit. bodyAtPoint always returns nil, even when it appears I'm always tapping the sprite node.</p> <p>Here's the code:</p> <pre><code>... let spaceship = SKSpriteNode(color: UIColor.blueColor(), size: CGSizeMake(100, 100)) override func didMoveToView(view: SKView) { /* Setup your scene here */ var borderBody = SKPhysicsBody(edgeLoopFromRect: self.frame) self.physicsBody = borderBody self.physicsBody.friction = 0.0 self.physicsWorld.gravity = CGVectorMake(0.0, 0.0) spaceship.name = "spaceship" spaceship.position = CGPointMake(400, 300) var bodySize = CGSizeMake(spaceship.size.width / 1.15, spaceship.size.height / 1.15); spaceship.physicsBody = SKPhysicsBody(rectangleOfSize: bodySize) spaceship.physicsBody.dynamic = false spaceship.physicsBody.restitution = 1.0 spaceship.physicsBody.friction = 0.0 spaceship.physicsBody.linearDamping = 0.0 spaceship.physicsBody.allowsRotation = false self.addChild(spaceship) } override func touchesBegan(touches: NSSet, withEvent event: UIEvent) { /* Called when a touch begins */ super.touchesBegan(touches, withEvent: event) var touch : UITouch! = touches.anyObject() as UITouch var touchLocation : CGPoint! = touch.locationInNode(self) if self.physicsWorld.bodyAtPoint(touchLocation) { NSLog("true") } else { NSLog("false") } } ... </code></pre> <p>RESULTS:</p> <p>spaceship.physicsBody outputs:</p> <pre><code>&lt;SKPhysicsBody&gt; type:&lt;Rectangle&gt; representedObject:[&lt;SKSpriteNode&gt; name:'spaceship' texture:['nil'] position:{400, 300} size:{100, 100} rotation:0.00] </code></pre> <p>touchLocation output:</p> <pre><code>(411.943664550781,553.014099121094) </code></pre> <p>self.physicsWorld.bodyAtPoint(touchLocation) is always:</p> <pre><code>nil </code></pre> <p>...therefore the conditional always returns 'false'.</p> <p>Can anybody explain where I'm going wrong? I want to ultimately detect a touch on a sprite node and perform an action.</p> <p>All help appreciated.</p> <p>LM</p> <p><strong>EDIT:</strong></p> <p>Even if I simplify to the following I still always get false:</p> <p>override func touchesBegan(touches: NSSet, withEvent event: UIEvent) {</p> <pre><code>... for touch: AnyObject in touches { let location = touch.locationInNode(self) if self.physicsWorld.bodyAtPoint(location) { NSLog("true") } else { NSLog("false") } } } ... </code></pre>
<p>With many thanks to @eXhausted for the answer. </p> <p>The trick is to call nodeAtPoint and access nodeAtPoint.name.</p> <pre><code>override func touchesBegan(touches: NSSet, withEvent event: UIEvent) { for touch: AnyObject in touches { let location: CGPoint! = touch.locationInNode(self) let nodeAtPoint = self.nodeAtPoint(location) if nodeAtPoint.name { println("NODE FOUND: \(nodeAtPoint.name)") } else { println("NULL") } } } </code></pre>
<p>If you want to use exactly bodyAtPoint, you cannot access to the name of the node. The problem is if you want <strong>a pixel perfect touch detection</strong>, for example, you need to detect the shape not the rect of the sprite with alpha part.</p> <p>The trick is to use the <strong>categoryBitMask</strong>. You can assign the category 0x1 &lt;&lt; 1, for example, to an object and then ask for its category. Category is an Uint32 with the same function like name, mainly for physics collision detection, but you can use it for recognize a physicsBody:</p> <pre><code> let nodo = self.physicsWorld.bodyAtPoint(punto) if (nodo?.categoryBitMask == 0x1 &lt;&lt; 1) { } </code></pre> <p>So easy! Hope it helps you!</p>
<p>I had a similar problem as nodes approached another node that had an attached particle emitter. Seems the <code>nodeAtPoint()</code> detected the emitter even though it was hidden at the time. </p> <p>I solved this by using the alternative <code>nodesAtPoint()</code> and iterating through the nodes until I found the node I really wanted to detect.</p> <p>Not sure if the z order if the particle emitter is bringing it to the top of the stack or not, but not wanting to fiddle with the z ordering at this stage, finding all touched nodes at the touch point worked for me.</p>