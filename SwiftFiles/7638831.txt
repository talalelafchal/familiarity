Fade/dissolve when changing UIImageView's image
<p>Rather than creating two <code>UIImageViews</code>, it seems logical to simply change the <code>image</code> of one view. If I do that, is there anyway of having a fade/cross dissolve between the two images rather than an instant switch?</p>
<p>Yes what you say is absolutely correct and thats the way to do it. I wrote this method &amp; always use this to Fade in my image. I deal with <code>CALayer</code> for this. You need to import Core Animation for this. </p> <pre><code>+ (void)fadeInLayer:(CALayer *)l { CABasicAnimation *fadeInAnimate = [CABasicAnimation animationWithKeyPath:@"opacity"]; fadeInAnimate.duration = 0.5; fadeInAnimate.repeatCount = 1; fadeInAnimate.autoreverses = NO; fadeInAnimate.fromValue = [NSNumber numberWithFloat:0.0]; fadeInAnimate.toValue = [NSNumber numberWithFloat:1.0]; fadeInAnimate.removedOnCompletion = YES; [l addAnimation:fadeInAnimate forKey:@"animateOpacity"]; return; } </code></pre> <p>You could do the opposite for Fade out an image. After it fades out. You just remove it from superview (which is <code>UIImageView</code>). <code>[imageView removeFromSuperview]</code>.</p>
<p><strong>Edit: there is a better solution from <a href="http://stackoverflow.com/a/9773674/377384">@algal below</a>.</strong></p> <p>Another way to do this is by using predefined CAAnimation transitions:</p> <pre><code>CATransition *transition = [CATransition animation]; transition.duration = 0.25; transition.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]; transition.type = kCATransitionFade; transition.delegate = self; [self.view.layer addAnimation:transition forKey:nil]; view1.hidden = YES; view2.hidden = NO; </code></pre> <p>See the View Transitions example project from Apple: <a href="http://developer.apple.com/library/ios/#samplecode/ViewTransitions/Introduction/Intro.html#//apple_ref/doc/uid/DTS40007411">http://developer.apple.com/library/ios/#samplecode/ViewTransitions/Introduction/Intro.html#//apple_ref/doc/uid/DTS40007411</a></p>
<p>It can be much simpler using the new block-based, UIKit animation methods.</p> <p>Suppose the following code is in the view controller, and the UIImageView you want to cross-dissolve is a subview of self.view addressable via the property self.imageView. Then all you need is:</p> <pre><code>UIImage * toImage = [UIImage imageNamed:@"myname.png"]; [UIView transitionWithView:self.imageView duration:5.0f options:UIViewAnimationOptionTransitionCrossDissolve animations:^{ self.imageView.image = toImage; } completion:nil]; </code></pre> <p>Done.</p> <p>And to do it in Swift, it's like so:</p> <pre><code>let toImage = UIImage(named:"myname.png") UIView.transitionWithView(self.imageView, duration:5, options: UIViewAnimationOptions.TransitionCrossDissolve, animations: { self.imageView.image = toImage }, completion: nil) </code></pre>
<p>You could also package the fade-in feature in a subclass, so that you can then use it as a common UIImageView, as in the following example:</p> <pre><code>IMMFadeImageView *fiv=[[IMMFadeImageView alloc] initWithFrame:CGRectMake(10, 10, 50, 50)]; [self.view addSubview:fiv]; fiv.image=[UIImage imageNamed:@"initialImage.png"]; fiv.image=[UIImage imageNamed:@"fadeinImage.png"]; // fades in </code></pre> <p>A possible implementation follows. </p> <p><em>Note: the way you actually implement the fade-in in the <code>setImage:</code> function can change, and could be one of the other excellent examples described in the other answers to this question â€” creating an additional on-the-fly <code>UIImageView</code> as I'm doing here might be an unacceptable overhead in your specific situation</em>.</p> <p><strong>IMMFadeImageView.h</strong> :</p> <pre><code>#import &lt;UIKit/UIKit.h&gt; @interface IMMFadeImageView : UIImageView @property (nonatomic,assign) float fadeDuration; @end </code></pre> <p><strong>IMMFadeImageView.m</strong> :</p> <pre><code>#import "IMMFadeImageView.h" @implementation IMMFadeImageView @synthesize fadeDuration; - (id)initWithFrame:(CGRect)frame { self = [super initWithFrame:frame]; if (self) { self.fadeDuration=1; } return self; } -(void)setImage:(UIImage *)newImage{ if(!self.image||self.fadeDuration&lt;=0){ super.image=newImage; } else { UIImageView *iv=[[UIImageView alloc] initWithFrame:self.bounds]; iv.contentMode=self.contentMode; iv.image=super.image; iv.alpha=1; [self addSubview:iv]; super.image=newImage; [UIView animateWithDuration:self.fadeDuration delay:0 options:UIViewAnimationCurveEaseInOut animations:^{ iv.alpha=0; } completion:^(BOOL finished) { [iv removeFromSuperview]; }]; } } </code></pre> <p><em>The above code relies on a few assumptions (including ARC being enabled in your XCode project), is only intended as a proof of concept, and in the interest of clarity and focus, it stays relevant by omitting important unrelated code. Please don't just copy-paste it blindly.</em></p>
<p>I needed the transition to repeat indefinitely. It took a LOT of trial and error for this one but I finally got the end-result I was looking for. These are code snippets for adding image animation to a UIImageView in a UITableViewCell.</p> <p>Here is the relevant code:</p> <pre><code>@interface SomeViewController () @property(nonatomic, strong) NSMutableArray *imagesArray; @property(nonatomic, assign) NSInteger varietyImageAnimationIndex; @property(nonatomic, assign) BOOL varietyImagesAnimated; @end @implementation SomeViewController @synthesize imagesArray; @synthesize varietyImageAnimationIndex; @synthesize varietyImagesAnimated; ... // NOTE: Initialize the array of images in perhaps viewDidLoad method. -(void)animateImages { varietyImageAnimationIndex++; [UIView transitionWithView:varietyImageView duration:2.0f options:UIViewAnimationOptionTransitionCrossDissolve animations:^{ varietyImageView.image = [imagesArray objectAtIndex:varietyImageAnimationIndex % [imagesArray count]]; } completion:^(BOOL finished) { [self animateImages]; }]; } - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { ... [cell.imageView setImage:[imagesArray objectAtIndex:0]]; [self setVarietyImageView:cell.imageView]; if (! varietyImagesAnimated) { varietyImagesAnimated = YES; [self animateImages]; } ... return cell; } </code></pre>
<p>This is I think the shortest way of doing it. Create a UIView animation and commit it on your imageView.</p> <pre><code>[UIView beginAnimations:nil context:NULL]; [UIView setAnimationDuration:0.5]; [myImageView setAlpha:0.0]; [UIView commitAnimations]; </code></pre>
<p>By using the <code>highlightedImage</code> property this can be made a bit more simple. Here's an example in Swift 3. First set both normal and highlighted image:</p> <pre><code>let imageView = UIImageView(image: UIImage(named: "image"), highlightedImage: UIImage(named: "highlightedImage")) </code></pre> <p>And when you want to change between those animated:</p> <pre><code>UIView.transition(with: imageView, duration: 0.3, options: .transitionCrossDissolve, animations: { self.imageView.isHighlighted = !self.imageView.isHighlighted}, completion: .none) </code></pre>