Error in Swift class: Property not initialized at super.init call
<p>I have two classes, <code>Shape</code> and <code>Square</code></p> <pre><code>class Shape { var numberOfSides = 0 var name: String init(name:String) { self.name = name } func simpleDescription() -&gt; String { return "A shape with \(numberOfSides) sides." } } class Square: Shape { var sideLength: Double init(sideLength:Double, name:String) { super.init(name:name) // Error here self.sideLength = sideLength numberOfSides = 4 } func area () -&gt; Double { return sideLength * sideLength } } </code></pre> <p>With the implementation above I get the error:</p> <pre><code>property 'self.sideLength' not initialized at super.init call super.init(name:name) </code></pre> <p>Why do I have to set <code>self.sideLength</code> before calling <code>super.init</code>?</p>
<p>swift enforces you to initialise every member var before it is ever/might ever be used. Since it can't be sure what happens when it is supers turn, it errors out: better safe than sorry</p>
<p>Quote from The Swift Programming Language, which answers your question:</p> <blockquote> <p>“Swift’s compiler performs four helpful safety-checks to make sure that two-phase initialization is completed without error:”</p> <p>Safety check 1 “A designated initializer must ensure that all of the “properties introduced by its class are initialized before it delegates up to a superclass initializer.”</p> <p>Excerpt From: Apple Inc. “The Swift Programming Language.” iBooks. <a href="https://itunes.apple.com/us/book/swift-programming-language/id881256329?mt=11">https://itunes.apple.com/us/book/swift-programming-language/id881256329?mt=11</a></p> </blockquote>
<p>Sorry for ugly formatting. Just put a question character after declaration and everything will be ok. A question tells the compiler that the value is optional.</p> <pre><code>class Square: Shape { var sideLength: Double? // &lt;=== like this .. init(sideLength:Double, name:String) { super.init(name:name) // Error here self.sideLength = sideLength numberOfSides = 4 } func area () -&gt; Double { return sideLength * sideLength } } </code></pre> <p><strong>Edit1:</strong></p> <p>There is a better way to skip this error. According to jmaschad's comment there is no reason to use optional in your case cause optionals are not comfortable in use and You always have to check if optional is not nil before accessing it. So all you have to do is to initialize member after declaration:</p> <pre><code>class Square: Shape { var sideLength: Double=Double() init(sideLength:Double, name:String) { super.init(name:name) self.sideLength = sideLength numberOfSides = 4 } func area () -&gt; Double { return sideLength * sideLength } } </code></pre> <p><strong>Edit2:</strong></p> <p>After two minuses got on this answer I found even better way. If you want class member to be initialized in your constructor you must assign initial value to it inside contructor and before super.init() call. Like this:</p> <pre><code>class Square: Shape { var sideLength: Double init(sideLength:Double, name:String) { self.sideLength = sideLength // &lt;= before super.init call.. super.init(name:name) numberOfSides = 4 } func area () -&gt; Double { return sideLength * sideLength } } </code></pre> <p>Good luck in learning Swift.</p>
<p>It's a staggeringly stupid design.</p> <p>Consider something like this:</p> <pre><code>. . . var playerShip:PlayerShip var deltaPoint = CGPointZero init(size: CGSize) { super.init(size: size) playerShip = PlayerShip(pos: CGPointMake(self.size.width / 2.0, 100)) playerLayerNode.addChild(playerShip) } . . . </code></pre> <p>This is invalid, as noted above. But so is:</p> <pre><code>. . . var playerShip:PlayerShip = PlayerShip(pos: CGPointMake(self.size.width / 2.0, 100)) var deltaPoint = CGPointZero init(size: CGSize) { super.init(size: size) playerLayerNode.addChild(playerShip) } . . . </code></pre> <p>Because 'self' hasn't be initialised.</p> <p>I sincerely hope this bug is fixed soon.</p> <p>(Yes I know I could create an empty object and then set the size but that's just stupid).</p>
<p>Swift has a very clear, specific sequence of operations that are done in initializers. Let's start with some basic examples and work our way up to a general case.</p> <p>Let's take an object A. We'll define it as follows.</p> <pre><code>class A { var x: Int init(x: Int) { self.x = x } } </code></pre> <p>Notice that A does not have a superclass, so it cannot call a super.init() function as it does not exist.</p> <p>OK, so now let's subclass A with a new class named B.</p> <pre><code>class B: A { var y: Int init(x: Int, y: Int) { self.y = y super.init(x: x) } } </code></pre> <p>This is a departure from Objective-C where <code>[super init]</code> would typically be called first before anything else. Not so in Swift. You are responsible for ensuring that your instance variables are in a consistent state before you do anything else, including calling methods (which includes your superclass' initializer).</p>
<p>The "super.init()" should be called after you initialize all your instance variables.</p> <p>In Apple's "Intermediate Swift" video (you can find it in Apple Developer video resource page <a href="https://developer.apple.com/videos/wwdc/2014/">https://developer.apple.com/videos/wwdc/2014/</a>), at about 28:40, it is explicit said that all initializers in super class must be called AFTER you initialize your instance variables.</p> <p>In Objective-C, it was the reverse. In Swift, since all properties need to be initialized before it's used, we need to initialize properties first. This is meant to prevent a call to overrided function from super class's "init()" method, without initializing properties first.</p> <p>So the implementation of "Square" should be:</p> <pre><code>class Square: Shape { var sideLength: Double init(sideLength:Double, name:String) { self.sideLength = sideLength numberOfSides = 4 super.init(name:name) // Correct position for "super.init()" } func area () -&gt; Double { return sideLength * sideLength } } </code></pre>
<p>Edward, </p> <p>You can modify the code in your example like this:</p> <pre><code>var playerShip:PlayerShip! var deltaPoint = CGPointZero init(size: CGSize) { super.init(size: size) playerLayerNode.addChild(playerShip) } </code></pre> <p>This is using an implicitly unwrapped optional.</p> <p>In documentation we can read:</p> <blockquote> <p>"As with optionals, if you don’t provide an initial value when you declare an implicitly unwrapped optional variable or property, it’s value automatically defaults to nil."</p> </blockquote>
<p>Swift will not allow you to initialise super class with out initialising the properties, reverse of Obj C. So you have to initialise all properties before calling "super.init". </p> <p>Please go to <a href="http://blog.scottlogic.com/2014/11/20/swift-initialisation.html">http://blog.scottlogic.com/2014/11/20/swift-initialisation.html</a>. It gives a nice explanation to your problem.</p>
<p>Add nil to the end of the declaration.</p> <hr> <pre><code>// Must be nil or swift complains var someProtocol:SomeProtocol? = nil // Init the view override init(frame: CGRect) super.init(frame: frame) ... </code></pre> <hr> <p><em>This worked for my case, but may not work for yours</em></p>
<p>Most of the answer here have explain the reasoning behind calling super.init at last pretty well, but the lack code example.</p> <p>So,</p> <blockquote> <p>Why do I have to set self.sideLength before calling super.init?</p> </blockquote> <p>Here is the example that clarifies WHY?</p> <pre><code>class Shape { var name: String var sides : Int init(sides:Int, named: String) { self.sides = sides self.name = named printShapeDescription() } func printShapeDescription() { print("Shape Name :\(self.name)") print("Sides :\(self.sides)") } } class Triangle: Shape { var hypotenuse: Int init(hypotenuse:Int) { self.hypotenuse = hypotenuse super.init(sides: 3, named: "Triangle") } override func printShapeDescription() { super.printShapeDescription() print("Hypotenuse :\(self.hypotenuse)") } } let triangle = Triangle(hypotenuse: 12) </code></pre> <p>Output :</p> <pre><code>Shape Name :Triangle Sides :3 Hypotenuse :12 </code></pre> <p>Here if we had called the <code>super.init</code> before setting the <code>hypotenuse</code>, the <code>super.init</code> call would then have called the <code>printShapeDescription()</code> and since that has been overridden it would first fallback to Triangle class implementation of <code>printShapeDescription()</code>. The <code>printShapeDescription()</code> of Triangle class access the <code>hypotenuse</code> a non optional property that still has not been initialised. And this cannot happen as all the non optional properties of a class need to be initialised before being accessed.</p>