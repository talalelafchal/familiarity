What's the best way to convert String into [Character] in Swift?
<p>I would like to run a filter on a string. My first attempt failed as string is not automagically converted to Character[].</p> <pre><code>var s: String = "abc" s.filter { $0 != "b" } </code></pre> <p>If I clumsily convert the String to Character[] with following code, it works as expected. But surely there has to be a neater way?</p> <pre><code>var cs:Character[] = [] for c in s { cs = cs + [c] } cs = cs.filter { $0 != "b" } println(cs) </code></pre>
<p>I don't know of a built in way to do it, but you could write your own filter method for String:</p> <pre><code>extension String { func filter(f: (Character) -&gt; Bool) -&gt; String { var ret = "" for character in self { if (f(character)) { ret += character } } return ret } } </code></pre> <p>If you don't want to use an extension you could do this:</p> <pre><code>Array(s).filter({ $0 != "b" }).reduce("", combine: +) </code></pre>
<p>You can use this syntax:</p> <pre><code>var chars = Character[]("abc") </code></pre> <p>I'm not 100% sure if the result is an array of <code>Character</code>s or not but works for my use case.</p> <pre><code>var str = "abc" var chars = Character[](str) var result = chars.map { char in "char is \(char)" } result </code></pre>
<p>The easiest way to convert a char to string is using the backslash (), for example I have a function to reverse a string, like so.</p> <pre><code>var identityNumber:String = id for char in identityNumber{ reversedString = "\(char)" + reversedString } </code></pre>
<p><code>String</code> conforms to the <code>CollectionType</code> protocol, so you can pass it directly to the function forms of <code>map</code> and <code>filter</code> without converting it at all:</p> <pre><code>let cs = filter(s) { $0 != "f" } </code></pre> <p><code>cs</code> here is an <code>Array</code> of <code>Character</code>s. You can turn it into a <code>String</code> by using the <code>String(seq:)</code> initializer, which constructs a <code>String</code> from any <code>SequenceType</code> of <code>Character</code>s. (<code>SequenceType</code> is a protocol that all lists conform to; <code>for</code> loops use them, among many other things.)</p> <pre><code>let filteredString = String(seq: cs) </code></pre> <p>Of course, you can just as easily put those two things in one statement:</p> <pre><code>let filteredString = String(seq: filter(s) { $0 != "f" }) </code></pre> <p>Or, if you want to make a convenience <code>filter</code> method like the one on <code>Array</code>, you can use an extension:</p> <pre><code>extension String { func filter(includeElement: Character -&gt; Bool) -&gt; String { return String(seq: Swift.filter(self, includeElement)) } } </code></pre> <p>(You write it "Swift.filter" so the compiler doesn't think you're trying to recursively call the <code>filter</code> method you're currently writing.)</p> <p>As long as we're hiding how the filtering is performed, we might as well use a lazy <code>filter</code>, which should avoid constructing the temporary array at all:</p> <pre><code>extension String { func filter(includeElement: Character -&gt; Bool) -&gt; String { return String(seq: lazy(self).filter(includeElement)) } } </code></pre>