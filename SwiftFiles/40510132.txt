Swift 3 - How to create a serial queue that waits for closure completion to keep executing work items
I am trying to get a queue that executes serially, wether its queued items are synchronous or asynchronous. The idea is that one of the functions returns a block. That block should somehow be queued onto the serial queue and dequeued when executed to let subsequent work items through. Here is an example of what I am trying to achieve: let serialQueue = DispatchQueue(label: "print.serial.queue") var i = 0 override func viewDidLoad() { super.viewDidLoad() printSomething() // Executes immediately printSomething() // Executes immediately let completion = printSomethingWithClosure() // Will execute when the closure is called printSomething() // Queued because completion hasn't been called yet printSomething() // Queued because completion hasn't been called yet completion() // The closure is executed, the queue can move on to the next work item // Expected output: // serial 1 // serial 2 // serial 3 (closure called) // serial 4 // serial 5 } func printSomething(){ let workItem = DispatchWorkItem(qos: .userInitiated, flags: .assignCurrentContext) {[unowned self] in print("serial \(self.i)") self.i = self.i + 1 } serialQueue.sync(execute: workItem) } func printSomethingWithClosure() -> (() -> ()){ let completionHandler = { print("serial \(self.i) (closure called)") self.i = self.i + 1 } // How do I queue this onto the DispatchQueue so it gets executed when the completionHandler is called? return completionHandler } Is this possible?