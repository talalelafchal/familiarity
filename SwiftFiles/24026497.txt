How to declare a block with arguments in swift?
<p>Having a hard time figuring out how to properly declare/use blocks with swift. What would be the swift equivalent of the following code? </p> <p>Thanks.</p> <pre><code>^(PFUser *user, NSError *error) { if (!user) { NSLog(@"Uh oh. The user cancelled the Facebook login."); } else if (user.isNew) { NSLog(@"User signed up and logged in through Facebook!"); } else { NSLog(@"User logged in through Facebook!"); } </code></pre>
<p>The equivalent of Objective-C blocks are swift closures, so it would go as follows</p> <pre><code>{ (user: PFUser, error: NSError) in if (!user) { println("Uh oh. The user cancelled the Facebook login."); } else if (user.isNew) { println("User signed up and logged in through Facebook!"); } else { println("User logged in through Facebook!"); } } </code></pre>
<p>Critically, if <code>user</code> can be <code>nil</code> then it <strong>must be</strong> declared as an Optional. Thus: </p> <pre><code>{ (user: PFUser?, error: NSError) -&gt; {} in if (nil == user) ... } </code></pre> <p>noting that the type for <code>user</code> includes <code>?</code> to indicate that <code>user</code> is an <em>optional argument</em> (either <code>nil</code> or of type <code>PFUser</code>).</p> <p>Other answers, that don't use an Optional, won't even compile.</p>
<p>See if this works for you. It's crazy trying to learn this on day two.</p> <pre><code>let afterSignInAttempt: (PFUser?, NSError) -&gt; Void = { user, error in if(!user){ NSLog("Uh oh.") } else { user.isNew ? NSLog("Signed up") : NSLog("User Logged in") } } </code></pre>
<p>You have many ways offered to pass a block equivalent to function in Swift. </p> <p>I found three.</p> <p>To understand this I suggest you to test in playground this little piece of code.</p> <pre><code>func test(function:String -&gt; String) -&gt; String { return function("test") } func funcStyle(s:String) -&gt; String { return "FUNC__" + s + "__FUNC" } let resultFunc = test(funcStyle) let blockStyle:(String) -&gt; String = {s in return "BLOCK__" + s + "__BLOCK"} let resultBlock = test(blockStyle) let resultAnon = test({(s:String) -&gt; String in return "ANON_" + s + "__ANON" }) println(resultFunc) println(resultBlock) println(resultAnon) </code></pre> <p>Update: There are 2 special cases to the Anonymous function.</p> <p>The first is that function signature can be inferred so you don't have to rewrite it. </p> <pre><code>let resultShortAnon = test({return "ANON_" + $0 + "__ANON" }) </code></pre> <p>The second special case works only if the block is the last argument, it's called <em>trailing closure</em></p> <p>Here is an example (merged with inferred signature to show Swift power)</p> <pre><code>let resultTrailingClosure = test { return "TRAILCLOS_" + $0 + "__TRAILCLOS" } </code></pre> <p>Finally:</p> <p>Using all this power what I'd do is mixing trailing closure and type inference (with naming for readability)</p> <pre><code>PFFacebookUtils.logInWithPermissions(permissions) { user, error in if (!user) { println("Uh oh. The user cancelled the Facebook login.") } else if (user.isNew) { println("User signed up and logged in through Facebook!") } else { println("User logged in through Facebook!") } } </code></pre> <p>IMO it's more beautiful than in ObjC</p>
<p>If you want to store block in a variable and call it later, check this <a href="http://stackoverflow.com/a/24604820/1996294">answer</a></p>