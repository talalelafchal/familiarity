AFNetworking and Swift
<p>I'm trying to get a JSON response using swift. I sniffed the request and response -> everything ok However the return value is always nil.</p> <pre><code> let httpClient = AppDelegate.appDelegate().httpRequestOperationManager as AFHTTPRequestOperationManager; let path = "/daten/wfs"; let query = "?service=WFS&amp;request=GetFeature&amp;version=1.1.0&amp;typeName=ogdwien:AMPELOGD&amp;srsName=EPSG:4326&amp;outputFormat=json".stringByAddingPercentEscapesUsingEncoding(NSUTF8StringEncoding); func successBlock(operation: AFHTTPRequestOperation!, responseObject: AnyObject!) { println("JSON: " + "\(responseObject)") } func errorBlock(operation: AFHTTPRequestOperation!, error:NSError!) { println("Error: " + error.localizedDescription) } let urlString = "\(path)" + "/" + "\(query)" println("urlString: " + httpClient.baseURL.absoluteString + urlString) </code></pre> <p>i also tried it this way:</p> <pre><code> httpClient.GET(urlString, parameters: nil, success: { (operation: AFHTTPRequestOperation!, responseObject: AnyObject!) -&gt; Void in println("Success") println("JSON: " + "\(responseObject)") }, failure:{ (operation: AFHTTPRequestOperation!, error:NSError!) -&gt; Void in println("Failure") }) </code></pre> <p>â€¦ but the responseObject always seems to be nil</p> <p>[EDIT] Maybe the reason is the possible wrong initialisation in my AppDelegate:</p> <pre><code>var httpRequestOperationManager: AFHTTPRequestOperationManager? // JAVA SERVER Client class func appDelegate() -&gt; AppDelegate { return UIApplication.sharedApplication().delegate as AppDelegate } func configureWebservice() { let requestSerializer = AFJSONRequestSerializer() requestSerializer.setValue("1234567890", forHTTPHeaderField: "clientId") requestSerializer.setValue("Test", forHTTPHeaderField: "appName") requestSerializer.setValue("1.0.0", forHTTPHeaderField: "appVersion") let responseSerializer = AFJSONResponseSerializer() AFNetworkActivityIndicatorManager.sharedManager().enabled = true // ##### HTTP ##### let baseURL = NSURL(string: "http://data.wien.gv.at"); httpRequestOperationManager = AFHTTPRequestOperationManager(baseURL: baseURL)) httpRequestOperationManager!.requestSerializer = requestSerializer httpRequestOperationManager!.responseSerializer = responseSerializer } </code></pre> <p>Any suggestions what I'm doing wrong?</p> <p>Kind regards, Steve</p>
<p>Swift is fully compatible with Objective-C code, so your problem is <strong>not</strong> connected with Swift itself. In <code>AFNetworking</code>, the <code>responseObject</code> <strong>can</strong> sometimes be <code>nil</code>. This includes cases, where:</p> <ul> <li>A <code>204 No Content</code> status code was returned,</li> <li>If output stream was set to write to file,</li> <li>If the error during validation wasn't <code>NSURLErrorCannotDecodeContentData</code> (e.g. unacceptable content type)</li> </ul> <p>Check out <a href="https://github.com/AFNetworking/AFNetworking/issues/740">#740</a> and <a href="https://github.com/AFNetworking/AFNetworking/issues/1280">#1280</a> for more information.</p>
<p>You can use Swift's interoperability with Objective-C frameworks but now there is an official library out there, let's check it out:</p> <p><a href="https://github.com/Alamofire/Alamofire">https://github.com/Alamofire/Alamofire</a></p> <p>This library is written in native Swift, from the creator of AFNetworking. You will probably want to look for this kind of thing when moving to Swift. I tried it out and it's awesome, like its predecessor.</p>
<p>HttpManager.sharedInstance.getNewestAppList("(self.numberofPhoto)", offset: "0", device_type: "ios",search: self.strSearch, filter: self.strFilter, onCompletion: { (responseObject:NSDictionary?, error:NSError?) -> Void in if((error) != nil) {</p> <pre><code> SwiftLoader.hide() self.showAlertWithMessage("\(error!.localizedFailureReason!)\n\(error!.localizedRecoverySuggestion!)") } else { SwiftLoader.hide() if responseObject!.valueForKey("status") as! NSString as String == "0" { self.showAlertWithMessage(responseObject!.valueForKey("message") as! NSString as String) } else { self.itemsArray = responseObject!.valueForKey("data") as! NSArray print(self.itemsArray.count) self.tableCategoryDetailRef.reloadData() } } }) </code></pre> <p>====================</p> <p>import Foundation</p> <p>typealias getResponse = (NSDictionary?, NSError?) -> Void class HttpManager: NSObject {</p> <pre><code>var AFManager: AFURLSessionManager? var strUrl : NSString = "url" class var sharedInstance:HttpManager { struct Singleton { static let instance = HttpManager() } return Singleton.instance } // MARK: - Method func getCount(device_type:String, onCompletion: getResponse) -&gt; Void { let post: String = "device_type=\(device_type)" let postData: NSData = post.dataUsingEncoding(NSASCIIStringEncoding, allowLossyConversion: true)! let postLength:NSString = String( postData.length ) let configuration: NSURLSessionConfiguration = NSURLSessionConfiguration.defaultSessionConfiguration() AFManager = AFURLSessionManager(sessionConfiguration: configuration) let URL: NSURL = NSURL(string: "\(strUrl)/count" as String)! let urlRequest: NSMutableURLRequest = NSMutableURLRequest(URL: URL) urlRequest.HTTPMethod = "POST" urlRequest.setValue(postLength as String, forHTTPHeaderField: "Content-Length") urlRequest.setValue("application/x-www-form-urlencoded", forHTTPHeaderField: "Content-Type") urlRequest.HTTPBody = postData let task = AFManager?.dataTaskWithRequest(urlRequest) { (data, response, error) in if(response == nil) { SwiftLoader.hide() } else { let responseDict:NSDictionary = response as! NSDictionary onCompletion(responseDict,error) } } task!.resume() } </code></pre> <p>}</p>