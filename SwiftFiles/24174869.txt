In Swift, how to generically limit function to types that understand T + T
<p>I would like to have a generic function that can use the plus operator on two values.</p> <pre><code>class funccalc { func doAdd&lt;T&gt;(x:T,y:T) -&gt; T { return x + y } } let a = funccalc() println(a.doAdd(1, y: 4)) println(a.doAdd(23.54, y:200)) </code></pre> <p>I get an error on <code>return x + y</code></p> <p>Is my only option to follow the suggestion in this answer: <a href="http://stackoverflow.com/a/24047239/67566">http://stackoverflow.com/a/24047239/67566</a>, and create my own protocol as <code>Int</code> and <code>String</code> would define the operator?</p>
<p>You should do as that answer suggested. Create a protocol for your use and extend all of the classes that you want to use it. Then make sure T implements that protocol in your method signature.</p> <p>You can't use an "addable" protocol because there isn't one in swift. The swift library actually creates a function + for each valid addition operations. Command-click on something like Int to see where all of these are defined. It will look something like this:</p> <pre><code>//.... func +(lhs: Int8, rhs: Int8) -&gt; Int8 func +(lhs: UInt16, rhs: UInt16) -&gt; UInt16 func +(lhs: Int16, rhs: Int16) -&gt; Int16 func +(lhs: UInt32, rhs: UInt32) -&gt; UInt32 func +(lhs: Int32, rhs: Int32) -&gt; Int32 //etc... </code></pre>
<p>You may have a similar need for other functions too and implementing them for all integer and floating point types (or other "summable" things) would cause massive code duplication.</p> <p>One partial solution, specifically for +, -, *, /, % is to require conformance to IntegerArithmeticType protocol:</p> <pre><code>func example&lt;T: IntegerArithmeticType&gt;(x: T, y: T) -&gt; T { return x + y } println(example(40, 2)) // --&gt; 42 </code></pre> <p>This does not apply to floating point types because they do not implement overflow operations defined in _IntegerArithmeticType protocol, which IntegerArithmeticType inherits from.</p> <p>However, extending types for a specific globally defined operator function conformance is not as "annoying" as you might think:</p> <pre><code>protocol Summable { func +(lhs: Self, rhs: Self) -&gt; Self } extension Int: Summable {} extension Double: Summable {} extension String: Summable {} // extension for any other types... you are in full control! </code></pre> <p>You do this once, then forevermore you can use Summable in you code:</p> <pre><code>func example&lt;T: Summable&gt;(x: T, y: T) -&gt; T { return x + y } println( example("4", "2") ) // --&gt; 42 </code></pre> <p>Indeed, and as @connor pointed out, this is equivalent to @Jean-PhilippePellet's answer you mentioned.</p>