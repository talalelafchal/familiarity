How to share common init code between different designated init methods?
<p>In Objective-C I often move common init code into its own method, and then I call that method from the various designated initialisers of the class. Like this:</p> <pre><code>- (void)commonInit { _gradientLayer = [CAGradientLayer layer]; _gradientLayer.frame = self.bounds; /* ... */ } - (id)initWithCoder:(NSCoder *)aDecoder { self = [super initWithCoder:aDecoder]; [self commonInit]; return self; } - (id)initWithFrame:(CGRect)frame { self = [super initWithFrame:frame]; [self commonInit]; return self; } </code></pre> <p>In Swift this pattern does not work because you basically have to use a "two stage init". First you have to assign variables of your own subclass, then call <code>super.init</code> and only then you are allowed to access self. e.g.:</p> <pre><code>init(coder aDecoder: NSCoder!) { // initial assignment must be done first gradientLayer = CAGradientLayer() // no calls to self allowed super.init(coder: aDecoder) // calls to self allowed gradientLayer.frame = self.bounds /* ... */ } </code></pre> <p>I can easily move the "second phase", the set up, which happens after <code>super.init</code> to its own method. However, I can't move the "first phase", the initial assignment to its own method because calling the method involves a call to self, which is not allowed before calling <code>super.init</code>.</p> <p>Am I missing a way to move the initial assignment to its own method? I really don't want to duplicate all the assignments in the various init methods. </p>