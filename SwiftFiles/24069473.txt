Swift require that two generics are of the same type
<p>In the Swift programming language I see an example</p> <pre><code>func anyCommonElements &lt;T, U where T: Sequence, U: Sequence, T.GeneratorType.Element: Equatable, T.GeneratorType.Element == U.GeneratorType.Element&gt; (lhs: T, rhs: U) -&gt; Bool { for lhsItem in lhs { for rhsItem in rhs { if lhsItem == rhsItem { return true } } } return false } </code></pre> <p>It appears that <code>T.GeneratorType.Element == U.GeneratorType.Element</code> means that the elements generated when the sequences are decomposed share the same underlying type. So I can do</p> <pre><code>anyCommonElements("123", "1234") anyCommonElements([1, 2, 3], [1]) </code></pre> <p>but not</p> <pre><code>anyCommonElements("123", [1, 2]) </code></pre> <p>But <code>T: Sequence, U: Sequence</code> means that the parameters T and U have to be sequences, such as a String or an Array.</p> <p>What is the proper way to write a function that takes two parameters T and U which are required to be the same type using the where clause? Omitting the <code>T: Sequence, U: Sequence</code> requirement results in the error "GeneratorType is not a member of type T"</p>
<p>If you want both of your parameters to be the same type, you can just use the same generic for both of them. Something like:</p> <pre><code>func functionName &lt;T, T&gt; (lhs: T, rhs: T) -&gt; Bool { return false } </code></pre>
<p>As @conner noted but you would never specify it that way as there is only one type. This is better:</p> <pre><code>func functionName&lt;T&gt; (lhs: T, rhs: T) -&gt; Bool { ... } </code></pre>