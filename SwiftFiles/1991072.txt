How to handle with a default URL scheme
<p>I want to build URI (or URL scheme) support in my app.</p> <p>I do a <code>LSSetDefaultHandlerForURLScheme()</code> in my <code>+ (void)initialize</code> and I setted the specific URL schemes also in my <code>info.plist</code>. So I have URL schemes without <code>Apple Script</code> or <code>Apple Events</code>. </p> <p>When I call <code>myScheme:</code> in my favorite browser the system activates my app.</p> <p>The problem is, how to handle the schemes when they are called. Or better said: How can I define what my app should do, when <code>myScheme:</code> is called.</p> <p>Is there a special method that I have to implement or do I have to register one somewhere?</p>
<p>As you are mentioning AppleScript, I suppose you are working on Mac OS X.</p> <p>A simple way to register and use a custom URL scheme is to define the scheme in your .plist:</p> <pre><code>&lt;key&gt;CFBundleURLTypes&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;CFBundleURLName&lt;/key&gt; &lt;string&gt;URLHandlerTestApp&lt;/string&gt; &lt;key&gt;CFBundleURLSchemes&lt;/key&gt; &lt;array&gt; &lt;string&gt;urlHandlerTestApp&lt;/string&gt; &lt;/array&gt; &lt;/dict&gt; &lt;/array&gt; </code></pre> <p>To register the scheme, put this in your AppDelegate's initialization:</p> <pre><code>[[NSAppleEventManager sharedAppleEventManager] setEventHandler:self andSelector:@selector(handleURLEvent:withReplyEvent:) forEventClass:kInternetEventClass andEventID:kAEGetURL]; </code></pre> <p>Whenever your application gets activated via URL scheme, the defined selector gets called.</p> <p>A stub for the event-handling method, that shows how to get the URL string:</p> <pre><code>- (void)handleURLEvent:(NSAppleEventDescriptor*)event withReplyEvent:(NSAppleEventDescriptor*)replyEvent { NSString* url = [[event paramDescriptorForKeyword:keyDirectObject] stringValue]; NSLog(@"%@", url); } </code></pre> <p>Apple's documentation: <a href="http://developer.apple.com/mac/library/DOCUMENTATION/Cocoa/Conceptual/ScriptableCocoaApplications/SApps_handle_AEs/SAppsHandleAEs.html#//apple_ref/doc/uid/20001239-SW10" rel="nofollow noreferrer">Installing a Get URL Handler</a></p> <p><strong>Update</strong> I just noticed a problem for sandboxed apps that install the event handler in <code>applicationDidFinishLaunching:</code>. With enabled sandboxing, the handler method doesn't get called when the app is launched by clicking a URL that uses the custom scheme. By installing the handler a bit earlier, in <code>applicationWillFinishLaunching:</code>, the method gets called as expected:</p> <pre><code>- (void)applicationWillFinishLaunching:(NSNotification *)aNotification { [[NSAppleEventManager sharedAppleEventManager] setEventHandler:self andSelector:@selector(handleURLEvent:withReplyEvent:) forEventClass:kInternetEventClass andEventID:kAEGetURL]; } - (void)handleURLEvent:(NSAppleEventDescriptor*)event withReplyEvent:(NSAppleEventDescriptor*)replyEvent { NSString* url = [[event paramDescriptorForKeyword:keyDirectObject] stringValue]; NSLog(@"%@", url); } </code></pre> <hr> <p>On the iPhone, the easiest way to handle URL-scheme activation is, to implement UIApplicationDelegate's <code>application:handleOpenURL:</code> - <a href="http://developer.apple.com/iPhone/library/documentation/UIKit/Reference/UIApplicationDelegate_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/UIApplicationDelegate/application:handleOpenURL:" rel="nofollow noreferrer">Documentation</a></p>
<blockquote> <p>The problem is, how to handle the schemes when they are called.</p> </blockquote> <p>That's where the Apple Events come in. When Launch Services wants your app to open a URL, it sends your app a <code>kInternetEventClass</code>/<code>kAEGetURL</code> event.</p> <p><a href="http://developer.apple.com/mac/library/documentation/Cocoa/Conceptual/ScriptableCocoaApplications" rel="nofollow noreferrer">The Cocoa Scripting Guide</a> uses <a href="http://developer.apple.com/mac/library/documentation/Cocoa/Conceptual/ScriptableCocoaApplications/SApps_handle_AEs/SAppsHandleAEs.html#//apple_ref/doc/uid/20001239-BBCIDFHG" rel="nofollow noreferrer">this very task as an example of installing an event handler</a>.</p>
<p>You can define the “get URL” command in a scripting terminology SDEF and implement the corresponding method. For example, Terminal’s SDEF contains the following command definition for handling URLs</p> <pre><code>&lt;command name="get URL" code="GURLGURL" description="Open a command an ssh, telnet, or x-man-page URL." hidden="yes"&gt; &lt;direct-parameter type="text" description="The URL to open." /&gt; &lt;/command&gt; </code></pre> <p>and declares that the application responds to it:</p> <pre><code>&lt;class name="application" code="capp" description="The application's top-level scripting object."&gt; &lt;cocoa class="TTApplication"/&gt; &lt;responds-to command="get URL"&gt; &lt;cocoa method="handleGetURLScriptCommand:" /&gt; &lt;/responds-to&gt; &lt;/class&gt; </code></pre> <p>The TTApplication class (a subclass of NSApplication) defines the method:</p> <pre><code>- (void)handleGetURLScriptCommand:(NSScriptCommand *)command { … } </code></pre>
<p>All credits should go to <strong>weichsel</strong> and <strong>kch</strong></p> <p>I'm just adding swift(2.2/3.0) code for your convenience</p> <pre><code>func applicationWillFinishLaunching(_ notification: Notification) { NSAppleEventManager.shared().setEventHandler(self, andSelector: #selector(self.handleGetURL(event:reply:)), forEventClass: UInt32(kInternetEventClass), andEventID: UInt32(kAEGetURL) ) } func handleGetURL(event: NSAppleEventDescriptor, reply:NSAppleEventDescriptor) { if let urlString = event.paramDescriptor(forKeyword: keyDirectObject)?.stringValue { print("got urlString \(urlString)") } } </code></pre>