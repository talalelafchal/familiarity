How can we create a generic Array Extension that sums Number types in Swift?
<p>Swift lets you create an Array extension that sums Integer's with:</p> <pre><code>extension Array { func sum() -&gt; Int { return self.map { $0 as Int }.reduce(0) { $0 + $1 } } } </code></pre> <p>Which can now be used to sum <code>Int[]</code> like:</p> <pre><code>[1,2,3].sum() //6 </code></pre> <p>But how can we make a generic version that supports summing other Number types like <code>Double[]</code> as well?</p> <pre><code>[1.1,2.1,3.1].sum() //fails </code></pre> <hr> <p>This question is <strong>NOT how to sum numbers</strong>, but how to <strong>create a generic Array Extension</strong> to do it.</p> <hr> <h2>Getting Closer</h2> <p>This is the closest I've been able to get if it helps anyone get closer to the solution:</p> <p>You can create a protocol that can fulfills what we need to do, i.e:</p> <pre><code>protocol Addable { func +(lhs: Self, rhs: Self) -&gt; Self init() } </code></pre> <p>Then extend each of the types we want to support that conforms to the above protocol:</p> <pre><code>extension Int : Addable { } extension Double : Addable { } </code></pre> <p>And then add an extension with that constraint:</p> <pre><code>extension Array { func sum&lt;T : Addable&gt;(min:T) -&gt; T { return self.map { $0 as T }.reduce(min) { $0 + $1 } } } </code></pre> <p>Which can now be used against numbers that we've extended to support the protocol, i.e:</p> <pre><code>[1,2,3].sum(0) //6 [1.1,2.1,3.1].sum(0.0) //6.3 </code></pre> <p>Unfortunately I haven't been able to get it working without having to supply an argument, i.e:</p> <pre><code>func sum&lt;T : Addable&gt;(x:T...) -&gt; T? { return self.map { $0 as T }.reduce(T()) { $0 + $1 } } </code></pre> <p>The modified method still works with 1 argument:</p> <pre><code>[1,2,3].sum(0) //6 </code></pre> <p>But is unable to resolve the method when calling it with no arguments, i.e:</p> <pre><code>[1,2,3].sum() //Could not find member 'sum' </code></pre> <p>Adding <code>Integer</code> to the method signature also doesn't help method resolution:</p> <pre><code>func sum&lt;T where T : Integer, T: Addable&gt;() -&gt; T? { return self.map { $0 as T }.reduce(T()) { $0 + $1 } } </code></pre> <p>But hopefully this will help others come closer to the solution.</p> <hr> <h3>Some Progress</h3> <p>From @GabrielePetronella answer, it looks like we can call the above method if we explicitly specify the type on the call-site like:</p> <pre><code>let i:Int = [1,2,3].sum() let d:Double = [1.1,2.2,3.3].sum() </code></pre>
<p>I think I found a reasonable way of doing it, borrowing some ideas from <a href="https://github.com/scalaz/scalaz">scalaz</a> and starting from your proposed implementation. Basically what we want is to have typeclasses that represents monoids.</p> <p>In other words, we need:</p> <ul> <li>an associative function</li> <li>an identity value (i.e. a zero)</li> </ul> <p>Here's a proposed solution, which works around the swift type system limitations</p> <p>First of all, our friendly <code>Addable</code> typeclass</p> <pre><code>protocol Addable { class func add(lhs: Self, _ rhs: Self) -&gt; Self class func zero() -&gt; Self } </code></pre> <p>Now let's make <code>Int</code> implement it.</p> <pre><code>extension Int: Addable { static func add(lhs: Int, _ rhs: Int) -&gt; Int { return lhs + rhs } static func zero() -&gt; Int { return 0 } } </code></pre> <p>So far so good. Now we have all the pieces we need to build a generic `sum function:</p> <pre><code>extension Array { func sum&lt;T : Addable&gt;() -&gt; T { return self.map { $0 as T }.reduce(T.zero()) { T.add($0, $1) } } } </code></pre> <p>Let's test it</p> <pre><code>let result: Int = [1,2,3].sum() // 6, yay! </code></pre> <p>Due to limitations of the type system, you need to explicitly cast the result type, since the compiler is not able to figure by itself that <code>Addable</code> resolves to <code>Int</code>.</p> <p>So you cannot just do:</p> <pre><code>let result = [1,2,3].sum() </code></pre> <p>I think it's a bearable drawback of this approach.</p> <p>Of course, this is completely generic and it can be used on any class, for any kind of monoid. The reason why I'm not using the default <code>+</code> operator, but I'm instead defining an <code>add</code> function, is that this allows <strong>any</strong> type to implement the <code>Addable</code> typeclass. If you use <code>+</code>, then a type which has no <code>+</code> operator defined, then you need to implement such operator in the global scope, which I kind of dislike.</p> <p>Anyway, here's how it would work if you need for instance to make both <code>Int</code> and <code>String</code> 'multipliable', given that <code>*</code> is defined for <code>Int</code> but not for `String.</p> <pre><code>protocol Multipliable { func *(lhs: Self, rhs: Self) -&gt; Self class func m_zero() -&gt; Self } func *(lhs: String, rhs: String) -&gt; String { return rhs + lhs } extension String: Multipliable { static func m_zero() -&gt; String { return "" } } extension Int: Multipliable { static func m_zero() -&gt; Int { return 1 } } extension Array { func mult&lt;T: Multipliable&gt;() -&gt; T { return self.map { $0 as T }.reduce(T.m_zero()) { $0 * $1 } } } let y: String = ["hello", " ", "world"].mult() </code></pre> <p>Now array of <code>String</code> can use the method <code>mult</code> to perform a reverse concatenation (just a silly example), and the implementation uses the <code>*</code> operator, newly defined for <code>String</code>, whereas <code>Int</code> keeps using its usual <code>*</code> operator and we only need to define a zero for the monoid.</p> <p>For code cleanness, I much prefer having the whole typeclass implementation to live in the <code>extension</code> scope, but I guess it's a matter of taste.</p>
<pre><code> 3&gt; [1,2,3].reduce(0, +) $R2: Int = 6 4&gt; [1.1,2.1,3.1].reduce(0, +) $R3: Double = 6.3000000000000007 </code></pre> <p><a href="http://www.weheartswift.com/higher-order-functions-map-filter-reduce-and-more/" rel="nofollow">Map, Filter, Reduce and more</a></p>
<p>Here's a silly implementation:</p> <pre><code>extension Array { func sum(arr:Array&lt;Int&gt;) -&gt; Int { return arr.reduce(0, {(e1:Int, e2:Int) -&gt; Int in return e1 + e2}) } func sum(arr:Array&lt;Double&gt;) -&gt; Double { return arr.reduce(0, {(e1:Double, e2:Double) -&gt; Double in return e1 + e2}) } } </code></pre> <p>It's silly because you have to say <code>arr.sum(arr)</code>. In other words, it isn't encapsulated; it's a "free" function <code>sum</code> that just happens to be hiding inside Array. Thus I failed to solve the problem you're <em>really</em> trying to solve.</p>
<p>From my understanding of the swift grammar, a <a href="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/type-identifier" rel="nofollow">type identifier</a> cannot be used with generic parameters, only a generic argument. Hence, the <a href="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/extension-declaration" rel="nofollow">extension declaration</a> can only be used with a concrete type.</p>
<p>As of Swift 2 it's possible to do this using protocol extensions. (See <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html" rel="nofollow">The Swift Programming Language: Protocols</a> for more information). </p> <p>First of all, the <code>Addable</code> protocol:</p> <pre><code>protocol Addable: IntegerLiteralConvertible { func + (lhs: Self, rhs: Self) -&gt; Self } extension Int : Addable {} extension Double: Addable {} // ... </code></pre> <p>Next, extend <code>SequenceType</code> to add sequences of <code>Addable</code> elements:</p> <pre><code>extension SequenceType where Generator.Element: Addable { var sum: Generator.Element { return reduce(0, combine: +) } } </code></pre> <p>Usage:</p> <pre><code>let ints = [0, 1, 2, 3] print(ints.sum) // Prints: "6" let doubles = [0.0, 1.0, 2.0, 3.0] print(doubles.sum) // Prints: "6.0" </code></pre>
<p>It's doable based on prior answers in Swift 1.x with minimal effort:</p> <pre><code>import Foundation protocol Addable { func +(lhs: Self, rhs: Self) -&gt; Self init(_: Int) init() } extension Int : Addable {} extension Int8 : Addable {} extension Int16 : Addable {} extension Int32 : Addable {} extension Int64 : Addable {} extension UInt : Addable {} extension UInt8 : Addable {} extension UInt16 : Addable {} extension UInt32 : Addable {} extension UInt64 : Addable {} extension Double : Addable {} extension Float : Addable {} extension Float80 : Addable {} // NSNumber is a messy, fat class for ObjC to box non-NSObject values // Bit is weird extension Array { func sum&lt;T : Addable&gt;(min: T = T(0)) -&gt; T { return map { $0 as! T }.reduce(min) { $0 + $1 } } } </code></pre> <p>And here: <a href="https://gist.github.com/46c1d4d1e9425f730b08" rel="nofollow">https://gist.github.com/46c1d4d1e9425f730b08</a></p> <p>Swift 2, as used elsewhere, plans major improvements, including exception handling, promises and better generic metaprogramming.</p>
<p>In Swift 2, you can solve it like this:</p> <p>Define the monoid for addition as protocol</p> <pre><code>protocol Addable { init() func +(lhs: Self, rhs: Self) -&gt; Self static var zero: Self { get } } extension Addable { static var zero: Self { return Self() } } </code></pre> <p>In addition to other solutions, this explicitly defines the zero element using the standard initializer.</p> <p>Then declare Int and Double as Addable:</p> <pre><code>extension Int: Addable {} extension Double: Addable {} </code></pre> <p>Now you can define a sum() method for all Arrays storing Addable elements:</p> <pre><code>extension Array where Element: Addable { func sum() -&gt; Element { return self.reduce(Element.zero, combine: +) } } </code></pre>