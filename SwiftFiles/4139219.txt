How do you trigger a block after a delay, like -performSelector:withObject:afterDelay:?
<p>Is there a way to call a block with a primitive parameter after a delay, like using <code>performSelector:withObject:afterDelay:</code> but with an argument like <code>int</code>/<code>double</code>/<code>float</code>?</p>
<p>You can either wrap the argument in your own class, or wrap the method call in a method that doesn't need to be passed in the primitive type. Then call that method after your delay, and within that method perform the selector you wish to perform.</p>
<p>I think you're looking for <code>dispatch_after()</code>. It requires your block to accept no parameters, but you can just let the block capture those variables from your local scope instead.</p> <pre><code>int parameter1 = 12; float parameter2 = 144.1; // Delay execution of my block for 10 seconds. dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 10 * NSEC_PER_SEC), dispatch_get_main_queue(), ^{ NSLog(@"parameter1: %d parameter2: %f", parameter1, parameter2); }); </code></pre> <p>More: <a href="https://developer.apple.com/library/prerelease/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html#//apple_ref/c/func/dispatch_after">https://developer.apple.com/library/prerelease/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html#//apple_ref/c/func/dispatch_after</a></p>
<p>Perhaps simpler than going thru GCD, in a class somewhere (e.g. "Util"), or a Category on Object:</p> <pre><code>+ (void)runBlock:(void (^)())block { block(); } + (void)runAfterDelay:(CGFloat)delay block:(void (^)())block { void (^block_)() = [[block copy] autorelease]; [self performSelector:@selector(runBlock:) withObject:block_ afterDelay:delay]; } </code></pre> <p>So to use:</p> <pre><code>[Util runAfterDelay:2 block:^{ NSLog(@"two seconds later!"); }]; </code></pre>
<p>You can use <code>dispatch_after</code> to call a block later. In Xcode, start typing <code>dispatch_after</code> and hit <code>Enter</code> to autocomplete to the following:</p> <p><img src="https://i.stack.imgur.com/lO1Kc.png" alt="enter image description here"></p> <p>Here's an example with two floats as "arguments." You don't have to rely on any type of macro, and the intent of the code is quite clear: </p> <h2>Swift 3</h2> <pre><code>let time1 = 8.23 let time2 = 3.42 // Delay 2 seconds DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) { print("Sum of times: \(time1 + time2)") } </code></pre> <h2>Swift 2</h2> <pre><code>let time1 = 8.23 let time2 = 3.42 // Delay 2 seconds dispatch_after(dispatch_time(DISPATCH_TIME_NOW, Int64(2.0 * Double(NSEC_PER_SEC))), dispatch_get_main_queue()) { () -&gt; Void in println("Sum of times: \(time1 + time2)") } </code></pre> <h2>Objective C</h2> <pre><code>CGFloat time1 = 3.49; CGFloat time2 = 8.13; // Delay 2 seconds dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ CGFloat newTime = time1 + time2; NSLog(@"New time: %f", newTime); }); </code></pre>
<p>There's a nice one in the BlocksKit framework.</p> <p><a href="https://github.com/zwaldowski/BlocksKit" rel="nofollow">BlocksKit</a></p> <p>(and the class)</p> <p><a href="https://github.com/zwaldowski/BlocksKit/blob/master/BlocksKit/NSObject+BlocksKit.m" rel="nofollow">BBlocksKit.m</a></p>
<p>[NSTimer scheduledTimerWithTimeInterval:2.5 target:self selector:@selector(toDoSomething) userInfo:nil repeats:NO];</p>
<p>Expanding on Jaime Cham's answer I created a NSObject+Blocks category as below. I felt these methods better matched the existing <code>performSelector:</code> NSObject methods </p> <p><strong>NSObject+Blocks.h</strong></p> <pre><code>#import &lt;Foundation/Foundation.h&gt; @interface NSObject (Blocks) - (void)performBlock:(void (^)())block afterDelay:(NSTimeInterval)delay; @end </code></pre> <p><strong>NSObject+Blocks.m</strong></p> <pre><code>#import "NSObject+Blocks.h" @implementation NSObject (Blocks) - (void)performBlock:(void (^)())block { block(); } - (void)performBlock:(void (^)())block afterDelay:(NSTimeInterval)delay { void (^block_)() = [block copy]; // autorelease this if you're not using ARC [self performSelector:@selector(performBlock:) withObject:block_ afterDelay:delay]; } @end </code></pre> <p>and use like so:</p> <pre><code>[anyObject performBlock:^{ [anotherObject doYourThings:stuff]; } afterDelay:0.15]; </code></pre>
<p>PerformSelector:WithObject always takes an object, so in order to pass arguments like int/double/float etc..... You can use something like this.</p> <p>//NSNumber is an object..</p> <pre><code>[self performSelector:@selector(setUserAlphaNumber:) withObject: [NSNumber numberWithFloat: 1.0f] afterDelay:1.5]; -(void) setUserAlphaNumber: (NSNumber*) number{ [txtUsername setAlpha: [number floatValue] ]; } </code></pre> <p>Same way you can use [NSNumber numberWithInt:] etc.... and in the receiving method you can convert the number into your format as [number int] or [number double].</p>
<p>Here are my 2 cents = 5 methods ;) </p> <p>I like encapsulate these details and have AppCode tell me how to finish my sentences. </p> <pre><code>void dispatch_after_delay(float delayInSeconds, dispatch_queue_t queue, dispatch_block_t block) { dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, delayInSeconds * NSEC_PER_SEC); dispatch_after(popTime, queue, block); } void dispatch_after_delay_on_main_queue(float delayInSeconds, dispatch_block_t block) { dispatch_queue_t queue = dispatch_get_main_queue(); dispatch_after_delay(delayInSeconds, queue, block); } void dispatch_async_on_high_priority_queue(dispatch_block_t block) { dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), block); } void dispatch_async_on_background_queue(dispatch_block_t block) { dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0), block); } void dispatch_async_on_main_queue(dispatch_block_t block) { dispatch_async(dispatch_get_main_queue(), block); } </code></pre>
<p>How about using Xcode built-in code snippet library?</p> <p><img src="https://i.stack.imgur.com/bXYBo.jpg" alt="enter image description here"></p> <p><strong>Update for Swift:</strong><br></p> <p>Many up votes inspired me to update this answer.</p> <p>The build-in Xcode code snippet library has <code>dispatch_after</code> for only <code>objective-c</code> language. People can also create their own <strong>Custom Code Snippet</strong> for <code>Swift</code>. </p> <p>Write this in Xcode. </p> <pre><code>dispatch_after(dispatch_time(DISPATCH_TIME_NOW, Int64(&lt;#delayInSeconds#&gt; * Double(NSEC_PER_SEC))), dispatch_get_main_queue(), { &lt;#code to be executed after a specified delay#&gt; }) </code></pre> <p>Drag this code and drop it in the code snippet library area. <a href="https://i.stack.imgur.com/ym3Kw.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/ym3Kw.png" alt="enter image description here"></a></p> <p>Bottom of the code snippet list, there will be a new entity named <code>My Code Snippet</code>. Edit this for a title. For suggestion as you type in the Xcode fill in the <strong><code>Completion Shortcut</code></strong>.</p> <p>For more info see <a href="https://developer.apple.com/library/ios/recipes/xcode_help-source_editor/chapters/CreatingaCustomCodeSnippet.html" rel="nofollow noreferrer">CreatingaCustomCodeSnippet</a>.</p> <h2>Update Swift 3</h2> <p>Drag this code and drop it in the code snippet library area. </p> <pre><code>DispatchQueue.main.asyncAfter(deadline: .now() + .seconds(&lt;#delayInSeconds#&gt;)) { &lt;#code to be executed after a specified delay#&gt; } </code></pre>
<p>For Swift I've created a global function, nothing special, using the <code>dispatch_after</code> method. I like this more as it's readable and easy to use:</p> <pre><code>func performBlock(block:() -&gt; Void, afterDelay delay:NSTimeInterval){ dispatch_after(dispatch_time(DISPATCH_TIME_NOW, Int64(delay * Double(NSEC_PER_SEC))), dispatch_get_main_queue(), block) } </code></pre> <p>Which you can use as followed:</p> <pre><code>performBlock({ () -&gt; Void in // Perform actions }, afterDelay: 0.3) </code></pre>
<p>Here is how you can trigger a block after a delay in Swift:</p> <pre><code>runThisAfterDelay(seconds: 2) { () -&gt; () in print("Prints this 2 seconds later in main queue") } /// EZSwiftExtensions func runThisAfterDelay(seconds seconds: Double, after: () -&gt; ()) { let time = dispatch_time(DISPATCH_TIME_NOW, Int64(seconds * Double(NSEC_PER_SEC))) dispatch_after(time, dispatch_get_main_queue(), after) } </code></pre> <p>Its included as a standard function in <a href="https://github.com/goktugyil/EZSwiftExtensions" rel="nofollow">my repo</a>.</p>
<p>The dispatch_after function dispatches a block object to a dispatch queue after a given period of time. Use below code to perform some UI related taks after 2.0 seconds.</p> <pre><code> let delay = 2.0 let delayInNanoSeconds = dispatch_time(DISPATCH_TIME_NOW, Int64(delay * Double(NSEC_PER_SEC))) let mainQueue = dispatch_get_main_queue() dispatch_after(delayInNanoSeconds, mainQueue, { print("Some UI related task after delay") }) </code></pre> <p>In swift 3.0 :</p> <pre><code> let dispatchTime: DispatchTime = DispatchTime.now() + Double(Int64(2.0 * Double(NSEC_PER_SEC))) / Double(NSEC_PER_SEC) DispatchQueue.main.asyncAfter(deadline: dispatchTime, execute: { }) </code></pre>
<p>Here's a <strong>handy helper</strong> to prevent making the <em>annoying GCD call</em> over and over again:</p> <pre><code>public func delay(bySeconds seconds: Double, dispatchLevel: DispatchLevel = .main, closure: @escaping () -&gt; Void) { let dispatchTime = DispatchTime.now() + seconds dispatchLevel.dispatchQueue.asyncAfter(deadline: dispatchTime, execute: closure) } public enum DispatchLevel { case main, userInteractive, userInitiated, utility, background var dispatchQueue: DispatchQueue { switch self { case .main: return DispatchQueue.main case .userInteractive: return DispatchQueue.global(qos: .userInteractive) case .userInitiated: return DispatchQueue.global(qos: .userInitiated) case .utility: return DispatchQueue.global(qos: .utility) case .background: return DispatchQueue.global(qos: .background) } } } </code></pre> <p>Now you simply <strong>delay your code on the Main thread</strong> like this:</p> <pre><code>delay(bySeconds: 1.5) { // delayed code } </code></pre> <p>If you want to <strong>delay your code to different thread</strong>:</p> <pre><code>delay(bySeconds: 1.5, dispatchLevel: .background) { // delayed code that will run on background thread } </code></pre> <hr> <p>If you prefer a <strong>Framework</strong> that also has some more handy features then checkout <strong><a href="https://github.com/Flinesoft/HandySwift" rel="nofollow noreferrer">HandySwift</a></strong>. You can add it to your project <strong>via Carthage</strong> then use it exactly like in the examples above:</p> <pre><code>import HandySwift delay(bySeconds: 1.5) { // delayed code } </code></pre>
<p>Here's the Swift 3 way to queue work after a delay.</p> <pre><code>DispatchQueue.main.asyncAfter( DispatchTime.now() + DispatchTimeInterval.seconds(2)) { // do work } </code></pre>