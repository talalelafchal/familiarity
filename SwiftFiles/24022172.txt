Does Swift use message dispatch for methods?
<p>I'm sure my terminology is off, so here's an example:</p> <ul> <li>C/C++ has methods and virtual methods. Both have the opportunity to be inlined at compile time.</li> <li>C#'s CIL has <code>call</code> and <code>callvirt</code> instructions (which closely resemble C++ methods and virtual methods). Although almost all method calls in C# become <code>callvirt</code> (due to langauge snafu) the JIT compiler is able to optimize most back to <code>call</code> instructions and then (if worthwhile) also inline them.</li> <li>Objective-C method calls are done very differently (and inefficiently); a message object is passed via <code>objc_msgsend</code> every time you call a method, it's a form of dynamic dispatch, and can never be inlined.</li> </ul> <p>Reading up on the language <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html#//apple_ref/doc/uid/TP40014097-CH10-XID_204">specification for functions</a> for Swift, I don't know if Swift is using the same messaging system as Objective-C or something different.</p>
<p>Sometimes yes, sometimes no. If you have pure swift code, and do not expose your classes/protocols to Objective-C with the <code>@objc</code> decoration, it appears that pure-swift method calls are <em>not</em> dispatched via <code>objc_msgSend</code>, however in other cases they are. If the protocol your swift object adopts is declared in Objective-C, or if the swift protocol is decorated with <code>@objc</code>, then method calls to protocol methods, even from swift objects to other swift objects, are dispatched via <code>objc_msgSend</code>.</p> <p>The documentation is currently a little thin; I'm sure there are other nuances... but empirically speaking (i.e. I've tried it out) some swift method calls go through <code>objc_msgSend</code> and others don't. I think getting the best performance will be dependent on keeping your code as much pure-swift as possible and crossing the Obj-C/swift boundary as little as possible, and through bottleneck interfaces/protocols, so as to limit the number of swift calls that have to be dispatched dynamically.</p> <p>I'm sure more detailed docs will emerge sooner or later.</p>
<p>Unlike C++, it is not necessary to designate that a method is virtual in Swift. The compiler will work out which of the following to use: </p> <p>The performance metrics of course depend on hardware. </p> <ul> <li>Inline the method : 0 ns</li> <li>Static dispatch: &lt; 1.1ns</li> <li>Virtual dispatch 1.1ns (like Java, C# or C++ when designated). </li> <li>Dynamic Dispatch 4.9ns (like Objective-C). </li> </ul> <p>Objective-C of course always uses the latter. The 4.9ns overhead is not usually a problem as this would represent a small fraction of the overall method execution time. However, where necessary developers could seamlessly fall-back to C or C++ where required. This is still somewhat of an option in Swift, however the compiler will analyze which of the fastest can be used and try to decide on your behalf. </p> <p>One side-effect of this, is that some of the powerful features afforded by dynamic dispatch may not be available, where as this could previously have been assumed to be the case for any Objective-C method. Dynamic dispatch is used for method interception, which is in turn used by: </p> <ul> <li>Cocoa-style property observers. </li> <li>CoreData model object instrumentation. </li> <li>Aspect Oriented Programming</li> </ul> <p>With the latest release of Swift, even if an Object is marked as '@objc' or extends NSObject the compiler may still not necessarily use dynamic dispatch. There's a dynamic attribute that can be added to the method to opt-in. </p>