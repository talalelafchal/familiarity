Does Swift have dynamic dispatch and virtual methods?
<p>Coming form a C++/Java/C# background I was expecting to see virtual methods in Swift, however reading the swift documentation I see no mention of virtual methods.</p> <p>What am I missing?</p>
<pre><code>class A { func visit(target: Target) { target.method(self); } } class B: A {} class C: A { override func visit(target: Target) { target.method(self); } } class Target { func method(argument: A) { println("A"); } func method(argument: B) { println("B"); } func method(argument: C) { println("C"); } } let t = Target(); let a: A = A(); let ab: A = B(); let b: B = B(); let ac: A = C(); let c: C = C(); a.visit(t); ab.visit(t); b.visit(t); ac.visit(t); c.visit(t); </code></pre> <p>Note the <code>self</code> reference in the <code>visit()</code> of <code>A</code> and <code>C</code>. Just like in Java it gets not copied over but instead <code>self</code> keeps the same type until it is used in an override again.</p> <p>The result is <strong>A, A, A, C, C</strong> so there's no dynamic dispatch available. Unfortunately.</p>
<p>Swift was made to be easy to learn for Objective-C programmers, and in Objective-C there are no virtual methods, at least not in the way that you might think of them. If you look for instruction on how to create an abstract class or virtual method in Objective-C here on SO, usually it's a normal method that just throws an exception and crashes the app. (Which kinda makes sense, because you're not supposed to call a virtual method)</p> <p>Therefore if Swift documentation says nothing about virtual methods, my guess is that, just as in Objective-C, there are none.</p>
<p>All methods are virtual; however you need to declare that you are overriding a method from a base class using the <code>override</code> keyword:</p> <p>From the <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Inheritance.html#//apple_ref/doc/uid/TP40014097-CH17-XID_251" rel="nofollow">Swift Programming Guide</a>:</p> <blockquote> <p>Overriding</p> <p>A subclass can provide its own custom implementation of an instance method, class method, instance property, or subscript that it would otherwise inherit from a superclass. This is known as overriding.</p> <p>To override a characteristic that would otherwise be inherited, you prefix your overriding definition with the <code>override</code> keyword. Doing so clarifies that you intend to provide an override and have not provided a matching definition by mistake. Overriding by accident can cause unexpected behavior, and any overrides without the <code>override</code> keyword are diagnosed as an error when your code is compiled.</p> <p>The <code>override</code> keyword also prompts the Swift compiler to check that your overriding classâ€™s superclass (or one of its parents) has a declaration that matches the one you provided for the override. This check ensures that your overriding definition is correct.</p> </blockquote>
<p>Unlike C++, it is not necessary to designate that a method is virtual in Swift. The compiler will work out which of the following to use: </p> <p><em>(the performance metrics of course depend on hardware)</em></p> <ul> <li>Inline the method : 0 ns</li> <li>Static dispatch: &lt; 1.1ns</li> <li>Virtual dispatch 1.1ns (like Java, C# or C++ when designated). </li> <li>Dynamic Dispatch 4.9ns (like Objective-C). </li> </ul> <p>Objective-C of course always uses the latter. The 4.9ns overhead is not usually a problem as this would represent a small fraction of the overall method execution time. However, where necessary developers could seamlessly fall-back to C or C++. In Swift, however the compiler will analyze which of the fastest can be used and try to decide on your behalf, favoring inline, static and virtual but retaining messaging for Objective-C interoperability. Its possible to mark a method with <code>dynamic</code> to encourage messaging. </p> <p>One side-effect of this, is that some of the powerful features afforded by dynamic dispatch may not be available, where as this could previously have been assumed to be the case for any Objective-C method. Dynamic dispatch is used for method interception, which is in turn used by: </p> <ul> <li>Cocoa-style property observers. </li> <li>CoreData model object instrumentation. </li> <li>Aspect Oriented Programming</li> </ul> <p>The kinds of features above are those afforded by a <code>late binding</code> language. Note that while Java uses vtable dispatch for method invocation, its still considered a late binding language, and therefore capable of the above features by virtue of having a virtual machine and class loader system, which is another approach to providing run-time instrumentation. "Pure" Swift (without Objective-C interop) is like C++ in that being a direct-to-executable compiled language with static dispatch, then these dynamic features are not possible at runtime. In the tradition of ARC, we might see more of these kinds of features moving to compile time, which gives an edge with regards to "performance per watt" - an important consideration in mobile computing. </p>