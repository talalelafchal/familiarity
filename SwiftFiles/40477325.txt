swift 3 alphanumeric sorting re: I, II, III, IV, IX, V,
Curious to know if anyone can offer a solution to sorting roman numerals (string type) I through X. When I sort an array using {$0.compare ($1, options: .numeric) == .orderedAscending}, I get I, II, III, IV, IX, V, VI, VII, VIII X. As you can see, IX follows IV because of the "I." By the way, the data model is a dictionary [String:[String:[String]]] The Bold indicates where in the dictionary the data to be sorted exists.
Is this what you mean? Perhaps by converting them first let romanValues = ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"] let arabicValues = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1] var romanValue = "" var startingValue = number for (index, romanChar) in enumerate(romanValues) { var arabicValue = arabicValues[index] var div = startingValue / arabicValue if (div > 0) { for j in 0..<div { //println("Should add \(romanChar) to string") romanValue += romanChar } startingValue -= arabicValue * div } } return romanValue
I came up with a simple solution. Rather than hassle with the key of the dictionary to populate the rows of a table view in the desired numeric order, I created a simple array- which is ordered. When a row is selected, I can use didSelectRow to identify the indexPath and the related string of the array- for example row 1 = "Article I". I can then pass the selected string value "Article I" as a variable to use in the selection of the identical key [String:[String:[String]]] within the nested dictionary. PS - the solution posted by Lucas appears to be a partial copy and paste of a function that can be found on GitHub. It appears Lucas inadvertently failed to copy and paste the entire function.