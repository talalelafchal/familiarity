What language level support (if any) does Swift have for asynchronous programming?
<p>Asynchronous programming is a must for responsive user interfaces when application have to communicate over unpredictable networks (e.g. smart phone applications). The user interface must remain responsive while waiting for results to come back from servers somewhere over the internet.</p> <p>In most languages, the application programmer has to implement their own state machines (maybe using closures) to respond to asynchronous callbacks and/or coordinate multiply threads using locks. </p> <p>Both of these are very error prone and not for the fait hearted! </p> <p>(c# introduced the async keyword to help with this, <strong>only time (at least 5 years) will tell if it is a good solution</strong>.)</p> <p>Does Swift have any built in support to assist the writing of asynchronous code?</p>
<p>Swift's approach to asynchronous programming is the same as Objective C's: use Grand Central Dispatch. You can pass closures to gcd dispatch_ functions, just as in ObjC. However, for aesthetic reasons, you can also pass your closure (block) after the close parentheses:</p> <pre><code>dispatch_async(dispatch_get_main_queue()) { println("async hello world") } </code></pre>
<p>While it isn't a built-in language feature, it may be interesting to note that <a href="https://alastairs-place.net/blog/2014/06/12/async-in-swift/">it's possible to implement C# style <code>async</code>/<code>await</code> for Swift</a>, and that because of the special syntax afforded to the last closure argument of a function call, it even looks like it might be part of the language.</p> <p>If anyone is interested, you can get code for this <a href="https://bitbucket.org/al45tair/async">on Bitbucket</a>. Here's a quick taster of what's possible:</p> <pre><code>let task = async { () -&gt; () in let fetch = async { (t: Task&lt;NSData&gt;) -&gt; NSData in let req = NSURLRequest(URL: NSURL.URLWithString("http://www.google.com")) let queue = NSOperationQueue.mainQueue() var data = NSData! NSURLConnection.sendAsynchronousRequest(req, queue:queue, completionHandler:{ (r: NSURLResponse!, d: NSData!, error: NSError!) -&gt; Void in data = d Async.wake(t) }) Async.suspend() return data! } let data = await(fetch) let str = NSString(bytes: data.bytes, length: data.length, encoding: NSUTF8StringEncoding) println(str) } </code></pre> <p>Also, if you want something like @synchronized, try this:</p> <pre><code>func synchronized(obj: AnyObject, blk:() -&gt; ()) { objc_sync_enter(obj) blk() objc_sync_exit(obj) } var str = "A string we can synchronise on" synchronized(str) { println("The string is locked here") } </code></pre>