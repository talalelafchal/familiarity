Cannot downcast from 'AnyObject' whilst parsing JSON array
<p>I'm in the process of trying to migrate an existing project to Swift, its more of a learning exercise but I think I've hit a problem which seems pretty basic and I think it may relate to my lack of understanding of AnyObject.</p> <p>I've created a object that consists of a number of variables and is initialised as:</p> <pre><code>var customObject:MycustomObject = MYcustomObject() </code></pre> <p>I'm then using NSURLConnection to retrieve JSON data and this all appears to be working correctly as the jsonArray is being populated with data </p> <pre><code>jsonArray = NSJSONSerialization.JSONObjectWithData(jsonData, options: NSJSONReadingOptions.MutableContainers, error: &amp;error) as NSArray </code></pre> <p>I'm then looping through the array and attempting to parse the data and this is where I'm experiencing problems, the for loop defaults details to AnyObject.</p> <pre><code>for details:AnyObject in jsonArray { parseDetail(details as NSDictionary) } </code></pre> <p>The problem relates to the integerValue, its generating an "Cannot downcast from 'AnyObject' to non-@objc...." error</p> <pre><code>func parseDetail(element: NSDictionary ) { self.customObject.stringValue = element["id"] as String self.customObject.integerValue = element["type"] as Integer } </code></pre> <p>There also seems to be some differences in the way NSString &amp; String are working, my understanding so far is that when using Swift I should be using the native types Sting, Float Integer etc etc. If I use NSString the stringValue displays correctly in the debug window but when using the type String I receive the following:</p> <pre><code>{ core = { _baseAddress = Builtin.RawPointer = 0x0b227f49 _countAndFlags = 1073741828 _owner = Some { Some = (instance_type = Builtin.RawPointer = 0x0b227f40 -&gt; 0x006d58f0 (void *)0x006d58c8: __NSCFString) } } } </code></pre> <p>Sorry this is a little long but is there any info regarding threading, this is my next challenge?</p> <pre><code>NSThread.detachNewThreadSelector(Selector: parseDetail(), toTarget: self, withObject: nil) </code></pre>
<p>A progress update, the following items are correct and are working:</p> <pre><code>.interegervalue .doublevalue .boolvalue </code></pre> <p>The reason why the above were appearing not to be working is that the JSON data had changed and some elements no longer existed. So element["type"] didn't exist, using Swift this results in a crash whereas in Objective-C no crash occurs.</p> <p>All part of the learning process.. </p>
<p>Here's a little example that does the job. First, here's a model class for our purposes:</p> <pre><code>class CustomObject { var name: String = "" var age : Int = 0 init(json: Dictionary&lt;String, AnyObject&gt;) { name = json["name"] as NSString age = (json["age" ] as NSNumber).integerValue } } </code></pre> <p>As you can see, we still need to deal with NSNumbers and NSStrings since NSJSONSerialization is not yet updated to the Swift types.</p> <p>Next, a little json.txt file residing in our project:</p> <pre><code>[{"name":"Alice","age":30},{"name":"Bob","age":40}] </code></pre> <p>And last, the parser, right in application launch for a quick test:</p> <pre><code>func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: NSDictionary?) -&gt; Bool { var filePath = NSBundle.mainBundle().pathForResource("json", ofType:"txt") var data = NSData(contentsOfFile:filePath) var json = NSJSONSerialization.JSONObjectWithData(data, options: .MutableContainers, error: nil) as Array&lt;Dictionary&lt;String, AnyObject&gt;&gt; var customObjects = json.map { dict in CustomObject(json: dict) } println(customObjects[0].name) println(customObjects[0].age) return true } </code></pre> <p>This will print:</p> <pre><code>Alice 30 </code></pre>