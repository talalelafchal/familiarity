Generic type with custom object in Swift language
<p>I wonder is there any way to compare two generic type instances with <code>==</code> operator in following generic function:</p> <pre><code> func compare&lt;T&gt;(T a, T b) -&gt; Bool { if a == b{ // do something return true; }else{ // do another thing return false; } } </code></pre> <p>Here is my custom object:</p> <pre><code>class MyObj{ var id = 3 var name: String? } </code></pre>
<p>You can create your own implementation of the <em>equivalence operators</em> == and !=, like this:</p> <pre><code>@infix func == (left: MyObj, right: MyObj) -&gt; Bool { return (left.id == right.id) &amp;&amp; (left.name == right.name) } @infix func != (left: MyObj, right: MyObj) -&gt; Bool { return !(left == right) } var obj1 = MyObj() var obj2 = MyObj() obj1.id = 5 obj1 == obj2 // false obj2.id = 5 obj1 == obj2 // true obj1.name = "John" obj1 == obj2 // false </code></pre>
<p>From Apple Developer Resources,</p> <blockquote> <p>Not every type in Swift can be compared with the equal to operator (==). If you create your own class or structure to represent a complex data model, for example, then the meaning of “equal to” for that class or structure is not something that Swift can guess for you. Because of this, it is not possible to guarantee that this code will work for every possible type T, and an appropriate error is reported when you try to compile the code.</p> <p>All is not lost, however. The Swift standard library defines a protocol called<br> Equatable, which requires any conforming type to implement the equal to operator (==) and the not equal to operator (!=) to compare any two values of that type. All of Swift’s standard types automatically support the Equatable protocol.</p> <p>Any type that is Equatable can be used safely with the findIndex function, because it is guaranteed to support the equal to operator. To express this fact, you write a type constraint of Equatable as part of the type parameter’s definition when you define the function:</p> </blockquote> <pre><code>func findIndex&lt;T: Equatable&gt;(array: T[], valueToFind: T) -&gt; Int? { for (index, value) in enumerate(array) { if value == valueToFind { return index } } return nil } </code></pre> <p>Here is a sample from their documentation explaining how to override <code>==</code> </p> <pre><code>struct MyStruct: Equatable { var name = "Untitled" } func == (lhs: MyStruct, rhs: MyStruct) -&gt; Bool { return lhs.name == rhs.name } let value1 = MyStruct() var value2 = MyStruct() let firstCheck = value1 == value2 // firstCheck is true value2.name = "A New Name" let secondCheck = value1 == value2 // secondCheck is false </code></pre> <p>In your case you would do,</p> <pre><code>class MyObj{ var id = 3 var name: String? } func == (lhs: MyObj, rhs: MyObj) -&gt; Bool { return lhs.id == rhs.id } </code></pre>
<p>In order to use your generic <code>compare()</code> method, you need to make the class conform to the <a href="https://developer.apple.com/library/prerelease/ios/documentation/General/Reference/SwiftStandardLibraryReference/Equatable.html#//apple_ref/doc/uid/TP40014608-CH17-SW1" rel="nofollow"><code>Equatable</code> protocol</a> and you can then use the <code>==</code> operator (however you could just as easily call the <code>==</code> operator directly):</p> <pre><code>import Cocoa class MyObj : Equatable { var id: Int = 0 var name: String? } func == (lhs: MyObj, rhs: MyObj) -&gt; Bool { return lhs.id == rhs.id &amp;&amp; lhs.name? == rhs.name? } func compare&lt;T: Equatable&gt;(a: T, b: T) -&gt; Bool { return a == b } var obj1 = MyObj() obj1.id = 12; obj1.name = "Andy" var obj2 = MyObj() obj2.id = 12; obj2.name = "Andy" if compare(obj1, obj2) { println("equal") } else { println("not equal") } </code></pre>