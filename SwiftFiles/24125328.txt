Swift optional chaining doesn't work in closure
<p>My code looks like this. My class has an optional var</p> <pre><code>var currentBottle : BottleLayer? </code></pre> <p>BottleLayer has a method <code>jiggle()</code>.</p> <p>This code, using optional chaining, compiles fine in my class:</p> <pre><code>self.currentBottle?.jiggle() </code></pre> <p>Now I want to construct a closure that uses that same code:</p> <pre><code>let clos = {() -&gt; () in self.currentBottle?.jiggle()} </code></pre> <p>But I get a compile error:</p> <blockquote> <p>Could not find member 'jiggle'</p> </blockquote> <p>As a workaround I can force unwrapping</p> <pre><code>let clos = {() -&gt; () in self.currentBottle!.jiggle()} </code></pre> <p>or of course I can use full-fledged optional binding, but I'd rather not. I do recognize that optional chaining is just syntactical sugar, but it is hard to see why this syntactical sugar would stop working just because it's in a handler (though there may, of course, be a reason - but it's a surprise in any case).</p> <p>Perhaps someone else has banged into this and has thoughts about it? Thanks.</p>
<p>Letting the closure type be inferred seems to work as well.</p> <pre><code>let clos2 = { currentBottle?.jiggle() } clos2() // does a jiggle </code></pre> <p>But I'm pretty sure this is just the compiler assigning a type of <code>() -&gt; ()?</code></p>
<p>This is NOT a bug. It's simply your closure type which is wrong. The correct type should return an optional <code>Void</code> to reflect the optional chaining:</p> <pre><code>let clos = { ()-&gt;()? in currentBottle?.jiggle() } </code></pre> <hr> <h2>The problem in details:</h2> <ul> <li>You declare your closure as a closure that returns <code>Void</code> (namely <code>-&gt;()</code>).</li> <li>But, do remember that, as like every time you use optional chaining, the return type of the whole expression is <strong>of optional type</strong>. Because your closure can <strong>either return <code>Void</code></strong> if <code>currentBottle</code> do exists… <strong>or <code>nil</code></strong> if it doesn't!</li> </ul> <p>So the correct syntax is to make your closure return a <code>Void?</code> (or <code>()?</code>) instead of a simple <code>Void</code></p> <pre><code>class BottleLayer { func jiggle() { println("Jiggle Jiggle") } } var currentBottle: BottleLayer? currentBottle?.jiggle() // OK let clos = { Void-&gt;Void? in currentBottle?.jiggle() } // Also OK let clos = { () -&gt; ()? in currentBottle?.jiggle() } // Still OK (Void and () are synonyms) </code></pre> <p>Note: if you had let Swift infer the correct type for you instead of explicitly forcing it, it would have fixed the issue for you:</p> <pre><code>// Even better: type automatically inferred as ()-&gt;()? — also known as Void-&gt;Void? let clos = { currentBottle?.jiggle() } </code></pre> <hr> <p>[EDIT]</p> <h2>Additional trick: directly assign the optional chaining to a variable</h2> <p>You can even assign the function directly to a variable, like so:</p> <pre><code>let clos2 = currentBottle?.jiggle // no parenthesis, we don't want to call the function, just refer to it </code></pre> <p>Note that the type of <code>clos2</code> (which is not explicitly specified here and is thus inferred automatically by Swift) in this case is <strong>not</strong> <code>Void-&gt;Void?</code> — namely a function that returns either <code>nil</code> or <code>Void</code>) as in the previous case — but <strong>is <code>(Void-&gt;Void)?</code></strong>, which is the type for "an <strong>optional</strong> function of type <code>Void-&gt;Void</code>".</p> <p>This means that <code>clos2</code> itself is "either <code>nil</code> or is a function returning <code>Void</code>". To use it, you could once again use optional chaining, simply like that:</p> <pre><code>clos2?() </code></pre> <p>This will evaluate to <code>nil</code> and do nothing if <code>clos2</code> is itself <code>nil</code> (likely because <code>currentBottle</code> is itself nil)… and execute the closure — thus the <code>currentBottle!.jiggle()</code> code — and return <code>Void</code> if <code>clos2</code> is non-nil (likely because <code>currentBottle</code> itself is non-nil).</p> <p>The return type of <code>clos2?()</code> itself is indeed <code>Void?</code>, as it returns either nil or Void.</p> <p>Doing the distinction between <code>Void</code> and <code>Void?</code> may seem pointless (after all, the <code>jiggle</code> function does not return anything in either case), but it let you do powerful stuff like testing the <code>Void?</code> in an <code>if</code> statement to check if the call actually did happen (and returned <code>Void</code> namely nothing) or didn't happen (and return <code>nil</code>):</p> <pre><code>if clos2?() { println("The jiggle function got called after all!") } </code></pre> <hr> <p>[EDIT2] As you (@matt) pointed out yourself, this other alternative has one other major difference: it evaluates <code>currentBottle?.jiggle</code> at the time that expression got affected to <code>clos2</code>. So if <code>currentBottle</code> is <code>nil</code> at that time, <code>clos2</code> will be <code>nil</code>… even if <code>currentBottle</code> got a non-nil value later.</p> <p>Conversely, <code>clos</code> is affected to the closure itself, and the optional chaining is only evaluated each time <code>clos</code> is called, so it will evaluate to <code>nil</code> if <code>currentBottle</code> is nil… but will be evaluated to non-nil and will call <code>jiggle()</code> if we call <code>clos()</code> at a later time at which point <code>currentBottle</code> became non-nil.</p>
<pre><code>let closure = { () -&gt; () in self.currentBottle?.jiggle() return } </code></pre> <p>Otherwise the compiler thinks the result of that statement should be returned from the closure and it realizes there is a mismatch between <code>()</code> (return type) and the optional returned by the statement (<code>Optional&lt;Void&gt;</code>). By adding an explicit <code>return</code>, the compiler will know that we don't want to return anything.</p> <p>The error message is wrong, of course.</p>
<p>Okay, another approach. This is because closures in Swift have <em>Implicit Returns from Single-Expression Closures</em>. Because of the optional chain, your closure has a return type of <code>Void?</code>, so:</p> <pre><code>let clos = {() -&gt; Void? in self.currentBottle?.jiggle()} </code></pre>