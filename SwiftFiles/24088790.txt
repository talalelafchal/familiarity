Swift switch case compiler error
<p>The following code is a derivation from the examples of Intermediate Swift talk in WWDC. What I'm trying to do is to initialize a model class from a key-attribute list, which comes from some kind of API.</p> <pre><code>class Movie { var title: String init(title: String) { self.title = title } } func movieFromDictionary(dict: Dictionary&lt;String, AnyObject&gt;) -&gt; Movie? { switch dict["title"] { case .Some(let movieTitle as String): return Movie(title: movieTitle) default: return nil } } </code></pre> <p>When I try to compile these, I get the following error:</p> <pre><code>Bitcast requires both operands to be pointer or neither %38 = bitcast i8* %37 to %SS, !dbg !161 Invalid operand types for ICmp instruction %39 = icmp ne %SS %38, null, !dbg !161 PHI nodes must have at least one entry. If the block is dead, the PHI should be removed! %42 = phi i64 , !dbg !161 PHI node operands are not the same type as the result! %41 = phi i8* [ %38, %34 ], !dbg !161 LLVM ERROR: Broken function found, compilation aborted! Command /Applications/Xcode6-Beta.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift failed with exit code 1 </code></pre> <p>Interestingly editor seems to be OK with the code. Is this a compiler bug or something wrong with the code?</p>
<p>I agree with the commenters that this is a compiler bug, which you should report to apple. But, you can also implement it this way, which is simpler and should work fine:</p> <pre><code>func movieFromDictionary(dict: Dictionary&lt;String, AnyObject&gt;) -&gt; Movie? { if let title = dict["title"] as? String { return Movie(title: title) } else { return nil } } </code></pre>
<p>I've had a similar issue, and found that if I extracted the thing I was switching on first, then it all worked fine ie.</p> <p>instead of </p> <pre><code>switch segue.sourceViewController { case let c as XYZAddToDoItemViewController where c.toDoItem.name.utf16count &gt; 0 : toDoItems.append(c.toDoItem) tableView.reloadData() default: println("Unexpected source controller") } </code></pre> <p>You should declare the thing you're switching on first (and it insisted on the AnyObject)</p> <pre><code>let s:AnyObject = segue.sourceViewController switch s { case let c as XYZAddToDoItemViewController where c.toDoItem.name.utf16count &gt; 0 : toDoItems.append(c.toDoItem) tableView.reloadData() default: println("Unexpected source controller") } </code></pre>
<pre><code>switch dict["title"] { case .Some(let movieTitle as String): </code></pre> <p>I just encountered something similar, also with a dictionary. The problem seems to be what I would call a double-cast. <code>dict["title"]</code> is an <code>AnyObject!</code> â€” that is to say, it's an Optional. The fact that it's implicitly unwrapped is irrelevant for the moment. Now you are asking to cast that to a String. So you are taking two casting steps at once:</p> <ul> <li>You want to unwrap the Optional</li> <li>You want what's inside the Optional, which is typed as an AnyObject, to be castable to a String</li> </ul> <p>It is this double-cast that gives the compiler trouble. It should provide a better error message, and since this issue is readily reproducible, you should file a bug. Nonetheless, I think this kind of double-casting is wrong. You have to do it in two steps (as bulleted above): first find out whether <code>dict["title"]</code> is nil, and then and only then, if it is not, unwrap it and see if you can cast to a String.</p> <p>(The situation is not helped by the fact that the interplay between NSDictionary and Dictionary is not as clean as it might be. In my case things were even more complicated, because the dictionary was coming out of user defaults, so it <em>itself</em> was an Optional.)</p>