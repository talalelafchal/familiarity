Swift Unit testing with XCTAssertThrows analogue
<p>Is there any equivalent to check for throwing exceptions in swift language Unit tests?</p> <p>For example I Have a class:</p> <pre><code>class Square : NSObject{ let sideLength: Int init(sideLength: Int) { assert(sideLength &gt;= 0, "Wrong initialization of Square class with below zero side length") self.sideLength = sideLength super.init() } } </code></pre> <p>and Test to check it work. In objective C I can write test method like this:</p> <pre><code>- (void)testInitializationWithWrongSideLengthThrowsExceptions{ XCTAssertThrows([[Shape alloc] initWithSideLength: -50], "Should throw exceptions on wrong side values initialisations"); } </code></pre> <p>What is Swift equal technic?</p>
<p>I think the <code>assert()</code>-function should only be used for debug-purposes. Not only because of the following statement from Apple's Swift-Book (<a href="https://itun.es/de/jEUH0.l" rel="nofollow">https://itun.es/de/jEUH0.l</a>):</p> <p><em>„Assertions cause your app to terminate and are not a substitute for designing your code in such a way that invalid conditions are unlikely to arise.“</em></p> <p>Thats why I would solve this as follows:</p> <pre><code>import Cocoa import XCTest class Square { let sideLength: Int init(_ sideLength: Int) { self.sideLength = sideLength &gt;= 0 ? sideLength : 0 } } class SquareTests: XCTestCase { override func setUp() { super.setUp() } override func tearDown() { super.tearDown() } func testMySquareSideLength() { let square1 = Square(1); XCTAssert(square1.sideLength == 1, "Sidelength should be 1") let square2 = Square(-1); XCTAssert(square2.sideLength &gt;= 0, "Sidelength should be not negative") } } let tester = SquareTests() tester.testMySquareSideLength() </code></pre>
<p>There is no equivalent to XCTAssertThrows in swift. For now you can't use a native function, but there is a solution with some objective-c help. You can use Quick, or only Nimble. Or to make your own assert function - see this article - <a href="http://modocache.io/xctest-the-good-parts" rel="nofollow">http://modocache.io/xctest-the-good-parts</a> - Potential Improvement #2: Add XCTAssertThrows to Swift</p>
<p>If you add the following three files to your tests:</p> <pre><code>// ThrowsToBool.h #import &lt;Foundation/Foundation.h&gt; /// A 'pure' closure; has no arguments, returns nothing. typedef void (^VoidBlock)(void); /// Returns: true if the block throws an `NSException`, otherwise false BOOL throwsToBool(VoidBlock block); // ThrowsToBool.m #import "ThrowsToBool.h" BOOL throwsToBool(VoidBlock const block) { @try { block(); } @catch (NSException * const notUsed) { return YES; } return NO; } // xxxTests-Bridging-Header.h #import "ThrowsToBool.h" </code></pre> <p>Then you can write:</p> <pre><code>XCTAssert(throwsToBool { // test code that throws an NSException }) </code></pre> <p>But it doesn't work for assert or precondition :(</p> <p>PS I got the idea from: <a href="http://modocache.io/xctest-the-good-parts" rel="nofollow">http://modocache.io/xctest-the-good-parts</a></p>
<p>the best way is add a bridge I think.</p> <p>please look at <a href="https://gist.github.com/akolov/8894408226dab48d3021" rel="nofollow">https://gist.github.com/akolov/8894408226dab48d3021</a></p> <p>it works for me.</p>
<p>correct way in Swift 2:</p> <pre><code>class Square : NSObject{ let sideLength: Int init(sideLength: Int) throws { // throwable initializer guard sideLength &gt;= 0 else { // use guard statement throw ...// your custom error type } self.sideLength = sideLength super.init() } } </code></pre> <p>and testing:</p> <pre><code>func testInitThrows() { do { _ = try Square(sideLength: -1) // or without parameter name depending on Swift version XCTFail() } catch ... { // your custom error type } catch { XCTFail() } } </code></pre>