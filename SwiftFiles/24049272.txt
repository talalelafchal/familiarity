Swift error: missing argument label 'name:' in call
<p>I'm learning about default arguments and I ran aground of something weird:</p> <pre><code>import UIKit func greet(name: String = "world") { println("hello \(name)") } greet("jiaaro") </code></pre> <p>this throws an error:</p> <blockquote> <pre><code>Playground execution failed: error: &lt;REPL&gt;:9:7: error: missing argument label 'name:' in call greet("jiaaro") ^ name: </code></pre> </blockquote> <p>I understand that it wants <code>greet(name: "jiaaro")</code> but I <em>don't</em> understand why that should be necessary.</p>
<p>Swift functions can specify local and external argument names:</p> <pre><code>func greet(who name: String = "world") { println("hello \(name)") } // prints "hello world" greet() // prints "hello jiaaro" greet(who:"jiaaro") // error greet("jiaaro") // error greet(name: "jiaaro") </code></pre> <p>To opt out of this behavior you can use an underscore for the external name. Note that the first parameter implicitly uses the "no external name" behavior:</p> <pre><code>func greet(name: String = "world", _ hello: String = "hello") { println("\(hello) \(name)") } // prints "hello world" greet() // prints "hello jiaaro" greet("jiaaro") // prints "hi jiaaro" greet("jiaaro", "hi") // error greet(name: "jiaaro") </code></pre> <blockquote> <p>The following is now disallowed in Swift 2.0, see below for equivalent code.</p> </blockquote> <p>You can use the <code>#</code> prefix to use the same local and external name for the first parameter:</p> <pre><code>func greet(#name: String = "world", hello: String = "hello") { println("\(hello) \(name)") } // prints "hi jiaaro" greet(name: "jiaaro", hello: "hi") </code></pre> <blockquote> <p>Swift 2.0 code:</p> <pre><code>func greet(name name: String = "world", hello: String = "hello") { println("\(hello) \(name)") } // prints "hi jiaaro" greet(name: "jiaaro", hello: "hi") </code></pre> </blockquote>
<p>Swift requires argument labels by default, because it supports classes with multiple initializers. The benefit of argument labels comes from the ability of Swift to infer which initializer to use; not only by argument type, but argument name as well.</p> <pre><code>struct Celsius { var temperatureInCelsius: Double = 0.0 init(fromFahrenheit fahrenheit: Double) { temperatureInCelsius = (fahrenheit - 32.0) / 1.8 } init(fromKelvin kelvin: Double) { temperatureInCelsius = kelvin - 273.15 } } let boilingPointOfWater = Celsius(fromFahrenheit: 212.0) // boilingPointOfWater.temperatureInCelsius is 100.0 let freezingPointOfWater = Celsius(fromKelvin: 273.15) // freezingPointOfWater.temperatureInCelsius is 0.0 </code></pre> <p>See this page for more details: <a href="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-XID_272" rel="nofollow">https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-XID_272</a></p>
<p>I just wanted to add that now your code</p> <pre><code>func greet(name: String = "world") { print("hello \(name)") } greet("jiaaro") </code></pre> <p>works fine in xcode, i just changed "println" with "print"</p>