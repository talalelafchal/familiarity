Swift and mutating struct
<p>There is something that I don't entirely understand when it comes to mutating value types in Swift.</p> <p>As the "The Swift Programming Language" iBook states: <strong><em>By default, the properties of a value type cannot be modified from within its instance methods.</em></strong></p> <p>And so to make this possible we can declare methods with the <code>mutating</code> keyword inside structs and enums.</p> <p>The thing that is not entirely clear to me is this: You can change a var from outside a struct, but you cannot change it from its own methods. This seems counter-intuitive to me, as in Object Oriented languages, you generally try to encapsulate variables so they can only be changed from within. With structs this appears to be the other way around. To elaborate, here's a code snippet:</p> <pre><code>struct Point { var x = 0, y = 0 mutating func moveToX(x: Int, andY y:Int) { //Needs to be a mutating method in order to work self.x = x self.y = y } } var p = Point(x: 1, y: 2) p.x = 3 //Works from outside the struct! p.moveToX(5, andY: 5) </code></pre> <p>Does anyone know the reason why structs cannot change their content from inside their own context, while the contents can easily be changed elsewhere?</p>
<p>The mutability attribute is marked on a storage (constant or variable), not the type. You can think struct has two modes: <em>mutable</em> and <em>immutable</em>. If you assign a struct value to an immutable storage (we call it <code>let</code> or <strong>constant</strong> in Swift) the value becomes immutable mode, and you cannot change any state in the value. (including calling any mutating method)</p> <p>If the value is assigned to a mutable storage (we call it <code>var</code> or <em>variable</em> in Swift), you're free to modify the state of them, and calling of mutating method is allowed.</p> <p>In addition, classes don't have this immutable/mutable mode. IMO, this is because classes are usually used to represent <em>reference-able</em> entity. And reference-able entity is usually mutable because it's very hard to make and manage reference graphs of entities in immutable manner with proper performance. They may add this feature later, but not now at least.</p> <p>For Objective-C programmers, mutable/immutable concepts are very familiar. In Objective-C we had two separated classes for each concept, but in Swift, you can do this with one struct. Half work.</p> <p>For C/C++ programmers, this is also very familiar concept. This is exactly what <code>const</code> keyword do in C/C++.</p> <p>Also, immutable value can be very nicely optimised. In theory, Swift compiler (or LLVM) can perform copy-elision on values passed by <code>let</code>, just as like C++. If you use immutable struct wisely, it will outperform refcounted classes.</p> <h3>Update</h3> <p>As @Joseph claimed this doesn't provide <em>why</em>, I am adding a little more.</p> <p>Structs have two kind of methods. <em>plain</em> and <em>mutating</em> methods. <em>Plain</em> method implies <em>immutable (or non-mutating)</em>. This separation exists only to support <em>immutable</em> semantics. An object in immutable mode shouldn't change its state at all.</p> <p>Then, immutable methods must guarantee this <em>semantic immutability</em>. Which means it shouldn't change any internal value. So compiler disallows any state changes of itself in a immutable method. In contrast, mutating methods are free to modify states.</p> <p>And then, you may have a question of <em>why immutable is the default?</em> That's because it's very hard to predict the future state of mutating value, and that usually becomes the main source of headaches and bugs. Many people agreed that the solution is avoiding mutable stuffs, and then <em>immutable by default</em> was on top of wish list for decades in C/C++ family languages and its derivations.</p> <p>See <a href="http://en.wikipedia.org/wiki/Purely_functional"><em>purely functional style</em></a> for more details. Anyway, we still need mutable stuffs because immutable stuffs have some weaknesses, and discussing about this seems to be out of topic.</p> <p>I hope this helps.</p>
<p>Consider an analogy with C++. A struct method in Swift being <code>mutating</code>/not-<code>mutating</code> is analogous to a method in C++ being non-<code>const</code>/<code>const</code>. A method marked <code>const</code> in C++ similarly cannot mutate the struct.</p> <blockquote> <p>You can change a var from outside a struct, but you cannot change it from its own methods.</p> </blockquote> <p>In C++, you can also "change a var from outside the struct" -- but <em>only</em> if you have a non-<code>const</code> struct variable. If you have a <code>const</code> struct variable, you cannot assign to a var, and you also cannot call a non-<code>const</code> method. Similarly, in Swift, you can change a property of a struct only if the struct variable is not a constant. If you have a struct constant, you cannot assign to a property, and you also cannot call a <code>mutating</code> method.</p>
<p>A structure is an aggregation of fields; if a particular structure instance is mutable, its fields will be mutable; if an instance is immutable, its fields will be immutable. A structure type must thus be prepared for the possibility that the fields of any particular instance may be mutable or immutable.</p> <p>In order for a structure method to mutate the fields of the underlying struct, those fields have to be mutable. If a method that mutates fields of the underlying struct is invoked upon an immutable structure, it would try to mutate immutable fields. Since nothing good could come of that, such invocation needs to be forbidden.</p> <p>To achieve that, Swift divides structure methods into two categories: those that modify the underlying structure, and thus may only be invoked on mutable structure instances, and those that do not modify the underlying structure and should thus be invokable on both mutable and immutable instances. The latter usage is probably the more frequent, and is thus the default.</p> <p>By comparison, .NET presently (still!) offers no means of distinguishing structure methods that modify the structure from those that don't. Instead, invoking a structure method on an immutable structure instance will cause the compiler to make a mutable copy of the structure instance, let the method do whatever it wants with it, and discard the copy when the method is done. This has the effect of forcing the compiler to waste time copying the structure whether or not the method modifies it, even though adding the copy operation will almost never turn what would be semantically-incorrect code into semantically-correct code; it will merely cause code that is semantically wrong in one way (modifying an "immutable" value) to be wrong in a different way (allowing code to think it's modifying a structure, but discarding the attempted changes). Allowing struct methods to indicate whether they will modify the underlying structure can eliminate the need for a useless copy operation, and also ensures that attempted erroneous usage will get flagged.</p>
<p>Swift structs can be instantiated as either constants (via <code>let</code>) or variables (via <code>var</code>)</p> <p>Consider Swift's <code>Array</code> struct (yes it's a struct). </p> <pre><code>var petNames: [String] = ["Ruff", "Garfield", "Nemo"] petNames.append("Harvey") // ["Ruff", "Garfield", "Nemo", "Harvey"] let planetNames: [String] = ["Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune"] planetNames.append("Pluto") //Error, sorry Pluto. No can do </code></pre> <p>Why didn't the append work with the planet names? Because append is marked with the <code>mutating</code> keyword. And since <code>planetNames</code> was declared using <code>let</code>, all methods thus marked are off limits.</p> <p>In your example the compiler can tell you're modifying the struct by assigning to one or more of its properties outside of an <code>init</code>. If you change your code a bit you'll see that <code>x</code> and <code>y</code> aren't always accessible outside the struct. Notice the <code>let</code> on the first line.</p> <pre><code>let p = Point(x: 1, y: 2) p.x = 3 //error p.moveToX(5, andY: 5) //error </code></pre>