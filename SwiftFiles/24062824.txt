Strong reference cycles in Swift
<p>I'm looking at the example from the “Unowned References and Implicitly Unwrapped Optional Properties” section of the book “The Swift Programming Language.”</p> <p>Their example code is</p> <pre><code>class Country { let name: String let capitalCity: City! init(name: String, capitalName: String) { self.name = name self.capitalCity = City(name: capitalName, country: self) } } class City { let name: String unowned let country: Country init(name: String, country: Country) { self.name = name self.country = country } } </code></pre> <p>This works if I want to deal exclusively with Countries and the only purpose of the <code>City</code> type is to be a capital of a <code>Country</code>. But what happens if I want to create a City?</p> <p>This creates a runtime exception because no reference to the <code>City</code>'s <code>Country</code> is retained since it is an unowned variable:</p> <pre><code>var chicago = City(name:"Chicago", country: Country(name: "USA", capitalName: "Washington DC")) chicago.country.name // Playground execution failed: error: Execution was interrupted, reason: EXC_BAD_ACCESS (code=EXC_I386_GPFLT). </code></pre> <p>How would I allow something like this without creating a Strong Reference Cycle?</p>
<p>In your example, nobody is owning the <code>Country</code> instance. That means it gets deallocated (freed) immediately.</p> <pre><code>var country = Country(name: "USA", capitalName: "Washington DC") var chicago = City(name:"Chicago", country: country) chicago.country.name </code></pre> <p>will fix it because our <code>coutry</code> variable will keep <code>USA</code> from deallocating</p> <p>If you use an unowned reference, you always have to keep a strong reference somewhere else.</p>
<p>There are two typical solutions:</p> <ul> <li><p>If you want to primarily deal with cities, invert the relationship so that <code>City</code> has a strong reference to <code>Country</code>, and <code>Country</code> points back to an unowned instance.</p></li> <li><p>If you want to have cities and countries as primary objects that cross reference each other, put all cities and countries into collections (or other form of store that owns them), and make both references weak. That way they don't own each other, and you don't have a cycle.</p></li> </ul> <p>The best way to avoid retain cycles is to consider who owns every object. Objects can own each other, but that should be a clear hierarchy (i.e. a tree). If you have connections that go sidewards and and upwards in the hierarchy, make them weak or unowned.</p> <p>Solution one is the upwards case, solution two is sidewards case.</p> <h3>Edit</h3> <ul> <li>A third option is, to have <code>Country</code> own a collection of all its cities. I think that makes most sense in this simple case, but it means the <code>Country</code> needs to create all cities in it's initialization, or have a method that adds cities.</li> </ul> <p>Here's an example for the second case. It's quite complex, probably too much so for this simple case, but it illustrates extracting a common owner. I would normally use it if there are a lot of cross references. (Think relational database. The records don't own each other.)</p> <pre> class Country { let name: String weak var capitalCity: City? init(name: String) { self.name = name } } class City { let name: String unowned let country: Country init(name: String, country: Country, isCapital: Bool) { self.name = name self.country = country if isCapital { country.capitalCity = self } } } class Planet { var countries: [Country] = [] var cities: [City] = [] } let earth = Planet() earth.countries = [ Country(name: "USA"), Country(name: "Canada"), ] earth.cities = [ City(name: "Washington DC", country: earth.countries[0], isCapital: true), City(name: "Chicago", country: earth.countries[0], isCapital: false), City(name: "Ottawa", country: earth.countries[1], isCapital: true), ] </pre>