What is the Swift equivalent to Objective-C's &quot;@synchronized&quot;?
<p>I've searched the Swift book, but can't find the Swift version of @synchronized. How do I do mutual exclusion in Swift?</p>
<p>You can sandwich statements between <code>objc_sync_enter(obj: AnyObject?)</code> and <code>objc_sync_exit(obj: AnyObject?)</code>. The @synchronized keyword is using those methods under the covers. i.e.</p> <pre><code>objc_sync_enter(self) ... synchronized code ... objc_sync_exit(self) </code></pre>
<p>I'm using GCD. It's a little more verbose than <code>@synchronized</code>, but works perfectly well as a replacement:</p> <pre><code>let lockQueue = dispatch_queue_create("com.test.LockQueue", nil) dispatch_sync(lockQueue) { // code } </code></pre>
<p>I was looking for this myself and came to the conclusion there's no native construct inside of swift for this yet.</p> <p>I did make up this small helper function based on some of the code I've seen from Matt Bridges and others.</p> <pre><code>func synced(lock: AnyObject, closure: () -&gt; ()) { objc_sync_enter(lock) closure() objc_sync_exit(lock) } </code></pre> <p>Usage is pretty straight forward</p> <pre><code>synced(self) { println("This is a synchronized closure") } </code></pre> <p>There is one problem I've found with this. Passing in an array as the lock argument seems to cause a very obtuse compiler error at this point. Otherwise though it seems to work as desired.</p> <pre><code>Bitcast requires both operands to be pointer or neither %26 = bitcast i64 %25 to %objc_object*, !dbg !378 LLVM ERROR: Broken function found, compilation aborted! </code></pre>
<p>To add return functionalty, you could do this:</p> <pre><code>func synchronize&lt;T&gt;(lockObj: AnyObject!, closure: ()-&gt;T) -&gt; T { objc_sync_enter(lockObj) var retVal: T = closure() objc_sync_exit(lockObj) return retVal } </code></pre> <p>Subsequently, you can call it using:</p> <pre><code>func importantMethod(...) -&gt; Bool { return synchronize(self) { if(feelLikeReturningTrue) { return true } // do other things if(feelLikeReturningTrueNow) { return true } // more things return whatIFeelLike ? true : false } } </code></pre>
<p>Another method is to create a superclass and then inherit it. This way you can use GCD more directly</p> <pre><code>class Lockable { let lockableQ:dispatch_queue_t init() { lockableQ = dispatch_queue_create("com.blah.blah.\(self.dynamicType)", DISPATCH_QUEUE_SERIAL) } func lock(closure: () -&gt; ()) { dispatch_sync(lockableQ, closure) } } class Foo: Lockable { func boo() { lock { ....... do something } } </code></pre>
<p>Why make it difficult and hassle with locks? Use Dispatch Barriers.</p> <p>A dispatch barrier creates a synchronization point within a concurrent queue. <p> While it’s running, no other block on the queue is allowed to run, even if it’s concurrent and other cores are available. <p> If that sounds like an exclusive (write) lock, it is. Non-barrier blocks can be thought of as shared (read) locks. <p> As long as all access to the resource is performed through the queue, barriers provide very cheap synchronization.</p>
<p>I like and use many of the answers here, so I'd choose whichever works best for you. That said, the method I prefer when I need something like objective-c's <code>@synchronized</code> uses the <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/doc/uid/TP40014097-CH33-ID532"><code>defer</code></a> statement introduced in swift 2.</p> <pre><code>{ objc_sync_enter(lock) defer { objc_sync_exit(lock) } // // code of critical section goes here // } // &lt;-- lock released when this block is exited </code></pre> <p>The nice thing about this method, is that your critical section can exit the containing block in any fashion desired (e.g., <code>return</code>, <code>break</code>, <code>continue</code>, <code>throw</code>), and "the statements within the defer statement are executed no matter how program control is transferred."<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/doc/uid/TP40014097-CH33-ID532">1</a></p>
<p>Using Bryan McLemore answer, I extended it to support objects that throw in a safe manor with the Swift 2.0 defer ability. </p> <pre><code>func synchronized( lock:AnyObject, block:() throws -&gt; Void ) rethrows { objc_sync_enter(lock) defer { objc_sync_exit(lock) } try block() } </code></pre>
<p>Based on the answers from GNewc <a href="http://stackoverflow.com/a/26743647/3541063">[1]</a> (where I like possibly non-void return type) and Tod Cunningham <a href="http://stackoverflow.com/a/32923617/3541063">[2]</a> (where I like <code>defer</code>).</p> <p>Add <code>@noescape</code> (see <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html">Attributes</a> in the Language Reference) attribute to the closure to allow more optimisations and use <code>rethrows</code> to simplify usage with non-throwing closures:</p> <pre><code>func synchronized&lt;T&gt;(lock: AnyObject, @noescape _ body: () throws -&gt; T) rethrows -&gt; T { objc_sync_enter(lock) defer { objc_sync_exit(lock) } return try body() } </code></pre>
<p><a href="http://stackoverflow.com/a/31949965/">Based on ɲeuroburɳ</a>, test an sub-class case</p> <pre><code>class Foo: NSObject { func test() { print("1") objc_sync_enter(self) defer { objc_sync_exit(self) print("3") } print("2") } } class Foo2: Foo { override func test() { super.test() print("11") objc_sync_enter(self) defer { print("33") objc_sync_exit(self) } print("22") } } let test = Foo2() test.test() </code></pre> <h2>Output:</h2> <pre><code>1 2 3 11 22 33 </code></pre>
<p>dispatch_barrier_async is the better way, while not blocking current thread.</p> <p>dispatch_barrier_async(accessQueue, { dictionary[object.ID] = object })</p>
<p>In conclusion, Here give more common way that include return value or void, and throw</p> <p>import Foundation</p> <pre><code>extension NSObject { func synchronized&lt;T&gt;(lockObj: AnyObject!, closure: () throws -&gt; T) rethrows -&gt; T { objc_sync_enter(lockObj) defer { objc_sync_exit(lockObj) } return try closure() } } </code></pre>
<p>In Swift 3 you can use GCDs dispatch queues to lock resources. </p> <pre><code> class MyObject { private var internalState: Int = 0 private let internalQueue: DispatchQueue = DispatchQueue(label:"LockingQueue",attributes: .serial) var state: Int { get { return internalQueue.sync { internalState } } set (newState) { internalQueue.sync { internalState = newState } } } } </code></pre>
<p><strong>Swift 3</strong> </p> <p>This code has the re-entry ability and can work with Asynchronous function calls. In this code, after someAsyncFunc() is called, another function closure on the serial queue will process but be blocked by semaphore.wait() until signal() is called. internalQueue.sync shouldn't be used as it will block the main thread if I'm not mistaken.</p> <pre><code>let internalQueue = DispatchQueue(label: "serialQueue") let semaphore = DispatchSemaphore(value: 1) internalQueue.async { self.semaphore.wait() // Critical section someAsyncFunc() { // Do some work here self.semaphore.signal() } } </code></pre> <p>objc_sync_enter/objc_sync_exit isn't a good idea without error handling.</p>