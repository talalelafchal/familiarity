What is the Swift equivalent of -[NSObject description]?
<p>In Objective-C, one can add a <code>description</code> method to their class to aid in debugging:</p> <pre><code>@implementation MyClass - (NSString *)description { return [NSString stringWithFormat:@"&lt;%@: %p, foo = %@&gt;", [self class], foo _foo]; } @end </code></pre> <p>Then in the debugger, you can do:</p> <pre><code>po fooClass &lt;MyClass: 0x12938004, foo = "bar"&gt; </code></pre> <p>What is the equivalent in Swift? Swift's REPL output can be helpful:</p> <pre><code> 1&gt; class MyClass { let foo = 42 } 2&gt; 3&gt; let x = MyClass() x: MyClass = { foo = 42 } </code></pre> <p>But I'd like to override this behavior for printing to the console:</p> <pre><code> 4&gt; println("x = \(x)") x = C11lldb_expr_07MyClass (has 1 child) </code></pre> <p>Is there a way to clean up this <code>println</code> output? I've seen the <code>Printable</code> protocol:</p> <pre><code>/// This protocol should be adopted by types that wish to customize their /// textual representation. This textual representation is used when objects /// are written to an `OutputStream`. protocol Printable { var description: String { get } } </code></pre> <p>I figured this would automatically be "seen" by <code>println</code> but it does not appear to be the case:</p> <pre><code> 1&gt; class MyClass: Printable { 2. let foo = 42 3. var description: String { get { return "MyClass, foo = \(foo)" } } 4. } 5&gt; 6&gt; let x = MyClass() x: MyClass = { foo = 42 } 7&gt; println("x = \(x)") x = C11lldb_expr_07MyClass (has 1 child) </code></pre> <p>And instead I have to explicitly call description:</p> <pre><code> 8&gt; println("x = \(x.description)") x = MyClass, foo = 42 </code></pre> <p>Is there a better way?</p>
<p>Through some experimentation I have discovered that the <code>Printable</code> and <code>DebugPrintable</code> protocols work when compiling an actual app, but not in the REPL or Playground.</p> <p><strong>Side Note</strong>: The code you wrote is correct, but in this case, you are probably looking for <code>DebugPrintable</code></p> <hr> <p>Swift has renamed these protocols to be <code>CustomStringConvertible</code> and <code>CustomDebugStringConvertible</code> - though the compiler currently helpfully tells you it's done that :)</p>
<p><strong>Example of using <code>CustomStringConvertible</code> and <code>CustomDebugStringConvertible</code> protocols in Swift:</strong></p> <p><strong>PageContentViewController.swift</strong></p> <pre><code>import UIKit class PageContentViewController: UIViewController { var pageIndex : Int = 0 override var description : String { return "**** PageContentViewController\npageIndex equals \(pageIndex) ****\n" } override var debugDescription : String { return "---- PageContentViewController\npageIndex equals \(pageIndex) ----\n" } ... } </code></pre> <p><strong>ViewController.swift</strong></p> <pre><code>import UIKit class ViewController: UIViewController { /* Called after the controller's view is loaded into memory. */ override func viewDidLoad() { super.viewDidLoad() let myPageContentViewController = self.storyboard!.instantiateViewControllerWithIdentifier("A") as! PageContentViewController print(myPageContentViewController) print(myPageContentViewController.description) print(myPageContentViewController.debugDescription) } ... } </code></pre> <p><strong>Which print out:</strong></p> <pre><code>**** PageContentViewController pageIndex equals 0 **** **** PageContentViewController pageIndex equals 0 **** ---- PageContentViewController pageIndex equals 0 ---- </code></pre> <p><strong>Note:</strong> if you have a custom class which does not inherit from any class included in <strong>UIKit</strong> or <strong>Foundation</strong> libraries, then make it inherit of <code>NSObject</code> class or make it conform to <code>CustomStringConvertible</code> and <code>CustomDebugStringConvertible</code> protocols.</p>
<p>Just use <code>CustomStringConvertible</code> and <code>var description: String { return "Some string" }</code></p> <p>works in Xcode 7.0 beta </p> <pre><code>class MyClass: CustomStringConvertible { var string: String? var description: String { //return "MyClass \(string)" return "\(self.dynamicType)" } } var myClass = MyClass() // this line outputs MyClass nil // and of course print("\(myClass)") </code></pre>
<pre><code>class SomeBaseClass: CustomStringConvertible { //private var string: String = "SomeBaseClass" var description: String { return "\(self.dynamicType)" } } class SomeSubClass: SomeBaseClass { // If needed one can override description here } var mySomeBaseClass = SomeBaseClass() // Outputs SomeBaseClass var mySomeSubClass = SomeSubClass() // Outputs SomeSubClass var myOtherBaseClass = SomeSubClass() // Outputs SomeSubClass </code></pre>
<pre><code>struct WorldPeace: CustomStringConvertible { let yearStart: Int let yearStop: Int var description: String { return "\(yearStart)-\(yearStop)" } } let wp = WorldPeace(yearStart: 2020, yearStop: 2040) print("world peace: \(wp)") // outputs: // world peace: 2020-2040 </code></pre>
<p>The answers relating to <code>CustomStringConvertible</code> are the way to go. Personally, to keep the class (or struct) definition as clean as possible, I would also separate out the description code into a separate extension:</p> <pre><code>class foo { // Just the basic foo class stuff. var bar = "Humbug!" } extension foo: CustomStringConvertible { var description: String { return bar } } let xmas = foo() print(xmas) // Prints "Humbug!" </code></pre>