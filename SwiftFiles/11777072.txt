How to set a default Value of a UIPickerView
<p>I have a problem with my UIPickerView. I have 3 values in it EU AP and NA. When I start the app EU seems to be selected but when I make a <code>NSLog(@"%@", [regions objectAtIndex:row]);</code> I only get back <code>(null)</code>, now when I touch the UIPickerView the EU value is selected and I get <code>"EU"</code> back from a NSLog.</p> <p><strong>My question is:</strong> </p> <p>How can I define a default value which is selected (not only the label) when the user only starts the app and touches nothing.</p> <p><em>Edit:</em> Here is my code to get the selected item:</p> <pre><code>#pragma mark - #pragma mark PickerView DataSource - (NSInteger)numberOfComponentsInPickerView: (UIPickerView *)pickerView { return 1; } - (NSInteger)pickerView:(UIPickerView *)pickerView numberOfRowsInComponent:(NSInteger)component { return [regions count]; } - (NSString *)pickerView:(UIPickerView *)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component { return [regions objectAtIndex:row]; } #pragma mark - #pragma mark PickerView Delegate -(void)pickerView:(UIPickerView *)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component { selectedRegion = [[NSString alloc] initWithFormat: @"%@", [regions objectAtIndex:row]]; NSLog(@"%@", selectedRegion); } </code></pre>
<p>Either you didn't set your picker to select the row (which you say you seem to have done but anyhow):</p> <pre><code>- (void)selectRow:(NSInteger)row inComponent:(NSInteger)component animated:(BOOL)animated </code></pre> <p>OR you didn't use the the following method to get the selected item from your picker</p> <pre><code>- (NSInteger)selectedRowInComponent:(NSInteger)component </code></pre> <p>This will get the selected row as Integer from your picker and do as you please with it. This should do the trick for yah. Good luck.</p> <p>Anyhow read the ref: <a href="https://developer.apple.com/library/ios/#documentation/uikit/reference/UIPickerView_Class/Reference/UIPickerView.html">https://developer.apple.com/library/ios/#documentation/uikit/reference/UIPickerView_Class/Reference/UIPickerView.html</a></p> <hr> <p>EDIT:</p> <p>An example of manually setting and getting of a selected row in a UIPickerView:</p> <p>the .h file:</p> <pre><code>#import &lt;UIKit/UIKit.h&gt; @interface ViewController : UIViewController &lt;UIPickerViewDelegate, UIPickerViewDataSource&gt; { UIPickerView *picker; NSMutableArray *source; } @property (nonatomic,retain) UIPickerView *picker; @property (nonatomic,retain) NSMutableArray *source; -(void)pressed; @end </code></pre> <p>the .m file:</p> <pre><code>#import "ViewController.h" @interface ViewController () @end @implementation ViewController @synthesize picker; @synthesize source; - (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. } - (void)viewDidUnload { [super viewDidUnload]; // Release any retained subviews of the main view. } - (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation { return YES; } - (void) viewWillAppear:(BOOL)animated { [super viewWillAppear:animated]; self.view.backgroundColor = [UIColor yellowColor]; self.source = [[NSMutableArray alloc] initWithObjects:@"EU", @"USA", @"ASIA", nil]; UIButton *pressme = [[UIButton alloc] initWithFrame:CGRectMake(20, 20, 280, 80)]; [pressme setTitle:@"Press me!!!" forState:UIControlStateNormal]; pressme.backgroundColor = [UIColor lightGrayColor]; [pressme addTarget:self action:@selector(pressed) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:pressme]; self.picker = [[UIPickerView alloc] initWithFrame:CGRectMake(20, 110, 280, 300)]; self.picker.delegate = self; self.picker.dataSource = self; [self.view addSubview:self.picker]; //This is how you manually SET(!!) a selection! [self.picker selectRow:2 inComponent:0 animated:YES]; } //logs the current selection of the picker manually -(void)pressed { //This is how you manually GET(!!) a selection int row = [self.picker selectedRowInComponent:0]; NSLog(@"%@", [source objectAtIndex:row]); } - (NSInteger)numberOfComponentsInPickerView: (UIPickerView *)pickerView { return 1; } - (NSInteger)pickerView:(UIPickerView *)pickerView numberOfRowsInComponent:(NSInteger)component { return [source count]; } - (NSString *)pickerView:(UIPickerView *)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component { return [source objectAtIndex:row]; } #pragma mark - #pragma mark PickerView Delegate -(void)pickerView:(UIPickerView *)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component { // NSLog(@"%@", [source objectAtIndex:row]); } @end </code></pre>
<p>You have to send <code>- (void)selectRow:(NSInteger)row inComponent:(NSInteger)component animated:(BOOL)animated</code> to the picker view before it appears. The documentation states that the method selectedRowInComp... will give -1, thus it is possible that the picker view is in a state with no selected row. It turns out to be in that state when created.</p>
<p>This is How to set a default Value of a UIPickerView</p> <pre><code>[self.picker selectRow:4 inComponent:0 animated:YES]; </code></pre>
<p>In normal case, you can do something like this in <strong>viewDidLoad</strong> method;</p> <blockquote> <p>[_picker selectRow:1 inComponent:0 animated:YES];</p> </blockquote> <p>In my case, I'd like to fetch data from api server and display them onto <code>UIPickerView</code> then I want the picker to select the <code>first</code> item by default.</p> <p>The UIPickerView will <strong>look like</strong> it selected the first item after it was created, but when you try to get the selected index by using <code>selectedRowInComponent</code>, you will get <code>NSNull</code>. That's because it detected nothing <strong>changed</strong> by the user (select 0 from 0 ).</p> <p>Following is my solution (in viewWillAppear, after I fetched the data)</p> <pre><code>[_picker selectRow:1 inComponent:0 animated:NO]; [_picker selectRow:0 inComponent:0 animated:NO]; </code></pre> <p>Its a bit dirty, but dont worry, the UI rendering in iOS is very fast ;)</p>
<p>I too had this problem. But apparently there is an issue of the order of method calls. You must call:</p> <pre><code>[self.picker selectRow:2 inComponent:0 animated:YES]; </code></pre> <p><strong>after</strong> calling</p> <pre><code>[self.view addSubview:self.picker]; </code></pre>
<h2>Swift solution:</h2> <p>Define an Outlet:</p> <pre><code>@IBOutlet weak var pickerView: UIPickerView! // for example </code></pre> <p>Then in your <em>viewWillAppear</em> or your <em>viewDidLoad</em>, for example, you can use the following:</p> <pre><code>pickerView.selectRow(rowMin, inComponent: 0, animated: true) pickerView.selectRow(rowSec, inComponent: 1, animated: true) </code></pre> <p>If you inspect the Swift 2.0 framework you'll see <code>.selectRow</code> defined as:</p> <pre><code>func selectRow(row: Int, inComponent component: Int, animated: Bool) </code></pre> <p><strong>option clicking</strong> .selectRow in Xcode displays the following:</p> <p><img src="https://i.stack.imgur.com/zgoGT.png" alt="enter image description here"></p>
<pre><code>For example: you populated your UIPickerView with array values, then you wanted </code></pre> <p>to select a certain array value in the first load of pickerView like "Arizona". Note that the word "Arizona" is at index 2. This how to do it :) Enjoy coding.</p> <pre><code>NSArray *countryArray =[NSArray arrayWithObjects:@"Alabama",@"Alaska",@"Arizona",@"Arkansas", nil]; UIPickerView *countryPicker=[[UIPickerView alloc]initWithFrame:self.view.bounds]; countryPicker.delegate=self; countryPicker.dataSource=self; [countryPicker selectRow:2 inComponent:0 animated:YES]; [self.view addSubview:countryPicker]; </code></pre>