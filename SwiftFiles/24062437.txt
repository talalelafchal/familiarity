Cannot form weak reference to instance of class NSTextView
<p>Using Swift only, here's my code in AppDelegate.swift:</p> <pre><code>import Cocoa class AppDelegate: NSObject, NSApplicationDelegate { @IBOutlet var window: NSWindow @IBOutlet var textField: NSTextView @IBAction func displaySomeText(AnyObject) { textField.insertText("A string...") } func applicationDidFinishLaunching(aNotification: NSNotification?) { // Insert code here to initialize your application } func applicationWillTerminate(aNotification: NSNotification?) { // Insert code here to tear down your application } } </code></pre> <p>In the interface builder, I have an object hooked up to receive input from a button, then the output goes to a text view. I'm trying to get the text view to populate with some text when I hit the button.</p> <p>I tried this with a text field as well, and didn't get the error, but got a "dong" error sound and it didn't do anything else. In Objective-C, you had to use the <code>(assign)</code> parameter to get this to work from what I understand.</p> <p>What am I doing wrong?</p>
<p>Does the "dong" error suggest a responder chain problem? What if you call <code>becomeFirstResponder</code> on the text field before inserting the text?</p>
<p>To create a weak reference user the <code>weak</code> keyword:</p> <p>example:</p> <pre><code>@IBOutlet weak var myView: UIView </code></pre> <p>In your case</p> <pre><code>@IBOutlet weak var textField: NSTextView </code></pre>
<p>Use <code>@IBOutlet var scrollView: NSScrollView</code> instead of <code>@IBOutlet var textField: NSTextView</code>.<br> Then create a property returns documentView in scrollView.</p> <pre><code>import Cocoa class AppDelegate: NSObject, NSApplicationDelegate { @IBOutlet var window: NSWindow @IBOutlet var scrollView: NSScrollView var textField: NSTextView { get { return scrollView.contentView.documentView as NSTextView } } @IBAction func displaySomeText(AnyObject) { textField.insertText("A string...") } func applicationDidFinishLaunching(aNotification: NSNotification?) { // Insert code here to initialize your application } func applicationWillTerminate(aNotification: NSNotification?) { // Insert code here to tear down your application } } </code></pre>
<p>@IBOutlet automatically makes a property weak IIRC, but weak doesn't automatically make a property optional. But it is required that a weak property be made optional, as the property could at any time be deallocated and made nil. So you have to declare your @IBOutlets as optional.</p> <pre><code>import Cocoa class AppDelegate: NSObject, NSApplicationDelegate { @IBOutlet var window: NSWindow? // Optional @IBOutlet var textField: NSTextView? @IBAction func displaySomeText(AnyObject) { textField?.insertText("A string...") // Only call the method if the object exists } func applicationDidFinishLaunching(aNotification: NSNotification?) { // Insert code here to initialize your application } func applicationWillTerminate(aNotification: NSNotification?) { // Insert code here to tear down your application } } </code></pre>
<p>I have tried to replicate what you described. I have created a new OS X app using Xcode 6 beta 7. I have dropped a button and text view in the main form.</p> <p>I think your problem is that the connection to the Text View object is not correct for some reason. To make things easier, I've connected the objects using control-drag, which adds the required code automatically. So first I've connected the Text View. To do this click on the text view object until Text View is selected. When I do this in my version of Xcode, the first time I click on the object, <em>Bordered Scroll View</em> is selected. Clicking on it again then selects <em>Clip View</em>. Finally, clicking on it again selects <em>Text View</em>. Now I control-drag from the object to the AppDelegate.swift code (It helps to display the Assistant Editor so that you have your form UI and code side-by-side).</p> <p>By doing this I get this little window:</p> <p><img src="https://i.stack.imgur.com/r5z2M.png" alt="enter image description here"></p> <p>Notice that the type is NSTextView and the storage is Weak. I've only had to add the name and click Connect. This adds the following code in AppDelegate.swift:</p> <pre><code>@IBOutlet var textField: NSTextView! </code></pre> <p>The code is almost exactly like the one you have, except for the <code>!</code> at the end of the line, which forces to unwrap the value of textField.</p> <p>Just with that, the code as you have it in your question should work.</p> <p>The other thing I would suggest is not to use <code>insertText</code>. According to Apple's documentation for <a href="https://developer.apple.com/library/prerelease/mac/documentation/Cocoa/Reference/ApplicationKit/Classes/NSTextView_Class/#//apple_ref/occ/instm/NSTextView/insertText:" rel="nofollow noreferrer">NSTextView.insertText</a>:</p> <blockquote> <p>This method is the entry point for inserting text typed by the user and is generally not suitable for other purposes. Programmatic modification of the text is best done by operating on the text storage directly.</p> </blockquote> <p>As far as I understand this, <em>programmatic modification of the text by operating on the text storage directly</em> means dealing with NSText, which NSTextView inherits from. So instead, use <a href="https://developer.apple.com/library/prerelease/mac/documentation/Cocoa/Reference/ApplicationKit/Classes/NSText_Class/index.html#//apple_ref/occ/instm/NSText/string" rel="nofollow noreferrer">NSText.string</a>. This is how the click button action looks in my code:</p> <pre><code>@IBAction func displaySomeText(sender: NSButton) { // If you want to add a new 'A string... ' every time you click the button textField.string! += "A string... " // otherwise just use //textField.string = "A string..." } </code></pre> <p>I have added the Button Action in the same way as I've added the Text View Outlet, by control-dragging, and, in this case, selecting <code>NSButton</code> as the sender, instead of leaving the default <code>AnyObject</code>.</p>
<p>You cannot store a weak reference to an <code>NSTextView</code> due to historical issues with Cocoa and AppKit. See <a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#weak-unavailable-types">details in the Clang documentation</a>. <code>NSTextView</code> is marked as <code>NS_AUTOMATED_REFCOUNT_WEAK_UNAVAILABLE</code> in NSTextView.h.</p> <p>Have you tried a Swift unowned reference instead of weak, which is kind of like Objective-C's assign (what you'd use for an <code>NSTextView</code> outlet in Objective-C)?</p>