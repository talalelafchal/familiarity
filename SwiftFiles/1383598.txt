Core Data: Quickest way to delete all instances of an entity
<p>I'm using Core Data to locally persist results from a Web Services call. The web service returns the full object model for, let's say, "Cars" - could be about 2000 of them (and I can't make the Web Service return anything less than 1 or ALL cars.</p> <p>The next time I open my application, I want to refresh the Core Data persisted copy by calling the Web Service for all Cars again, however to prevent duplicates I would need to purge all data in the local cache first.</p> <p>Is there a quicker way to purge ALL instances of a specific entity in the managed object context (e.g. all entities of type "CAR"), or do I need to query them call, then iterate through the results to delete each, then save?</p> <p>Ideally I could just say delete all where entity is Blah.</p>
<p>Why not fold in the data that you receive with the existing cache? Otherwise it's not really 'refreshing', it's 'starting again' and you might as well drop/delete the SQLLite file and start again (assuming you're not persisting other data as well).</p>
<h2>iOS 9 and later:</h2> <p>iOS 9 added a new class called <code>NSBatchDeleteRequest</code> that allows you to easily delete objects matching a predicate without having to load them all in to memory. Here's how you'd use it:</p> <h3>Swift 2</h3> <pre><code>let fetchRequest = NSFetchRequest(entityName: "Car") let deleteRequest = NSBatchDeleteRequest(fetchRequest: fetchRequest) do { try myPersistentStoreCoordinator.executeRequest(deleteRequest, withContext: myContext) } catch let error as NSError { // TODO: handle the error } </code></pre> <h3>Objective-C</h3> <pre><code>NSFetchRequest *request = [[NSFetchRequest alloc] initWithEntityName:@"Car"]; NSBatchDeleteRequest *delete = [[NSBatchDeleteRequest alloc] initWithFetchRequest:request]; NSError *deleteError = nil; [myPersistentStoreCoordinator executeRequest:delete withContext:myContext error:&amp;deleteError]; </code></pre> <p>More information about batch deletions can be found in the <a href="https://developer.apple.com/videos/wwdc/2015/?id=220" rel="nofollow noreferrer">"What's New in Core Data" session from WWDC 2015</a> (starting at ~14:10).</p> <h2>iOS 8 and earlier:</h2> <p>Fetch 'em all and delete 'em all:</p> <pre><code>NSFetchRequest *allCars = [[NSFetchRequest alloc] init]; [allCars setEntity:[NSEntityDescription entityForName:@"Car" inManagedObjectContext:myContext]]; [allCars setIncludesPropertyValues:NO]; //only fetch the managedObjectID NSError *error = nil; NSArray *cars = [myContext executeFetchRequest:allCars error:&amp;error]; [allCars release]; //error handling goes here for (NSManagedObject *car in cars) { [myContext deleteObject:car]; } NSError *saveError = nil; [myContext save:&amp;saveError]; //more error handling here </code></pre>
<p>This is a similar question to the one <a href="http://stackoverflow.com/questions/1574208/cocoa-touch-core-data-how-do-i-delete-all-objects-for-a-entity/2033955#comment-6557293">here</a> and someone suggested setting up a relationship delete rule so you only have to delete one object. So if you have or can make an entity with a to-many relationship to the cars and set the delete rule to cascade when you delete the higher entity all the cars will be deleted as well. This may save some processing time since you don't have to do the steps involved with loading ALL the cars. In a larger data set this could be absolutely necessary. </p>
<p>A little bit more cleaned and universal : Add this method :</p> <pre><code>- (void)deleteAllEntities:(NSString *)nameEntity { NSFetchRequest *fetchRequest = [[NSFetchRequest alloc] initWithEntityName:nameEntity]; [fetchRequest setIncludesPropertyValues:NO]; //only fetch the managedObjectID NSError *error; NSArray *fetchedObjects = [theContext executeFetchRequest:fetchRequest error:&amp;error]; for (NSManagedObject *object in fetchedObjects) { [theContext deleteObject:object]; } error = nil; [theContext save:&amp;error]; } </code></pre>
<p>A good answer was already posted, this is only a recommendation!</p> <p>A good way would be to just add a category to <code>NSManagedObject</code> and implement a method like I did:</p> <p>Header File (e.g. <code>NSManagedObject+Ext.h</code>)</p> <pre><code>@interface NSManagedObject (Logic) + (void) deleteAllFromEntity:(NSString*) entityName; @end </code></pre> <hr> <p>Code File: (e.g. NSManagedObject+Ext.m)</p> <pre><code>@implementation NSManagedObject (Logic) + (void) deleteAllFromEntity:(NSString *)entityName { NSManagedObjectContext *managedObjectContext = [AppDelegate managedObjectContext]; NSFetchRequest * allRecords = [[NSFetchRequest alloc] init]; [allRecords setEntity:[NSEntityDescription entityForName:entityName inManagedObjectContext:managedObjectContext]]; [allRecords setIncludesPropertyValues:NO]; NSError * error = nil; NSArray * result = [managedObjectContext executeFetchRequest:allRecords error:&amp;error]; for (NSManagedObject * profile in result) { [managedObjectContext deleteObject:profile]; } NSError *saveError = nil; [managedObjectContext save:&amp;saveError]; } @end </code></pre> <p>... the only thing you have to is to get the managedObjectContext from the app delegate, or where every you have it in ;)</p> <p>afterwards you can use it like:</p> <pre><code>[NSManagedObject deleteAllFromEntity:@"EntityName"]; </code></pre> <p>one further optimization could be that you remove the parameter for tha entityname and get the name instead from the clazzname. this would lead to the usage:</p> <pre><code>[ClazzName deleteAllFromEntity]; </code></pre> <hr> <p>a more clean impl (as category to NSManagedObjectContext):</p> <pre><code>@implementation NSManagedObjectContext (Logic) - (void) deleteAllFromEntity:(NSString *)entityName { NSFetchRequest * allRecords = [[NSFetchRequest alloc] init]; [allRecords setEntity:[NSEntityDescription entityForName:entityName inManagedObjectContext:self]]; [allRecords setIncludesPropertyValues:NO]; NSError * error = nil; NSArray * result = [self executeFetchRequest:allRecords error:&amp;error]; for (NSManagedObject * profile in result) { [self deleteObject:profile]; } NSError *saveError = nil; [self save:&amp;saveError]; } @end </code></pre> <p>The usage then:</p> <pre><code>[managedObjectContext deleteAllFromEntity:@"EntityName"]; </code></pre>
<p>if the entity contains a lot of entries the best way is like this because it saves memory </p> <pre><code> - (void)deleteAll:(NSManagedObjectContext *)managedObjectContext entityName:(NSString *)entityName { NSFetchRequest *fetchRequest = [[NSFetchRequest alloc] init]; [managedObjectContext setUndoManager:nil]; NSEntityDescription *entity = [NSEntityDescription entityForName:entityName inManagedObjectContext:managedObjectContext]; [fetchRequest setEntity:entity]; [fetchRequest setIncludesPropertyValues:NO]; [fetchRequest setFetchLimit:100]; // you can change this number if you want NSError *error; NSArray *items = [managedObjectContext executeFetchRequest:fetchRequest error:&amp;error]; while ([items count] &gt; 0) { @autoreleasepool { for (NSManagedObject *item in items) { [managedObjectContext deleteObject:item]; } if (![managedObjectContext save:&amp;error]) { NSLog(@"Error deleting %@ - error:%@",self.entityName, error); } } items = [managedObjectContext executeFetchRequest:fetchRequest error:&amp;error]; } } </code></pre>
<p><strong>Swift:</strong></p> <pre><code>let fetchRequest = NSFetchRequest() fetchRequest.entity = NSEntityDescription.entityForName(entityName, inManagedObjectContext: context) fetchRequest.includesPropertyValues = false var error:NSError? if let results = context.executeFetchRequest(fetchRequest, error: &amp;error) as? [NSManagedObject] { for result in results { context.deleteObject(result) } var error:NSError? if context.save(&amp;error) { // do something after save } else if let error = error { println(error.userInfo) } } else if let error = error { println("error: \(error)") } </code></pre>
<p><strong>For Swift 2.0:</strong></p> <pre><code>class func clearCoreData(entity:String) { let fetchRequest = NSFetchRequest() fetchRequest.entity = NSEntityDescription.entityForName(entity, inManagedObjectContext: moc!) fetchRequest.includesPropertyValues = false do { if let results = try moc!.executeFetchRequest(fetchRequest) as? [NSManagedObject] { for result in results { moc!.deleteObject(result) } try moc!.save() } } catch { LOG.debug("failed to clear core data") } } </code></pre>
<p>Extending Dave Delong's answer.</p> <p>Swift Version that takes care of iOS 9 and previous versions as well. I have also covered Error handling in this:</p> <p>let appDelegate: AppDelegate = UIApplication.sharedApplication().delegate as! AppDelegate</p> <pre><code> let fetchRequest = NSFetchRequest(entityName: "Car") if #available(iOS 9.0, *) { let delete = NSBatchDeleteRequest(fetchRequest: fetchRequest) do { try appDelegate.persistentStoreCoordinator.executeRequest(delete, withContext: appDelegate.managedObjectContext) } catch let error as NSError { print("Error occured while deleting: \(error)") } } else { // Fallback on earlier versions let carRequest = NSFetchRequest() carRequest.entity = NSEntityDescription.entityForName("Cars", inManagedObjectContext: appDelegate.managedObjectContext) carRequest.includesPropertyValues = false do { let cars: NSArray = try appDelegate.managedObjectContext.executeFetchRequest(carRequest) for car in cars { appDelegate.managedObjectContext.delete(car) } try appDelegate.managedObjectContext.save() } catch let error as NSError { print("Error occured while fetching or saving: \(error)") } } </code></pre>
<p>Dave Delongs's Swift 2.0 answer was crashing for me (in iOS 9)</p> <p>But this worked:</p> <pre><code>let fetchRequest = NSFetchRequest(entityName: "Car") let deleteRequest = NSBatchDeleteRequest(fetchRequest: fetchRequest) do { try managedObjectContext.executeRequest(deleteRequest) try managedObjectContext.save() } catch let error as NSError { // Handle error } </code></pre>
<p><strong>In Swift 2.0:</strong></p> <pre><code>func deleteAllData(entity: String) { let appDelegate = UIApplication.sharedApplication().delegate as! AppDelegate let managedContext = appDelegate.managedObjectContext let fetchRequest = NSFetchRequest(entityName: entity) fetchRequest.returnsObjectsAsFaults = false do { let results = try managedContext.executeFetchRequest(fetchRequest) for managedObject in results { let managedObjectData:NSManagedObject = managedObject as! NSManagedObject managedContext.deleteObject(managedObjectData) } } catch let error as NSError { print("Detele all data in \(entity) error : \(error) \(error.userInfo)") } } </code></pre>
<p><strong>iOS 9.0 and Later :</strong></p> <p>NSBatchDeleteRequest is used to delete records in core data. It works very fast and takes less time to delete all records from an entity. It requires NSFetchRequest in argument. If you want to delete all records from an entity , you can use it and it works for me. </p> <p>let manageObject:NSManagedObjectContext = appDelegateObject.managedObjectContext</p> <pre><code>let fetchRequest = NSFetchRequest(entityName: “EnityName”) let deleteRequest = NSBatchDeleteRequest(fetchRequest: fetchRequest) let persistCor:NSPersistentStoreCoordinator = appDelegateObject.persistentObject do { try persistCor.executeRequest(deleteRequest, withContext: manageObject) try manageObject.save() } catch { } </code></pre>