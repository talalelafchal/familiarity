How to recovery dataSource after disposed from a catchError
I have one UITableView populated by reactive viewmodel using RxSwift, pagination and refresh are working well. The viewModel.dataSource() is consuming my API and sometime I can receive a empty result parsed as error type. I want to catch this error and create an empty state, hiding tableview and showing a emptyViewState. I thought I could make it with the catchError. My problem is after catchError, the dataSource is disposed and I couldn't be able to recovery the empty state and repopulated the tableview, I tried to recreate the dataSource calling self.bindDataSource() but I getting fatal error. There is a way to avoid dataSource disposed ? How can I reconnect / rebuild the dataSource to recovery from the empty state ? class MyViewControl: UIViewController { fileprivate let disposeBag = DisposeBag() fileprivate let viewModel = ViewModel() let dataSource = SearchViewModel.SearchDataSource() @IBOutlet fileprivate weak var tableView: UITableView! @IBOutlet weak var emptyStateView: UIView! override func viewDidLoad() { super.viewDidLoad() // When I disable tableview, can see a hidden view with empty state message and one button viewModel.isTableViewHidden .bindTo(tableView.rx.isHidden) .addDisposableTo(disposeBag) self.setupTableView() } fun setupTableView() { // ... setup table view self.bindDataSource() } fileprivate func bindDataSource() { // Bind dataSource from search to UITableView viewModel.dataSource() .debug("[DEBUG] Loading Search Tableview ") .bindTo( tableView.rx.items(dataSource: dataSource) ) .addDisposableTo( disposeBag ) } @IBAction fileprivate func emptyStateAction(_ sender: UIButton) { // Do something and try to recreate the bindDataSource self.bindDataSource() } } class SearchViewModel { private let disposeBag = DisposeBag() typealias SearchDataSource = RxTableViewSectionedReloadDataSource<PaginationStatus<WorkerEntity>> let isTableViewHidden = BehaviorSubject<Bool>(value: false) // Controls to refresh and paging tableview let refreshTrigger = BehaviorSubject<Void>(value:()) let nextPageTrigger = PublishSubject<Void>() // Others things happing herer func dataSource() -> Observable<[PaginationStatus<WorkerEntity>]> { return self.refreshTrigger.debug("[DEBUG] Refreshing dataSource") .flatMapLatest { [unowned self] _ -> Observable<[PaginationStatus<WorkerEntity>]> in // Access the API and return dataSource } .catchError { [unowned self] error -> Observable<[PaginationStatus<WorkerEntity>]> in // Hidden the tableview self.isTableViewHidden.onNext(true) // Do others things return Observable.of([PaginationStatus.sectionEmpty]) } } }
when you bindDataSource() you dont reinitialised your datasource, so you bind it to a error event. You need to init it, to bind it again. And you might want to remove your binding too let disposeBagTableView = DisposeBag() //remove let dataSource = SearchViewModel.SearchDataSource() fileprivate func bindDataSource() { // Bind dataSource from search to UITableView disposeBagTableView = DisposeBag() SearchViewModel.SearchDataSource() .debug("[DEBUG] Loading Search Tableview ") .bindTo( tableView.rx.items(dataSource: dataSource) ) .addDisposableTo( disposeBagTableView ) }