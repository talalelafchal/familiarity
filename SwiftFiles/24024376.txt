Passing an array to a function with variable number of args in Swift
<p>In <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/GuidedTour.html#//apple_ref/doc/uid/TP40014097-CH2-XID_1">The Swift Programming Language</a>, it says:</p> <blockquote> <p>Functions can also take a variable number of arguments, collecting them into an array.</p> <pre><code> func sumOf(numbers: Int...) -&gt; Int { ... } </code></pre> </blockquote> <p>When I call such a function with a comma-separated list of numbers (`sumOf(1, 2, 3, 4), they are made available as an array inside the function.</p> <p>Question: what if I already have an array of numbers that I want to pass to this function?</p> <pre><code>let numbers = [1, 2, 3, 4] sumOf(numbers) </code></pre> <p>This fails with a compiler error, “Could not find an overload for '__conversion' that accepts the supplied arguments”. Is there a way to turn an existing array into a list of elements that I can pass to a variadic function?</p>
<p>You can use a helper function as such:</p> <pre><code>func sumOf (numbers : [Int]) -&gt; Int { return numbers.reduce(0, combine: +) } func sumOf (numbers : Int...) -&gt; Int { return sumArray (numbers) } </code></pre>
<p><a href="https://devforums.apple.com/message/970958">Splatting is not in the language yet</a>, as confirmed by the devs. Workaround for now is to use an overload or wait if you cannot add overloads.</p>
<p>Here's a work around that I found. I know it's not exactly what you want, but it seems to be working.</p> <p>Step 1: Declare the function you'd like with an array instead of variadic arguments:</p> <pre><code>func sumOf(numbers: [Int]) -&gt; Int { var total = 0 for i in numbers { total += i } return total } </code></pre> <p>Step 2: Call this from within your variadic function:</p> <pre><code>func sumOf(numbers: Int...) -&gt; Int { return sumOf(numbers) } </code></pre> <p>Step 3: Call Either Way:</p> <pre><code>var variadicSum = sumOf(1, 2, 3, 4, 5) var arraySum = sumOf([1, 2, 3, 4, 5]) </code></pre> <p>It seems strange, but it is working in my tests. Let me know if this causes unforeseen problems for anyone. Swift seems to be able to separate the difference between the two calls with the same function name.</p> <p>Also, with this method if Apple updates the language as @manojid's answer suggests, you'll only need to update these functions. Otherwise, you'll have to go through and do a lot of renaming.</p>
<p>I know this response does not answer your exact question, but I feel its worth noting. I too was starting to play with Swift and immediately ran into a similar question. Manojlds answer is better for your question, I agree, but again, another workaround I came up with. I do happen to like Logan's better too.</p> <p>In my case I just wanted to pass an array:</p> <pre><code>func sumOf(numbers: Array&lt;Int&gt;) -&gt; Int { var sum = 0 for number in numbers { sum += number } return sum } var someNums = [8,7,2,9,12] sumOf(someNums) sumOf([10, 15, 20]) </code></pre> <p>Just wanted to share, in case anyone else was thinking like me. Most of the time I would prefer pass the array like this, but I don't think the "Swiftly" yet. :)</p>
<p>You can cast the function:</p> <pre><code>typealias Function = [Int] -&gt; Int let sumOfArray = unsafeBitCast(sumOf, Function.self) sumOfArray([1, 2, 3]) </code></pre>
<p>I use <em>inout</em> for passing array to function.</p> <p>obstacleUnlockArray is my public variable. I have multiple public variables typically.</p> <pre><code>unlock(unlockArray: &amp;obstacleUnlockArray) func unlock(unlockArray:inout [Int]) { // modify array unlockArray.append(1) } </code></pre>