How passing a protocol as parameter in Swift
<p>In Objective-C, I know how passing a <code>protocol</code> as parameter:</p> <pre><code>- (void)MyMethod:(Protocol *)myparameter </code></pre> <p>But in Swift there is no more <code>Protocol</code> type.</p> <p>How can I pass a protocol as parameter without knowing which is ?</p>
<p>Here is what I have tried:</p> <pre><code>@objc protocol Walker { func walk() } @objc protocol Runner { func run() } @objc class Zombie : Walker { func walk () { println("Brains...") } } @objc class Survivor : Runner { func run() { println("Aaaah, zombies!") } } func classesConformingToProtocol(proto:Protocol) -&gt; AnyClass[] { let availableClasses : AnyClass[] = [ Zombie.self, Survivor.self ] var conformingClasses = Array&lt;AnyClass&gt;() for myClass : AnyClass in availableClasses { if myClass.conformsToProtocol(proto) { conformingClasses.append(myClass) } } return conformingClasses } // This does not work let walkers = classesConformingToProtocol(Walker.self) let runners = classesConformingToProtocol(Runner.self) </code></pre> <p>I have been unable to convert Swift's <code>Metatype</code> information into a <code>Protocol</code> object.</p>
<p>Worked out a way today (Xcode 6.1):</p> <p>Firstly, the protocol must be marked as @objc for any checking to work. Then use an "if let" cast to check for conformance.</p> <pre><code>@objc protocol MyProtocol { var protocolValue: Int { get set } } if let conformingObject = someObject as? MyProtocol { // conformingObject is now someObject cast to MyProtocol conformingObject.protocolValue = 3 } </code></pre>
<p>In one of your comments you say:</p> <p>"I want create a method which return an array of type of class which implements a desired protocol."</p> <p>Have you tried something like the following:</p> <pre><code>//notice the use of @objc here @objc protocol AlertProtocol { func getMyName()-&gt;String } class Class1 : AlertProtocol { let name = "Object 1" func getMyName() -&gt; String { return name } } class Class2 : AlertProtocol { let name = "Object 2" func getMyName() -&gt; String { return name } } //borrowing from and refactoring siLo's answer func classesConformingToProtocol(proto:Protocol) -&gt; [AnyClass] { let availableClasses : [AnyClass] = [ Class1.self, Class2.self ] var conformingClasses = Array&lt;AnyClass&gt;() for myClass : AnyClass in availableClasses { if myClass.conformsToProtocol(proto) { conformingClasses.append(myClass) } } return conformingClasses } </code></pre> <p>Then use the above structure like this:</p> <pre><code>let classes = classesConformingToProtocol(AlertProtocol.self) </code></pre> <p>The tricky part that does the work is the "@objc" that exposes the protocol to the objective c runtime and allows us to pass any "Protocol Type" as a parameter.</p> <p>Probably at some point in the future we will be able to do this in a "pure" Swift way.</p>
<p>In swift 2.0, I use it like this before:</p> <p><em><code>classA.conformsToProtocol(XXXProtocol.self as! Protocol)</code></em></p> <p>It doesn't works fine...</p> <p>Look the definition of <code>Protocol:</code></p> <pre><code>// All methods of class Protocol are unavailable. // Use the functions in objc/runtime.h instead. @available(iOS 2.0, *) public class Protocol { } </code></pre> <p>All are unavailable...and I don't know which to use instead in objc/runtime.h </p> <p>So I have to use this method:</p> <pre><code>if ClassA is protocol&lt;XXXProtocol&gt; { // do something } </code></pre> <p>Currently, it works...</p>