Does Swift have access modifiers?
<p>In Objective-C instance data can be <code>public</code>, <code>protected</code> or <code>private</code>. For example:</p> <pre><code>@interface Foo : NSObject { @public int x; @protected: int y; @private: int z; } -(int) apple; -(int) pear; -(int) banana; @end </code></pre> <p>I haven't found any mention of access modifiers in the Swift reference. Is it possible to limit the visibility of data in Swift?</p>
<p>No, it's not possible. There aren't any private/protected methods and variables at all.</p> <p>Everything is public.</p>
<p>The <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/zzSummaryOfTheGrammar.html" rel="nofollow">language grammar</a> does not have the keywords 'public', 'private' or 'protected'. This would suggest everything is public. Of course, there could be some alternative method of specifying access modifiers without those keywords but I couldn't find it in the language reference.</p>
<p>As far as I can tell, there are no keywords 'public', 'private' or 'protected'. This would suggest everything is public.</p> <p>However Apple may be expecting people to use “<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-XID_345">protocols</a>” (called interfaces by the rest of the world) and the <a href="http://en.wikipedia.org/wiki/Factory_%28object-oriented_programming%29">factory design pattern</a> to hide details of the implementation type. </p> <p>This is often a good design pattern to use anyway; as it lets you change your <strong>implementation</strong> class hierarchy, while keeping the <strong>logical</strong> type system the same.</p>
<p><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html" rel="nofollow noreferrer">As of <strong>Swift 3.0.1</strong>, there are <strong>4 levels of access</strong></a>, described below from the highest (least restrictive) to the lowest (most restrictive).</p> <hr> <h3>1. <code>open</code> and <code>public</code></h3> <p>Enable an entity to be used outside the defining module (target). You typically use <code>open</code> or <code>public</code> access when specifying the public interface to a framework.</p> <p>However, <strong><code>open</code> access applies only to classes and class members</strong>, and it differs from <code>public</code> access as follows:</p> <ul> <li><code>public</code> classes and class members can only be subclassed and overridden within the defining module (target).</li> <li><code>open</code> classes and class members can be subclassed and overridden both within and outside the defining module (target).</li> </ul> <p></p> <pre><code>// First.framework – A.swift open class A {} </code></pre> <p></p> <pre><code>// First.framework – B.swift public class B: A {} // ok </code></pre> <p></p> <pre><code>// Second.framework – C.swift import First internal class C: A {} // ok </code></pre> <p></p> <pre><code>// Second.framework – D.swift import First internal class D: B {} // error: B cannot be subclassed </code></pre> <h3>2. <code>internal</code></h3> <p>Enables an entity to be used withing the defining module (target). You typically use <code>internal</code> access when defining an app’s or a framework’s internal structure.</p> <pre><code>// First.framework – A.swift internal struct A {} </code></pre> <p></p> <pre><code>// First.framework – B.swift A() // ok </code></pre> <p></p> <pre><code>// Second.framework – C.swift import First A() // error: A is unavailable </code></pre> <h3>3. <code>fileprivate</code></h3> <p>Restricts the use of an entity to its defining source file. You typically use <code>fileprivate</code> access to hide the implementation details of a specific piece of functionality when those details are used within an entire file.</p> <pre><code>// First.framework – A.swift internal struct A { fileprivate static let x: Int } A.x // ok </code></pre> <p></p> <pre><code>// First.framework – B.swift A.x // error: x is not available </code></pre> <h3>4. <code>private</code></h3> <p>Restricts the use of an entity to its enclosing declaration. You typically use <code>private</code> access to hide the implementation details of a specific piece of functionality when those details are used only within a single declaration.</p> <pre><code>// First.framework – A.swift internal struct A { private static let x: Int internal static func doSomethingWithX() { x // ok } } A.x // error: x is unavailable </code></pre>
<p>Using a combination of protocols, closures, and nested/inner classes, it's possible to use something along the lines of the module pattern to hide information in Swift right now. It's not super clean or nice to read but it does work.</p> <p>Example:</p> <pre><code>protocol HuhThing { var huh: Int { get set } } func HuhMaker() -&gt; HuhThing { class InnerHuh: HuhThing { var innerVal: Int = 0 var huh: Int { get { return mysteriousMath(innerVal) } set { innerVal = newValue / 2 } } func mysteriousMath(number: Int) -&gt; Int { return number * 3 + 2 } } return InnerHuh() } HuhMaker() var h = HuhMaker() h.huh // 2 h.huh = 32 h.huh // 50 h.huh = 39 h.huh // 59 </code></pre> <p>innerVal and mysteriousMath are hidden here from outside use and attempting to dig your way into the object should result in an error.</p> <p>I'm only part of the way through my reading of the Swift docs so if there's a flaw here please point it out, would love to know.</p>
<p>One of the options you could use is to wrap the instance creation into a function and supply the appropriate getters and setters in a constructor:</p> <pre><code>class Counter { let inc: () -&gt; Int let dec: () -&gt; Int init(start: Int) { var n = start inc = { ++n } dec = { --n } } } let c = Counter(start: 10) c.inc() // 11 c.inc() // 12 c.dec() // 11 </code></pre>
<p>When one talks about making a "private method" in Swift or ObjC (or ruby or java or…) those methods aren't <em>really</em> private. There's no actual access control around them. Any language that offers even a little introspection lets developers get to those values from outside the class if they really want to.</p> <p>So what we're really talking about here is a way to define a public-facing interface that merely <em>presents</em> the functionality we want it to, and "hides" the rest that we consider "private".</p> <p>The Swift mechanism for declaring interfaces is the <code>protocol</code>, and it can be used for this purpose.</p> <pre><code>protocol MyClass { var publicProperty:Int {get set} func publicMethod(foo:String)-&gt;String } class MyClassImplementation : MyClass { var publicProperty:Int = 5 var privateProperty:Int = 8 func publicMethod(foo:String)-&gt;String{ return privateMethod(foo) } func privateMethod(foo:String)-&gt;String{ return "Hello \(foo)" } } </code></pre> <p>Remember, protocols are first-class types and can be used anyplace a type can. <em>And</em>, when used this way, they only expose their own interfaces, not those of the implementing type.</p> <p>Thus, as long as you use <code>MyClass</code> instead of <code>MyClassImplementation</code> in your parameter types, etc. it should all just work:</p> <pre><code>func breakingAndEntering(foo:MyClass)-&gt;String{ return foo.privateMethod() //ERROR: 'MyClass' does not have a member named 'privateMethod' } </code></pre> <p>There are some cases of direct assignment where you have to be explicit with type instead of relying on Swift to infer it, but that hardly seems a deal breaker:</p> <pre><code>var myClass:MyClass = MyClassImplementation() </code></pre> <p>Using protocols this way is semantic, reasonably concise, and to my eyes looks a lot like the Class Extentions we've been using for this purpose in ObjC.</p>
<p>Now in beta 4, they've added access modifiers to Swift.</p> <p>from <a href="http://adcdownload.apple.com//Developer_Tools/xcode_6_beta_4_o2p8fz/xcode_6_beta_4_release_notes.pdf" rel="nofollow">Xcode 6 beta 4 realese notes</a>:</p> <blockquote> <p>Swift access control has three access levels:</p> <ul> <li><code>private</code> entities can only be accessed from within the source ﬁle where they are deﬁned.</li> <li><code>internal</code> entities can be accessed anywhere within the target where they are deﬁned.</li> <li><code>public</code> entities can be accessed from anywhere within the target and from any other context that imports the current target’s module.</li> </ul> <p>By default, most entities in a source ﬁle have internal access. This allows application developers to largely ignore access control while allowing framework developers full control over a framework's API.</p> </blockquote>
<p>As of Xcode 6 beta 4, Swift has access modifiers. From the release notes:</p> <blockquote> <p>Swift access control has three access levels:</p> <ul> <li><strong>private</strong> entities can only be accessed from within the source file where they are defined.</li> <li><strong>internal</strong> entities can be accessed anywhere within the target where they are defined.</li> <li><strong>public</strong> entities can be accessed from anywhere within the target and from any other context that imports the current target’s module.</li> </ul> </blockquote> <p>The implicit default is <code>internal</code>, so within an application target you can leave access modifiers off except where you want to be more restrictive. In a framework target (e.g. if you're embedding a framework to share code between an app and an sharing or Today view extension), use <code>public</code> to designate API you want to expose to clients of your framework.</p>
<p>Hopefully to save some time for those who want something akin to protected methods:</p> <p>As per other answers, swift now provides the 'private' modifier - which is defined file-wise rather than class-wise such as those in Java or C# for instance. This means that if you want protected methods, you can do it with swift private methods <em>if they are in the same file</em></p> <ol> <li>Create a base class to hold 'protected' methods (actually private)</li> <li>Subclass this class to use the same methods</li> <li>In other files you cannot access the base class methods, even when you subclass either</li> </ol> <p>e.g. File 1:</p> <pre><code>class BaseClass { private func protectedMethod() { } } class SubClass : BaseClass { func publicMethod() { self.protectedMethod() //this is ok as they are in same file } } </code></pre> <p>File 2:</p> <pre><code>func test() { var a = BaseClass() a.protectedMethod() //ERROR var b = SubClass() b.protectedMethod() //ERROR } class SubClass2 : BaseClass { func publicMethod() { self.protectedMethod() //ERROR } </code></pre> <p>}</p>
<p>In Beta 6, the documentation states that there are three different access modifiers:</p> <ul> <li>Public</li> <li>Internal</li> <li>Private</li> </ul> <p>And these three apply to Classes, Protocols, functions and properties.</p> <pre><code>public var somePublicVariable = 0 internal let someInternalConstant = 0 private func somePrivateFunction() {} </code></pre> <p>For more, check <em><a href="https://developer.apple.com/library/prerelease/mac/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html" rel="nofollow">Access Control</a></em>.</p>
<h1>Access control mechanisms as <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html#//apple_ref/doc/uid/TP40014097-CH41-ID5" rel="nofollow">introduced in Xcode 6</a>:</h1> <blockquote> <p>Swift provides three different access levels for entities within your code. These access levels are relative to the source file in which an entity is defined, and also relative to the module that source file belongs to.</p> <ul> <li><em>Public access</em> enables entities to be used within any source file from their defining module, and also in a source file from another module that imports the defining module. You typically use public access when specifying the public interface to a framework.</li> <li><em>Internal access</em> enables entities to be used within any source file from their defining module, but not in any source file outside of that module. You typically use internal access when defining an app’s or a framework’s internal structure.</li> <li><em>Private access</em> restricts the use of an entity to its own defining source file. Use private access to hide the implementation details of a specific piece of functionality.</li> </ul> <p>Public access is the highest (least restrictive) access level and private access is the lowest (or most restrictive) access level.</p> </blockquote> <p>Default accecss it <em>internal</em>, and does as such not need to be specified. Also note that the <em>private</em> specifier does <strong>not</strong> work on the class level, but on the source file level. This means that to get parts of a class really private you need to separate into a file of its own. This also introduces some interesting cases with regards to unit testing...</p> <p>Another point to me made, which is commented upon in the link above, is that you can't 'upgrade' the access level. If you subclass something, you can restrict it more, but not the other way around. </p> <p>This last bit also affects functions, tuples and surely other stuff in the way that if i.e. a function uses a <em>private</em> class, then it's not valid to have the function <em>internal</em> or <em>public</em>, as they might not have access to the <em>private</em> class. This results in a compiler warning, and you need to redeclare the function as a <em>private</em> function.</p>
<p><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html#//apple_ref/doc/uid/TP40014097-CH41-ID3" rel="nofollow">https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html#//apple_ref/doc/uid/TP40014097-CH41-ID3</a></p> <p>STARTING SWIFT 2.2 ;) </p> <ul> <li>Public </li> <li>Internal</li> <li>Private </li> </ul> <p>By default Internal</p>
<p><strong>Swift 3.0 provides five different access controls:</strong></p> <ol> <li>open </li> <li>public</li> <li>internal </li> <li>fileprivate </li> <li>private</li> </ol> <blockquote> <p><strong>Open</strong> access and <strong>public</strong> access enable entities to be used within any source file from their defining module, and also in a source file from another module that imports the defining module. You typically use open or public access when specifying the public interface to a framework. </p> <p><strong>Internal</strong> access enables entities to be used within any source file from their defining module, but not in any source file outside of that module. You typically use internal access when defining an app’s or a framework’s internal structure.</p> <p><strong>File-private</strong> access restricts the use of an entity to its own defining source file. Use file-private access to hide the implementation details of a specific piece of functionality when those details are used within an entire file.</p> <p><strong>Private</strong> access restricts the use of an entity to the enclosing declaration. Use private access to hide the implementation details of a specific piece of functionality when those details are used only within a single declaration.</p> <p><strong><em>Open</strong> access is the highest (least restrictive) access level and <strong>private</strong> access is the lowest (most restrictive) access level.</em></p> </blockquote> <p><strong>Default Access Levels</strong></p> <p>All entities in your code (with a few specific exceptions) have a default access level of internal if you do not specify an explicit access level yourself. As a result, in many cases you do not need to specify an explicit access level in your code.</p> <p><strong>The release note on the topic:</strong></p> <blockquote> <p>Classes declared as public can no longer be subclassed outside of their defining module, and methods declared as public can no longer be overridden outside of their defining module. To allow a class to be externally subclassed or a method to be externally overridden, declare them as open, which is a new access level beyond public. Imported Objective-C classes and methods are now all imported as open rather than public. Unit tests that import a module using an @testable import will still be allowed to subclass public or internal classes as well as override public or internal methods. (SE-0117)</p> </blockquote> <p>More information &amp; details : <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html" rel="nofollow">The Swift Programming Language (Access Control)</a></p>
<p><strong>Note: This answer is updated for Swift 3</strong></p> <p>Referring to Apple's documentation: <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html" rel="nofollow">https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html</a></p> <p>Swift 3 has 5 Access Controls:</p> <ul> <li><p><em><strong>open</strong></em> and <em><strong>public</strong></em>: can be accessed from their module's entities and any module's entities that imports the defining module.</p></li> <li><p><em><strong>internal</strong></em>: can only be accessed from their module's entities. It is the default access level.</p></li> <li><p><em><strong>fileprivate</strong></em> and <em><strong>private</strong></em>: can only be accessed in limited within a limited scope where you define them.</p></li> </ul> <p>And now, you might ask:</p> <ul> <li>What is the difference between "<em><strong>open</strong></em>" and "<em><strong>public</strong></em>"?</li> </ul> <p><strong>open</strong> is the same as public in previous versions of Swift, they allow classes from other modules to use and inherit them, i.e: they can be subclassed from other modules. Also, they allow members from other modules to use and override them. The same logic goes for their modules.</p> <p><strong>public</strong> allow classes from other module to use them, but NOT to inherit them, i.e: they CANNOT be subclassed from other modules. Also, they allow members from other modules to use them, but NOT to override them. For their modules, they have the same open's logic (they allow classes to use and inherit them; They allow members to use and override them).</p> <ul> <li>What is the difference between "<em><strong>fileprivate</strong></em>" and "<em><strong>private</strong></em>"?</li> </ul> <p><strong>fileprivate</strong> can be accessed from the their entire files.</p> <p><strong>private</strong> can only be accessed from their single declaration.</p> <p>for example:</p> <pre><code>// Declaring "A" class that has the two types of "private" and "fileprivate": class A { private var aPrivate: String? fileprivate var aFileprivate: String? func accessMySelf() { // this works fine self.aPrivate = "" self.aFileprivate = "" } } // Declaring "B" for checking the abiltiy of accessing "A" class: class B { func accessA() { // create an instance of "A" class let aObject = A() // Error! this is NOT accessable... aObject.aPrivate = "I CANNOT set a value for it!" // this works fine aObject.aFileprivate = "I CAN set a value for it!" } } </code></pre> <p>For more information, don't forget to check the Apple's documentation.</p>
<p><strong>Swift 3</strong> brought a lot of change including the access levels of instance variables and methods. Swift 3 now has a minimum of 4 access levels:</p> <p><strong>private</strong> : entities can only be accessed from within the scope (struct, class, …) where they were defined <strong>-> that means also, that from an extension of a class you don't have access to a var of the extended class</strong></p> <p><strong>fileprivate</strong> : entities can only be accessed from within the source file where they are defined. <strong>internal</strong> : entities can be accessed anywhere within the target where they are defined. <strong>public</strong> entities can be accessed from anywhere within the target and from any other context that imports the current target’s module.</p> <p><strong>Converting to Swift 3</strong>: The default solution changing “private” to “fileprivate” is appropriate in most cases, because the meaning of “private” in swift &lt; 3.0 was like “fileprivate” in Swift >= 3.0</p> <p><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html" rel="nofollow">Apple documentation</a></p>