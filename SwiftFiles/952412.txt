UIScrollView scroll to bottom programmatically
<p>How can I make a <code>UIScrollView</code> scroll to the bottom within my code? Or in a more generic way, to any point of a subview?</p>
<p>You can use the UIScrollView's <code>setContentOffset:animated:</code> function to scroll to any part of the content view. Here's some code that would scroll to the bottom, assuming your scrollView is <code>self.scrollView</code>:</p> <pre><code>CGPoint bottomOffset = CGPointMake(0, self.scrollView.contentSize.height - self.scrollView.bounds.size.height); [self.scrollView setContentOffset:bottomOffset animated:YES]; </code></pre> <p>Hope that helps!</p>
<p>I also found another useful way of doing this in the case you are using a UITableview (which is a subclass of UIScrollView):</p> <pre><code>[(UITableView *)self.view scrollToRowAtIndexPath:scrollIndexPath atScrollPosition:UITableViewScrollPositionBottom animated:YES]; </code></pre>
<p>Didn't work for me, when I tried to use it in <code>UITableViewController</code> on <code>self.tableView</code> <code>(iOS 4.1)</code>, after adding <code>footerView</code>. It scrolls out of the borders, showing black screen.</p> <p>Alternative solution:</p> <pre><code> CGFloat height = self.tableView.contentSize.height; [self.tableView setTableFooterView: myFooterView]; [self.tableView reloadData]; CGFloat delta = self.tableView.contentSize.height - height; CGPoint offset = [self.tableView contentOffset]; offset.y += delta; [self.tableView setContentOffset: offset animated: YES]; </code></pre>
<p>valdyr, hope this will help you:</p> <pre><code>CGPoint bottomOffset = CGPointMake(0, [textView contentSize].height - textView.frame.size.height); if (bottomOffset.y &gt; 0) [textView setContentOffset: bottomOffset animated: YES]; </code></pre>
<p>Setting the content offset to the height of the content size is wrong: it scrolls the bottom of the content to the <em>top</em> of the scroll view, and thus out of sight.</p> <p>The correct solution is to scroll the bottom of the content to the <em>bottom</em> of the scroll view, like this (<code>sv</code> is the UIScrollView):</p> <pre><code>CGSize csz = sv.contentSize; CGSize bsz = sv.bounds.size; if (sv.contentOffset.y + bsz.height &gt; csz.height) { [sv setContentOffset:CGPointMake(sv.contentOffset.x, csz.height - bsz.height) animated:YES]; } </code></pre>
<p>With an (optional) footerView and contentInset, the solution is:</p> <pre><code>CGPoint bottomOffset = CGPointMake(0, _tableView.contentSize.height - tableView.frame.size.height + _tableView.contentInset.bottom); if (bottomOffset.y &gt; 0) [_tableView setContentOffset: bottomOffset animated: YES]; </code></pre>
<p>Scroll To Top</p> <pre><code>- CGPoint topOffset = CGPointMake(0, 0); - [scrollView setContentOffset:topOffset animated:YES]; </code></pre> <p>Scroll To Bottom</p> <pre><code>- CGPoint bottomOffset = CGPointMake(0, scrollView.contentSize.height - self.scrollView.bounds.size.height); - [scrollView setContentOffset:bottomOffset animated:YES]; </code></pre>
<p>Category to the rescue!</p> <p>Add this to a shared utility header somewhere:</p> <pre><code>@interface UIScrollView (ScrollToBottom) - (void)scrollToBottomAnimated:(BOOL)animated; @end </code></pre> <p>And then to that utility implementation:</p> <pre><code>@implementation UIScrollView(ScrollToBottom) - (void)scrollToBottomAnimated:(BOOL)animated { CGPoint bottomOffset = CGPointMake(0, self.contentSize.height - self.bounds.size.height); [self setContentOffset:bottomOffset animated:animated]; } @end </code></pre> <p>Then Implement it wherever you like, for instance:</p> <pre><code>[[myWebView scrollView] scrollToBottomAnimated:YES]; </code></pre>
<p>A good way to ensure the bottom of your content is visible is to use the formula:</p> <pre><code>contentOffsetY = MIN(0, contentHeight - boundsHeight) </code></pre> <p>This ensures the bottom edge of your content is always at or above the bottom edge of the view. The <code>MIN(0, ...)</code> is required because <code>UITableView</code> (and probably <code>UIScrollView</code>) ensures <code>contentOffsetY &gt;= 0</code> when the user tries to scroll by visibly snapping <code>contentOffsetY = 0</code>. This looks pretty weird to the user.</p> <p>The code to implement this is:</p> <pre><code>UIScrollView scrollView = ...; CGSize contentSize = scrollView.contentSize; CGSize boundsSize = scrollView.bounds.size; if (contentSize.height &gt; boundsSize.height) { CGPoint contentOffset = scrollView.contentOffset; contentOffset.y = contentSize.height - boundsSize.height; [scrollView setContentOffset:contentOffset animated:YES]; } </code></pre>
<p>Just an enhancement to the existing answer.</p> <pre><code>CGPoint bottomOffset = CGPointMake(0, self.scrollView.contentSize.height - self.scrollView.bounds.size.height + self.scrollView.contentInset.bottom); [self.scrollView setContentOffset:bottomOffset animated:YES]; </code></pre> <p>It takes care of the bottom inset as well (in case you're using that to adjust your scroll view when the keyboard is visible)</p>
<p>If you don't need animation, this works:</p> <pre><code>[self.scrollView setContentOffset:CGPointMake(0, CGFLOAT_MAX) animated:NO]; </code></pre>
<pre><code>CGFloat yOffset = scrollView.contentOffset.y; CGFloat height = scrollView.frame.size.height; CGFloat contentHeight = scrollView.contentSize.height; CGFloat distance = (contentHeight - height) - yOffset; if(distance &lt; 0) { return ; } CGPoint offset = scrollView.contentOffset; offset.y += distance; [scrollView setContentOffset:offset animated:YES]; </code></pre>
<p>Simplest Solution:</p> <pre><code>[scrollview scrollRectToVisible:CGRectMake(scrollview.contentSize.width - 1,scrollview.contentSize.height - 1, 1, 1) animated:YES]; </code></pre>
<p>While <code>Matt</code> solution seems correct to me you need to take in account also the collection view inset if there is one that has been set-up.</p> <p>The adapted code will be:</p> <pre><code>CGSize csz = sv.contentSize; CGSize bsz = sv.bounds.size; NSInteger bottomInset = sv.contentInset.bottom; if (sv.contentOffset.y + bsz.height + bottomInset &gt; csz.height) { [sv setContentOffset:CGPointMake(sv.contentOffset.x, csz.height - bsz.height + bottomInset) animated:YES]; } </code></pre>
<p>Swift version of the accepted answer for easy copy pasting: </p> <pre><code>let bottomOffset = CGPoint(x: 0, y: scrollView.contentSize.height - scrollView.bounds.size.height) scrollView.setContentOffset(bottomOffset, animated: true) </code></pre>
<p>I found that <code>contentSize</code> doesn't really reflect the actual size of the text, so when trying to scroll to the bottom, it will be a little bit off. The best way to determine the actual content size is actually to use the <code>NSLayoutManager</code>'s <code>usedRectForTextContainer:</code> method:</p> <pre><code>UITextView *textView; CGSize textSize = [textView.layoutManager usedRectForTextContainer:textView.textContainer].size; </code></pre> <p>To determine how much text actually is shown in the <code>UITextView</code>, you can calculate it by subtracting the text container insets from the frame height.</p> <pre><code>UITextView *textView; UIEdgeInsets textInsets = textView.textContainerInset; CGFloat textViewHeight = textView.frame.size.height - textInsets.top - textInsets.bottom; </code></pre> <p>Then it becomes easy to scroll:</p> <pre><code>// if you want scroll animation, use contentOffset UITextView *textView; textView.contentOffset = CGPointMake(textView.contentOffset.x, textSize - textViewHeight); // if you don't want scroll animation CGRect scrollBounds = textView.bounds; scrollBounds.origin = CGPointMake(textView.contentOffset.x, textSize - textViewHeight); textView.bounds = scrollBounds; </code></pre> <p>Some numbers for reference on what the different sizes represent for an empty <code>UITextView</code>.</p> <pre><code>textView.frame.size = (width=246, height=50) textSize = (width=10, height=16.701999999999998) textView.contentSize = (width=246, height=33) textView.textContainerInset = (top=8, left=0, bottom=8, right=0) </code></pre>
<p>In swift:</p> <pre><code> if self.mainScroll.contentSize.height &gt; self.mainScroll.bounds.size.height { let bottomOffset = CGPointMake(0, self.mainScroll.contentSize.height - self.mainScroll.bounds.size.height); self.mainScroll.setContentOffset(bottomOffset, animated: true) } </code></pre>
<p>Using UIScrollView's <code>setContentOffset:animated:</code> function to scroll to the bottom in Swift.</p> <pre><code>let bottomOffset : CGPoint = CGPointMake(0, scrollView.contentSize.height - scrollView.bounds.size.height + scrollView.contentInset.bottom) scrollView.setContentOffset(bottomOffset, animated: true) </code></pre>
<p>What if <code>contentSize</code> is lower than <code>bounds</code>? </p> <p>For Swift it is: </p> <pre><code>scrollView.setContentOffset(CGPointMake(0, max(scrollView.contentSize.height - scrollView.bounds.size.height, 0) ), animated: true) </code></pre>
<p>A Swift 2.2 solution, taking <code>contentInset</code> into account</p> <pre><code>let bottomOffset = CGPoint(x: 0, y: scrollView.contentSize.height - scrollView.bounds.size.height + scrollView.contentInset.bottom) scrollView.setContentOffset(bottomOffset, animated: true) </code></pre> <p>This should be in an extension</p> <pre><code>extension UIScrollView { func scrollToBottom() { let bottomOffset = CGPoint(x: 0, y: contentSize.height - bounds.size.height + contentInset.bottom) setContentOffset(bottomOffset, animated: true) } } </code></pre> <p>Note that you may want to check if <code>bottomOffset.y &gt; 0</code> before scroll</p>
<p>A swifty implementation: </p> <pre><code>extension UIScrollView { func scrollToBottom(animated animated: Bool) { if self.contentSize.height &lt; self.bounds.size.height { return } let bottomOffset = CGPoint(x: 0, y: self.contentSize.height - self.bounds.size.height) self.setContentOffset(bottomOffset, animated: animated) } } </code></pre>