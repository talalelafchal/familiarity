Check if view controller is presented modally, or pushed on a navigation stack
<p>How can I, in my view controller code, differentiate between:</p> <ul> <li>presented modally</li> <li>pushed on navigation stack</li> </ul> <p>Both <code>presentingViewController</code> and <code>isMovingToParentViewController</code> are <code>YES</code> in both cases, so are not very helpful.</p> <p>What complicates things is that my parent view controller is sometimes modal, on which the to be checked view controller is pushed.</p> <p>It turns out my issue is that I embed my <code>HtmlViewController</code> in a <code>UINavigationController</code> which is then presented. That's why my own attempts and the good answers below were not working.</p> <pre><code>HtmlViewController* termsViewController = [[HtmlViewController alloc] initWithDictionary:dictionary]; UINavigationController* modalViewController; modalViewController = [[UINavigationController alloc] initWithRootViewController:termsViewController]; modalViewController.modalTransitionStyle = UIModalTransitionStyleCoverVertical; [self presentViewController:modalViewController animated:YES completion:nil]; </code></pre> <p>I guess I'd better tell my view controller when it's modal, instead of trying to determine.</p>
<p>Take with a grain of salt, didn't test.</p> <pre><code>- (BOOL)isModal { if([self presentingViewController]) return YES; if([[[self navigationController] presentingViewController] presentedViewController] == [self navigationController]) return YES; if([[[self tabBarController] presentingViewController] isKindOfClass:[UITabBarController class]]) return YES; return NO; } </code></pre>
<p><code>self.navigationController != nil</code> would mean it's in a navigation stack.</p>
<p>You overlooked one method: <code>isBeingPresented</code>.</p> <p><code>isBeingPresented</code> is true when the view controller is being presented and false when being pushed.</p> <pre><code>- (void)viewWillAppear:(BOOL)animated { [super viewWillAppear:animated]; if ([self isBeingPresented]) { // being presented } else if ([self isMovingToParentViewController]) { // being pushed } else { // simply showing again because another VC was dismissed } } </code></pre>
<p>In <strong>Swift</strong>:</p> <pre><code>func isModal() -&gt; Bool { if self.presentingViewController != nil { return true } else if self.navigationController?.presentingViewController?.presentedViewController == self.navigationController { return true } else if self.tabBarController?.presentingViewController is UITabBarController { return true } return false } </code></pre>
<pre><code>id presentedController = self.navigationController.modalViewController; if (presentedController) { // Some view is Presented } else { // Some view is Pushed } </code></pre> <p>This will let you know if viewController is presented or pushed</p>
<p>As many folks here suggest, that "checking" methods don't work well for all cases, in my project I've come up with solution to manage that manually. The point is, we usually manage presentation on our own - this is not what happens behind the scene and we must to introspect.</p> <p><code>DEViewController.h</code> file:</p> <pre><code>#import &lt;UIKit/UIKit.h&gt; // it is a base class for all view controllers within a project @interface DEViewController : UIViewController // specify a way viewcontroller, is presented by another viewcontroller // the presented view controller should manually assign the value to it typedef NS_ENUM(NSUInteger, SSViewControllerPresentationMethod) { SSViewControllerPresentationMethodUnspecified = 0, SSViewControllerPresentationMethodPush, SSViewControllerPresentationMethodModal, }; @property (nonatomic) SSViewControllerPresentationMethod viewControllerPresentationMethod; // other properties/methods... @end </code></pre> <p>The presentations now could be managed this way:</p> <p><strong>pushed on navigation stack:</strong></p> <pre><code>// DETestViewController inherits from DEViewController DETestViewController *vc = [DETestViewController new]; vc.viewControllerPresentationMethod = SSViewControllerPresentationMethodPush; [self.navigationController pushViewController:vc animated:YES]; </code></pre> <p><strong>presented modally with navigation:</strong></p> <pre><code>DETestViewController *vc = [DETestViewController new]; vc.viewControllerPresentationMethod = SSViewControllerPresentationMethodModal; UINavigationController *nav = [[UINavigationController alloc] initWithRootViewController:vc]; [self presentViewController:nav animated:YES completion:nil]; </code></pre> <p><strong>presented modally:</strong></p> <pre><code>DETestViewController *vc = [DETestViewController new]; vc.viewControllerPresentationMethod = SSViewControllerPresentationMethodModal; [self presentViewController:vc animated:YES completion:nil]; </code></pre> <p>Also, in <code>DEViewController</code> we could add a fallback to "checking" if the aforementioned property equals to <code>SSViewControllerPresentationMethodUnspecified</code>:</p> <pre><code>- (BOOL)isViewControllerPushed { if (self.viewControllerPresentationMethod != SSViewControllerPresentationMethodUnspecified) { return (BOOL)(self.viewControllerPresentationMethod == SSViewControllerPresentationMethodPush); } else { // fallback to default determination method return (BOOL)self.navigationController.viewControllers.count &gt; 1; } } </code></pre>
<blockquote> <p>self.navigationController != nil would mean it's in a navigation stack.</p> </blockquote> <p>I have added some lines of code to check if the current view controller is the root controller in the navigation stack to handle the case that the current view controller is pushed while the navigation controller is presented modally.</p> <pre><code>extension UIViewController{ func isModal() -&gt; Bool { if let navigationController = self.navigationController{ if navigationController.viewControllers.first != self{ return false } } if self.presentingViewController != nil { return true } if self.navigationController?.presentingViewController?.presentedViewController == self.navigationController { return true } if self.tabBarController?.presentingViewController is UITabBarController { return true } return false } </code></pre> <p>}</p>
<p>Assuming that all viewControllers that you present modally are wrapped inside a new navigationController (which you should always do anyway), you can add this property to your VC.</p> <pre><code>private var wasPushed: Bool { guard let vc = navigationController?.viewControllers.first where vc == self else { return true } return false } </code></pre>