Is there a way to bind a variable to multiple alternatives in a switch statement?
<p>Suppose I have an enum definition as follows:</p> <pre><code>enum Response { case Result(String, Int) case Error(String) } </code></pre> <p>Then, I get such a response:</p> <pre><code>let resp: Response = // ... </code></pre> <p>Suppose I want to write a switch statement and handle the same way the Result and the Error cases and bind a variable of the same name to the <code>String</code> they contain. How can I do this? Conceptually, something similar to this:</p> <pre><code>switch resp { case let .Result(str, _), let .Error(str): println("Found: \(str)") } </code></pre> <p>where <code>str</code> is bound twice, and <code>_</code> signals that I'm not interested in the <code>Int</code> value that a <code>Result</code> carries.</p> <p>So far, the closest thing I could find was to declare an inline function like this and then call it:</p> <pre><code>func processRespString(str: String) { println("Found \(str)") } switch resp { case let .Result(str, _): processRespString(str) case let .Error(str): processRespString(str) } </code></pre> <p>Is there a better way?</p>
<p>The most obvious way would be to signify an error by using an <strong>optional</strong> instead of the enum:</p> <pre><code>struct Response { var string:String var result: Int? var isError: Bool { return result == nil } } </code></pre> <p>You can mix this with the original code if you insist on having an enum &ndash; </p> <pre><code>// Auxiliary enum enum IntResponse { case Result(Int) case Error() } struct FullResponse { // Real properties var string: String var response: IntResponse // Convenience property var result: Int? { switch(response) { case let .Result(value): return value case let .Error(): return nil } } // Initializers for success and error init(errorString:String) { self.string = errorString self.response = IntResponse.Error() } init(string:String, result:Int) { self.string = string self.response = IntResponse.Result(result) } } // An example usage let error = FullResponse(errorString: "some error") let success = FullResponse(string: "success", result: 10) func do_something(response: FullResponse) { println(response.string) // works for any of the cases } </code></pre>
<p>No, but if you want to access the String value of a Response regardless of whether it is a .Result or an .Error, you can do this:</p> <pre><code>enum Response { case Result(String, Int) case Error(String) func Message() -&gt; String { switch self { case let .Result(str, _): return str case let .Error(str): return str } } } var resp: Response = .Error("Fault") resp = .Result("Success",5) println(resp.Message()) </code></pre> <p>This way you keep the logic for the enum inside the enum itself.</p>
<p>The <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0043-declare-variables-in-case-labels-with-multiple-patterns.md" rel="nofollow">Swift evolution Proposal SE-0043</a> that has been accepted fixed this issue with Swift 3.</p> <pre><code>enum Response { case result(String, Int) case error(String) } let resp = Response.error("Some text") switch resp { case let .result(str, _), let .error(str): print("Found: \(str)") // prints Found: Some text } </code></pre> <p>With Swift 2, the previous Playground code would generate an error: <code>case labels with multiple patterns cannot declare variables</code>. However, with Swift 3, it generates no errors and has the expected behavior.</p>