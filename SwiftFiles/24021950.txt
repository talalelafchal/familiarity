How do I put different types in a dictionary in the Swift Language?
<p>Swift only allows a dictionary to contain a single type.</p> <p>Here's the definition that is taken from the Swift book:</p> <blockquote> <p>A dictionary is a container that stores multiple values of the same type </p> <p>[...] </p> <p>They differ from Objective-C’s <code>NSDictionary</code> and <code>NSMutableDictionary</code> classes, which can use any kind of object as their keys and values and do not provide any information about the nature of these objects.</p> </blockquote> <p>If that’s the case then how are we going to create nested dictionaries? </p> <p>Imagine we have a <code>plist</code> that holds String, Array and Dictionary items in it . If I’m allowed to hold only the same of type of items (either string, array etc.) then how am I going to use different types of items stored in the plist?</p> <p>How do I put different types in the same dictionary in Swift?</p>
<pre><code>let dictionary : Dictionary = [ "key": "value", "key2": 2, "key3": NSString(), 2: "test", ] </code></pre> <p>One can specify types which restricts the dictionary</p> <pre><code>let dictionary : Dictionary&lt;String, String&gt; = [ "key": "value", "key2": 2, // This errors ] </code></pre>
<p>You can achieve plist-like nested structures using <code>Any</code> type for dictionary values which is Swift's somewhat counterpart to Objective-C's <code>id</code> type but can also hold value types.</p> <pre><code>var response = Dictionary&lt;String, Any&gt;() response["user"] = ["Login": "Power Ranger", "Password": "Mighty Morfin'"] response["status"] = 200 </code></pre> <p>EDIT:</p> <p><code>Any</code> seems to be better than <code>AnyObject</code> because in the above code <code>response["status"]</code> is of type <code>Swift.Int</code>, while using value type of <code>AnyObject</code> it is <code>__NSCFNumber</code>.</p>
<p>Use: Dictionary&lt;String, AnyObject&gt;</p> <pre><code>var dict: Dictionary&lt;String, AnyObject&gt; = [ "number": 1, "string": "Hello", ] </code></pre>
<p>As has been suggested, you can use the <code>Any</code> type to represent a plist dictionary's values. But then how do you work with the data? Cast every value any time you look it up from the dictionary? That's really messy. A better, more type-safe way to model a plist would be to take advantage of Swift's enums, also known as algebraic data types or discriminated unions. They let you specify exactly what types are permitted in the dictionary and avoid ever having to cast. Here's an implementation, explained:</p> <pre><code>// An atomic (i.e. non-collection) data type in a plist. enum PListNode { case PLN_String(String) case PLN_Integer(Int) case PLN_Float(Double) case PLN_Bool(Bool) case PLN_Date(CFDate) case PLN_Data(CFData) } </code></pre> <p>At the most atomic level, only the above data types may be stored in a plist. Each 'node' in the plist can ultimately can only be <em>one</em> of these types. So we create an enum which lets us specify this.</p> <pre><code>// A value that can be stored in a plist Dictionary's key-value pair. enum PListValue { case PLV_Node(PListNode) case PLV_Array(PListNode[]) case PLV_Dictionary(Dictionary&lt;String, Box&lt;PListValue&gt;&gt;) } typealias PList = Dictionary&lt;String, Box&lt;PListValue&gt;&gt; </code></pre> <p>A plist is basically a dictionary of key-value pairs, and <em>each value</em> can be either an atomic (i.e. non-collection) value; or it can be an array of atomic values; or it can be a dictionary of string-plist value pairs. The above enum expresses these constraints, and the typealias gives the plist type an easy-to-remember name.</p> <p>Given the above types, we can completely express any given plist <em>in a type-safe way,</em> e.g.:</p> <pre><code>// Example translated from // https://developer.apple.com/library/Mac/documentation/Darwin/Reference/ManPages/man5/plist.5.html let myPlist: PList = [ "Year Of Birth": Box(PLV_Node(PLN_Integer(1965))) , "Pets Names": Box(PLV_Array([])) , "Picture": Box(PLV_Node(PLN_Data(...))) , "City of Birth": Box(PLV_Node(PLN_String("Springfield"))) , "Name": Box(PLV_Node(PLN_String("John Doe"))) , "Kids Names": Box( PLV_Array([PLN_String("John"), PLN_String("Kyra")]) ) ] </code></pre> <p>What it means to be type-safe here is that you can process any given plist using a <code>switch</code> statement and cover all possibilities without the need for any casting. You're eliminating a whole class of potential runtime errors. E.g.:</p> <pre><code>// See https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html#//apple_ref/doc/uid/TP40014097-CH12-XID_189 for explanation switch myPlist["Year Of Birth"] { case Box(.PLV_Node(let plvNodeValue)): ... case Box(.PLV_Array(let plvArrayValue)): ... case Box(.PLV_Dictionary(let plvDictionaryValue)): ... } </code></pre> <p>Note that it's necessary to wrap up recursive data structures in a 'box' (a pointer to the actual value) to keep their sizes finite.</p>
<p>NSObject works for my case while "Any" does not</p> <pre><code>var d:Dictionary&lt;String,NSObject&gt; = [:] d["key1"] = "ddd" d["key2"] = 111 //OK NSLog("%@", d) //OK var d2:Dictionary = Dictionary&lt;String,Any&gt;() d2["key1"] = "ddd" d2["key2"] = 111 NSLog("%@", d2) //I got error here </code></pre>
<p><strong>NSMutableDictionary to Dictionary works like a charm and will allow you to put different types in a Dictionary in the Swift Language:</strong></p> <pre><code>let nsMutableDictionary = NSMutableDictionary() nsMutableDictionary[NSFontAttributeName] = UIFont(name: "HelveticaNeue", size: 12.0)! nsMutableDictionary[NSForegroundColorAttributeName] = UIColor.redColor() let dictionary: Dictionary&lt;NSObject, AnyObject&gt; = nsMutableDictionary self.attributedPlaceholder = NSAttributedString(string: textParam, attributes: dictionary) </code></pre>
<p>Use NSMutableDictionary like this :</p> <pre><code>var dictInfo : NSMutableDictionary = [ "lang_key": "1"] dictInfo["food_type"] = lbl_TypeOfFood.text dictInfo["search_text"] = txt_Search.text dictInfo["date"] = lbl_Date.text dictInfo["opening_hours"] = lbl_OpeningHours.text </code></pre> <p>hope this will work fine .</p>