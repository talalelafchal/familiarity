How to create array of unique object list in Swift
<p>How can we create unique object list in Swift language like <code>NSSet</code> &amp; <code>NSMutableSet</code> in Objective-C. </p>
<p>You can use any Objective-C class in Swift:</p> <pre><code>var set = NSMutableSet() set.addObject(foo) </code></pre>
<p>Swift has no concept of sets. Using <code>NSMutableSet</code> in Swift might be slower than using a <code>Dictionary</code> that holds dummy values. You could do this :</p> <pre><code>var mySet: Dictionary&lt;String, Boolean&gt; = [:] mySet["something"]= 1 </code></pre> <p>Then just iterate over the keys.</p>
<p>Always in such a case the critical factor is how to compare objects and what types of objects go into the Set. Using a Swift Dictionary, where the Set objects are the dictionary keys, could be a problem based on the restrictions on the key type (String, Int, Double, Bool, valueless Enumerations or hashable).</p> <p><strong>If you can define a hash function</strong> on your object type then you can use a Dictionary. <strong>If the objects are orderable</strong>, then you could define a Tree. <strong>If the objects are only comparable with <code>==</code></strong> then you'll need to iterate over the set elements to detect a preexisting object.</p> <pre><code>// When T is only Equatable class Set&lt;T: Equatable&gt; { var items = Array&lt;T&gt;() func hasItem (that: T) { // No builtin Array method of hasItem... // because comparison is undefined in builtin Array for this: T in items { if (this == that) { return true } } return false } func insert (that: T) { if (!hasItem (that)) items.append (that) } } </code></pre> <p>The above is an example of building a Swift <code>Set</code>; the example used objects that are only <code>Equatable</code> - which, while a common case, doesn't necessarily lead to an efficient <code>Set</code> implementations (O(N) search complexity - the above is an example).</p>
<p>You actually can create a Set object pretty easy (in contradiction to GoZoner, there is a built in contains method):</p> <pre><code>class Set&lt;T : Equatable&gt; { var items : T[] = [] func add(item : T) { if !contains(items, {$0 == item}) { items += item } } } </code></pre> <p>and you maybe even want to declare a custom operator:</p> <pre><code>@assignment @infix func += &lt;T : Equatable&gt; (inout set : Set&lt;T&gt;, items : T[]) -&gt; Set&lt;T&gt; { for item in items { set.add(item) } return set } </code></pre>
<p>So I think creating a Set with an array is a terrible idea - O(n) is the time complexity of that set. </p> <p>I have put together a nice Set that uses a dictionary: <a href="https://github.com/evilpenguin/Swift-Stuff/blob/master/Set.swift" rel="nofollow">https://github.com/evilpenguin/Swift-Stuff/blob/master/Set.swift</a></p>
<p>I thought a struct with an internal Dictionary would be the way to go. I have only just started using it, so itâ€™s not complete and I have no idea on performance yet.</p> <pre><code>struct Set&lt;T : Hashable&gt; { var _items : Dictionary&lt;T, Bool&gt; = [:] mutating func add(newItem : T) { _items[newItem] = true } mutating func remove(newItem : T) { _items[newItem] = nil } func contains(item: T) -&gt; Bool { if _items.indexForKey(item) != nil { return true } else { return false } } var items : [T] { get { return [T](_items.keys) } } var count : Int { get { return _items.count } } } </code></pre>
<p>I've built an extensive <code>Set</code> type similar to the built-in <code>Array</code> and <code>Dictionary</code> - here are blog posts one and two and a GitHub repository:</p> <ul> <li><a href="http://natecook.com/blog/2014/08/creating-a-set-type-in-swift/">Creating a Set Type in Swift</a></li> <li><a href="http://natecook.com/blog/2014/08/set-type-follow-up/">Set Type Follow-up</a></li> <li><a href="https://github.com/natecook1000/SwiftSets">SwiftSets on GitHub</a></li> </ul>
<p>I wrote a function to solve this problem.</p> <pre><code>public func removeDuplicates&lt;C: ExtensibleCollectionType where C.Generator.Element : Equatable&gt;(aCollection: C) -&gt; C { var container = C() for element in aCollection { if !contains(container, element) { container.append(element) } } return container } </code></pre> <p>To use it, just pass an array which contains duplicate elements to this function. And then it will return a uniqueness-guaranteed array.</p> <p>You also can pass a <code>Dictionary</code>, <code>String</code> or anything conforms to <code>ExtensibleCollectionType</code> protocol if you like.</p>
<p>As of Swift 1.2 (Xcode 6.3 beta), Swift has a native set type. From the release notes:</p> <blockquote> <p>A new <code>Set</code> data structure is included which provides a generic collection of unique elements, with full value semantics. It bridges with <code>NSSet</code>, providing functionality analogous to <code>Array</code> and <code>Dictionary</code>.</p> </blockquote> <p>Here are some simple usage examples:</p> <pre><code>// Create set from array literal: var set = Set([1, 2, 3, 2, 1]) // Add single elements: set.insert(4) set.insert(3) // Add multiple elements: set.unionInPlace([ 4, 5, 6 ]) // Swift 3: set.formUnion([ 4, 5, 6 ]) // Remove single element: set.remove(2) // Remove multiple elements: set.subtractInPlace([ 6, 7 ]) // Swift 3: set.subtract([ 6, 7 ]) print(set) // [5, 3, 1, 4] // Test membership: if set.contains(5) { print("yes") } </code></pre> <p>but there are far more methods available.</p> <p><strong>Update:</strong> Sets are now also documented in the <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/CollectionTypes.html" rel="nofollow">"Collection Types"</a> chapter of the Swift documentation.</p>
<pre><code>extension Array where Element: Hashable { var setValue: Set&lt;Element&gt; { return Set&lt;Element&gt;(self) } } let numbers = [1,2,3,4,5,6,7,8,9,0,0,9,8,7] let uniqueNumbers = numbers.setValue // {0, 2, 4, 9, 5, 6, 7, 3, 1, 8} let names = ["John","Mary","Steve","Mary"] let uniqueNames = names.setValue // {"John", "Mary", "Steve"} </code></pre>