How to make an enum conform to a protocol in Swift?
<p>Swift documentation says that <em>classes</em>, <em>structs</em>, and <em>enums</em> can all conform to protocols, and I can get to a point where they all conform. But I can't get the <em>enum</em> to behave quite like the <em>class</em> and <em>struct</em> examples:</p> <pre><code>protocol ExampleProtocol { var simpleDescription: String { get set } mutating func adjust() } class SimpleClass: ExampleProtocol { var simpleDescription: String = "A very simple class." var anotherProperty: Int = 69105 func adjust() { simpleDescription += " Now 100% adjusted." } } var a = SimpleClass() a.adjust() let aDescription = a.simpleDescription struct SimpleStructure: ExampleProtocol { var simpleDescription: String = "A simple structure" mutating func adjust() { simpleDescription += " (adjusted)" } } var b = SimpleStructure() b.adjust() let bDescription = b.simpleDescription enum SimpleEnum: ExampleProtocol { case Base var simpleDescription: String { get { return "A Simple Enum" } set { newValue } } mutating func adjust() { self.simpleDescription += ", adjusted" } } var c = SimpleEnum.Base c.adjust() let cDescription = c.simpleDescription </code></pre> <p>I haven't figured out how to get the <code>simpleDescription</code> to change as a result of calling <code>adjust()</code>. My example obviously won't do that because the <em>getter</em> has a value hard-coded, but how can I set a value for the <code>simpleDescription</code> while still conforming to the <code>ExampleProtocol</code>?</p>
<p>This is my attempt:</p> <pre><code>protocol ExampleProtocol { var simpleDescription: String { get } mutating func adjust() } enum ExampleEnum : ExampleProtocol { case Base, Adjusted var simpleDescription: String { return self.getDescription() } func getDescription() -&gt; String { switch self { case .Base: return "A simple description of enum" case .Adjusted: return "Adjusted description of enum" } } mutating func adjust() { self = ExampleEnum.Adjusted } } var c = ExampleEnum.Base c.adjust() let cDescription = c.simpleDescription </code></pre>
<p>It is not possible to define variables without getter and setter in enums and therefore it is impossible to have a variable that you can modify.</p> <p>You can conform to the protocol but you cannot have same behavior with mutating as in classes.</p>
<p>Here is my take at it.</p> <p>As this is an <code>enum</code> and not a <code>class</code>, you have to <em>think different(TM)</em>: it is your description that has to change when the "state" of your <code>enum</code> changes (as pointed out by @hu-qiang).</p> <pre><code>enum SimpleEnumeration: ExampleProtocol { case Basic, Adjusted var description: String { switch self { case .Basic: return "A simple Enumeration" case .Adjusted: return "A simple Enumeration [adjusted]" } } mutating func adjust() { self = SimpleEnumeration.Adjusted } } var c = SimpleEnumeration.Basic c.description c.adjust() c.description </code></pre> <p>Hope that helps.</p>
<p>Another option is for adjust() to flip between cases as follows:</p> <pre><code>enum SimpleEnum: ExampleProtocol { case Foo, Bar var simpleDescription: String { get { let value = self == .Foo ? "Foo" : "Bar" return "A simple \(value) enum." } } mutating func adjust() { self = self == .Foo ? .Bar : .Foo } } </code></pre>
<p>Here's another approach, using only the knowledge gained from the tour until that point*</p> <pre><code>enum SimpleEnumeration: String, ExampleProtocol { case Basic = "A simple enumeration", Adjusted = "A simple enumeration (adjusted)" var simpleDescription: String { get { return self.toRaw() } } mutating func adjust() { self = .Adjusted } } var c = SimpleEnumeration.Basic c.adjust() let cDescription = c.simpleDescription </code></pre> <p>If you want to have <code>adjust()</code> act as a toggle (although there's nothing to suggest this is the case), use:</p> <pre><code>mutating func adjust() { switch self { case .Basic: self = .Adjusted default: self = .Basic } } </code></pre> <p>*(Although it doesn't explicitly mention how to specify a return type <em>and</em> a protocol)</p>
<p>It is a <a href="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Enumerations.html#//apple_ref/doc/uid/TP40014097-CH12-XID_185" rel="nofollow">link</a> about enum in swift.</p> <p>Structures and enumerations are value types. By default, the properties of a value type cannot be modified from within its instance methods. <a href="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Enumerations.html#//apple_ref/doc/uid/TP40014097-CH12-XID_185" rel="nofollow">link</a></p> <p>Then, you have to use mutating function. </p> <pre><code>enum ProtocolEnum: ExampleProtocol { case on, off var simpleDescription: String { switch self { case .on: return "Switch is ON" case .off: return "Switch is OFF" } } mutating func adjust() { switch self { case .on: self = off case .off: self = on } } } var c = ProtocolEnum.on c.simpleDescription c.adjust() let cDescription = c.simpleDescription </code></pre>
<p>Here's a solution that doesn't change the current enum value, but their instance values instead (just in case it is useful to anyone).</p> <pre><code>enum ProtoEnumeration : ExampleProtocol { case One(String) case Two(String) var simpleDescription: String { get { switch self { case let .One(desc): return desc case let .Two(desc): return desc } } } mutating func adjust() { switch self { case let .One(desc): self = .One(desc + ", adjusted 1") case let .Two(desc): self = .Two(desc + ", adjusted 2") } } } var p = ProtoEnumeration.One("test") p.simpleDescription p.adjust() p.simpleDescription </code></pre>
<p>Here's building on Jack's answer:</p> <pre><code>protocol ICanWalk { var description: String { get } mutating func stepIt() } enum TwoStepsForwardThreeStepsBack: Int, ICanWalk { case Base = 0, Step1, Step2 var description: String { return "Step \(self.rawValue)" } mutating func stepIt() { if let nextStep = TwoStepsForwardThreeStepsBack( rawValue: self.rawValue + 1 ) { // going forward. self = nextStep } else { // back to the base. self = TwoStepsForwardThreeStepsBack.Base } } } </code></pre>
<p>here's my code</p> <pre><code>enum SimpleEnum: ExampleProtocol { case Base, Adjusted var simpleDescription: String { get { var description = "A simple enum." switch self { case .Base: return description case .Adjusted: return description + " - [adjusted]" } } } mutating func adjust() { self = SimpleEnum.Adjusted } } var simpleEnum = SimpleEnum.Base simpleEnum.adjust() simpleEnum.simpleDescription </code></pre>
<p>My first contribution here:</p> <pre><code>enum SimpleEnum: ExampleProtocol { case Basic(String), Adjusted(String) init() { self = SimpleEnum.Basic("A simple Enum") } var simpleDescription: String { get { switch self { case let .Basic(string): return string case let .Adjusted(string): return string } } } mutating func adjust() { self = SimpleEnum.Adjusted("full adjusted") } } var c = SimpleEnum() c.adjust() let cDescription = c.simpleDescription </code></pre> <p>Thanks for others!</p>
<p>This experiment threw me off too, due to the previous SimpleClass and SimpleStructure examples showing the property simpleDescription being modified internally, which caused me to think that I needed to do the same thing. After looking over the other answers posted here and reading the official Apple Swift 2.1 documentation, I came up with this:</p> <pre><code>protocol ExampleProtocol { var simpleDescription: String { get } mutating func adjust() } enum SimpleEnum: ExampleProtocol { case Simple case Adjusted var simpleDescription: String { switch self { case .Simple: return "A simple enumeration" case .Adjusted: return "A simple enumeration somewhat changed." } } mutating func adjust() { self = .Adjusted } mutating func restore() { self = .Simple } } var d: SimpleEnum = .Simple d.simpleDescription d.adjust() d.simpleDescription d.restore() d.simpleDescription </code></pre> <p>Also notice that in the examples given by Apple for SimpleClass and SimpleStructure prior to this experiment, the simple description is lost internally - you cannot get the original value back (unless of course you save it outside of the class/structure); this is what prompted me to create a restore() method for the SimpleEnum example, which allows you to toggle it back and forth between values. Hope this is useful to someone!</p>
<p>I was thinking that the goal is simply to retain state and use a description to make the current state easier to read:</p> <pre><code>enum SimpleEnum: ExampleProtocol { case Default, Adjusted init() { self = .Default } var simpleDescription: String { get { return "\(self) Value" }} mutating func adjust() { self = .Adjusted } } var simpleEnum = SimpleEnum() simpleEnum.adjust() let adjustedSimple = simpleEnum.simpleDescript </code></pre>
<p>how about this</p> <pre><code>enum SimpleEnum : ExampleProtocol { case Desc(String) init() { self = Desc("a simple enum") } var simpleDescription:String { get { return (Mirror(reflecting: self).children.first!.value as? String)! } } mutating func adjust() { self = SimpleEnum.Desc(self.desc + " adjusted") } } var e = SimpleEnum() e.simpleDescription # =&gt; "a simple enum" e.adjust() e.simpleDescription # =&gt; "a simple enum adjusted" </code></pre>
<p>I came up with this</p> <pre><code>protocol ExampleProtocol { var simpleDescription: String { get } mutating func adjust() } enum Seat: ExampleProtocol { case WindowSeat, MiddleSeat, AisleSeat var simpleDescription : String { switch self { case .WindowSeat: return "Window Seat" case .MiddleSeat: return "Middle Seat" case .AisleSeat: return "Aisle Seat" } } mutating func adjust() { switch self { case .WindowSeat: self = .MiddleSeat case .MiddleSeat: self = . AisleSeat case .AisleSeat: self = .WindowSeat } } } var seat = Seat.MiddleSeat print(seat.simpleDescription) // Middle Seat seat.adjust() print(seat.simpleDescription) // Aisle Seat </code></pre>