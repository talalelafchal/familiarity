Weird optional value usage in swift
<pre><code> var z1 = false var z2 = false var z3 = false if let y1: Int = nil { z1 = true } if let y2: Int? = nil { z2 = true } var x: Int? = nil if let y3: Int? = x { z3 = true } println(z1) // false println(z2) // ture println(z3) // false </code></pre> <p>I try to use optional value like this( I know this is weired, I just curious about the optional value in deepth). </p> <p>The reuslt is not as I'm expect. z1 is false, this is as I'm expected, but why z2 is true? y2 is nil after the assignment, but the if statement thought this expression(<code>let y2: Int? = nil</code>) is true, and the next statement is executed(<code>z2=true</code>), why this happend? </p> <p>Why z2 not be false?</p> <p>If y2 is just declared as an optional value which can contains anther optional value, and optional value may be nil, <code>if let</code> statement just detect the unwrap is success, then, why z3 is not true ?</p>
<p>The way optional binding works is the if checks to see if the let declaration is successful. In your first statement, it is unsuccessful because you can't assign nil to an Int, but in your second statement it is successful and enters the body because you are allowed to assign nil to an Int Optional.</p>
<p>Because you are missing a "?" in z1</p>
<p>This is because you can declare optional variable to be recursively optional, like this:</p> <pre><code>var x: Int?? = 5 // LLDB: p x.dynamicType returns (Int??) </code></pre> <p>You can go even further:</p> <pre><code>var y: Int????????? = 6 // LLDB: p x.dynamicType returns (Int?????????) </code></pre> <p>What <code>if let</code> construct does is it checks whether you can unwrap an optional value, and it happens that you can unwrap optional optional value even if it's final value is <code>nil</code>. Think of it like the optional value is not <code>nil</code> itself, it's some object that wraps <code>nil</code>.</p> <p>To check it in the code you can do following:</p> <pre><code>var a: Int? = nil; // LLDB: p a! returns fatal error: Can't unwrap Optional.None var b: Int?? = nil; // LLDB: p b! returns (Int?) $R2 = nil </code></pre> <p>So this is what happend in case of your <code>z2</code> condition: the <code>if let</code> construct is checking whether it can unwrap the <code>y2</code> and it was, so the if block was executed.</p>
<p>I'll try to explain it adding block comments so you can see the inferred types and values.</p> <pre><code>var z1 = false var z2 = false var z3 = false if let y1: Int = nil /* nil : Optional&lt;T&gt; instantiated to Optional&lt;Int&gt;, value is .None */ { z1 = true } if let y2: Int? = nil /* nil : Optional&lt;T&gt; instantiated to Optional&lt;Optional&lt;Int&gt;&gt;, value is .Some(.None) */ { z2 = true } var x: Int? = nil /* nil : Optional&lt;T&gt; instantiated to Optional&lt;Int&gt;, value is .None */ if let y3: Int? = x /* x : Optional&lt;Int&gt; value is .None */ { z3 = true } println(z1) // false println(z2) // ture println(z3) // false </code></pre>
<p>For me <code>z2</code> is false and <code>z3</code> is true:</p> <pre><code>println(z1) // false println(z2) // false println(z3) // true </code></pre> <p>Recalling that <code>if let A = optB { ... }</code> means, essentially, "if <code>optB</code> is not <code>nil</code> assign it to <code>A</code> and execute the following block", the reason that <code>z3</code> is true is that <code>x</code> is <code>Optional(nil)</code> rather than <code>nil</code>. You can see this by trying</p> <pre><code>var x: Int? = 5 if let y3: Int? = x { println(x) // Optional(5) z3 = true } println(z3) // true </code></pre> <p>and comparing this and the original version with</p> <pre><code>var x: Int? = nil if let y3: Int? = x? { z3 = true } println(z3) // false! </code></pre> <p>In the first case you can see that <code>x</code> is wrapped (so the original version was not <code>nil</code> but <code>Optional(nil)</code>); in the second you can see how <code>x</code> can be unwrapped to produce <code>nil</code>.</p> <p>Swift (especially viewed in an Xcode Playground) makes this hard to see because of the way it displays <code>nil</code> (probably because it can't be unwrapped, it shows <code>Optional(nil)</code> and <code>nil</code> as <code>nil</code>).</p> <hr> <p>As an aside, variations on this can also be used to explore some subtleties of what's going in on the left hand side of the assignment, which is the only difference between the <code>z1</code> and <code>z2</code> cases. For example, you can see that in for the <code>z3</code> case as in the <code>z2</code> case, <code>y3</code> is an optional</p> <pre><code>var x: Int? = 5 if let y3: Int? = x { println(x) // Optional(5) println(y3) // Optional(5) z3 = true } println(z3) // true </code></pre> <p>while removing the <code>?</code> from the type for <code>y3</code> makes it like the <code>z1</code> case, where <code>y1</code> is not an optional</p> <pre><code>var x: Int? = 5 if let y3: Int = x { println(x) // Optional(5) println(y3) // 5 z3 = true } println(z3) // true </code></pre>