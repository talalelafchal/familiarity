Swift - Read plist
<p>I am playing around with Apple's new <strong>Swift</strong> programming language and have some problems...</p> <p>Currently I'm trying to read a plist file, in Objective-C I would do the following to get the content as a NSDictionary:</p> <pre><code>NSString *filePath = [[NSBundle mainBundle] pathForResource:@"Config" ofType:@"plist"]; NSDictionary *dict = [[NSDictionary alloc] initWithContentsOfFile:filePath]; </code></pre> <p>How do I get a plist as a Dictionary in Swift?</p> <p>I assume I can get the path to the plist with:</p> <pre><code>let path = NSBundle.mainBundle().pathForResource("Config", ofType: "plist") </code></pre> <p>When this works (If it's correct?): How do I get the content as a Dictionary?</p> <p>Also a more general question:</p> <p>Is it OK to use the default <strong>NS*</strong> classes? I think so...or am I missing something? As far as I know the default framework <strong>NS*</strong> classes are still valid and alright to use?</p>
<p>You can still use NSDictionaries in Swift:</p> <pre><code>var myDict: NSDictionary? if let path = NSBundle.mainBundle().pathForResource("Config", ofType: "plist") { myDict = NSDictionary(contentsOfFile: path) } if let dict = myDict { // Use your dict here } </code></pre> <p>The NSClasses are still available and perfectly fine to use in Swift. I think they'll probably want to shift focus to swift soon, but currently the swift APIs don't have all the functionality of the core NSClasses.</p>
<p>It is best to use native dictionaries and arrays because they have been optimized for use with swift. That being said you can use NS... classes in swift and I think this situation warrants that. Here is how you would implement it:</p> <pre><code>var path = NSBundle.mainBundle().pathForResource("Config", ofType: "plist") var dict = NSDictionary(contentsOfFile: path) </code></pre> <p>So far (in my opinion) this is the easiest and most efficient way to access a plist, but in the future I expect that apple will add more functionality (such as using plist) into native dictionaries.</p>
<p>can actually do it in 1 line </p> <pre><code> var dict = NSDictionary(contentsOfFile: NSBundle.mainBundle().pathForResource("Config", ofType: "plist")) </code></pre>
<p>Here's the solution I found:</p> <pre><code>let levelBlocks = NSDictionary(contentsOfFile: NSBundle.mainBundle().pathForResource("LevelBlocks", ofType: "plist")) let test: AnyObject = levelBlocks.objectForKey("Level1") println(test) // Prints the value of test </code></pre> <p>I set the type of <code>test</code> to <code>AnyObject</code> to silence a warning about an unexpected inference that could occur.</p> <p>Also, it has to be done in a class method.</p> <p>To access and save a specific value of a known type:</p> <pre><code>let value = levelBlocks.objectForKey("Level1").objectForKey("amount") as Int println(toString(value)) // Converts value to String and prints it </code></pre>
<p>You can read plist in SWIFT Language in this way:</p> <pre><code>let path = NSBundle.mainBundle().pathForResource("PriceList", ofType: "plist") let dict = NSDictionary(contentsOfFile: path) </code></pre> <p>Read Single Dictionary value:</p> <pre><code>let test: AnyObject = dict.objectForKey("index1") </code></pre> <p>If you want to get full multi-dimensional dictionary in plist:</p> <pre><code>let value: AnyObject = dict.objectForKey("index2").objectForKey("date") </code></pre> <p>Here is the plist:</p> <pre><code>&lt;plist version="1.0"&gt; &lt;dict&gt; &lt;key&gt;index2&lt;/key&gt; &lt;dict&gt; &lt;key&gt;date&lt;/key&gt; &lt;string&gt;20140610&lt;/string&gt; &lt;key&gt;amount&lt;/key&gt; &lt;string&gt;110&lt;/string&gt; &lt;/dict&gt; &lt;key&gt;index1&lt;/key&gt; &lt;dict&gt; &lt;key&gt;amount&lt;/key&gt; &lt;string&gt;125&lt;/string&gt; &lt;key&gt;date&lt;/key&gt; &lt;string&gt;20140212&lt;/string&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/plist&gt; </code></pre>
<p><strong>Swift - Read/Write plist and text file....</strong></p> <pre><code>override func viewDidLoad() { super.viewDidLoad() let fileManager = (NSFileManager .defaultManager()) let directorys : [String]? = NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory.DocumentDirectory,NSSearchPathDomainMask.AllDomainsMask, true) as? [String] if (directorys != nil){ let directories:[String] = directorys!; let dictionary = directories[0]; //documents directory // Create and insert the data into the Plist file .... let plistfile = "myPlist.plist" var myDictionary: NSMutableDictionary = ["Content": "This is a sample Plist file ........."] let plistpath = dictionary.stringByAppendingPathComponent(plistfile); if !fileManager .fileExistsAtPath(plistpath){//writing Plist file myDictionary.writeToFile(plistpath, atomically: false) } else{ //Reading Plist file println("Plist file found") let resultDictionary = NSMutableDictionary(contentsOfFile: plistpath) println(resultDictionary?.description) } // Create and insert the data into the Text file .... let textfile = "myText.txt" let sampleText = "This is a sample text file ......... " let textpath = dictionary.stringByAppendingPathComponent(textfile); if !fileManager .fileExistsAtPath(textpath){//writing text file sampleText.writeToFile(textpath, atomically: false, encoding: NSUTF8StringEncoding, error: nil); } else{ //Reading text file let reulttext = String(contentsOfFile: textpath, encoding: NSUTF8StringEncoding, error: nil) println(reulttext) } } else { println("directory is empty") } } </code></pre>
<p>This is what I do if I want to convert a .plist to a Swift dictionary: </p> <pre><code>if let path = NSBundle.mainBundle().pathForResource("Config", ofType: "plist") { if let dict = NSDictionary(contentsOfFile: path) as? Dictionary&lt;String, AnyObject&gt; { // use swift dictionary as normal } } </code></pre> <p><strong>Edited for Swift 2.0:</strong></p> <pre><code>if let path = NSBundle.mainBundle().pathForResource("Config", ofType: "plist"), dict = NSDictionary(contentsOfFile: path) as? [String: AnyObject] { // use swift dictionary as normal } </code></pre>
<p>You can use that, I create a simple extension for Dictionary in github <a href="https://github.com/DaRkD0G/LoadExtension" rel="nofollow">https://github.com/DaRkD0G/LoadExtension</a></p> <pre><code>extension Dictionary { /** Load a Plist file from the app bundle into a new dictionary :param: File name :return: Dictionary&lt;String, AnyObject&gt;? */ static func loadPlistFromProject(filename: String) -&gt; Dictionary&lt;String, AnyObject&gt;? { if let path = NSBundle.mainBundle().pathForResource("GameParam", ofType: "plist") { return NSDictionary(contentsOfFile: path) as? Dictionary&lt;String, AnyObject&gt; } println("Could not find file: \(filename)") return nil } } </code></pre> <p>And you can use that for load</p> <pre><code>/** Example function for load Files Plist :param: Name File Plist */ func loadPlist(filename: String) -&gt; ExampleClass? { if let dictionary = Dictionary&lt;String, AnyObject&gt;.loadPlistFromProject(filename) { let stringValue = (dictionary["name"] as NSString) let intergerValue = (dictionary["score"] as NSString).integerValue let doubleValue = (dictionary["transition"] as NSString).doubleValue return ExampleClass(stringValue: stringValue, intergerValue: intergerValue, doubleValue: doubleValue) } return nil } </code></pre>
<p><strong>Heres' how I read/write a plist file:</strong> <a href="http://stackoverflow.com/a/28252457/4514671">http://stackoverflow.com/a/28252457/4514671</a></p> <p>Step by step blog post tutorial: <a href="http://rebeloper.com/read-write-plist-file-swift/" rel="nofollow">http://rebeloper.com/read-write-plist-file-swift/</a></p> <p>Hope it helps :)</p>
<p>I use swift dictionaries but convert them to and from NSDictionaries in my file manager class like so:</p> <pre><code> func writePlist(fileName:String, myDict:Dictionary&lt;String, AnyObject&gt;){ let docsDir:String = dirPaths[0] as String let docPath = docsDir + "/" + fileName let thisDict = myDict as NSDictionary if(thisDict.writeToFile(docPath, atomically: true)){ NSLog("success") } else { NSLog("failure") } } func getPlist(fileName:String)-&gt;Dictionary&lt;String, AnyObject&gt;{ let docsDir:String = dirPaths[0] as String let docPath = docsDir + "/" + fileName let thisDict = NSDictionary(contentsOfFile: docPath) return thisDict! as! Dictionary&lt;String, AnyObject&gt; } </code></pre> <p>This seems the least troubling way to read and write but let's the rest of my code stay as swift as possible.</p>
<p>Simple <strong>struct</strong> to access plist file (Swift 2.0)</p> <pre><code>struct Configuration { static let path = NSBundle.mainBundle().pathForResource("Info", ofType: "plist")! static let dict = NSDictionary(contentsOfFile: path) as! [String: AnyObject] static let someValue = dict["someKey"] as! String } </code></pre> <p>Usage: </p> <pre><code>print("someValue = \(Configuration.someValue)") </code></pre>
<p><strong>Swift 2.0 : Accessing Info.Plist</strong></p> <p>I have a Dictionary named CoachMarksDictionary with a boolean value in Info.Plist . I want to access the bool value and make it true.</p> <pre><code>let path = NSBundle.mainBundle().pathForResource("Info", ofType: "plist")! let dict = NSDictionary(contentsOfFile: path) as! [String: AnyObject] if let CoachMarksDict = dict["CoachMarksDictionary"] { print("Info.plist : \(CoachMarksDict)") var dashC = CoachMarksDict["DashBoardCompleted"] as! Bool print("DashBoardCompleted state :\(dashC) ") } </code></pre> <p><strong>Writing To Plist:</strong></p> <p>From a Custom Plist:- (Make from File-New-File-Resource-PropertyList. Added three strings named : DashBoard_New, DashBoard_Draft, DashBoard_Completed)</p> <pre><code>func writeToCoachMarksPlist(status:String?,keyName:String?) { let path1 = NSBundle.mainBundle().pathForResource("CoachMarks", ofType: "plist") let coachMarksDICT = NSMutableDictionary(contentsOfFile: path1!)! as NSMutableDictionary var coachMarksMine = coachMarksDICT.objectForKey(keyName!) coachMarksMine = status coachMarksDICT.setValue(status, forKey: keyName!) coachMarksDICT.writeToFile(path1!, atomically: true) } </code></pre> <p>The method can be called as </p> <pre><code>self.writeToCoachMarksPlist(" true - means user has checked the marks",keyName: "the key in the CoachMarks dictionary"). </code></pre>
<p>I have been working with Swift 3.0 and wanted to contribute an answer for the updated syntax. Additionally, and possibly more importantly, I am using the <strong>PropertyListSerialization</strong> object to do the heavy lifting, which is a lot more flexible than just using the NSDictionary as it allows for an Array as the root type of the plist.</p> <p>Below is a screenshot of the plist I am using. It is a <em>little</em> complicated, so as to show the power available, but this will work for any allowable combination of plist types.</p> <p><a href="https://i.stack.imgur.com/Ydffw.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/Ydffw.png" alt="Sample plist file"></a> As you can see I am using an Array of String:String dictionaries to store a list of website names and their corresponding URL.</p> <p>I am using the <strong>PropertyListSerialization</strong> object, as mentioned above, to do the heavy lifting for me. Additionally, Swift 3.0 has become more "Swifty" so all of the object names have lost the "NS" prefix.</p> <pre><code>let path = Bundle.main().pathForResource("DefaultSiteList", ofType: "plist")! let url = URL(fileURLWithPath: path) let data = try! Data(contentsOf: url) let plist = try! PropertyListSerialization.propertyList(from: data, options: .mutableContainers, format: nil) </code></pre> <p>After the above code runs <code>plist</code> will be of type <code>Array&lt;AnyObject&gt;</code>, but we know what type it really is so we can cast it to the correct type:</p> <pre><code>let dictArray = plist as! [[String:String]] // [[String:String]] is equivalent to Array&lt; Dictionary&lt;String, String&gt; &gt; </code></pre> <p>And now we can access the various properties of our Array of String:String Dictionaries in a natural way. <em>Hopefully to convert them into actual strongly typed structs or classes ;)</em></p> <pre><code>print(dictArray[0]["Name"]) </code></pre>
<p>In <strong><em>swift 3.0</em></strong> Reading from Plist.</p> <pre><code>func readPropertyList() { var propertyListForamt = PropertyListSerialization.PropertyListFormat.xml //Format of the Property List. var plistData: [String: AnyObject] = [:] //Our data let plistPath: String? = Bundle.main.path(forResource: "data", ofType: "plist")! //the path of the data let plistXML = FileManager.default.contents(atPath: plistPath!)! do {//convert the data to a dictionary and handle errors. plistData = try PropertyListSerialization.propertyList(from: plistXML, options: .mutableContainersAndLeaves, format: &amp;propertyListForamt) as! [String:AnyObject] } catch { print("Error reading plist: \(error), format: \(propertyListForamt)") } } </code></pre> <p><em>Read More <a href="https://makeapppie.com/2016/02/11/how-to-use-property-lists-plist-in-swift/#comment-17173" rel="nofollow">HOW TO USE PROPERTY LISTS (.PLIST) IN SWIFT</a>.</em></p>
<p>in my case I create a <code>NSDictionary</code> called <em><code>appSettings</code></em> and add all needed keys. For this case, the solution is:</p> <pre><code>if let dict = NSBundle.mainBundle().objectForInfoDictionaryKey("appSettings") { if let configAppToken = dict["myKeyInsideAppSettings"] as? String { } } </code></pre>
<p>Here is a bit shorter version, based on @connor 's answer</p> <pre><code>guard let path = Bundle.main.path(forResource: "GoogleService-Info", ofType: "plist"), let myDict = NSDictionary(contentsOfFile: path) else { return nil } let value = dict.value(forKey: "CLIENT_ID") as! String? </code></pre>
<p><a href="https://github.com/BenziAhamed/Plist" rel="nofollow noreferrer">Plist</a> is a simple Swift enum I made for working with property lists.</p> <pre><code>// load an applications info.plist data let info = Plist(NSBundle.mainBundle().infoDictionary) let identifier = info["CFBundleIndentifier"].string! </code></pre> <p>More examples:</p> <pre><code>import Plist // initialize using an NSDictionary // and retrieve keyed values let info = Plist(dict) let name = info["name"].string ?? "" let age = info["age"].int ?? 0 // initialize using an NSArray // and retrieve indexed values let info = Plist(array) let itemAtIndex0 = info[0].value // utility initiaizer to load a plist file at specified path let info = Plist(path: "path_to_plist_file") // we support index chaining - you can get to a dictionary from an array via // a dictionary and so on // don't worry, the following will not fail with errors in case // the index path is invalid if let complicatedAccessOfSomeStringValueOfInterest = info["dictKey"][10]["anotherKey"].string { // do something } else { // data cannot be indexed } // you can also re-use parts of a plist data structure let info = Plist(...) let firstSection = info["Sections"][0]["SectionData"] let sectionKey = firstSection["key"].string! let sectionSecret = firstSection["secret"].int! </code></pre> <p><strong>Plist.swift</strong></p> <p>Plist itself is quite simple, here's its listing in case you to refer directly.</p> <pre><code>// // Plist.swift // import Foundation public enum Plist { case dictionary(NSDictionary) case Array(NSArray) case Value(Any) case none public init(_ dict: NSDictionary) { self = .dictionary(dict) } public init(_ array: NSArray) { self = .Array(array) } public init(_ value: Any?) { self = Plist.wrap(value) } } // MARK:- initialize from a path extension Plist { public init(path: String) { if let dict = NSDictionary(contentsOfFile: path) { self = .dictionary(dict) } else if let array = NSArray(contentsOfFile: path) { self = .Array(array) } else { self = .none } } } // MARK:- private helpers extension Plist { /// wraps a given object to a Plist fileprivate static func wrap(_ object: Any?) -&gt; Plist { if let dict = object as? NSDictionary { return .dictionary(dict) } if let array = object as? NSArray { return .Array(array) } if let value = object { return .Value(value) } return .none } /// tries to cast to an optional T fileprivate func cast&lt;T&gt;() -&gt; T? { switch self { case let .Value(value): return value as? T default: return nil } } } // MARK:- subscripting extension Plist { /// index a dictionary public subscript(key: String) -&gt; Plist { switch self { case let .dictionary(dict): let v = dict.object(forKey: key) return Plist.wrap(v) default: return .none } } /// index an array public subscript(index: Int) -&gt; Plist { switch self { case let .Array(array): if index &gt;= 0 &amp;&amp; index &lt; array.count { return Plist.wrap(array[index]) } return .none default: return .none } } } // MARK:- Value extraction extension Plist { public var string: String? { return cast() } public var int: Int? { return cast() } public var double: Double? { return cast() } public var float: Float? { return cast() } public var date: Date? { return cast() } public var data: Data? { return cast() } public var number: NSNumber? { return cast() } public var bool: Bool? { return cast() } // unwraps and returns the underlying value public var value: Any? { switch self { case let .Value(value): return value case let .dictionary(dict): return dict case let .Array(array): return array case .none: return nil } } // returns the underlying array public var array: NSArray? { switch self { case let .Array(array): return array default: return nil } } // returns the underlying dictionary public var dict: NSDictionary? { switch self { case let .dictionary(dict): return dict default: return nil } } } // MARK:- CustomStringConvertible extension Plist : CustomStringConvertible { public var description:String { switch self { case let .Array(array): return "(array \(array))" case let .dictionary(dict): return "(dict \(dict))" case let .Value(value): return "(value \(value))" case .none: return "(none)" } } } </code></pre>