Swift: function with default parameter before non-default parameter
<p>say I have a function that has non-default parameter after default parameter like this:</p> <pre><code>func f(first:Int = 100, second:Int){} </code></pre> <p>how can I call it and use the default value for the first parameter?</p>
<p>You should have the default parameters at the end of the parameter list.</p> <pre><code>func f(second:Int, first:Int = 100){} f(10) </code></pre> <blockquote> <p>Place parameters with default values at the end of a functionâ€™s parameter list. This ensures that all calls to the function use the same order for their non-default arguments, and makes it clear that the same function is being called in each case.</p> </blockquote> <p><a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html#//apple_ref/doc/uid/TP40014097-CH10-XID_204">Documentation link</a></p>
<p>The current compiler does allow default parameters in the middle of a parameter list.</p> <p><img src="https://i.stack.imgur.com/WFMv4.png" alt="screenshot of Playground"></p> <p>You can call the function like this if you want to use the default value for the <code>first</code> parameter:</p> <pre><code>f(1) </code></pre> <p>If you want to supply a new value for the <code>first</code> parameter, use its external name:</p> <pre><code>f(first: 3, 1) </code></pre> <p>The documentation <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html#//apple_ref/doc/uid/TP40014097-CH10-XID_220" rel="nofollow noreferrer">explains</a> that parameters with a default value are automatically given an external name:</p> <blockquote> <p>Swift provides an automatic external name for any defaulted parameter you define, if you do not provide an external name yourself. The automatic external name is the same as the local name, as if you had written a hash symbol before the local name in your code.</p> </blockquote>
<p>If it is a method on a class, you need to call it like this</p> <pre><code>class Test { func f(first:Int = 100, second:Int) { println("first is \(first)") println("second is \(second)") } func other() { f(second: 4) f(first: 30, second: 5) //f(4) will not compile, and neither will f(9,12) } } </code></pre> <p>If the function f is global, you need to call it like this:</p> <pre><code>f(4) f(first: 30, 5) </code></pre> <p>This prints:</p> <pre><code>first is 100 second is 4 first is 30 second is 5 </code></pre>
<p>On Swift 3:</p> <pre><code>func defaultParameterBefore(_ x: Int = 1, y: Int ) {} </code></pre> <p>Calling</p> <pre><code>defaultParameterBefore(2) </code></pre> <p>will raise this error</p> <pre><code>error: missing argument for parameter 'y' in call </code></pre> <p>The only exception is:</p> <ul> <li>There is a parameter before the default parameter;</li> <li><strong>and</strong> the parameter after the default parameter is a closure;</li> <li><strong>and</strong> the closure parameter is the last parametr;</li> <li><strong>and</strong> calling via trailing closure</li> </ul> <p>For example:</p> <pre><code>func defaultParameterBetween(_ x: Int, _ y: Bool = true, _ z: String) { if y { print(x) } else z() } } // error: missing argument for parameter #3 in call // defaultParameterWithTrailingClosure(1, { print(0) } // Trailing closure does work, though. func defaultParameterWithTrailingClosure(_ x: Int, y: Bool = true, _ z: () -&gt; Void) { if y { print(x) } else { z() } } defaultParameterWithTrailingClosure(1) { print(0) } </code></pre> <p><em>swift version</em>: <code>DEVELOPMENT-SNAPSHOT-2016-04-12</code></p>