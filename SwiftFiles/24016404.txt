Implicitly Unwrapped Optionals in UIViewController init method
<p>As document said “<strong>you’re sure that the optional does contain a value, you can access its underlying value by adding an exclamation mark (!)</strong>”</p> <p>So why UIViewController init method use </p> <p><code>init(nibName nibName: String!,bundle nibBundle: NSBundle!)</code> </p> <p>and tell me "<strong>If you specify nil, the nibName property is set to nil.</strong>"</p> <p>Why not use <code>init(nibName nibName: String?,bundle nibBundle: NSBundle?)</code> instead?</p> <p>I am so confused about this.</p>
<p>I found the following on this <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-XID_26" rel="nofollow">Site</a></p> <blockquote> <p>In some cases, you might be absolutely certain that an Objective-C method or property never returns a nil object reference. To make objects in this special scenario more convenient to work with, Swift imports object types as implicitly unwrapped optionals. Implicitly unwrapped optional types include all of the safety features of optional types. In addition, you can access the value directly without checking for nil or unwrapping it yourself. When you access the value in this kind of optional type without safely unwrapping it first, the implicitly unwrapped optional checks whether the value is missing. If the value is missing, a runtime error occurs. As a result, you should always check and unwrap an implicitly unwrapped optional yourself, unless you are sure that the value cannot be missing.</p> </blockquote> <p>I'm not sure yet if this makes sense.</p>
<p>From my understanding <code>?</code> is used to indicate an optional variable. <code>!</code> is used to access the value of an optional variable. Document says </p> <blockquote> <p>“Once you’re sure that the optional does contain a value, you can access its underlying value by adding an exclamation mark (!)”</p> </blockquote> <p>That means use <code>!</code> only if you are sure it has a non nil value otherwise it will throw error. <strong><em>Its like forcing an optional variable to have value</strong></em>. </p> <p>Then about your question </p> <pre><code>init(nibName nibName: String!,bundle nibBundle: NSBundle!) </code></pre> <p>Here the init function is forcing the caller to pass the values for <code>nibName</code> and <code>nibBundle</code>. It cannot be nil. <code>!</code> is used to make sure that the parameters has a non nil value </p> <p>Note: If iam wrong please correct me, iam just learnig:)</p>
<p><code>!</code> is a pure syntactic sugar. The variable is still an optional; you can use it as a normal optional, passing <code>nil</code>, etc. It's only necessary so that you can simplify to <code>nibName</code> rather than use the full <code>nibName!</code></p> <p>Source&mdash;</p> <blockquote> <p>“These kinds of optionals are defined as implicitly unwrapped optionals. You write an implicitly unwrapped optional by placing an exclamation mark (<code>String!</code>) rather than a question mark (<code>String?</code>) after the type that you want to make optional.” ...</p> <p>“An implicitly unwrapped optional is a normal optional behind the scenes, but can also be used like a nonoptional value, without the need to unwrap the optional value each time it is accessed. ”</p> <p><em>Excerpt From: <a href="https://itunes.apple.com/ru/book/swift-programming-language/id881256329?l=en&amp;mt=11" rel="nofollow">Apple Inc. “The Swift Programming Language.” iBooks</a></em></p> </blockquote>
<pre><code>init(nibName nibName: String!,bundle nibBundle: NSBundle!) </code></pre> <p>Is calling into Objective C framework code. This calls initWithNibName:bundle. You can optionally pass this method's arguments nil. Objective C is fine with that. If you pass nil in initiWithNibName it tries to resolve the name for you based on the name of the class in question. If you pass in nil for bundle it replaces this with [NSBundle mainBundle]. </p> <p>So, Swift makes this parameter an optional. It must do so to permit the variable to optionally be nil. The question is why does it not make it a standard optional and require you to explicitly unwrap it. The answer is that the implicitly unwrapped optional immediately unwraps the optional before passing it to Objective C. You don't want to have to explicitly unwrap this since once you pass your argument in, whether nil or otherwise, you are done setting it. You don't want to have to explicitly unwrap it and then pass it to Objective C! Doing so wouldn't make any sense.</p>