Allowing single digit in UITextField in iOS
<p>I have a <code>Verification ViewController</code>, I get 4 digit verification code by SMS and I need to enter those code to login , I have created the <code>ViewController</code> like this</p> <p><img src="https://i.stack.imgur.com/oLq5Q.png" alt=""></p> <p>As you can see four <code>UITextField</code>s , I need to allow only single digit for each <code>UITextField</code> , </p> <p>What i tried : I was trying to use <code>shouldChangeCharactersInRange:method:</code> , but its not getting called ,I don't know whats wrong, i think because <code>UITextField</code>s are in <code>UITableView</code> so it is not working . </p> <p>Can Anyone suggest me how to solve this issue.</p> <p>thanks</p>
<p>Try this sample tutorial <a href="https://github.com/aporat/KKPasscodeLock" rel="nofollow">passcode lock</a></p> <p><strong>ViewController.h</strong></p> <pre><code>#import &lt;UIKit/UIKit.h&gt; @interface ViewController : UIViewController&lt;UITextFieldDelegate&gt; { IBOutlet UITextField *txtPassword; } @end </code></pre> <p><strong>ViewController.m</strong></p> <pre><code>- (void)viewDidLoad { [super viewDidLoad]; txtPassword.delegate=self; } - (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string { NSUInteger newLength = [textField.text length] + [string length] - range.length; return (newLength &gt; 1) ? NO : YES; } </code></pre>
<p>I have taken one Hidden text field &amp; four imageViews for that with two images. One for Blank and other for Bullet same as iOS default.</p> <p>Also set tags for four imageviews.</p> <p>On Load set Focus for Pin Code</p> <pre><code>- (void)startPinCode { txtPinCodeLockDigits.text = @""; for (int i = 1; i &lt;= 4; i++) { UIImageView *img = (UIImageView *)[self.view viewWithTag:i]; [img setImage:[UIImage imageNamed:@"Img_BG_PinCode.png"]]; } [txtPinCodeLockDigits becomeFirstResponder]; } </code></pre> <p>Then change imageview's images as per user input and only allow four characters</p> <pre><code>- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string { NSString *result = [textField.text stringByReplacingCharactersInRange:range withString:string]; textField.text = result; for (int i = 1; i &lt;= 4; i++) { UIImageView *img = (UIImageView *)[self.view viewWithTag:i]; if (i &lt;= [result length]) [img setImage:[UIImage imageNamed:@"Img_BG_PinCode_Filled.png"]]; else [img setImage:[UIImage imageNamed:@"Img_BG_PinCode.png"]]; } NSLog(@"Result :: %@", result); if ([result length] == 4) { [self performSelector:@selector(keyGenerationForApplication:) withObject:result afterDelay:0.2]; } return NO; } </code></pre> <p>After Four characters call function for generated PIN Code and store it in User Defaults same as iOS default PIN settings</p> <pre><code>- (void)keyGenerationForApplication:(NSString *)pinCode { int appCode = [pinCode intValue]; [DefaultsValues setIntegerValueToUserDefaults:appCode ForKey:PIN_LOCK_PATTERN]; } </code></pre> <p>Here, you can again call <strong>StartPinCode</strong> method for re-confirming code.</p> <p>Hopefully, it'll help you. <br/>Thanks</p>
<p>you can change the textfield like this by using delegate function of text field and initially you need to set the delegate and tag of each text field as 1,2,3,4</p> <pre><code>- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string { if ((textField.text.length &gt;= 1) &amp;&amp; (string.length &gt; 0)) { NSInteger nextTag = textField.tag + 1; // Try to find next responder UIResponder* nextResponder = [textField.superview viewWithTag:nextTag]; if (! nextResponder) nextResponder = [textField.superview viewWithTag:1]; if (nextResponder) // Found next responder, so set it. [nextResponder becomeFirstResponder]; return NO; } return YES; } </code></pre> <p>Here is the Swift 2.0 Code for the same:</p> <pre><code>func textField(textField: UITextField, shouldChangeCharactersInRange range: NSRange, replacementString string: String) -&gt; Bool { // On inputing value to textfield if (textField.text?.characters.count &lt; 1 &amp;&amp; string.characters.count &gt; 0){ let nextTag = textField.tag + 1; // get next responder var nextResponder = textField.superview?.viewWithTag(nextTag); if (nextResponder == nil){ nextResponder = textField.superview?.viewWithTag(1); } textField.text = string; nextResponder?.becomeFirstResponder(); return false; } else if (textField.text?.characters.count &gt;= 1 &amp;&amp; string.characters.count == 0){ // on deleteing value from Textfield let previousTag = textField.tag - 1; // get next responder var previousResponder = textField.superview?.viewWithTag(previousTag); if (previousResponder == nil){ previousResponder = textField.superview?.viewWithTag(1); } textField.text = ""; previousResponder?.becomeFirstResponder(); return false; } return true; } </code></pre>
<p>There's a 4-digit code input text field called <a href="https://github.com/acani/CodeInputView" rel="nofollow">CodeInputView</a> written in Swift.</p>
<p>It can be achieve using UITextField delegate &amp; by setting Tag for each Textfield in increasing order (say 1 - 4), below is the delegate handler to solve the issue.</p> <pre><code>func textField(textField: UITextField, shouldChangeCharactersInRange range: NSRange, replacementString string: String) -&gt; Bool { // On inputing value to textfield if (textField.text?.characters.count &lt; 1 &amp;&amp; string.characters.count &gt; 0){ let nextTag = textField.tag + 1; // get next responder var nextResponder = textField.superview?.viewWithTag(nextTag); if (nextResponder == nil){ nextResponder = textField.superview?.viewWithTag(1); } textField.text = string; nextResponder?.becomeFirstResponder(); return false; } else if (textField.text?.characters.count &gt;= 1 &amp;&amp; string.characters.count == 0){ // on deleteing value from Textfield let previousTag = textField.tag - 1; // get next responder var previousResponder = textField.superview?.viewWithTag(previousTag); if (previousResponder == nil){ previousResponder = textField.superview?.viewWithTag(1); } textField.text = ""; previousResponder?.becomeFirstResponder(); return false; } return true; } </code></pre>
<p>The accepted answer didn't work for me. Here is the obj-C implementation, almost entirely similar to the accepted one, except a few modifications.</p> <pre><code>- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string{ if ((textField.text.length &lt; 1) &amp;&amp; (string.length &gt; 0)) { NSInteger nextTag = textField.tag + 1; UIResponder* nextResponder = [textField.superview viewWithTag:nextTag]; if (! nextResponder){ nextResponder = [textField.superview viewWithTag:1001]; } textField.text = string; if (nextResponder) [nextResponder becomeFirstResponder]; return NO; } // when tapping delete in a field else if ((textField.text.length &gt;= 1) &amp;&amp; (string.length == 0)) { NSInteger prevTag = textField.tag - 1; // Try to find prev responder UIResponder* prevResponder = [textField.superview viewWithTag:prevTag]; if (! prevResponder){ prevResponder = [textField.superview viewWithTag:1001]; } textField.text = string; if (prevResponder) // Found next responder, so set it. [prevResponder becomeFirstResponder]; return NO; } return YES; </code></pre> <p>}</p>
<p>Just use <code>TextFieldDelegate</code> method and check the length of the TextField after every changes</p> <pre><code>func textField(textField: UITextField, shouldChangeCharactersInRange range: NSRange, replacementString string: String) -&gt; Bool { let newString = (textField.text! as NSString).stringByReplacingCharactersInRange(range, withString: string) if newString.characters.count == 1 { nextTextField.becomeFirstResponder() return true } else { return false } } </code></pre>