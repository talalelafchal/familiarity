How to produce a documentation playground (mixing html and swift code)?
<p>Has anyone figured out a nice way to produce a document similar to the GuidedTour.playground with a mix of html sections and swift code without having to do it manually?</p> <p>We can explore the content of the playground file which is a package and it shows html/swift files and a contents.xcplayground xml file describing the structure but it would be nice to be able to create one in a user-friendly way.</p>
<p>I am pretty sure there is no automated workflow (at least no public one) available for now. But why don't create your own if you really need it?</p> <ul> <li>You can use the <strong>great</strong> workflow-automation tool Grunt (<a href="http://gruntjs.com" rel="nofollow">http://gruntjs.com</a>) which is quite often used in the web-industry.</li> <li>You can write your own little script/app (why not in swift itself :D) to parse your custom doc-file (with a predefined syntax to mark code- and documentation sections).</li> </ul> <p>Both ways seam feasible to me, but the question is of course if it is worth it.</p>
<p>Open the playground folder in Sublime or an IDE. You need to edit the .xcplayground extension file within that .playground folder as such where you insert <code>documentation</code> tag right before or after swift <code>code</code> tag. </p> <pre><code>&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt; &lt;playground version='3.0' sdk='macosx'&gt; &lt;sections&gt; &lt;code source-file-name='section-1.swift' hidden="true" /&gt; &lt;documentation relative-path='fragment0.html'/&gt; &lt;code source-file-name='section-3.swift'/&gt; &lt;documentation relative-path='fragment11.html'/&gt; &lt;code source-file-name='section-5.swift'/&gt; &lt;documentation relative-path='fragment21.html'/&gt; &lt;code source-file-name='section-7.swift'/&gt; &lt;documentation relative-path='fragment22.html'/&gt; &lt;code source-file-name='section-9.swift'/&gt; &lt;documentation relative-path='fragment23.html'/&gt; &lt;code source-file-name='section-11.swift'/&gt; &lt;documentation relative-path='fragment24.html'/&gt; &lt;code source-file-name='section-13.swift'/&gt; &lt;documentation relative-path='fragment25.html'/&gt; &lt;code source-file-name='section-15.swift'/&gt; &lt;documentation relative-path='fragment26.html'/&gt; &lt;code source-file-name='section-17.swift'/&gt; &lt;documentation relative-path='fragment27.html'/&gt; &lt;code source-file-name='section-19.swift'/&gt; &lt;documentation relative-path='fragment31.html'/&gt; &lt;code source-file-name='section-21.swift'/&gt; &lt;documentation relative-path='fragment32.html'/&gt; &lt;code source-file-name='section-23.swift'/&gt; &lt;documentation relative-path='fragment33.html'/&gt; &lt;/sections&gt; &lt;timeline fileName='timeline.xctimeline'/&gt; &lt;/playground&gt; </code></pre> <p>The documentation and Swift file and folder structure need to be like this.</p> <p><img src="https://i.stack.imgur.com/IMFnC.png" alt="Folder Structure"></p>
<p>Although the answer currently marked as 'correct' may have been true at the time of writing, there are in fact several ways to do this.</p> <ul> <li>Markdown: Jason Sandmeyer's <code>swift-playground-builder</code> is available on GitHub at <a href="https://github.com/jas/swift-playground-builder" rel="nofollow">https://github.com/jas/swift-playground-builder</a> and can be installed with <code>npm install -g swift-playground-builder</code>. As well has having a command line it can also be programmatically invoked from JavaScript and therefore called from Gulp as well (requires Node.JS and NPM)</li> <li>Asciidoc: James Carlson's <code>ad2play</code> is available on GitHub at <a href="https://github.com/jxxcarlson/ad2play" rel="nofollow">https://github.com/jxxcarlson/ad2play</a> and can be run as a Ruby scriipt (requires Ruby and asciidoctor installed)</li> </ul>
<p>As of version 6.3 this feature is now part of Xcode.</p> <p>Quote from the release note:</p> <blockquote> <p>Improved documentation authoring with inline marked-up comments, inline playground results, the ability to view and edit resources embedded in playgrounds, and the ability to integrate auxiliary source files into Playgrounds. These features enable the creation of rich new experiences in playgrounds.</p> </blockquote>