Convert Float to Int in Swift
<p>I want to convert a <code>Float</code> to an <code>Int</code> in Swift. Basic casting like this does not work because these types are not primitives, unlike <code>float</code>s and <code>int</code>s in Objective-C</p> <pre><code>var float: Float = 2.2 var integer: Int = float as Float </code></pre> <p>But this produces the following error message:</p> <blockquote> <p>'Float' is not convertible to 'Int'</p> </blockquote> <p>Any idea how to property convert from <code>Float</code> to <code>Int</code>?</p>
<p>Use a function style conversion (found in section labeled "Integer and Floating-Point Conversion" from "<a href="https://itun.es/us/jEUH0.l" rel="nofollow">The Swift Programming Language.</a>"[iTunes link])</p> <pre><code> 1&gt; Int(3.4) $R1: Int = 3 </code></pre>
<p>You can type cast like this:</p> <pre><code> var float:Float = 2.2 var integer:Int = Int(float) </code></pre>
<p>Like this:</p> <pre><code>var float:Float = 2.2 // 2.2 var integer:Int = Int(float) // 2 .. will always round down. 3.9 will be 3 var anotherFloat: Float = Float(integer) // 2.0 </code></pre>
<p>You can convert <code>Float</code> to <code>Int</code> in Swift like this:</p> <pre><code>var myIntValue:Int = Int(myFloatValue) println "My value is \(myIntValue)" </code></pre> <p>You can also achieve this result with @paulm's comment:</p> <pre><code>var myIntValue = Int(myFloatValue) </code></pre>
<p>You can get an integer representation of your float by passing the float into the Integer initializer method. </p> <p>Example:</p> <pre><code>Int(myFloat) </code></pre> <p>Keep in mind, that any numbers after the decimal point will be loss. Meaning, 3.9 is an Int of 3 and 8.99999 is an integer of 8. </p>
<h2>Explicit Conversion</h2> <p>Converting to Int will lose any precision (effectively rounding down). By accessing the math libraries you can perform explicit conversions. For example:</p> <p>If you wanted to <B>round down</B> and convert to integer:</p> <pre><code>let f = 10.51 let y = Int(floor(f)) </code></pre> <p>result is 10. </p> <p>If you wanted to <B>round up</B> and convert to integer:</p> <pre><code>let f = 10.51 let y = Int(ceil(f)) </code></pre> <p>result is 11. </p> <p>If you want to <em>explicitly</em> <B>round to the nearest integer</B></p> <pre><code>let f = 10.51 let y = Int(round(f)) </code></pre> <p>result is 11.</p> <p>In the latter case, this might seem pedantic, but it's semantically clearer as there is no implicit conversion...important if you're doing signal processing for example.</p>
<p>Just use type casting</p> <pre><code> var floatValue:Float = 5.4 var integerValue:Int = Int(floatValue) println("IntegerValue = \(integerValue)") </code></pre> <p>it will show roundoff value eg: IntegerValue = 5 means the decimal point will be loss</p>
<pre><code>var floatValue = 10.23 var intValue = Int(floatValue) </code></pre> <p>This is enough to convert from <code>float</code> to <code>Int</code></p>
<pre><code>var i = 1 as Int var cgf = CGFLoat(i) </code></pre>
<p>Converting is simple:</p> <pre><code>let float = Float(1.1) // 1.1 let int = Int(float) // 1 </code></pre> <p>But it is not safe:</p> <pre><code>let float = Float(Int.max) + 1 let int = Int(float) </code></pre> <p>Will due to a nice crash:</p> <pre><code>fatal error: floating point value can not be converted to Int because it is greater than Int.max </code></pre> <p>So I've created an extension that handles overflow:</p> <pre><code>extension Double { // If you don't want your code crash on each overflow, use this function that operates on optionals // E.g.: Int(Double(Int.max) + 1) will crash: // fatal error: floating point value can not be converted to Int because it is greater than Int.max func toInt() -&gt; Int? { if self &gt; Double(Int.min) &amp;&amp; self &lt; Double(Int.max) { return Int(self) } else { return nil } } } extension Float { func toInt() -&gt; Int? { if self &gt; Float(Int.min) &amp;&amp; self &lt; Float(Int.max) { return Int(self) } else { return nil } } } </code></pre> <p>I hope this can help someone</p>
<p>Use <code>Int64</code> instead of <code>Int</code>. <code>Int64</code> can store large int values.</p>
<p>Suppose you store float value in <code>"X"</code> and you are storing integer value in <code>"Y"</code>.</p> <pre><code>Var Y = Int(x); </code></pre> <p>or </p> <pre><code>var myIntValue = Int(myFloatValue) </code></pre>
<p>There are lots of ways to round number with precision. You should eventually use swift's standard library method <code>rounded()</code> to round float number with desired precision.</p> <p>To round <strong>up</strong> use <code>.up</code> rule:</p> <pre><code>let f: Float = 2.2 let i = Int(f.rounded(.up)) // 3 </code></pre> <p>To round <strong>down</strong> use <code>.down</code> rule:</p> <pre><code>let f: Float = 2.2 let i = Int(f.rounded(.down)) // 2 </code></pre> <p>To round to the <strong>nearest</strong> integer use <code>.down</code> rule:</p> <pre><code>let f: Float = 2.2 let i = Int(f.rounded(.toNearestOrEven)) // 2 </code></pre> <p>Be aware of the following example:</p> <pre><code>let f: Float = 2.5 let i = Int(roundf(f)) // 3 let j = Int(f.rounded(.toNearestOrEven)) // 2 </code></pre>