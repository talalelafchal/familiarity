Swift generics: requiring addition and multiplication abilities of a type
<p>I'm trying out some examples from the Swift book, namely the matrix example they have which introduces subscript options. This is the code I have:</p> <pre><code>struct Matrix&lt;T&gt; { let rows: Int, columns: Int var grid: T[] var description: String { return "\(grid)" } init(rows: Int, columns: Int, initialValue: T) { self.rows = rows self.columns = columns grid = Array(count: rows * columns, repeatedValue: initialValue) } func indexIsValidForRow(row: Int, column: Int) -&gt; Bool { return row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; columns } subscript(row: Int, column: Int) -&gt; T { get { assert(indexIsValidForRow(row, column: column), "Index out of range") return grid[(row * columns) + column] } set { assert(indexIsValidForRow(row, column: column), "Index out of range") grid[(row * columns) + column] = newValue } } } </code></pre> <p>This is mostly copied from the book. A major difference is in this line here:</p> <pre><code>struct Matrix&lt;T&gt; </code></pre> <p>As far as I can tell, this says to the compiler that my Matrix class can hold values of type T, specified by the code using this class. Now, I'd like to make sure that the type T can be compared, so I can write this:</p> <pre><code>struct Matrix&lt;T: Equatable&gt; </code></pre> <p>This might be useful in case I want to compare 2 matrices, which would mean comparing their values. I also want to provide the ability to sum two matrices, so I should also add to this line a protocol requiring that the type 'T' given by the user of the matrix can be added:</p> <pre><code>struct Matrix&lt;T: Equatable, "Summable"&gt; </code></pre> <p>Likewise, I'd also like to say:</p> <pre><code>struct Matrix&lt;T: Equatable, "Summable", "Multipliable"&gt; </code></pre> <p><strong>Question 1:</strong> What protocol name can I use? How can I achieve this?</p> <p>On a related note, to add addition abilities using the '+' operator, I should declare a function like this (this applies also to multiplication):</p> <pre><code>@infix func + (m1: Matrix&lt;T&gt;, m2: Matrix&lt;T&gt;) -&gt; Matrix&lt;T&gt; { // perform addition here and return a new matrix return result } </code></pre> <p>However, this code is not accepted by Xcode. More specifically, this <code>) -&gt; Matrix&lt;T&gt; {</code> produces the error: <code>Use of undeclared type 'T'</code>. What I mean by that <code>&lt;T&gt;</code> is that the result will be a matrix that has the same type of the two input matrices, but I'm probably messing the syntax completely.</p> <p><strong>Question 2:</strong> How can I provide type information to the result of the addition?</p>
<p>For <em>Question 1</em> start by defining a protocol</p> <pre><code>protocol Summable { func ignore () } </code></pre> <p>It has a throw away method. Then add it as an extension to the things that you want to be summable.</p> <pre><code>extension Int: Summable { func ignore () {} } </code></pre> <p>[Note: I tried the above w/o a throw away method but got a failure; I suspect Swift needed something, anything in the <code>protocol</code>.]</p> <p>Now a test</p> <pre><code> 35&gt; protocol Summable { func ignore () } 36&gt; extension Int: Summable { func ignore () {} } 37&gt; func testing&lt;T: Summable&gt; (x: T) -&gt; T { return x } 38&gt; testing(1) $R16: (Int) = 1 39&gt; testing(1.2) &lt;REPL&gt;:39:1: error: cannot convert the expression's type '$T1' to type 'Summable' testing(1.2) ^~~~~~~~~~~~ </code></pre> <p>For <em>Question 2</em>, [edit] Use the following</p> <pre><code>@infix func +&lt;T: Summable&gt; (m1: Matrix&lt;T&gt;, m2: Matrix&lt;T&gt;) -&gt; Matrix&lt;T&gt; { ... } </code></pre> <p>[Note: I tried the above in the REPL, which didn't work. But it works in a file (probably defines a 'global environment' which the REPL doesn't)]</p>
<p>Here's for your second question (but you really should ask two separate questions):</p> <pre><code>@infix func + &lt;T&gt; (m1: Matrix&lt;T&gt;, m2: Matrix&lt;T&gt;) -&gt; Matrix&lt;T&gt; { ... } </code></pre> <p>For your first question: before solving it, here's the syntax to define multiple constraints for type parameter:</p> <pre><code>struct Matrix&lt;T where T: Equatable, T: Summable, T: Multipliable&gt; {...} </code></pre> <p>or, as GoZoner writes in the comments:</p> <pre><code>struct Matrix&lt;T: protocol&lt;Equatable, Summable, Multipliable&gt;&gt; {...} </code></pre> <p>But we're not going to need it. First, define a new protocol and list the operations that you need. You can even make it extend <code>Equatable</code>:</p> <pre><code>protocol SummableMultipliable: Equatable { func +(lhs: Self, rhs: Self) -&gt; Self func *(lhs: Self, rhs: Self) -&gt; Self } </code></pre> <p>Then, provide extensions for the types that you want to conform. Here, for <code>Int</code> and <code>Double</code>, the extensions are even empty, as the implementation of the needed ops is built-in:</p> <pre><code>extension Int: SummableMultipliable {} extension Double: SummableMultipliable {} </code></pre> <p>Then, declare your type constraint on the type parameter:</p> <pre><code>struct Matrix&lt;T: SummableMultipliable&gt; { ... } </code></pre> <p>Finally, you can write stuff like this:</p> <pre><code>let intMat = Matrix&lt;Int&gt;(rows: 3, columns: 3, initialValue: 0) let doubleMat = Matrix&lt;Double&gt;(rows: 3, columns: 3, initialValue: 0) let i: Int = intMat[0,0] let d: Double = doubleMat[0,0] </code></pre> <p>The last thing you'll need is to insert the type constraint in the definition of your operator:</p> <pre><code>@infix func + &lt;T: SummableMultipliable&gt; (m1: Matrix&lt;T&gt;, m2: Matrix&lt;T&gt;) -&gt; Matrix&lt;T&gt; { ... } </code></pre>