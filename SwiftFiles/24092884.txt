Get nth character of a string in Swift programming language
<p>How can I get the nth character of a string? I tried bracket(<code>[]</code>) accessor with no luck. </p> <pre><code>var string = "Hello, world!" var firstChar = string[0] // Throws error </code></pre>
<p>The swift string class does not provide the ability to get a character at a specific index because of its native support for UTF characters. The variable length of a UTF character in memory makes jumping directly to a character impossible. That means you have to manually loop over the string each time.</p> <p>You can extend String to provide a method that will loop through the characters until your desired index</p> <pre><code>extension String { func characterAtIndex(index: Int) -&gt; Character? { var cur = 0 for char in self { if cur == index { return char } cur++ } return nil } } myString.characterAtIndex(0)! </code></pre>
<p>Swift's <code>String</code> type does not provide a <code>characterAtIndex</code> method because there are several ways a Unicode string could be encoded. Are you going with UTF8, UTF16, or something else?</p> <p>You can access the <code>CodeUnit</code> collections by retrieving the <code>String.utf8</code> and <code>String.utf16</code> properties. You can also access the <code>UnicodeScalar</code> collection by retrieving the <code>String.unicodeScalars</code> property.</p> <p>In the spirit of <code>NSString</code>'s implementation, I'm returning a <code>unichar</code> type.</p> <pre><code>extension String { func characterAtIndex(index:Int) -&gt; unichar { return self.utf16[index] } // Allows us to use String[index] notation subscript(index:Int) -&gt; unichar { return characterAtIndex(index) } } let text = "Hello Swift!" let firstChar = text[0] </code></pre>
<pre><code>extension String { subscript (i: Int) -&gt; Character { return self[self.startIndex.advancedBy(i)] } subscript (i: Int) -&gt; String { return String(self[i] as Character) } subscript (r: Range&lt;Int&gt;) -&gt; String { let start = startIndex.advancedBy(r.startIndex) let end = start.advancedBy(r.endIndex - r.startIndex) return self[Range(start ..&lt; end)] } } </code></pre> <p>Now, these all equal true.</p> <pre><code>"abcde"[0] == "a" "abcde"[0...2] == "abc" "abcde"[2..&lt;4] == "cd" </code></pre>
<p>I just came up with this neat workaround</p> <pre><code>var firstChar = Array(string)[0] </code></pre>
<p>No indexing using integers, only using <code>String.Index</code>. Mostly with linear complexity. You can also create ranges from <code>String.Index</code> and get substrings using them.</p> <p><em>Swift 3.0</em></p> <pre><code>let firstChar = someString[someString.startIndex] let lastChar = someString[someString.index(before: someString.endIndex)] let charAtIndex = someString[someString.index(someString.startIndex, offsetBy: 10)] let range = someString.startIndex..&lt;someString.index(someString.startIndex, offsetBy: 10) let subtring = someString[range] </code></pre> <p><em>Swift 2.x</em></p> <pre><code>let firstChar = someString[someString.startIndex] let lastChar = someString[someString.endIndex.predecessor()] let charAtIndex = someString[someString.startIndex.advanceBy(10)] let range = someString.startIndex..&lt;someString.startIndex.advanceBy(10) let subtring = someString[range] </code></pre> <p>Note that you can't ever use an index (or range) created from one string to another string</p> <pre><code>let index10 = someString.startIndex.advanceBy(10) //will compile //sometimes it will work but sometimes it will crash or result in undefined behaviour let charFromAnotherString = anotherString[index10] </code></pre>
<p>In order to feed the subject and show swift subscript possibilities, here's a little string "substring-toolbox" subscript based</p> <p>These methods are safe and never go over string indexes</p> <pre><code>extension String { // string[i] -&gt; one string char subscript(pos: Int) -&gt; String { return String(Array(self)[min(self.length-1,max(0,pos))]) } // string[pos,len] -&gt; substring from pos for len chars on the left subscript(pos: Int, len: Int) -&gt; String { return self[pos, len, .pos_len, .left2right] } // string[pos, len, .right2left] -&gt; substring from pos for len chars on the right subscript(pos: Int, len: Int, way: Way) -&gt; String { return self[pos, len, .pos_len, way] } // string[range] -&gt; substring form start pos on the left to end pos on the right subscript(range: Range&lt;Int&gt;) -&gt; String { return self[range.startIndex, range.endIndex, .start_end, .left2right] } // string[range, .right2left] -&gt; substring start pos on the right to end pos on the left subscript(range: Range&lt;Int&gt;, way: Way) -&gt; String { return self[range.startIndex, range.endIndex, .start_end, way] } var length: Int { return countElements(self) } enum Mode { case pos_len, start_end } enum Way { case left2right, right2left } subscript(var val1: Int, var val2: Int, mode: Mode, way: Way) -&gt; String { if mode == .start_end { if val1 &gt; val2 { let val=val1 ; val1=val2 ; val2=val } val2 = val2-val1 } if way == .left2right { val1 = min(self.length-1, max(0,val1)) val2 = min(self.length-val1, max(1,val2)) } else { let val1_ = val1 val1 = min(self.length-1, max(0, self.length-val1_-val2 )) val2 = max(1, (self.length-1-val1_)-(val1-1) ) } return self.bridgeToObjectiveC().substringWithRange(NSMakeRange(val1, val2)) //-- Alternative code without bridge -- //var range: Range&lt;Int&gt; = pos...(pos+len-1) //var start = advance(startIndex, range.startIndex) //var end = advance(startIndex, range.endIndex) //return self.substringWithRange(Range(start: start, end: end)) } } println("0123456789"[3]) // return "3" println("0123456789"[3,2]) // return "34" println("0123456789"[3,2,.right2left]) // return "56" println("0123456789"[5,10,.pos_len,.left2right]) // return "56789" println("0123456789"[8,120,.pos_len,.right2left]) // return "01" println("0123456789"[120,120,.pos_len,.left2right]) // return "9" println("0123456789"[0...4]) // return "01234" println("0123456789"[0..4]) // return "0123" println("0123456789"[0...4,.right2left]) // return "56789" println("0123456789"[4...0,.right2left]) // return "678" &lt;&lt; because ??? range can wear endIndex at 0 ??? </code></pre>
<p>My solution is in one line, supposing cadena is the string and 4 is the nth position that you want:</p> <pre><code>let character = cadena[advance(cadena.startIndex, 4)] </code></pre> <p>Simple... I suppose Swift will include more things about substrings in future versions.</p>
<h2>String supports subscript (access with <strong>[ ]</strong> ) out of the box:</h2> <p><em>Swift 3.0.1</em></p> <pre><code>let str = "Hello, world!" let index = str.index(str.startIndex, offsetBy: 4) str[index] // returns Character 'o' let endIndex = str.index(str.endIndex, offsetBy:-2) str[Range(index ..&lt; endIndex)] // returns String "o, worl" str.substring(from: index) // returns String "o, world!" str.substring(to: index) // returns String "Hell" </code></pre> <hr> <h2>Alternatively you can use this more neat syntax:</h2> <pre><code>let str = "abcdef" str[1 ..&lt; 3] // returns "bc" str[5] // returns "f" str[80] // returns "" str.substring(from: 3) // returns "def" str.substring(to: str.length - 2) // returns "abcd" </code></pre> <p>... but for that you'd need to add this String extension (fully tested):</p> <pre><code>extension String { var length: Int { return self.characters.count } subscript (i: Int) -&gt; String { return self[Range(i ..&lt; i + 1)] } func substring(from: Int) -&gt; String { return self[Range(min(from, length) ..&lt; length)] } func substring(to: Int) -&gt; String { return self[Range(0 ..&lt; max(0, to))] } subscript (r: Range&lt;Int&gt;) -&gt; String { let range = Range(uncheckedBounds: (lower: max(0, min(length, r.lowerBound)), upper: min(length, max(0, r.upperBound)))) let start = index(startIndex, offsetBy: range.lowerBound) let end = index(start, offsetBy: range.upperBound - range.lowerBound) return self[Range(start ..&lt; end)] } } </code></pre>
<p>first(str) // retrieve first letter</p> <p>More here: <a href="http://sketchytech.blogspot.com/2014/08/swift-pure-swift-method-for-returning.html" rel="nofollow">http://sketchytech.blogspot.com/2014/08/swift-pure-swift-method-for-returning.html</a></p>
<p>If you see <code>Cannot subscript a value of type 'String'...</code> use this extension:</p> <p><strong>Swift 3</strong></p> <pre><code>extension String { subscript (i: Int) -&gt; Character { return self[self.characters.index(self.startIndex, offsetBy: i)] } subscript (i: Int) -&gt; String { return String(self[i] as Character) } subscript (r: Range&lt;Int&gt;) -&gt; String { let start = index(startIndex, offsetBy: r.lowerBound) let end = index(startIndex, offsetBy: r.upperBound) return self[start..&lt;end] } subscript (r: ClosedRange&lt;Int&gt;) -&gt; String { let start = index(startIndex, offsetBy: r.lowerBound) let end = index(startIndex, offsetBy: r.upperBound) return self[start...end] } } </code></pre> <p><strong>Swift 2.3</strong></p> <pre><code>extension String { subscript(integerIndex: Int) -&gt; Character { let index = advance(startIndex, integerIndex) return self[index] } subscript(integerRange: Range&lt;Int&gt;) -&gt; String { let start = advance(startIndex, integerRange.startIndex) let end = advance(startIndex, integerRange.endIndex) let range = start..&lt;end return self[range] } } </code></pre> <p>Source: <a href="http://oleb.net/blog/2014/07/swift-strings/" rel="nofollow noreferrer">http://oleb.net/blog/2014/07/swift-strings/</a></p>
<p>I just had the same issue. Simply do this:</p> <pre><code>var aString: String = "test" var aChar:unichar = (aString as NSString).characterAtIndex(0) </code></pre>
<h2>Swift 2.2 Solution:</h2> <p>The following extension works in Xcode 7, this is a combination of <a href="http://oleb.net/blog/2014/07/swift-strings/" rel="nofollow">this</a> solution and Swift 2.0 syntax conversion. </p> <pre><code>extension String { subscript(integerIndex: Int) -&gt; Character { let index = startIndex.advancedBy(integerIndex) return self[index] } subscript(integerRange: Range&lt;Int&gt;) -&gt; String { let start = startIndex.advancedBy(integerRange.startIndex) let end = startIndex.advancedBy(integerRange.endIndex) let range = start..&lt;end return self[range] } } </code></pre>
<p>Update for swift 2.0 subString </p> <pre><code>public extension String { public subscript (i: Int) -&gt; String { return self.substringWithRange(self.startIndex..&lt;self.startIndex.advancedBy(i + 1)) } public subscript (r: Range&lt;Int&gt;) -&gt; String { get { return self.substringWithRange(self.startIndex.advancedBy(r.startIndex)..&lt;self.startIndex.advancedBy(r.endIndex)) } } } </code></pre>
<p><strong>Swift 2.0 as of Xcode 7 GM Seed</strong></p> <pre><code>var text = "Hello, world!" let firstChar = text[text.startIndex.advancedBy(0)] // "H" </code></pre> <p>For the nth character, replace 0 with n-1.</p> <p><strong>Edit: Swift 3.0</strong></p> <pre><code>text[text.index(text.startIndex, offsetBy: 0)] </code></pre> <p><br /> n.b. there are simpler ways of grabbing certain characters in the string</p> <p>e.g. <code>let firstChar = text.characters.first</code></p>
<p>As an aside note, there are a few functions applyable directly to the Character-chain representation of a String, like this:</p> <pre><code>var string = "Hello, playground" let firstCharacter = string.characters.first // returns "H" let lastCharacter = string.characters.last // returns "d" </code></pre> <p>The result is of type Character, but you can cast it to a String.</p> <p>Or this:</p> <pre><code>let reversedString = String(string.characters.reverse()) // returns "dnuorgyalp ,olleH" </code></pre> <p>:-)</p>
<p>A python-like solution, which allows you to use negative index, </p> <pre><code>var str = "Hello world!" str[-1] // "!" </code></pre> <p>could be:</p> <pre><code>extension String { subscript (var index:Int)-&gt;Character{ get { let n = distance(self.startIndex, self.endIndex) index %= n if index &lt; 0 { index += n } return self[advance(startIndex, index)] } } } </code></pre> <p>By the way, it may be worth it to transpose the whole <a href="http://stackoverflow.com/questions/509211/explain-pythons-slice-notation">python's slice notation</a></p>
<h1>One Line</h1> <pre><code>str = "My String" </code></pre> <p><strong><em>CharAtIndex n</em></strong></p> <pre><code>let charAtIndex = String(str[str.startIndex.advancedBy(3)]) // charAtIndex = "S" </code></pre> <p>Swift 2</p> <pre><code>str[str.index(str.startIndex, offsetBy: 3)] </code></pre> <p><strong><em>SubString fromIndex toIndex</em></strong></p> <pre><code>let subStr = str[str.startIndex.advancedBy(3)...str.startIndex.advancedBy(7)] // subStr = "Strin" </code></pre> <p>Swift 3</p> <pre><code>str[str.index(str.startIndex, offsetBy: 3)...str.index(str.startIndex, offsetBy: 7)] </code></pre> <p><strong><em>First n chars</em></strong></p> <pre><code>let first2Chars = String(str.characters.prefix(2)) // first2Chars = "My" </code></pre> <p><strong><em>Last n chars</em></strong></p> <pre><code>let last3Chars = String(str.characters.suffix(3)) // last3Chars = "ing" </code></pre>
<p>You could use SwiftString (<a href="https://github.com/amayne/SwiftString" rel="nofollow">https://github.com/amayne/SwiftString</a>) to do this.</p> <pre><code>"Hello, world!"[0] // H "Hello, world!"[0...4] // Hello </code></pre> <p>DISCLAIMER: I wrote this extension</p>
<p>used swift code (xcode 7.2.1) below to convert double to 2 parts to get one whole number for dollars &amp; one whole number for cents. Using string method makes it too complex for handling exceptions when different currency settings apply (eg. US$ 1,234.56 vs EUR 1.234,56)</p> <p>convert = 45.6785 </p> <pre><code>let nr = Double(convert) let firstPart = Int(nr) let digitPart = (nr-Double(firstPart))*100 let digits = Int(digitPart) </code></pre> <p>Result: firstpart = 45 digits = 67</p>
<p>You can also convert String to Array of Characters like that:</p> <pre><code>let text = "My Text" let index = 2 let charSequence = text.unicodeScalars.map{ Character($0) } let char = charSequence[index] </code></pre> <p>This is the way to get char at specified index in constant time.</p> <p>The example below doesn't run in constant time, but requires linear time. So If You have a lot of searching in String by index use the method above.</p> <pre><code>let char = text[text.startIndex.advancedBy(index)] </code></pre>
<p>I think that a fast answer for get the first character could be:</p> <pre><code>let firstCharacter = aString[aString.startIndex] </code></pre> <p>It's so much elegant and performance than: </p> <pre><code>let firstCharacter = Array(aString.characters).first </code></pre> <p>But.. if you want manipulate and do more operations with strings you could think create an extension..here is one extension with this approach, it's quite similar to that already posted here:</p> <pre><code>extension String { var length : Int { return self.characters.count } subscript(integerIndex: Int) -&gt; Character { let index = startIndex.advancedBy(integerIndex) return self[index] } subscript(integerRange: Range&lt;Int&gt;) -&gt; String { let start = startIndex.advancedBy(integerRange.startIndex) let end = startIndex.advancedBy(integerRange.endIndex) let range = start..&lt;end return self[range] } </code></pre> <p>}</p> <p>BUT IT'S A TERRIBLE IDEA!! </p> <p>The extension below is horribly inefficient. Every time a string is accessed with an integer, an O(n) function to advance its starting index is run. Running a linear loop inside another linear loop means this for loop is accidentally O(n2) — as the length of the string increases, the time this loop takes increases quadratically.</p> <p>Instead of doing that you could use the characters's string collection.</p>
<p><strong>Xcode 8.1 • Swift 3.0.1</strong></p> <pre><code>extension String { subscript(i: Int) -&gt; String { guard i &gt;= 0 &amp;&amp; i &lt; characters.count else { return "" } return String(self[index(startIndex, offsetBy: i)]) } subscript(range: CountableRange&lt;Int&gt;) -&gt; String { let lowerIndex = index(startIndex, offsetBy: max(0,range.lowerBound), limitedBy: endIndex) ?? endIndex return self[lowerIndex..&lt;(index(lowerIndex, offsetBy: range.upperBound - range.lowerBound, limitedBy: endIndex) ?? endIndex)] } subscript(range: ClosedRange&lt;Int&gt;) -&gt; String { let lowerIndex = index(startIndex, offsetBy: max(0,range.lowerBound), limitedBy: endIndex) ?? endIndex return self[lowerIndex..&lt;(index(lowerIndex, offsetBy: range.upperBound - range.lowerBound + 1, limitedBy: endIndex) ?? endIndex)] } } </code></pre>
<p><strong>Swift 3</strong></p> <pre><code>extension String { public func charAt(_ i: Int) -&gt; Character { return self[self.characters.index(self.startIndex, offsetBy: i)] } public subscript (i: Int) -&gt; String { return String(self.charAt(i) as Character) } public subscript (r: Range&lt;Int&gt;) -&gt; String { return substring(with: self.characters.index(self.startIndex, offsetBy: r.lowerBound)..&lt;self.characters.index(self.startIndex, offsetBy: r.upperBound)) } public subscript (r: CountableClosedRange&lt;Int&gt;) -&gt; String { return substring(with: self.characters.index(self.startIndex, offsetBy: r.lowerBound)..&lt;self.characters.index(self.startIndex, offsetBy: r.upperBound)) } } </code></pre> <p><strong>Usage</strong></p> <pre><code>let str = "Hello World" let sub = str[0...4] </code></pre> <p><em><a href="https://gist.github.com/chess92" rel="nofollow">Helpful Programming Tips and Tricks (written by me)</a></em></p>
<p>I wanted to point out that if you have a large string and need to randomly access many characters from it, you may want to pay the extra memory cost and convert the string to an array for better performance:</p> <pre><code>// Pay up front for O(N) memory let chars = Array(veryLargeString.characters) for i in 0...veryLargeNumber { // Benefit from O(1) access print(chars[i]) } </code></pre>
<p><strong>In Swift 3</strong></p> <pre><code> let mystring = "Hello, world!" let stringToArray = Array(mystring.characters) let indices = (stringToArray.count)-1 print(stringToArray[0]) //H print(stringToArray[indices]) //! </code></pre>
<p>In Swift 3 without extensions to the String class, as simple as I can make it!</p> <pre><code>let myString = "abcedfg" let characterLocationIndex = myString.index(myString.startIndex, offsetBy: 3) let myCharacter = myString[characterLocationIndex] </code></pre> <p>myCharacter is "3" in this example.</p>
<p>Using <strong>characters</strong> would do the job. You can quickly convert the <strong>String</strong> to an array of characters that can be manipulated by the CharacterView methods.</p> <p>Example:</p> <pre><code>let myString = "Hello World!" let myChars = myString.characters </code></pre> <p>(full <a href="http://swiftdoc.org/v3.0/type/String.CharacterView/" rel="nofollow noreferrer">CharacterView</a> doc)</p> <p>(tested in Swift 3)</p>