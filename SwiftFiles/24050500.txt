Swift isa pointer remapping or other supported method swizzling
<p>Do Swift classes have something like an isa pointer that can be remapped? </p> <p>We've seen that Swift <a href="http://stackoverflow.com/a/24020950/404201">uses a more static method dispatch</a> than objective-C, which (unless a class dervices from Foundation/NSObject) prevents the style of swizzling based on remapping method implementations at runtime.</p> <p>I'm wondering how we'll implement method interception-based dynamic features like the observer pattern, notifications, etc? Currently all this stuff is provided by the Objective-C layer, and can be easily integrated into Swift. But, if we want to provide these kinds of features in a framework (or app) of our own, is it necessary to implement them in Objective-C? I would assume there's a way to do it 'natively'. </p> <p>Another kind of swizzling common to objective-C is remapping the isa-pointer to generate a sub-class on the fly. Is this kind of swizzling supported in Swift? If not what <strong><em>is</em></strong> the supported way of intercepting arbitrary method invocations?</p> <p><strong>Edit:</strong> <em>As @jatoben points out, as of arm64 isa-remapping must be done by calling object_setClass() and not by accessing the value directly. This is still referred to as 'isa pointer swizzling'</em></p>
<p>I can't answer your question about swift "isa" equivalent, but I think I know part of the answer to your underlying question.</p> <p><em>Property Observers</em> seem to be the built-in means for the Observer Pattern. Instead of runtime discovery of "type" (RTTI, what-have-you) it is woven in explicitly.</p> <p>From 'The Swift Programming Language' page 345:</p> <blockquote> <p>Property observers observe and respond to changes in a property's value. Property observers are called every time a property's value is set, even if the new value is the same as the property's current value.</p> <p>You can add property observers to any stored properties you define, apart from lazy stored properties. You can also add property observers to any inherited property (whether stored or computed) by overriding the property within a subclass.</p> <p>You have the option to define either or both of these observers on a property:</p> <ul> <li>willSet is called just before the value is stored.</li> <li>didSet is called immediately after the new value is stored.</li> </ul> </blockquote> <p>I am not sure how this is all going to work out, but I am intrigued.</p> <p>Relying on run-time type discovery also seems to run counter to strong static type orthodoxy.</p>
<p>It looks like both method exchanging and the isa pointer remapping technique only works if the Swift class has NSObject as a super-class (either directly or further up). It does not currently work, when the Swift class has no super-class or some other non-Foundation base class. </p> <p>The following test shows this: </p> <p><strong>Class: Birdy</strong></p> <pre><code>class Birdy: NSObject { func sayHello() { println("tweet tweet") } } </code></pre> <p><strong>Class: HodorBirdy</strong></p> <pre><code>class HodorBirdy: Birdy { override func sayHello() { super.sayHello() println("hodor hodor") } } </code></pre> <p><strong>Test:</strong></p> <pre><code>func testExample() { var birdy : Birdy = Birdy() object_setClass(birdy, HodorBirdy.self) birdy.sayHello(); } </code></pre> <p>And the output was as expected: </p> <pre><code>tweet tweet hodor hodor </code></pre> <p>In this test both the base-class and sub-class were created in advance. Though they could also be created dynamically using the Objective-C runtime as long as the class has NSObject as an ancestor.</p> <p>When a Swift class does not derive from the Objective-C foundation, then the compiler will favor static- or vtable-based dispatch, therefore its not clear how method interception will work at all in this case! </p> <p>Unless the language/compiler make a specific allowance for it, we'll be foregoing dynamism in favor of performance. (Interception, which is the foundation of 'dynamic' behaviors can either be done at compile-time or run-time. In the case of static- or vtable-dispatch without a virtual machine, only compile-time applies). </p>