Can an [AnyObject] array be optionally downcast to a type-specific array?
<p>I'm reading through the Swift documentation, looking at the section regarding type casting.</p> <p>The documentation talks about getting an array of type <code>[AnyObject]</code> from Foundation frameworks stuff (what would be an <code>NSArray *</code> in Objective-C).</p> <p>First, the documentation provides this example:</p> <pre><code>for object in someObjects { let movie = object as Movie println("Movie: '\(movie.name)', dir. \(movie.director)") } </code></pre> <p>Now, I want to change the example slightly, to a case where I don't know all the objects are of type <code>Movie</code>, so I'd do this:</p> <pre><code>for object in someObject { if let movie = object as? Movie { println("Movie: '\(movie.name', dir. \(movie.director)") } } </code></pre> <p>The documentation then provides an example of a better way to write the first loop:</p> <pre><code>for movie in someObjects as [Movie] { println("Movie: '\(movie.name)', dir. \(movie.director)") } </code></pre> <p>Where we downcast <code>someObjects</code> from an <code>[AnyObject]</code> to a <code>[Movie]</code> so we don't have to downcast within the loop.</p> <p>And this got me thinking, can the array be option downcast as a whole?</p> <pre><code>if let someMovies = someObjects as? [Movie] { for movie in someMovies { println("Movie: '\(movie.name)', dir. \(movie.director)") } } </code></pre> <p>Does this work? And if so, how bad is this from a performance standpoint? How long would it take to check the type of every object in a 10,000 element array using the optional downcast?</p> <p>I understand that the implications between this snippet and my previous optional downcast snippet are different. The first will iterate through every object and only attempt to print if the object is a <code>Movie</code>, where the second will only enter the loop if the array can be downcast to a <code>[Movie]</code> array, in which case it will either print all or none, but I can imagine there are situations where this would be preferable.</p>
<p>Let's try this</p> <pre><code>var someObjects = [ NSString(), NSUUID() ] let uuids = someObjects as? NSUUID[] </code></pre> <p><code>uuids</code> is nil</p> <pre><code>var someOtherObjects = [ NSUUID(), NSUUID() ] let all_uuids = someOtherObjects as? NSUUID[] </code></pre> <p><code>all_uuids</code> is equal to <code>someOtherObjects</code></p> <p>So it looks like it does work. You can use the expression to test if all elements of the array are of the expected type but it will not filter the array to select only the expected type.</p>
<p>You've got it -- it works exactly like your example code:</p> <pre><code>let strings = ["Hi", "Hello", "Aloha"] let anyObjects: [AnyObject] = strings if let downcastStrings = anyObjects as? [String] { println("It's a [String]") } // console says "It's a [String]" </code></pre> <p>No idea about performance, but I wouldn't assume that it will have to iterate through the full array to determine if a downcast is possible.</p> <hr> <p>So I got curious, and ran a quick test with 100,000 simple values in a couple different <code>[AnyObject]</code> configurations, where I'm trying to downcast the array to a <code>[String]</code> vs. downcasting the individual elements:</p> <pre class="lang-none prettyprint-override"><code>// var anyObjects: [AnyObject] = [AnyObject]() // filled with random assortment of Int, String, Double, Bool Running test with mixed array downcast array execution time = 0.000522 downcast elements execution time = 0.571749 // var actuallyStrings: [AnyObject] = [AnyObject]() // filled with String values Running test with all strings downcast array execution time = 1.141267 downcast elements execution time = 0.853765 </code></pre> <p>It looks like it's super fast to dismiss the mixed array as non-downcastable, since it just needs to scan until it finds a non-<code>String</code> element. For an array that it <em>can</em> downcast, it clearly has to crunch through the whole array, and takes much longer, although I'm not sure why it's not the same speed as looping through the array and manually checking each element.</p>