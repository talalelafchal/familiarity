How to get download progress in AFNetworking 2.0?
<p>I am using AFURLSessionManager to create a new download task:</p> <pre><code>AFURLSessionManager* manager = ... NSProgress* p = nil; NSURLSessionDownloadTask* downloadTask = [manager downloadTaskWithRequest:request progress:&amp;p destination:^NSURL*(NSURL* targetPath, NSURLResponse* response) {...} completionHandler:^(NSURLResponse* response, NSURL* filePath, NSError* error) {...} ]; [downloadTask resume]; </code></pre> <p>The file gets downloaded fine, however, how do I get progress notifications? </p> <p><code>p</code> is always set to nil. I've filed an <a href="https://github.com/AFNetworking/AFNetworking/issues/1418">issue</a> for that.</p> <p>I've also tried to call <code>setDownloadTaskDidWriteDataBlock</code> on the manager, and I do get progress notifications there but I receive them all grouped together <em>after</em> the file has been downloaded.</p> <p>Seems like this area is still a bit buggy in AFNetworking 2.0</p> <p>Any ideas?</p>
<p>You should observe the <code>fractionCompleted</code> property of your <code>NSProgress</code> object using KVO:</p> <pre><code>NSURL *url = [NSURL URLWithString:@"http://www.hfrmovies.com/TheHobbitDesolationOfSmaug48fps.mp4"]; NSURLRequest *request = [NSURLRequest requestWithURL:url]; AFHTTPSessionManager *session = [AFHTTPSessionManager manager]; NSProgress *progress; NSURLSessionDownloadTask *downloadTask = [session downloadTaskWithRequest:request progress:&amp;progress destination:^NSURL *(NSURL *targetPath, NSURLResponse *response) { // … } completionHandler:^(NSURLResponse *response, NSURL *filePath, NSError *error) { [progress removeObserver:self forKeyPath:@"fractionCompleted" context:NULL]; // … }]; [downloadTask resume]; [progress addObserver:self forKeyPath:@"fractionCompleted" options:NSKeyValueObservingOptionNew context:NULL]; </code></pre> <p>Then add the observer method:</p> <pre><code>- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context { if ([keyPath isEqualToString:@"fractionCompleted"]) { NSProgress *progress = (NSProgress *)object; NSLog(@"Progress… %f", progress.fractionCompleted); } else { [super observeValueForKeyPath:keyPath ofObject:object change:change context:context]; } } </code></pre> <p>Of course, you should check <code>keyPath</code> and/or <code>object</code> parameters to decide if that's the object/property you want to observe.</p> <p>You can also use the <code>setDownloadTaskDidWriteDataBlock:</code> method from <code>AFURLSessionManager</code> (from which <code>AFHTTPSessionManager</code> inherits) to set a block for receiving download progress updates.</p> <pre><code>[session setDownloadTaskDidWriteDataBlock:^(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite) { NSLog(@"Progress… %lld", totalBytesWritten); }]; </code></pre> <p>This AFNetworking method maps the <code>URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:</code> method from <code>NSURLSessionDownloadDelegate</code> protocol to a more convenient block mechanism.</p> <p>BTW, Apple's KVO implementation is severely broken. I recommend using a better implementation like the one proposed by Mike Ash with <a href="https://github.com/mikeash/MAKVONotificationCenter">MAKVONotificationCenter</a>. If you are interested in reading why Apple's KVO is broken, read <a href="https://mikeash.com/pyblog/key-value-observing-done-right.html">Key-Value Observing Done Right</a> by Mike Ash.</p>
<p>I faced a similar problem, and found a solution. </p> <p>Check the link below: <a href="http://cocoadocs.org/docsets/AFNetworking/2.0.1/Categories/UIProgressView+AFNetworking.html">http://cocoadocs.org/docsets/AFNetworking/2.0.1/Categories/UIProgressView+AFNetworking.html</a></p> <pre><code>#import &lt;AFNetworking/UIKit+AFNetworking.h&gt; </code></pre> <p>and use the additional method available to your UIProgressView</p> <p>setProgressWithDownloadProgressOfTask:animated:</p> <p>How I did it:</p> <pre><code>NSURLSessionDownloadTask *downloadTask = [manager downloadTaskWithRequest:request progress:nil destination:^NSURL *(NSURL *targetPath, NSURLResponse *response){ NSURL *documentsDirectoryPath = [NSURL fileURLWithPath:[NSSearchPathForDirectoriesInDomains(NSDocumentationDirectory, NSUserDomainMask, YES) firstObject]]; return [documentsDirectoryPath URLByAppendingPathComponent:[targetPath lastPathComponent]]; } completionHandler:^(NSURLResponse *response, NSURL *filePath, NSError *error){ NSLog(@"File downloaded to: %@", filePath); }]; [self.progressView setProgressWithDownloadProgressOfTask:downloadTask animated:YES]; [downloadTask resume]; </code></pre>
<p>Simple solutions for Swift:</p> <pre><code>let sessionConfiguration = NSURLSessionConfiguration.defaultSessionConfiguration() let sessionManager = AFURLSessionManager(sessionConfiguration: sessionConfiguration) let request = NSURLRequest(URL: url) let sessionDownloadTask = sessionManager.downloadTaskWithRequest(request, progress: nil, destination: { (url, response) -&gt; NSURL in return destinationPath.URLByAppendingPathComponent(fileName) //this is destinationPath for downloaded file }, completionHandler: { response, url, error in //do sth when it finishes }) </code></pre> <p>Now you have 2 options:</p> <ol> <li><p>Using <code>UIProgressView</code> and <code>setProgressWithDownloadProgressOfTask:</code></p> <pre><code>progressView.setProgressWithDownloadProgressOfTask(sessionDownloadTask, animated: true) </code></pre></li> <li><p>Using <code>AFURLSessionManager</code> and <code>setDownloadTaskDidWriteDataBlock:</code></p> <pre><code>sessionManager.setDownloadTaskDidWriteDataBlock { session, sessionDownloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite in let progress = Float(totalBytesWritten)/Float(totalBytesExpectedToWrite) //do sth with current progress } </code></pre></li> </ol> <p>At the end do not forget about:</p> <pre><code>sessionDownloadTask.resume() </code></pre>