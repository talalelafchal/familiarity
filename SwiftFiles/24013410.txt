How to parse a JSON file in swift?
<p>I have a JSON file, want to parse and use list of objects in table view. Can any one share the code to parse JSON file in swift. </p>
<p>How to call a web service and get a response in Swift <a href="http://iosdevcenters.blogspot.com/2015/12/nsurlrequest-in-swift.html" rel="nofollow"><strong>Check IT</strong></a></p> <p><strong>Making the API Request</strong></p> <pre><code>var request: NSURLRequest = NSURLRequest(URL: url) var connection: NSURLConnection = NSURLConnection(request: request, delegate: self, startImmediately: false) </code></pre> <p><strong>Preparing for the response</strong></p> <p>Declare an array as below</p> <pre><code>var data: NSMutableData = NSMutableData() </code></pre> <p><strong>Receiving the response</strong></p> <p>1.</p> <pre><code>func connection(didReceiveResponse: NSURLConnection!, didReceiveResponse response: NSURLResponse!) { // Received a new request, clear out the data object self.data = NSMutableData() } </code></pre> <p>2.</p> <pre><code>func connection(connection: NSURLConnection!, didReceiveData data: NSData!) { // Append the received chunk of data to our data object self.data.appendData(data) } </code></pre> <p>3.</p> <pre><code>func connectionDidFinishLoading(connection: NSURLConnection!) { // Request complete, self.data should now hold the resulting info // Convert the retrieved data in to an object through JSON deserialization var err: NSError var jsonResult: NSDictionary = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers, error: nil) as NSDictionary if jsonResult.count&gt;0 &amp;&amp; jsonResult["results"].count&gt;0 { var results: NSArray = jsonResult["results"] as NSArray self.tableData = results self.appsTableView.reloadData() } } </code></pre> <p>When NSURLConnection receives a response, we can expect the didReceiveResponse method to be called on our behalf. At this point we simply reset our data by saying self.data = NSMutableData(), creating a new empty data object.</p> <p>After a connection is made, we will start receiving data in the method didReceiveData. The data argument being passed in here is where all our juicy information comes from. We need to hold on to each chunk that comes in, so we append it to the self.data object we cleared out earlier.</p> <p>Finally, when the connection is done and all data has been received, connectionDidFinishLoading is called and we’re ready to use the data in our app. Hooray!</p> <p>The connectionDidFinishLoading method here uses the NSJSONSerialization class to convert our raw data in to useful Dictionary objects by deserializing the results from your Url.</p>
<p>Couldn't be more simple:</p> <pre><code>import Foundation var error: NSError? let jsonData: NSData = /* get your json data */ let jsonDict = NSJSONSerialization.JSONObjectWithData(jsonData, options: nil, error: &amp;error) as NSDictionary </code></pre>
<p>I just wrote a class called JSON, which makes JSON handling in Swift as easy as JSON object in ES5.</p> <ul> <li><a href="https://github.com/dankogai/swift-json/" rel="nofollow">https://github.com/dankogai/swift-json/</a></li> </ul> <p>Turn your swift object to JSON like so:</p> <pre><code>let obj:[String:AnyObject] = [ "array": [JSON.null, false, 0, "",[],[:]], "object":[ "null": JSON.null, "bool": true, "int": 42, "double": 3.141592653589793, "string": "a α\t弾\n", "array": [], "object": [:] ], "url":"http://blog.livedoor.com/dankogai/" ] let json = JSON(obj) json.toString() </code></pre> <p>...or string...</p> <pre><code>let json = JSON.parse("{\"array\":[...}") </code></pre> <p>...or URL.</p> <pre><code>let json = JSON.fromURL("http://api.dan.co.jp/jsonenv") Tree Traversal </code></pre> <p>Just traverse elements via subscript:</p> <pre><code>json["object"]["null"].asNull // NSNull() // ... json["object"]["string"].asString // "a α\t弾\n" json["array"][0].asNull // NSNull() json["array"][1].asBool // false // ... </code></pre> <p>Just like <a href="https://github.com/lingoer/SwiftyJSON" rel="nofollow">SwiftyJSON</a> you don't worry if the subscripted entry does not exist.</p> <pre><code>if let b = json["noexistent"][1234567890]["entry"].asBool { // .... } else { let e = json["noexistent"][1234567890]["entry"].asError println(e) } </code></pre> <p>If you are tired of subscripts, add your scheme like so:</p> <pre><code>//// schema by subclassing class MyJSON : JSON { init(_ obj:AnyObject){ super.init(obj) } init(_ json:JSON) { super.init(json) } var null :NSNull? { return self["null"].asNull } var bool :Bool? { return self["bool"].asBool } var int :Int? { return self["int"].asInt } var double:Double? { return self["double"].asDouble } var string:String? { return self["string"].asString } } </code></pre> <p>And you go:</p> <pre><code>let myjson = MyJSON(obj) myjson.object.null myjson.object.bool myjson.object.int myjson.object.double myjson.object.string // ... </code></pre> <p>Hope you like it.</p> <p>With the new xCode 7.3+ its important to add your domain to the exception list (<a href="http://stackoverflow.com/questions/31216758/how-can-i-add-nsapptransportsecurity-to-my-info-plist-file">How can I add NSAppTransportSecurity to my info.plist file?</a>), refer to this posting for instructions, otherwise you will get a transport authority error.</p>
<p>I also wrote a small library which is specialized for the mapping of the json response into an object structure. I am internally using the library json-swift from David Owens. Maybe it is useful for someone else.</p> <p><a href="https://github.com/prine/ROJSONParser" rel="nofollow">https://github.com/prine/ROJSONParser</a></p> <p>Example <em>Employees.json</em></p> <pre><code>{ "employees": [ { "firstName": "John", "lastName": "Doe", "age": 26 }, { "firstName": "Anna", "lastName": "Smith", "age": 30 }, { "firstName": "Peter", "lastName": "Jones", "age": 45 }] } </code></pre> <p>As next step you have to create your data model (EmplyoeeContainer and Employee).</p> <p><em>Employee.swift</em></p> <pre><code>class Employee : ROJSONObject { required init() { super.init(); } required init(jsonData:AnyObject) { super.init(jsonData: jsonData) } var firstname:String { return Value&lt;String&gt;.get(self, key: "firstName") } var lastname:String { return Value&lt;String&gt;.get(self, key: "lastName") } var age:Int { return Value&lt;Int&gt;.get(self, key: "age") } } </code></pre> <p><em>EmployeeContainer.swift</em></p> <pre><code>class EmployeeContainer : ROJSONObject { required init() { super.init(); } required init(jsonData:AnyObject) { super.init(jsonData: jsonData) } lazy var employees:[Employee] = { return Value&lt;[Employee]&gt;.getArray(self, key: "employees") as [Employee] }() } </code></pre> <p>Then to actually map the objects from the JSON response you only have to pass the data into the EmployeeContainer class as param in the constructor. It does automatically create your data model.</p> <pre><code> var baseWebservice:BaseWebservice = BaseWebservice(); var urlToJSON = "http://prine.ch/employees.json" var callbackJSON = {(status:Int, employeeContainer:EmployeeContainer) -&gt; () in for employee in employeeContainer.employees { println("Firstname: \(employee.firstname) Lastname: \(employee.lastname) age: \(employee.age)") } } baseWebservice.get(urlToJSON, callback:callbackJSON) </code></pre> <p>The console output looks then like the following:</p> <pre><code>Firstname: John Lastname: Doe age: 26 Firstname: Anna Lastname: Smith age: 30 Firstname: Peter Lastname: Jones age: 45 </code></pre>
<h1><a href="https://github.com/mrap/SwiftJSONParser" rel="nofollow">SwiftJSONParse</a>: Parse JSON like a badass</h1> <p>Dead-simple and easy to read!</p> <h3>Example: get the value <code>"mrap"</code> from <code>nicknames</code> as a String from this JSON response</h3> <pre><code>{ "other": { "nicknames": ["mrap", "Mikee"] } </code></pre> <p>It takes your json data <code>NSData</code> as it is, no need to preprocess.</p> <pre><code>let parser = JSONParser(jsonData) if let handle = parser.getString("other.nicknames[0]") { // that's it! } </code></pre> <p>Disclaimer: I made this and I hope it helps everyone. Feel free to improve on it!</p>
<p>This parser uses generics to cast JSON to Swift types which reduces the code you need to type.</p> <p><a href="https://github.com/evgenyneu/JsonSwiftson" rel="nofollow">https://github.com/evgenyneu/JsonSwiftson</a></p> <pre><code>struct Person { let name: String? let age: Int? } let mapper = JsonSwiftson(json: "{ \"name\": \"Peter\", \"age\": 41 }") let person: Person? = Person( name: mapper["name"].map(), age: mapper["age"].map() ) </code></pre>
<p>Swift2 iOs9</p> <pre><code> let miadata = NSData(contentsOfURL: NSURL(string: "https://myWeb....php")!) do{ let MyData = try NSJSONSerialization.JSONObjectWithData(miadata!, options: NSJSONReadingOptions.MutableContainers) as? NSArray print(".........\(MyData)") } catch let error as NSError{ // error.description print(error.description) } </code></pre>
<p>Parsing JSON in Swift is an excellent job for code generation. I've created a tool at <a href="http://www.guideluxe.com/JsonToSwift" rel="nofollow">http://www.guideluxe.com/JsonToSwift</a> to do just that.</p> <p>You supply a sample JSON object with a class name and the tool will generate a corresponding Swift class, as well as any needed subsidiary Swift classes, to represent the structure implied by the sample JSON. Also included are class methods used to populate Swift objects, including one that utilizes the NSJSONSerialization.JSONObjectWithData method. The necessary mappings from the NSArray and NSDictionary objects are provided.</p> <p>From the generated code, you only need to supply an NSData object containing JSON that matches the sample provided to the tool.</p> <p>Other than Foundation, there are no dependencies.</p> <p>My work was inspired by <a href="http://json2csharp.com/" rel="nofollow">http://json2csharp.com/</a>, which is very handy for .NET projects.</p> <p>Here's how to create an NSData object from a JSON file.</p> <pre><code>let fileUrl: NSURL = NSBundle.mainBundle().URLForResource("JsonFile", withExtension: "json")! let jsonData: NSData = NSData(contentsOfURL: fileUrl)! </code></pre>
<p><strong>Step 1.</strong> Install Swifty Json <a href="https://github.com/SwiftyJSON/SwiftyJSON" rel="nofollow">https://github.com/SwiftyJSON/SwiftyJSON</a></p> <p><strong><em>Note:</em></strong> <em>if you are looking for this, there's also a high chance you don't know how to install swifty. Follow the instructions on <a href="https://guides.cocoapods.org/using/getting-started.html#toc_3" rel="nofollow">https://guides.cocoapods.org/using/getting-started.html#toc_3</a></em></p> <p>sudo gem install cocoapods</p> <p>cd ~/Path/To/Folder/Containing/ShowTracker</p> <p>Next enter this command:</p> <p>pod init</p> <p>This will create a default Podfile for your project. The Podfile is where you define the dependencies your project relies on.</p> <p>Type this command to open Podfile using Xcode for editing:</p> <p>open -a Xcode Podfile</p> <p>Add the Swifty into the podfile</p> <pre><code>platform :ios, '8.0' use_frameworks! target 'MyApp' do pod 'SwiftyJSON', '~&gt; X.X.X' end </code></pre> <p><strong>Step 2.</strong> Check this example</p> <pre><code>var mURL = NSURL(string: "http://api.openweathermap.org/data/2.5/weather?q=London,uk&amp;units=metric") if mURL == nil{ println("You are stupid") return } var request = NSURLRequest(URL: mURL!) NSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue.mainQueue(), completionHandler:{ (response: NSURLResponse!, data: NSData!, error: NSError!) -&gt; Void in if data != nil { var mJSON = JSON(data: data!) if let current_conditions = mJSON["weather"][0]["description"].string{ println("Current conditions: " + current_conditions) } else { println("MORON!") } if let current_temperature = mJSON["main"]["temp"].double{ println("Temperature: "+ String(format:"%.f", current_temperature) + "°C" } else { println("MORON!") } } }) </code></pre> <p>Step 3. Profit</p>
<p>Here is a code to make the conversions between JSON and NSData in Swift 2.0</p> <pre><code>// Convert from NSData to json object func nsdataToJSON(data: NSData) -&gt; AnyObject? { do { return try NSJSONSerialization.JSONObjectWithData(data, options: .MutableContainers) } catch let myJSONError { print(myJSONError) } return nil } // Convert from JSON to nsdata func jsonToNSData(json: AnyObject) -&gt; NSData?{ do { return try NSJSONSerialization.dataWithJSONObject(json, options: NSJSONWritingOptions.PrettyPrinted) } catch let myJSONError { print(myJSONError) } return nil; } </code></pre>
<p>The entire viewcontroller which show data in collecction view using two methods of json parsig</p> <pre><code>@IBOutlet weak var imagecollectionview: UICollectionView! lazy var data = NSMutableData() var dictdata : NSMutableDictionary = NSMutableDictionary() override func viewDidLoad() { super.viewDidLoad() startConnection() startNewConnection() // Do any additional setup after loading the view, typically from a nib. } func collectionView(collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int { return dictdata.count } func collectionView(collectionView: UICollectionView, cellForItemAtIndexPath indexPath: NSIndexPath) -&gt; UICollectionViewCell { let cell = collectionView.dequeueReusableCellWithReuseIdentifier("CustomcellCollectionViewCell", forIndexPath: indexPath) as! CustomcellCollectionViewCell cell.name.text = dictdata.valueForKey("Data")?.valueForKey("location") as? String let url = NSURL(string: (dictdata.valueForKey("Data")?.valueForKey("avatar_url") as? String)! ) LazyImage.showForImageView(cell.image, url:"URL return cell } func collectionView(collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAtIndexPath indexPath: NSIndexPath) -&gt; CGSize { let kWhateverHeightYouWant = 100 return CGSizeMake(self.view.bounds.size.width/2, CGFloat(kWhateverHeightYouWant)) } func startNewConnection() { let url:NSURL = NSURL(string: "YOUR URL")! let session = NSURLSession.sharedSession() let request = NSMutableURLRequest(URL: url) request.HTTPMethod = "GET" //set the get or post according to your request request.cachePolicy = NSURLRequestCachePolicy.ReloadIgnoringCacheData let task = session.dataTaskWithRequest(request) { ( let data, let response, let error) in guard let _:NSData = data, let _:NSURLResponse = response where error == nil else { print("error") return } let dataString = NSString(data: data!, encoding: NSUTF8StringEncoding) print(dataString!) } task.resume() } func startConnection(){ let urlPath: String = "your URL" let url: NSURL = NSURL(string: urlPath)! var request: NSURLRequest = NSURLRequest(URL: url) var connection: NSURLConnection = NSURLConnection(request: request, delegate: self, startImmediately: false)! connection.start() } func connection(connection: NSURLConnection!, didReceiveData data: NSData!){ self.data.appendData(data) } func buttonAction(sender: UIButton!){ startConnection() } func connectionDidFinishLoading(connection: NSURLConnection!) { do { let JSON = try NSJSONSerialization.JSONObjectWithData(self.data, options:NSJSONReadingOptions(rawValue: 0)) guard let JSONDictionary :NSDictionary = JSON as? NSDictionary else { print("Not a Dictionary") // put in function return } print("JSONDictionary! \(JSONDictionary)") dictdata.setObject(JSONDictionary, forKey: "Data") imagecollectionview.reloadData() } catch let JSONError as NSError { print("\(JSONError)") } } </code></pre>
<p>Using <a href="https://github.com/Hearst-DD/ObjectMapper" rel="nofollow noreferrer">ObjectMapper framework</a></p> <pre><code>if let path = Bundle(for: BPPView.self).path(forResource: jsonFileName, ofType: "json") { do { let data = try Data(contentsOf: URL(fileURLWithPath: path), options: NSData.ReadingOptions.mappedIfSafe) let json = try JSONSerialization.jsonObject(with: data, options: .allowFragments) self.levels = Mapper&lt;Level&gt;().mapArray(JSONArray: (json as! [[String : Any]]))! print(levels.count) } catch let error as NSError { print(error.localizedDescription) } } else { print("Invalid filename/path.") } </code></pre> <p>Before you should prepare the set of appropriate :Mappable objects to parse into</p> <pre><code>import UIKit import ObjectMapper class Level: Mappable { var levelName = "" var levelItems = [LevelItem]() required init?(map: Map) { } // Mappable func mapping(map: Map) { levelName &lt;- map["levelName"] levelItems &lt;- map["levelItems"] } } </code></pre> <hr> <pre><code> import UIKit import ObjectMapper class LevelItem: Mappable { var frontBackSide = BPPFrontBack.Undefined var fullImageName = "" var fullImageSelectedName = "" var bodyParts = [BodyPart]() required init?(map: Map) { } // Mappable func mapping(map: Map) { frontBackSide &lt;- map["frontBackSide"] fullImageName &lt;- map["fullImageName"] fullImageSelectedName &lt;- map["fullImageSelectedName"] bodyParts &lt;- map["bodyParts"] }} </code></pre>