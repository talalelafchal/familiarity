How to Set UITableViewCellStyleSubtitle and dequeueReusableCell in Swift?
<p>I'd like a <code>UITableView</code> with <code>subtitle</code>-style cells that use <code>dequeueReusableCellWithIdentifier</code>.</p> <p>My original Objective-C code was:</p> <pre><code>static NSString* reuseIdentifier = @"Cell"; UITableViewCell* cell = [tableView dequeueReusableCellWithIdentifier:reuseIdentifier]; if(!cell) { cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:reuseIdentifier]; } </code></pre> <p>After searching the few <code>UITableView</code> questions here already on SO, I thought to write it in Swift like so:</p> <pre><code> tableView.registerClass(UITableViewCell.classForCoder(), forCellReuseIdentifier: "Cell") let cell = tableView.dequeueReusableCellWithIdentifier("Cell", forIndexPath: indexPath) as UITableViewCell </code></pre> <p>But that doesn't let me say I want a <code>subtitle</code> style. So I tried this:</p> <pre><code>var cell :UITableViewCell = UITableViewCell(style: UITableViewCellStyle.Subtitle, reuseIdentifier: "Cell") </code></pre> <p>Which gives me a <code>subtitle</code> cell, but it doesn't let me <code>dequeueReusableCellWithIdentifier</code>.</p> <p>I've researched some more and looked at <a href="https://www.youtube.com/watch?v=Tq0nkr9nhyk">this video tutorial</a>, but he creates a separate <code>subclass</code> of <code>UITableViewCell</code> which I assume is unnecessary as I accomplished this same effect previously in Obj-C.</p> <p>Any ideas? Thanks.</p>
<p>I engage you to look at this little UITableView-Example on Github: <a href="https://github.com/YANGReal/UITableView-Swift" rel="nofollow">https://github.com/YANGReal/UITableView-Swift</a></p> <p>They do like follows:</p> <pre><code>func tableView(tableView: UITableView!, cellForRowAtIndexPath indexPath: NSIndexPath!) -&gt; UITableViewCell! { let cell = tableView .dequeueReusableCellWithIdentifier("cell", forIndexPath: indexPath) as UITableViewCell cell.textLabel.text = String(format: "%i", indexPath.row+1) // set any other property of your cell here return cell } </code></pre>
<p>Keep in mind that <code>UITableView</code> is defined as an optional in the function, which means your initial cell declaration needs to check for the optional in the property. Also, the returned queued cell is also optional, so ensure you make an optional cast to <code>UITableViewCell</code>. Afterwards, we can force unwrap because we know we have a cell.</p> <pre><code>var cell:UITableViewCell? = tableView?.dequeueReusableCellWithIdentifier(reuseIdentifier) as? UITableViewCell if (cell == nil) { cell = UITableViewCell(style: UITableViewCellStyle.Subtitle, reuseIdentifier: reuseIdentifier) } // At this point, we definitely have a cell -- either dequeued or newly created, // so let's force unwrap the optional into a UITableViewCell cell!.detailTextLabel.text = "some text" return cell </code></pre>
<p>Perfect as suggested by Michael G. Emmons, but in Xcode 6.1 using </p> <pre><code>if !cell { ..... </code></pre> <p>I get this error:</p> <blockquote> <p>Optional type '@|value UITableViewCell?' cannot be used as boolean ; test for '!= nil' instead</p> </blockquote> <p>The accepted syntax is:</p> <pre><code>if cell == nil { ... </code></pre>
<p>You can use a slightly different syntax than the one from memmons to prevent the forced unwrapping:</p> <pre><code>let cell = tableView.dequeueReusableCellWithIdentifier(reuseIdentifier) as? UITableViewCell ?? UITableViewCell(style: .Subtitle, reuseIdentifier: reuseIdentifier) cell.detailTextLabel?.text = "some text" return cell </code></pre> <p>This is using XCode <s>6.1</s> 7, Swift <s>1.2</s> 2.0 syntax where <code>UITableView</code> is no longer an optional.</p>
<pre><code>func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell { var CellIdentifier:String = "Cell" var cell:UITableViewCell? = tableView.dequeueReusableCellWithIdentifier(CellIdentifier) as? UITableViewCell if cell == nil { cell = UITableViewCell(style:UITableViewCellStyle(rawValue:3)!,reuseIdentifier:CellIdentifier) } return cell! } </code></pre>
<pre><code>func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell { let reuseIdentifier = "cell" var cell:UITableViewCell? = tableView.dequeueReusableCellWithIdentifier(reuseIdentifier) as UITableViewCell? if (cell == nil) { cell = UITableViewCell(style: UITableViewCellStyle.Subtitle, reuseIdentifier: reuseIdentifier) } cell!.textLabel?.text = self.items[indexPath.row] cell!.detailTextLabel?.text = self.items[indexPath.row] return cell! } </code></pre>
<p>Just building upon memmons' answer by cleaning it up Swift 2 style...</p> <pre><code>let cell = tableView.dequeueReusableCellWithIdentifier(reuseIdentifier) ?? UITableViewCell(style: UITableViewCellStyle.Subtitle, reuseIdentifier: reuseIdentifier) cell.detailTextLabel?.text = "some text" return cell </code></pre>
<p>This one is a little strange. I would expect that tableView would require us to return a cell that was registered to it with a cell identifier. But this does not appear to be the case and the following will render out a cell for textLabel and detailTextLabel text:</p> <pre><code>override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell { let cell = UITableViewCell(style: .Subtitle, reuseIdentifier: cellId) let user = users[indexPath.row] cell.textLabel?.text = user.name cell.detailTextLabel?.text = user.email return cell } </code></pre>
<p>Basically the same as other answers, but I get around dealing with nasty optionals (you can't return <code>nil</code> from <code>-tableView:cellForRow:atIndexPath:</code> in Swift) by using a computed variable:</p> <p><em>Swift 3</em></p> <pre><code>override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { let cell: UITableViewCell = { guard let cell = tableView.dequeueReusableCell(withIdentifier: "UITableViewCell") else { // Never fails: return UITableViewCell(style: UITableViewCellStyle.value1, reuseIdentifier: "UITableViewCell") } return cell }() // (cell is non-optional; no need to use ?. or !) // Configure your cell: cell.textLabel?.text = "Key" cell.detailTextLabel?.text = "Value" return cell } </code></pre>