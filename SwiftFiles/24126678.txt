Close iOS Keyboard by touching anywhere using Swift
<p>I have been looking all over for this but I can't seem to find it. I know how to dismiss the keyboard using <code>Objective-C</code> but I have no idea how to do that using <code>Swift</code>? Does anyone know?</p>
<p>You can call</p> <pre><code>resignFirstResponder() </code></pre> <p>on any instance of a UIResponder, such as a UITextField. If you call it on the view that is currently causing the keyboard to be displayed then the keyboard will dismiss.</p>
<p>Dash's answer is correct and preferred. A more "scorched earth" approach is to call <code>view.endEditing(true)</code>. This causes <code>view</code> and all its subviews to <code>resignFirstResponder</code>. If you don't have a reference to the view you'd like to dismiss, this is a hacky but effective solution.</p> <blockquote> <p>Note that personally I think you should have a reference to the view you'd like to have resign first responder. <code>.endEditing(force: Bool)</code> is a barbaric approach; please don't use it.</p> </blockquote>
<p>An answer to your question on how to dismiss the keyboard in Xcode 6.1 using Swift below:</p> <pre><code>import UIKit class ItemViewController: UIViewController, UITextFieldDelegate { @IBOutlet var textFieldItemName: UITextField! @IBOutlet var textFieldQt: UITextField! @IBOutlet var textFieldMoreInfo: UITextField! override func viewDidLoad() { super.viewDidLoad() textFieldItemName.delegate = self textFieldQt.delegate = self textFieldMoreInfo.delegate = self } ... /** * Called when 'return' key pressed. return NO to ignore. */ func textFieldShouldReturn(textField: UITextField) -&gt; Bool { textField.resignFirstResponder() return true } /** * Called when the user click on the view (outside the UITextField). */ override func touchesBegan(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?) { self.view.endEditing(true) } } </code></pre> <p>(<a href="https://www.youtube.com/watch?v=0YMNmLK0694">Source of this information</a>).</p>
<pre><code>override func viewDidLoad() { super.viewDidLoad() //Looks for single or multiple taps. let tap: UITapGestureRecognizer = UITapGestureRecognizer(target: self, action: "dismissKeyboard") //Uncomment the line below if you want the tap not not interfere and cancel other interactions. //tap.cancelsTouchesInView = false view.addGestureRecognizer(tap) } //Calls this function when the tap is recognized. func dismissKeyboard() { //Causes the view (or one of its embedded text fields) to resign the first responder status. view.endEditing(true) } </code></pre> <p>========================================================================</p> <p>Edit: Here is another way to do this task if you are going to use this functionality in multiple UIViewControllers:</p> <pre><code>// Put this piece of code anywhere you like extension UIViewController { func hideKeyboardWhenTappedAround() { let tap: UITapGestureRecognizer = UITapGestureRecognizer(target: self, action: #selector(UIViewController.dismissKeyboard)) view.addGestureRecognizer(tap) } func dismissKeyboard() { view.endEditing(true) } } </code></pre> <p>Now in every UIViewController, all you have to do is call this function:</p> <pre><code>override func viewDidLoad() { super.viewDidLoad() self.hideKeyboardWhenTappedAround() } </code></pre> <p>This function is included as a standard function in my repo which contains a lot of useful Swift Extensions like this one, check it out: <a href="https://github.com/goktugyil/EZSwiftExtensions">https://github.com/goktugyil/EZSwiftExtensions</a></p>
<p>You can also add a tap gesture recognizer to resign the keyboard. :D </p> <pre><code>override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. let recognizer = UITapGestureRecognizer(target: self, action: Selector("handleTap:")) backgroundView.addGestureRecognizer(recognizer) } func handleTap(recognizer: UITapGestureRecognizer) { textField.resignFirstResponder() textFieldtwo.resignFirstResponder() textFieldthree.resignFirstResponder() println("tappped") } </code></pre>
<p>![ how to disable the keyboard..][1]</p> <pre><code>import UIKit class ViewController: UIViewController,UITextFieldDelegate { @IBOutlet weak var username: UITextField! @IBOutlet weak var password: UITextField! override func viewDidLoad() { super.viewDidLoad() username.delegate = self password.delegate = self // Do any additional setup after loading the view, typically from a nib. } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. } func textFieldShouldReturn(textField: UITextField!) -&gt; Bool // called when 'return' key pressed. return NO to ignore. { textField.resignFirstResponder() return true; } override func touchesBegan(touches: NSSet, withEvent event: UIEvent) { username.resignFirstResponder() password.resignFirstResponder() self.view.endEditing(true) } } </code></pre>
<h1>When there is more than one text field in the view</h1> <p>To follow <a href="http://stackoverflow.com/a/24126929/37168">@modocache's recommendation</a> to avoid calling <code>view.endEditing()</code>, you could keep track of the text field that became first responder, but that is messy and error-prone. </p> <p>An alternative is to call <code>resignFirstResponder()</code> <strong>on all text fields in the viewcontroller</strong>. Here's an example of creating a collection of all text fields (which in my case was needed for validation code anyway):</p> <pre><code>@IBOutlet weak var firstName: UITextField! @IBOutlet weak var lastName: UITextField! @IBOutlet weak var email: UITextField! var allTextFields: Array&lt;UITextField&gt;! // Forced unwrapping so it must be initialized in viewDidLoad override func viewDidLoad() { super.viewDidLoad() self.allTextFields = [self.firstName, self.lastName, self.email] } </code></pre> <p>With the collection available, it's a simple matter to iterate through all of them:</p> <pre><code>private func dismissKeyboard() { for textField in allTextFields { textField.resignFirstResponder() } } </code></pre> <p>So now you can call <code>dismissKeyboard()</code> in your gesture recognizer (or wherever is appropriate for you). Drawback is that you must maintain the list of <code>UITextField</code>s when you add or remove fields.</p> <p>Comments welcome. If there is a problem with calling <code>resignFirstResponder()</code> on controls that aren't first responder, or if there's an easy and guaranteed non-buggy way to track the current first responder, I'd love to hear about it!</p>
<p>Another possibility is to simply add a big button with no content that lies underneath all views you might need to touch. Give it an action named:</p> <pre><code>@IBAction func dismissKeyboardButton(sender: AnyObject) { view.endEditing(true) } </code></pre> <p>The problem with a gesture recognizer was for me, that it also caught all touches I wanted to receive by the tableViewCells.</p>
<p>In storyboard: </p> <ol> <li>select the TableView</li> <li>from the the right-hand-side, select the attribute inspector</li> <li>in the keyboard section - select the dismiss mode you want</li> </ol>
<p>I worked out on uisearchbar . See mine.</p> <pre><code>import UIKit class BidderPage: UIViewController,UISearchBarDelegate,UITableViewDataSource { let recognizer = UITapGestureRecognizer() // Set recogniser as public in case of tableview and didselectindexpath. func searchBarTextDidBeginEditing(searchBar: UISearchBar) { recognizer.addTarget(self, action: "handleTap:") view.addGestureRecognizer(recognizer) } func handleTap(recognizer: UITapGestureRecognizer) { biddersearchbar .resignFirstResponder() } func searchBarTextDidEndEditing(searchBar: UISearchBar) { view .removeGestureRecognizer(recognizer) } </code></pre>
<pre><code>//Simple exercise to demonstrate, assuming the view controller has a //Textfield, Button and a Label. And that the label should display the //userinputs when button clicked. And if you want the keyboard to disappear //when clicken anywhere on the screen + upon clicking Return key in the //keyboard. Dont forget to add "UITextFieldDelegate" and //"self.userInput.delegate = self" as below import UIKit class ViewController: UIViewController,UITextFieldDelegate { @IBOutlet weak var userInput: UITextField! @IBAction func transferBtn(sender: AnyObject) { display.text = userInput.text } @IBOutlet weak var display: UILabel! override func viewDidLoad() { super.viewDidLoad() //This is important for the textFieldShouldReturn function, conforming to textfieldDelegate and setting it to self self.userInput.delegate = self } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. } //This is for the keyboard to GO AWAYY !! when user clicks anywhere on the view override func touchesBegan(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?) { self.view.endEditing(true) } //This is for the keyboard to GO AWAYY !! when user clicks "Return" key on the keyboard func textFieldShouldReturn(textField: UITextField) -&gt; Bool { textField.resignFirstResponder() return true } } </code></pre>
<pre><code> import UIKit class ItemViewController: UIViewController, UITextFieldDelegate { @IBOutlet weak var nameTextField: UITextField! override func viewDidLoad() { super.viewDidLoad() self.nameTextField.delegate = self } // Called when 'return' key pressed. return NO to ignore. func textFieldShouldReturn(textField: UITextField) -&gt; Bool { textField.resignFirstResponder() return true } // Called when the user click on the view (outside the UITextField). override func touchesBegan(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?) { self.view.endEditing(true) } } </code></pre>
<p>I prefer this <strong>one-liner</strong>:</p> <pre><code>view.addGestureRecognizer(UITapGestureRecognizer(target: self, action: "dismissKeyboardFromView:"))</code></pre> <p>Just put that in the override viewDidLoad function in whichever subclassed UIViewController you want it to occur, and then put the following code in a new empty file in your project called "UIViewController+dismissKeyboard.swift":</p> <pre><code>import UIKit extension UIViewController { // This function is called when the tap is recognized func dismissKeyboardFromView(sender: UITapGestureRecognizer?) { let view = sender?.view view?.endEditing(true) } } </code></pre>
<p>I got you fam</p> <pre class="lang-swift prettyprint-override"><code>override func viewDidLoad() { super.viewDidLoad() /*This ensures that our view loaded*/ self.textField.delegate = self /*we select our text field that we want*/ self.view.addGestureRecognizer(UITapGestureRecognizer(target: self, action: Selector("dismissKeyboard"))) } func dismissKeyboard(){ /*this is a void function*/ textField.resignFirstResponder() /*This will dismiss our keyboard on tap*/ } </code></pre>
<p>This one liner resigns Keyboard from all(any) the UITextField in a UIView</p> <pre><code>self.view.endEditing(true) </code></pre>
<p>I found the best solution included the accepted answer from @Esqarrouth, with some adjustments:</p> <pre><code>extension UIViewController { func hideKeyboardWhenTappedAround() { let tap: UITapGestureRecognizer = UITapGestureRecognizer(target: self, action: "dismissKeyboardView") tap.cancelsTouchesInView = false view.addGestureRecognizer(tap) } func dismissKeyboardView() { view.endEditing(true) } } </code></pre> <p>The line <code>tap.cancelsTouchesInView = false</code> was critical: it ensures that the <code>UITapGestureRecognizer</code> does not prevent other elements on the view from receiving user interaction. </p> <p>The method <code>dismissKeyboard()</code> was changed to the slightly less elegant <code>dismissKeyboardView()</code>. This is because in my project's fairly old codebase, there were numerous times where <code>dismissKeyboard()</code> was already used (I imagine this is not uncommon), causing compiler issues. </p> <p>Then, as above, this behaviour can be enabled in individual View Controllers:</p> <pre><code>override func viewDidLoad() { super.viewDidLoad() self.hideKeyboardWhenTappedAround() } </code></pre>
<p>As an extension to the <a href="http://stackoverflow.com/a/27079103/409958">correct answer</a> I always use the following extension:</p> <pre><code>extension UIApplication { /// Dismiss keyboard from key window. open static func endEditing(_ force: Bool = false) { shared.keyWindow?.endEditing(force) } } </code></pre> <p>This way, in case the class I am trying to cancel the editing in does not have a <code>view</code> property or is not a subclass of <code>UIView</code> I can just call <code>UIApplication.endEditing()</code>.</p>
<p>If you have other views that should receive the touch as well you have to set <code>cancelsTouchesInView = false</code></p> <p>Like this:</p> <pre><code>let elsewhereTap = UITapGestureRecognizer(target: self, action: #selector(dismissKeyboard)) elsewhereTap.cancelsTouchesInView = false self.view.addGestureRecognizer(elsewhereTap) </code></pre>
<p><strong>Swift 3:</strong></p> <p>Extension with <code>Selector</code> as parameter to be able to do additional stuff in the dismiss function and <code>cancelsTouchesInView</code> to prevent distortion with touches on other elements of the view.</p> <pre><code>extension UIViewController { func hideKeyboardOnTap(_ selector: Selector) { let tap: UITapGestureRecognizer = UITapGestureRecognizer(target: self, action: selector) tap.cancelsTouchesInView = false view.addGestureRecognizer(tap) } } </code></pre> <p>Usage:</p> <pre><code>override func viewDidLoad() { super.viewDidLoad() self.hideKeyboardOnTap(#selector(self.dismissKeyboard)) } func dismissKeyboard() { view.endEditing(true) // do aditional stuff } </code></pre>
<p>I found this simple solution: 1. Add UITapGestureRecognizer to your view Controller 2. Add IBAction to your UITapGestureRecognizer 3. Finally you can resign the first responder</p> <p>class ViewController: UIViewController {</p> <pre><code>@IBOutlet var tap: UITapGestureRecognizer! @IBOutlet weak var label: UILabel! @IBOutlet weak var textField: UITextField! override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. } @IBAction func dissVieGesture(_ sender: UITapGestureRecognizer) { self.textField.resignFirstResponder() label.text = textField.text! } </code></pre> <p>}</p>
<p>Swift 3: Easiest way to dismiss keyboard:</p> <pre><code> //Dismiss keyboard method func keyboardDismiss() { textField.resignFirstResponder() } //ADD Gesture Recignizer to Dismiss keyboard then view tapped @IBAction func viewTapped(_ sender: AnyObject) { keyboardDismiss() } //Dismiss keyboard using Return Key (Done) Button //Do not forgot to add protocol UITextFieldDelegate func textFieldShouldReturn(_ textField: UITextField) -&gt; Bool { keyboardDismiss() return true } </code></pre>
<p>for Swift 3 it is very simple</p> <pre><code>override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) { self.view.endEditing(true) } </code></pre> <p>if you want to hide keyboard on pressing RETURN key </p> <pre><code>func textFieldShouldReturn(_ textField: UITextField) -&gt; Bool { textField.resignFirstResponder() return true } </code></pre> <p>but in second case you will also need to pass delegate from all textFields to the ViewController in the Main.Storyboard</p>