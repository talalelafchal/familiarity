How can I return instancetype in Swift
<p>I want to make an extension of some class to return the runtime type object</p> <p>for example, I create extenstion of class A</p> <pre><code>extension A { class func niceObject() -&gt; XXXXX { // in objective-c is instancetype return .... } } </code></pre> <p>So anyone know there is instancetype keyword in Swift or not to replace <code>xxxxx</code> and I can call this function on subclass of A without manually cast</p> <pre><code>var b: B = B.niceObject() </code></pre> <p>Thanks</p>
<p>You can do it. Playground code below. It's self() that niceObject() has to return. Additionally, you must have a <code>required</code> init on the base class.</p> <pre><code>class A { required init() { } func whatClassAmI() -&gt; String { return "Class A" } } class B: A { required init() { super.init() } override func whatClassAmI() -&gt; String { return "Class B" } } let a = A() let sa = a.whatClassAmI() // "Class A", of course let b = B() let sb = b.whatClassAmI() // "Class B", of course extension A { class func niceObject() -&gt; Self { return self.init() } } let aa = A.niceObject() let saa = aa.whatClassAmI() // "Class A" let bb = B.niceObject() let sbb = bb.whatClassAmI() // "Class B", as required </code></pre>
<p>At least in procotols, you can use <code>Self</code>. This represents the actual type of <code>self</code>. Not sure about extensions, though...</p> <p>For instance, see the definition of <code>Equatable</code>:</p> <pre><code>protocol Equatable { func ==(lhs: Self, rhs: Self) -&gt; Bool } </code></pre>
<p>There is a keyword <code>Self</code> which is allowed in two places - in protocols (see Jean-Philippe Pellet's answer) and as a result of <code>class</code> methods:</p> <pre><code>extension A { class func niceObject() -&gt; Self? { return nil } } </code></pre> <p>Unfortunately, this won't help you because the following is invalid</p> <pre><code>extension A { class func niceObject() -&gt; Self? { //A can't be converted to Self return A() } } </code></pre> <p>The error is caused by the fact that when you inherit from <code>A</code></p> <pre><code>class B : A { } </code></pre> <p>then</p> <pre><code>var b = B.niceObject() </code></pre> <p>would actually return an <code>A</code> instance which is not convertible to <code>Self</code> (<code>Self</code> is <code>B</code>)</p> <p>@Grimxn found the correct solution (<a href="http://stackoverflow.com/a/24182819/669586">See his answer</a>):</p> <p>You have to add a required initializer to the base class, e.g.</p> <pre><code>class A { @required init() { } } </code></pre> <p>and then you can call the initialiser using <code>self()</code></p> <pre><code>extension A { class func niceObject() -&gt; Self { return self() } } </code></pre>
<p>When you use a Swift API from Objective-C, the compiler typically performs a direct translation. For example, the Swift API <code>func playSong(name: String)</code> is imported as <code>- (void)playSong:(NSString *)name</code> in Objective-C.</p> <p>However, there is one exception: When you use a <a href="https://developer.apple.com/library/prerelease/mac/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html" rel="nofollow">Swift initializer</a> in Objective-C, the compiler adds the text “<code>initWith</code>” to the beginning of the method and properly capitalizes the first character in the original initializer.</p> <p>For example, this Swift initializer <code>init (songName: String, artist: String)</code> is imported as <code>- (instancetype)initWithSongName:(NSString *)songName artist:(NSString *)artist</code> in Objective-C.</p>