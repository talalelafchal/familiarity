Generating Swift models from Core Data entities
<p><strong>Edit</strong>: I found the solution to generate a Swift model from Core Data entity:</p> <p>On Xcode:</p> <p><em>Editor > Create NSManagedOjbect > Click button "Next" > Click button "Next" > Select "Swift" Langage > Click button "Create"</em></p> <hr> <p>I tried Swift langage by creating a new Swift project on Xcode 6 beta using Core Data.</p> <p>When I generate my models from my Core Data's entities, Xcode creates Objective-C models.</p> <p>Is there a way to generate Swift model rather than Obejctive-C model with Core Data ?</p> <p>Thanks !</p>
<p>Lets have a look on the Objective-C way:</p> <p><strong>Person.h</strong> (Header-File)</p> <pre><code>#import &lt;Foundation/Foundation.h&gt; #import &lt;CoreData/CoreData.h&gt; @interface Person : NSManagedObject @property (nonatomic, retain) NSString *name; @end </code></pre> <p><strong>Person.m</strong> (Implementation-File)</p> <pre><code>#import "Person.h" @implementation Person @dynamic name; @end </code></pre> <h1>Swift</h1> <p>The documentation already included in Xcode6-Beta says:</p> <blockquote> <p>Core Data provides the underlying storage and implementation of properties in subclasses of the NSManagedObject class. Add the @NSManaged attribute before each property definition in your managed object subclass that corresponds to an attribute or relationship in your Core Data model. Like the @dynamic attribute in Objective-C, the @NSManaged attribute informs the Swift compiler that the storage and implementation of a property will be provided at runtime. However, unlike @dynamic, the @NSManaged attribute is available only for Core Data support.</p> </blockquote> <p>So that is how I would rewrite the above example for Swift (not tested):</p> <p><strong>Person.swift</strong></p> <pre><code>import CoreData class Person: NSManagedObject { @NSManaged var name : NSString } </code></pre> <p>And according to your question I think the subclass-generation-feature might be not included in Xcode6 yet. Did you made sure that you have chosen "Swift" as programming language when you were creating the Cocoa-Project in Xcode?</p>
<p>I tested @NSManaged, it didn't work. :( . But mixed models files(.h) generated by xcdatamodel, it succeed. please read the doc and code in <a href="https://github.com/iascchen/SwiftCoreDataSimpleDemo" rel="nofollow">https://github.com/iascchen/SwiftCoreDataSimpleDemo</a></p>
<p>Alternatively, you can just add <code>#import "Person.h"</code> to the bridging header, <code>Project-Bridging-Header.h</code> that Xcode generates for you (if you accepted it's offer to generate). Then you can use all the auto-generated Obj-C as if it were native Swift.</p>
<p>You can get Swift model back using <code>NSEntityDescription.insertNewObjectForEntityForName</code> but you must edit your core data model file and not use <code>Person</code> as a Class Entity but <code>&lt;ProjectName&gt;.Person</code> else it returns <code>NSManagedObject</code>...</p> <p>Using <code>println()</code> you won't see <code>Person</code> instance but something like <code>&lt;_TtC5ProjectName4Person: 0xc9ad5f0&gt;</code> but calling methods on this will prove it's a <code>Person</code> instance for real. I guess it's just the way for Swift to generate unique class names, not conflict and CoreData methods show this internal mechanism.</p> <p>The <a href="https://developer.apple.com/library/prerelease/mac/documentation/Swift/Conceptual/BuildingCocoaApps/WritingSwiftClassesWithObjective-CBehavior.html">Apple documentation says</a>:</p> <blockquote> <p>Swift classes are namespaced—they’re scoped to the module (typically, the project) they are compiled in. To use a Swift subclass of the NSManagedObject class with your Core Data model, prefix the class name in the Class field in the model entity inspector with the name of your module.</p> </blockquote>
<p>According to Apple's video regarding What's new In CoreData frame: 38mins (WWDC2014 Session 225), in inspector's Data Model, prefix the class name with the project name. Like <strong>projectName.Doctor</strong></p> <p>I've tried this but what will happen is that the generated managed object class becomes: <strong>projectName.swift</strong> instead of <strong>Doctor.swift</strong>. Even the class declaration becomes <strong>class projectName: ManagedObject</strong></p> <p><strong>Solution:</strong></p> <p>In Data model inspector, just specify the Name &amp; Class of your object to what name you want, <strong>example: Doctor</strong></p> <p>After you generated an object model and selecting Swift, this will create a file (<strong>Doctor.swift</strong>). </p> <p>Now, when inserting new records in Core Data, you might an experience error <em>"Class not found, using default NSManagedObject instead"</em> even if you cast the newly inserted object to a correct object name. </p> <p>To solve this, you just need to add <strong>@objc(class name)</strong> above the class declaration. See sample below.</p> <pre><code>import Foundation import CoreData @objc(Doctor) class Doctor: NSManagedObject { @NSManaged var name: String } </code></pre> <p>Then:</p> <pre><code>let doctorManagedObject = NSEntityDescription.insertNewObjectForEntityForName("Doctor", inManagedObjectContext: context) as Doctor doctorManagedObject.name = "John" // you can now use dot syntax instead of setValue </code></pre> <p>Save context to commit insert.</p>
<p><em>Editor</em> -> <em>Create NSManagedObject Subclass</em> works fine for Swift</p> <p>Simply go through all the usual steps, but when you get to creating the files, choose Language 'Swift' if it's the first time you've used <em>Create NSManagedObject Subclass</em> with a Swift project it'll be defaulting to Objective C</p>