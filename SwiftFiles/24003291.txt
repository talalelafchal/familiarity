#ifdef replacement in swift language
<p>In C/C++/Objective-C you can define a macro using compiler preprocesors. Moreover, you can include/exclude some parts of code using compiler preprocesors.</p> <pre><code>#ifdef DEBUG // debug only code #endif </code></pre> <p>Is there a similar solution in Swift?</p>
<p>There is no Swift preprocessor. (For one thing, arbitrary code substitution breaks type- and memory-safety.)</p> <p>Swift does include build-time configuration options, though, so you can conditionally include code for certain platforms or build styles or in response to flags you define with <code>-D</code> compiler args. Unlike with C, though, a conditionally compiled section of your code must be syntactically complete. There's a section about this in <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-XID_21">Using Swift With Cocoa and Objective-C</a>.</p> <p>For example:</p> <pre><code>#if os(iOS) let color = UIColor.redColor() #else let color = NSColor.redColor() #endif </code></pre>
<p>Yes you can do it.</p> <p>In Swift you can still use the "#if/#else/#endif" preprocessor macros (although more constrained), as per <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-ID34">Apple docs</a>. Here's an example:</p> <pre><code>#if DEBUG let a = 2 #else let a = 3 #endif </code></pre> <p>Now, you must set the "DEBUG" symbol elsewhere, though. Set it in the "Swift Compiler - Custom Flags" section, "Other Swift Flags" line. You add the DEBUG symbol with the <code>-D DEBUG</code> entry.</p> <p>As usual, you can set a different value when in Debug or when in Release.</p> <p>I tested it in real code and it works; it doesn't seem to be recognized in a playground though.</p> <p>You can read my original post <a href="http://stackoverflow.com/questions/24111854/in-absence-of-preprocessor-macros-is-there-a-way-to-define-practical-scheme-spe/24112024#24112024">here</a>.</p> <hr> <p><strong>IMPORTANT NOTE:</strong> <code>-DDEBUG=1</code> doesn't work. Only <code>-D DEBUG</code> works. Seems compiler is ignoring a flag with a specific value.</p>
<p>In many situations, you don't really need conditional <em>compilation</em>; you just need conditional <em>behavior</em> that you can switch on and off. For that, you can use an environment variable. This has the huge advantage that you don't actually have to recompile.</p> <p>You can set the environment variable, and easily switch it on or off, in the scheme editor:</p> <p><img src="https://i.stack.imgur.com/opfbT.png" alt="enter image description here"></p> <p>You can retrieve the environment variable with NSProcessInfo:</p> <pre><code> let dic = NSProcessInfo.processInfo().environment if dic["TRIPLE"] != nil { // ... do secret stuff here ... } </code></pre> <p>Here's a real-life example. My app runs only on the device, because it uses the music library, which doesn't exist on the Simulator. How, then, to take screen shots on the Simulator for devices I don't own? Without those screen shots, I can't submit to the AppStore.</p> <p>I need <em>fake data</em> and a <em>different way of processing it</em>. I have two environment variables: one which, when switched on, tells the app to generate the fake data from the real data while running on my device; the other which, when switched on, uses the fake data (not the missing music library) while running on the Simulator. Switching each of those special modes on / off is easy thanks to environment variable checkboxes in the Scheme editor. And the bonus is that I can't accidentally use them in my App Store build, because archiving has no environment variables. </p>
<p>As of Swift 2.1, if all you need is just check whether the code is built with debug or release configuration, you may use the built-in functions:</p> <ul> <li><code>_isDebugAssertConfiguration()</code> (true when optimization is set to <code>-Onone</code>)</li> <li><code>_isReleaseAssertConfiguration()</code> (true when optimization is set to <code>-O</code>)</li> <li><code>_isFastAssertConfiguration()</code> (true when optimization is set to <code>-Ounchecked</code>)</li> </ul> <p>e.g.</p> <pre><code>func obtain() -&gt; AbstractThing { if _isDebugAssertConfiguration() { return DecoratedThingWithDebugInformation(Thing()) } else { return Thing() } } </code></pre> <p>Compared with preprocessor macros,</p> <ul> <li>✓ You don't need to define a custom <code>-D DEBUG</code> flag to use it</li> <li>~ It is actually defined in terms of optimization settings, not Xcode build configuration</li> <li>✗ Undocumented, which means the function can be removed in any update (but it should be AppStore-safe since the optimizer will turn these into constants)</li> <li>✗ Using in if/else will always generate a "Will never be executed" warning.</li> </ul>
<p>As stated in <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-ID34" rel="nofollow noreferrer">Apple Docs</a></p> <blockquote> <p>The Swift compiler does not include a preprocessor. Instead, it takes advantage of compile-time attributes, build configurations, and language features to accomplish the same functionality. For this reason, preprocessor directives are not imported in Swift.</p> </blockquote> <p>I've managed to achieve what I wanted by using custom Build Configurations:</p> <ol> <li>Go to your project / select your target / Build Settings / search for Custom Flags</li> <li>For your chosen target set your custom flag using -D prefix (without white spaces), for both Debug and Release</li> <li>Do above steps for every target you have </li> </ol> <p>Here's how you check for target:</p> <pre><code>#if BANANA print("We have a banana") #elseif MELONA print("Melona") #else print("Kiwi") #endif </code></pre> <p><a href="https://i.stack.imgur.com/zAKzJ.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/zAKzJ.png" alt="enter image description here"></a></p> <p>Tested using Swift 2.2</p>
<p>my two cents for XCode 8:</p> <p>a) custom flag using -D prefix works fine but..</p> <p>b) simpler use:</p> <p>in xcode 8 there is a new section: "Active Compilation Conditions", already with two rows, for debug and release.</p> <p>Simply add your define WITHOUT -D.</p>
<p>A major change of <code>ifdef</code> replacement came up with Xcode 8. i.e use of <strong>Active Compilation Conditions</strong>.</p> <p>Refer to <strong>Building and Linking</strong> in <a href="https://developer.apple.com/library/prerelease/content/releasenotes/DeveloperTools/RN-Xcode/Introduction.html">Xcode 8 Release note</a>.</p> <p>New build settings</p> <p>New setting: <code>SWIFT_ACTIVE_COMPILATION_CONDITIONS</code></p> <pre><code>“Active Compilation Conditions” is a new build setting for passing conditional compilation flags to the Swift compiler. </code></pre> <p>Previously, we had to declare your conditional compilation flags under OTHER_SWIFT_FLAGS, remembering to prepend “-D” to the setting. For example, to conditionally compile with a MYFLAG value:</p> <pre><code>#if MYFLAG // do stuff #endif </code></pre> <p>The value to add to the setting <code>-DMYFLAG</code></p> <p>Now we only need to pass the value MYFLAG to the new setting. Time to move all those conditional compilation values!</p> <p>Please refer to below link for more Swift Build Settings feature in Xcode 8: <a href="http://www.miqu.me/blog/2016/07/31/xcode-8-new-build-settings-and-analyzer-improvements/">http://www.miqu.me/blog/2016/07/31/xcode-8-new-build-settings-and-analyzer-improvements/</a></p>