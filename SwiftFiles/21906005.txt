Dynamic global variables in iOS app
<p>I searched the internet and more than 20 topics about global variables, I just couldn't find the one I need.</p> <ul> <li>Will use it in an iOS application.</li> <li>I want the variable to be accessible from all views.</li> <li>I want a few views to be able to change that variable.</li> <li>Preferably don't want to mess with segues.</li> </ul>
<p>You should declare your 'global' variables in your Application Delegate class.</p> <p>This way you can ensure that all your viewsControllers etc will be able to access them.</p> <p>For me it's probably the most elegant solution, when you need access to one of these vars you can just get a reference to your app delegate.</p>
<p>Create a <a href="http://stackoverflow.com/questions/7568935/how-do-i-implement-an-objective-c-singleton-that-is-compatible-with-arc">singleton</a> class. Add all global variables as read/write properties. Create the singleton instance when your app starts, typically inside <code>application:didFinishLaunchingWithOptions:</code> method. Using this singleton instance you can now share information throughout your app. </p> <p>You may need to thing about making the properties <a href="http://stackoverflow.com/a/12348158/1407017">thread safe</a> in case your app will access these in a multithreaded environment. </p> <p>Hope that helps!</p>
<p>In app delegate header</p> <pre><code>extern NSString* const globalVariable1; </code></pre> <p>in app delegate m file</p> <pre><code>NSString* const globalVariable1 = @"My Value"; </code></pre> <p>You can access this global variable in any view controller.</p> <p>this is just for string.</p> <p><code>int const</code> for integer.</p> <p>just <code>BOOL</code> for boolean.</p> <p>Hope this helps</p>
<p>You could do what is suggesting, add a variable in AppDelegate and then fetch it from your view controllers like this:</p> <pre><code>AppDelegateNeme *ap = (AppDelegateNeme *)[[UIApplication sharedApplication] delegate]; ap.yourVar = smth </code></pre> <p>As you can see in code above, you are accessing shared instance of UIApplication and just by casting it to your AppDelegate class you can reach your "global" variable. But I personally don't see this as the best solution. What happens is that you need to include your app delegate in every UIViewController, and chances are that you already included that UIViewController in your AppDelegate so you could end up looking at recursive includes or a very messy code. </p> <p>Cleaner approach would be to create a class to store your global variables, just add a file and for a class choose NSObject. Then you can create singleton object of that class or you can just define class variables and class methods (the one with +) to store and fetc values from your "global vars".</p> <p>In this way your code will be mode readable and you will never have any include problems, as long as you don't start including stuff in that class.</p> <p>Example:</p> <pre><code>//GlobalClass.h @interface GlobalClass : NSObject @property (nonatomic) BOOL someBool; // example wit a singleton obj: + (GlobalClass *)globalClass; // example with class methods +(int)GetMyVar; +(void)SetMyVar:(int)var; //GlobalClass.m static int MyVar; @synthesize someBool; static GlobalClass *globalClass = nil; + (GlobalClass *)globalClass { if (globalClass == NULL) { // Thread safe allocation and initialization -&gt; singletone object static dispatch_once_t pred; dispatch_once(&amp;pred, ^{ globalClass = [[GlobalClass alloc] init]; }); } return globalClass; } +(int)GetMyVar { return MyVar; } +(void)SetMyVar:(int)var { MyVar = var; } </code></pre> <p>So from outside (from your viewcontroller): To create singleton and set our bool property:</p> <pre><code>//set var: [[GlobalClass globalClass] setSomeBool:YES]; // get BOOL b = [[GlobalClass globalClass] someBool]; </code></pre> <p>OR use class methods (don't need to create singletone obj)</p> <pre><code>// set [GlobalClass SetMyVar:5]; // get int num = [GlobalClass GetMyVar]; </code></pre> <p>Hope this helps...</p>
<p>For swift I used this method:</p> <pre><code>struct MyStyles { static let ThemeColor = UIColor(red: 41/255, green: 156/255, blue: 253/255, alpha: 1.0) static let ThemeSecondColor = UIColor.whiteColor() static let ThemeGrayLineColor = UIColor(red: 128/255, green: 128/255, blue: 128/255, alpha: 1.0) static let ThemeMyCommentsColor = UIColor(red: 219/255, green: 238/255, blue: 255/255, alpha: 1.0) static let ThemeCommentedToMeColor = UIColor(red: 227/255, green: 232/255, blue: 235/255, alpha: 1.0) static let ThemeFontName = "HelveticaNeue-Light" static let ThemeFontNameBold = "Helvetica-Bold" static let ScreenWidth = UIScreen.mainScreen().bounds.size.width static let ScreenHeight = UIScreen.mainScreen().bounds.size.height static let StatusBarHeight = UIApplication.sharedApplication().statusBarFrame.size.height static func largeButton(#title: String, action: String, target: UIViewController) -&gt; UIButton { let button = UIButton(frame: CGRect(x: 0, y: ScreenHeight*9/10, width: ScreenWidth, height: ScreenHeight/10)) button.setTitle(title, forState: UIControlState.Normal) button.backgroundColor = ThemeSecondColor button.tintColor = ThemeColor button.titleLabel?.font = UIFont(name: ThemeFontName, size: 50) button.setTitleColor(ThemeColor, forState: UIControlState.Normal) button.addTarget(target, action: Selector(action), forControlEvents: UIControlEvents.TouchUpInside) return button } } </code></pre> <p>I access them like this from other classes:</p> <pre><code>var color = MyStyles.ThemeColor </code></pre>