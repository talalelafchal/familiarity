How to navigate through textfields (Next / Done Buttons)
<p>How can I navigate through all my text fields with the "Next" Button on the iPhone Keyboard?</p> <p>The last text field should close the Keyboard.</p> <p>I've setup the IB the Buttons (Next / Done) but now I'm stuck.</p> <p>I implemented the textFieldShouldReturn action but now the Next and Done Buttons close the Keyboard.</p> <p>Thanks for your help!</p>
<p>After you exit from one text field, you call [otherTextField becomeFirstResponder] and the next field gets focus.</p> <p>This can actually be a tricky problem to deal with since often you'll also want to scroll the screen or otherwise adjust the position of the text field so it's easy to see when editing. Just make sure to do a lot of testing with coming into and out of the text fields in different ways and also leaving early (always give the user an option to dismiss the keyboard instead of going to the next field, usually with "Done" in the nav bar) </p>
<p>in textFieldShouldReturn you should check that the textfield you are currently on is not the last one when they click next and if its n ot dont dismiss the keyboard..</p>
<p>In Cocoa for Mac OS X, you have the next responder chain, where you can ask the text field what control should have focus next. This is what makes tabbing between text fields work. But since iOS devices do not have a keyboard, only touch, this concept has not survived the transition to Cocoa Touch.</p> <p>This can be easily done anyway, with two assumptions:</p> <ol> <li>All "tabbable" <code>UITextField</code>s are on the same parent view.</li> <li>Their "tab-order" is defined by the tag property.</li> </ol> <p>Assuming this you can override textFieldShouldReturn: as this:</p> <pre><code>-(BOOL)textFieldShouldReturn:(UITextField*)textField { NSInteger nextTag = textField.tag + 1; // Try to find next responder UIResponder* nextResponder = [textField.superview viewWithTag:nextTag]; if (nextResponder) { // Found next responder, so set it. [nextResponder becomeFirstResponder]; } else { // Not found, so remove keyboard. [textField resignFirstResponder]; } return NO; // We do not want UITextField to insert line-breaks. } </code></pre> <p>Add some more code, and the assumptions can be ignored as well.</p> <p><strong>UPDATE:- SWIFT 2.0</strong></p> <pre><code>func textFieldShouldReturn(textField: UITextField) -&gt; Bool { let nextTage=textField.tag+1; // Try to find next responder let nextResponder=textField.superview?.viewWithTag(nextTage) as UIResponder! if (nextResponder != nil){ // Found next responder, so set it. nextResponder?.becomeFirstResponder() } else { // Not found, so remove keyboard textField.resignFirstResponder() } return false // We do not want UITextField to insert line-breaks. } </code></pre> <p><strong>If the superview of the text field will be a UITableViewCell then next responder will be</strong></p> <pre><code>let nextResponder=textField.superview?.superview?.superview?.viewWithTag(nextTage) as UIResponder! </code></pre>
<p>Hi to everyone please see <a href="http://www.randomsequence.com/articles/adding-a-toolbar-with-next-previous-above-uitextfield-keyboard-iphone/" rel="nofollow">this one</a></p> <pre><code>- (void)nextPrevious:(id)sender { UIView *responder = [self.view findFirstResponder]; if (nil == responder || ![responder isKindOfClass:[GroupTextField class]]) { return; } switch([(UISegmentedControl *)sender selectedSegmentIndex]) { case 0: // previous if (nil != ((GroupTextField *)responder).previousControl) { [((GroupTextField *)responder).previousControl becomeFirstResponder]; DebugLog(@"currentControl: %i previousControl: %i",((GroupTextField *)responder).tag,((GroupTextField *)responder).previousControl.tag); } break; case 1: // next if (nil != ((GroupTextField *)responder).nextControl) { [((GroupTextField *)responder).nextControl becomeFirstResponder]; DebugLog(@"currentControl: %i nextControl: %i",((GroupTextField *)responder).tag,((GroupTextField *)responder).nextControl.tag); } break; } } </code></pre>
<p>There is a <em>much</em> more elegant solution which blew me away the first time I saw it. Benefits:</p> <ul> <li>Closer to OSX textfield implementation where a textfield knows where the focus should go next</li> <li>Does not rely on setting or using tags -- which are, IMO fragile for this use case</li> <li>Can be extended to work with both <code>UITextField</code> and <code>UITextView</code> controls -- or any keyboard entry UI control</li> <li>Doesn't clutter your view controller with boilerplate UITextField delegate code</li> <li>Integrates nicely with IB and can be configured through the familiar option-drag-drop to connect outlets.</li> </ul> <p>Create a UITextField subclass which has an <code>IBOutlet</code> property called nextField. Here's the header:</p> <pre><code>@interface SOTextField : UITextField @property (weak, nonatomic) IBOutlet UITextField *nextField; @end </code></pre> <p>And here's the implementation:</p> <pre><code>@implementation SOTextField @end </code></pre> <p>In your view controller, you'll create the <code>-textFieldShouldReturn:</code> delegate method:</p> <pre><code>- (BOOL)textFieldShouldReturn:(UITextField *)textField { if ([textField isKindOfClass:[SOTextField class]]) { UITextField *nextField = [(SOTextField *)textField nextField]; if (nextField) { dispatch_async(dispatch_get_current_queue(), ^{ [nextField becomeFirstResponder]; }); } else { [textField resignFirstResponder]; } } return YES; } </code></pre> <p>In IB, change your UITextFields to use the <code>SOTextField</code> class. Next, also in IB, set the delegate for each of the 'SOTextFields'to 'File's Owner' (which is right where you put the code for the delegate method - textFieldShouldReturn). The beauty of this design is that now you can simply right-click on any textField and assign the nextField outlet to the next <code>SOTextField</code> object you want to be the next responder. </p> <p><img src="https://i.stack.imgur.com/XOfau.png" alt="Assigning nextField in IB"></p> <p>Moreover, you can do cool things like loop the textFields so that after the last one loses focus, the first one will receive focus again.</p> <p>This can easily be extended to automatically assign the <code>returnKeyType</code> of the <code>SOTextField</code> to a <code>UIReturnKeyNext</code> if there is a nextField assigned -- one less thing manually configure.</p>
<p>Here is my solution for this problem.</p> <p>To solve this (and because I hate relying on tags to do stuff) I decided to add a custom property to the UITextField object. In other words I created a category on UITextField like this :</p> <p><em><strong>UITextField+Extended.h</em></strong></p> <pre><code>@interface UITextField (Extended) @property(retain, nonatomic)UITextField* nextTextField; @end </code></pre> <p><em><strong>UITextField+Extended.m</em></strong></p> <pre><code>#import "UITextField+Extended.h" #import &lt;objc/runtime.h&gt; static char defaultHashKey; @implementation UITextField (Extended) - (UITextField*) nextTextField { return objc_getAssociatedObject(self, &amp;defaultHashKey); } - (void) setNextTextField:(UITextField *)nextTextField{ objc_setAssociatedObject(self, &amp;defaultHashKey, nextTextField, OBJC_ASSOCIATION_RETAIN_NONATOMIC); } @end </code></pre> <p>Now, here is how I use it :</p> <pre><code>UITextField *textField1 = ...init your textfield UITextField *textField2 = ...init your textfield UITextField *textField3 = ...init your textfield textField1.nextTextField = textField2; textField2.nextTextField = textField3; textField3.nextTextField = nil; </code></pre> <p>And implement the textFieldShouldReturn method :</p> <pre><code>- (BOOL)textFieldShouldReturn:(UITextField *)theTextField { UITextField *next = theTextField.nextTextField; if (next) { [next becomeFirstResponder]; } else { [theTextField resignFirstResponder]; } return NO; } </code></pre> <p>I now have kind of a linked list of UITextField, each one knowing who's next in the line.</p> <p>Hope it'll help.</p>
<p>Without usings tags and without adding a property for nextField/nextTextField, you can try this to emulate TAB, where "testInput" is your current active field:</p> <pre><code>if ([textInput isFirstResponder]) [textInput.superview.subviews enumerateObjectsAtIndexes: [NSIndexSet indexSetWithIndexesInRange: NSMakeRange([textInput.superview.subviews indexOfObject:textInput]+1, [textInput.superview.subviews count]-[textInput.superview.subviews indexOfObject:textInput]-1)] options:0 usingBlock:^(UIView *obj, NSUInteger idx, BOOL *stop) { *stop = !obj.hidden &amp;&amp; [obj becomeFirstResponder]; }]; if ([textInput isFirstResponder]) [textInput.superview.subviews enumerateObjectsAtIndexes: [NSIndexSet indexSetWithIndexesInRange: NSMakeRange(0, [textInput.superview.subviews indexOfObject:textInput])] options:0 usingBlock:^(UIView *obj, NSUInteger idx, BOOL *stop) { *stop = !obj.hidden &amp;&amp; [obj becomeFirstResponder]; }]; </code></pre>
<p>A very easy method for dismissing the keyboard when the 'Done' button is pressed is:</p> <p>Create a new IBAction in the header</p> <pre><code>- (IBAction)textFieldDoneEditing:(id)sender; </code></pre> <p>In the implementation file (.m file) add the following method:</p> <pre><code>- (IBAction)textFieldDoneEditing:(id)sender { [sender resignFirstResponder]; } </code></pre> <p>Then, when you come to link the IBAction to the textfield - link to the 'Did End On Exit' event.</p>
<p>I like the OO solutions that have already been suggested by Anth0 and Answerbot. However, I was working on a quick and small POC, so I didn't want to clutter things with subclasses and categories.</p> <p>Another simple solution is to create an NSArray of fields and lookup the next field when you press next. Not an OO solution, but quick, simple, and easy to implement. Also, you can see and modify the ordering at a glance. </p> <p>Here's my code (built upon other answers in this thread):</p> <pre><code>@property (nonatomic) NSArray *fieldArray; - (void)viewDidLoad { [super viewDidLoad]; fieldArray = [NSArray arrayWithObjects: firstField, secondField, thirdField, nil]; } - (BOOL) textFieldShouldReturn:(UITextField *) textField { BOOL didResign = [textField resignFirstResponder]; if (!didResign) return NO; NSUInteger index = [self.fieldArray indexOfObject:textField]; if (index == NSNotFound || index + 1 == fieldArray.count) return NO; id nextField = [fieldArray objectAtIndex:index + 1]; activeField = nextField; [nextField becomeFirstResponder]; return NO; } </code></pre> <ul> <li>I always return NO because I don't want a line break inserted. Just thought I'd point that out since when I returned YES it would automatically exit the subsequent fields or insert a line break in my TextView. It took me a bit of time to figure that out.</li> <li>activeField keeps track of the active field in case scrolling is necessary to unobscure the field from the keyboard. If you have similar code, make sure you assign the activeField before changing the first responder. Changing first responder is immediate and will fire the KeyboardWasShown event immediately.</li> </ul>
<p>I have added to PeyloW's answer in case you're looking to implement a previous/next button functionality:</p> <pre><code>- (IBAction)moveThroughTextFields:(UIBarButtonItem *)sender { NSInteger nextTag; UITextView *currentTextField = [self.view findFirstResponderAndReturn]; if (currentTextField != nil) { // I assigned tags to the buttons. 0 represent prev &amp; 1 represents next if (sender.tag == 0) { nextTag = currentTextField.tag - 1; } else if (sender.tag == 1) { nextTag = currentTextField.tag + 1; } } // Try to find next responder UIResponder* nextResponder = [self.view viewWithTag:nextTag]; if (nextResponder) { // Found next responder, so set it. // I added the resign here in case there's different keyboards in place. [currentTextField resignFirstResponder]; [nextResponder becomeFirstResponder]; } else { // Not found, so remove keyboard. [currentTextField resignFirstResponder]; } } </code></pre> <p>Where you subclass the UIView like this:</p> <pre><code>@implementation UIView (FindAndReturnFirstResponder) - (UITextView *)findFirstResponderAndReturn { for (UITextView *subView in self.subviews) { if (subView.isFirstResponder){ return subView; } } return nil; } @end </code></pre>
<pre><code> -(BOOL)textFieldShouldReturn:(UITextField *)textField { [[self.view viewWithTag:textField.tag+1] becomeFirstResponder]; return YES; } </code></pre>
<p>I tried to solve this problem using a more sophisticated approach based on assigning each cell (or <code>UITextField</code>) in a <code>UITableView</code> a unique tag value that can be later retrieved: <a href="http://blog.encomiabile.it/2013/02/08/how-to-activate-next-uitextfield-in-uitableview-ios/" rel="nofollow">activate-next-uitextfield-in-uitableview-ios</a></p> <p>I hope this helps!</p>
<p>I rather prefer to:</p> <pre><code>@interface MyViewController : UIViewController @property (nonatomic, retain) IBOutletCollection(UIView) NSArray *inputFields; @end </code></pre> <p>In the NIB file I hook the textFields in the desired order into this inputFields array. After that I do a simple test for the index of the UITextField that reports that the user tapped return:</p> <pre><code>// for UITextField -(BOOL)textFieldShouldReturn:(UITextField*)textField { NSUInteger index = [_inputFields indexOfObject:textField]; index++; if (index &lt; _inputFields.count) { UIView *v = [_inputFields objectAtIndex:index]; [v becomeFirstResponder]; } return NO; } // for UITextView -(BOOL)textView:(UITextView*)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString*)text { if ([@"\n" isEqualToString:text]) { NSUInteger index = [_inputFields indexOfObject:textView]; index++; if (index &lt; _inputFields.count) { UIView *v = [_inputFields objectAtIndex:index]; [v becomeFirstResponder]; } else { [self.view endEditing:YES]; } return NO; } return YES; } </code></pre>
<p>First set keyboard return key in xib, otherwise you can write code in <code>viewdidload</code>:</p> <pre><code>passWord.returnKeyType = UIReturnKeyNext; -(BOOL)textFieldShouldReturn:(UITextField *)textField { if(textField == eMail) { [textField resignFirstResponder]; [userName becomeFirstResponder]; } if (textField==userName) { [textField resignFirstResponder]; [passWord becomeFirstResponder]; } if (textField==passWord) { [textField resignFirstResponder]; [country becomeFirstResponder]; } if (textField==country) { [textField resignFirstResponder]; } return YES; } </code></pre>
<p>Here's one without delegation:</p> <pre><code>[tf1 addTarget:tf2 action:@selector(becomeFirstResponder) forControlEvents:UIControlEventEditingDidEndOnExit]; [tf2 addTarget:tf3 action:@selector(becomeFirstResponder) forControlEvents:UIControlEventEditingDidEndOnExit]; </code></pre> <p>Works using the (mostly unknown) <code>UIControlEventEditingDidEndOnExit</code> <code>UITextField</code> action.</p> <p>You can also easily hook this up in the storyboard, so no delegation <em>or</em> code is required.</p> <p>Edit: actually I cannot figure out how to hook this up in storyboard. <code>becomeFirstResponder</code> does not seem to be a offered action for this control-event, which is a pity. Still, you can hook all your textfields up to a single action in your ViewController which then determines which textField to <code>becomeFirstResponder</code> based on the sender (though then it is not as elegant as the above programmatic solution so IMO do it with the above code in <code>viewDidLoad</code>).</p>
<p>Here is an implementation of tabbing using a category on UIControl. This solution has all of the advantages of the methods from Michael and Anth0, but works for all UIControls, not just <code>UITextField</code>s. It also works seamlessly with Interface Builder and storyboards.</p> <p>Source and sample app: <a href="https://github.com/picciano/UIControlsWithTabbing" rel="nofollow noreferrer">GitHub repository for UIControlsWithTabbing</a></p> <p>Usage:</p> <pre><code>- (BOOL)textFieldShouldReturn:(UITextField *)textField { [textField transferFirstReponderToNextControl]; return NO; } </code></pre> <p><img src="https://i.stack.imgur.com/zKrrW.png" alt="Assigning nextControl in Interface Builder"></p> <p>Header:</p> <pre><code>// // UIControl+NextControl.h // UIControlsWithTabbing // #import &lt;UIKit/UIKit.h&gt; @interface UIControl (NextControl) @property (nonatomic, weak) IBOutlet UIControl *nextControl; - (BOOL)transferFirstReponderToNextControl; @end </code></pre> <p>Implementation:</p> <pre><code>#import "UIControl+NextControl.h" #import &lt;objc/runtime.h&gt; static char defaultHashKey; @implementation UIControl (NextControl) - (UIControl *)nextControl { return objc_getAssociatedObject(self, &amp;defaultHashKey); } - (void)setNextControl:(UIControl *)nextControl { objc_setAssociatedObject(self, &amp;defaultHashKey, nextControl, OBJC_ASSOCIATION_RETAIN_NONATOMIC); } - (BOOL)transferFirstReponderToNextControl { if (self.nextControl) { [self.nextControl becomeFirstResponder]; return YES; } [self resignFirstResponder]; return NO; } @end </code></pre>
<pre><code> passWord.returnKeyType = UIReturnKeyNext; -(BOOL)textFieldShouldReturn:(UITextField *)textField { if(textField == eMail) { [textField resignFirstResponder]; [userName becomeFirstResponder]; } if (textField==userName) { [textField resignFirstResponder]; [passWord becomeFirstResponder]; } if (textField==passWord) { [textField resignFirstResponder]; [country becomeFirstResponder]; } if (textField==country) { [textField resignFirstResponder]; } return YES; } </code></pre>
<pre>if (cell == nil) { cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:cellIdentifier]; txt_Input = [[ UITextField alloc] initWithFrame:CGRectMake(0, 10, 150, 30)]; txt_Input.tag = indexPath.row+1; [self.array_Textfields addObject:txt_Input]; // Initialize mutable array in ViewDidLoad } -(BOOL)textFieldShouldReturn:(UITextField *)textField { int tag = ( int) textField.tag ; UITextField * txt = [ self.array_Textfields objectAtIndex:tag ] ; [ txt becomeFirstResponder] ; return YES ; } </pre>
<p>I had about 10+ UITextField in my story board and the way I enabled next functionality was by creating an array of UITextField and making the next UITextField the firstResponder. Here's the implementation file:</p> <pre><code>#import "RegistrationTableViewController.h" @interface RegistrationTableViewController () @property (weak, nonatomic) IBOutlet UITextField *fullNameTextField; @property (weak, nonatomic) IBOutlet UITextField *addressTextField; @property (weak, nonatomic) IBOutlet UITextField *address2TextField; @property (weak, nonatomic) IBOutlet UITextField *cityTextField; @property (weak, nonatomic) IBOutlet UITextField *zipCodeTextField; @property (weak, nonatomic) IBOutlet UITextField *urlTextField; @property (weak, nonatomic) IBOutlet UITextField *usernameTextField; @property (weak, nonatomic) IBOutlet UITextField *emailTextField; @property (weak, nonatomic) IBOutlet UITextField *passwordTextField; @property (weak, nonatomic) IBOutlet UITextField *confirmPWTextField; @end NSArray *uiTextFieldArray; @implementation RegistrationTableViewController - (void)viewDidLoad { [super viewDidLoad]; NSLog(@"view did load"); uiTextFieldArray = @[self.fullNameTextField,self.addressTextField,self.address2TextField,self.cityTextField,self.zipCodeTextField,self.urlTextField,self.usernameTextField,self.emailTextField,self.passwordTextField,self.confirmPWTextField]; for(UITextField *myField in uiTextFieldArray){ myField.delegate = self; } } -(BOOL)textFieldShouldReturn:(UITextField *)textField{ long index = [uiTextFieldArray indexOfObject:textField]; NSLog(@"%ld",index); if(index &lt; (uiTextFieldArray.count - 1)){ [uiTextFieldArray[++index] becomeFirstResponder]; }else{ [uiTextFieldArray[index] resignFirstResponder]; } return YES; } - (void)didReceiveMemoryWarning { [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated. } @end </code></pre>
<p>This is the best keyboard handler I have seen. Very excellent way to manage Text inputs. </p> <p>Some of its features 1) ZERO LINE OF CODE</p> <p>2) Works Automatically</p> <p>3) No More UIScrollView</p> <p>4) No More Subclasses</p> <p>5) No More Manual Work</p> <p>6) No More #imports</p> <p><a href="https://github.com/asefnoor/IQKeyboardManager" rel="nofollow">https://github.com/asefnoor/IQKeyboardManager</a></p>
<p>This is an old post, but has a high page rank so I'll chime in with my solution.</p> <p>I had a similar issue and ended up creating a subclass of <code>UIToolbar</code> to manage the next/previous/done functionality in a dynamic tableView with sections: <a href="https://github.com/jday001/DataEntryToolbar" rel="nofollow">https://github.com/jday001/DataEntryToolbar</a></p> <p>You set the toolbar as inputAccessoryView of your text fields and add them to its dictionary. This allows you to cycle through them forwards and backwards, even with dynamic content. There are delegate methods if you want to trigger your own functionality when textField navigation happens, but you don't have to deal with managing any tags or first responder status.</p> <p>There are code snippets &amp; an example app at the GitHub link to help with the implementation details. You will need your own data model to keep track of the values inside the fields.</p>
<p>I've been using Michael G. Emmons' answer for about a year now, works great. I did notice recently that calling resignFirstResponder and then becomeFirstResponder immediately can cause the keyboard to "glitch", disappearing and then appearing immediately. I changed his version slightly to skip the resignFirstResponder if the nextField is available.</p> <pre> - (BOOL)textFieldShouldReturn:(UITextField *)textField { if ([textField isKindOfClass:[NRTextField class]]) { NRTextField *nText = (NRTextField*)textField; if ([nText nextField] != nil){ dispatch_async(dispatch_get_main_queue(), ^ { [[nText nextField] becomeFirstResponder]; }); } else{ [textField resignFirstResponder]; } } else{ [textField resignFirstResponder]; } return true; } </pre>
<p>I am surprised by how many answers here fail to understand one simple concept: navigating through controls in your app is not something the views themselves should do. It's the <strong>controller</strong>'s job to decide which control to make the next first responder.</p> <p>Also most answers only applied to navigating forward, but users may also want to go backwards.</p> <p>So here's what I've come up with. Your form should be managed by a view controller, and view controllers are part of the responder chain. So you're perfectly free to implement the following methods:</p> <pre><code>#pragma mark - Key Commands - (NSArray *)keyCommands { static NSArray *commands; static dispatch_once_t once; dispatch_once(&amp;once, ^{ UIKeyCommand *const forward = [UIKeyCommand keyCommandWithInput:@"\t" modifierFlags:0 action:@selector(tabForward:)]; UIKeyCommand *const backward = [UIKeyCommand keyCommandWithInput:@"\t" modifierFlags:UIKeyModifierShift action:@selector(tabBackward:)]; commands = @[forward, backward]; }); return commands; } - (void)tabForward:(UIKeyCommand *)command { NSArray *const controls = self.controls; UIResponder *firstResponder = nil; for (UIResponder *const responder in controls) { if (firstResponder != nil &amp;&amp; responder.canBecomeFirstResponder) { [responder becomeFirstResponder]; return; } else if (responder.isFirstResponder) { firstResponder = responder; } } [controls.firstObject becomeFirstResponder]; } - (void)tabBackward:(UIKeyCommand *)command { NSArray *const controls = self.controls; UIResponder *firstResponder = nil; for (UIResponder *const responder in controls.reverseObjectEnumerator) { if (firstResponder != nil &amp;&amp; responder.canBecomeFirstResponder) { [responder becomeFirstResponder]; return; } else if (responder.isFirstResponder) { firstResponder = responder; } } [controls.lastObject becomeFirstResponder]; } </code></pre> <p>Additional logic for scrolling offscreen responders visible beforehand may apply.</p> <p>Another advantage of this approach is that you don't need to subclass all kinds of controls you may want to display (like <code>UITextField</code>s) but can instead manage the logic at controller level, where, let's be honest, is <em>the right place</em> to do so.</p>
<p>you can use IQKeyboardManager library to do this. it handle every thing, you don't need any additional setup.IQKeyboardManager is available through CocoaPods, to install it simply add the following line to your Podfile:</p> <pre><code>pod 'IQKeyboardManager' </code></pre> <p>or Just drag and drop IQKeyBoardManager directory from demo project to your project. That's it. you can find IQKeyBoardManager directory from <a href="https://github.com/hackiftekhar/IQKeyboardManager" rel="nofollow">https://github.com/hackiftekhar/IQKeyboardManager</a></p>
<p>A more consistent and robust way is to use <a href="https://github.com/mohamede1945/NextResponderTextField" rel="nofollow noreferrer" title="NextResponderTextField">NextResponderTextField</a> You can configure it totally from interface builder with no need for setting the delegate or using <code>view.tag</code>.</p> <p>All you need to do is </p> <ol> <li>Set the class type of your <code>UITextField</code> to be <code>NextResponderTextField</code> <img src="https://i.stack.imgur.com/aLUjC.png" alt="enter image description here"></li> <li>Then set the outlet of the <code>nextResponderField</code> to point to the next responder it can be anything <code>UITextField</code> or any <code>UIResponder</code> subclass. It can be also a UIButton and the library is smart enough to trigger the <code>TouchUpInside</code> event of the button only if it's enabled. <img src="https://i.stack.imgur.com/UhVUR.png" alt="enter image description here"> <img src="https://i.stack.imgur.com/Zb012.png" alt="enter image description here"></li> </ol> <p>Here is the library in action:</p> <p><img src="https://i.stack.imgur.com/C23Lp.gif" alt="enter image description here"></p>
<p>I've just created new Pod when dealing with this stuff <a href="https://github.com/jakubknejzlik/GNTextFieldsCollectionManager" rel="nofollow">GNTextFieldsCollectionManager</a>. It automatically handles next/last textField problem and is very easy to use:</p> <pre><code>[[GNTextFieldsCollectionManager alloc] initWithView:self.view]; </code></pre> <p>Grabs all textfields sorted by appearing in view hierarchy (or by tags), or you can specify your own array of textFields.</p>
<p>This worked for me in Xamarin.iOS / Monotouch. Change the keyboard button to Next, pass the control to the next UITextField and hide the keyboard after the last UITextField.</p> <pre><code>private void SetShouldReturnDelegates(IEnumerable&lt;UIView&gt; subViewsToScout ) { foreach (var item in subViewsToScout.Where(item =&gt; item.GetType() == typeof (UITextField))) { (item as UITextField).ReturnKeyType = UIReturnKeyType.Next; (item as UITextField).ShouldReturn += (textField) =&gt; { nint nextTag = textField.Tag + 1; var nextResponder = textField.Superview.ViewWithTag(nextTag); if (null != nextResponder) nextResponder.BecomeFirstResponder(); else textField.Superview.EndEditing(true); //You could also use textField.ResignFirstResponder(); return false; // We do not want UITextField to insert line-breaks. }; } } </code></pre> <p>Inside the <strong>ViewDidLoad</strong> you'll have:</p> <p>If your TextFields haven't a Tag set it now:</p> <pre><code>txtField1.Tag = 0; txtField2.Tag = 1; txtField3.Tag = 2; //... </code></pre> <p>and just the call</p> <pre><code>SetShouldReturnDelegates(yourViewWithTxtFields.Subviews.ToList()); //If you are not sure of which view contains your fields you can also call it in a safer way: SetShouldReturnDelegates(txtField1.Superview.Subviews.ToList()); //You can also reuse the same method with different containerViews in case your UITextField are under different views. </code></pre>
<p>A swift extension that applies mxcl's answer to make this particularly easy (adapted to swift 2.3 by Traveler):</p> <pre><code>extension UITextField { class func connectFields(fields:[UITextField]) -&gt; Void { guard let last = fields.last else { return } for i in 0 ..&lt; fields.count - 1 { fields[i].returnKeyType = .Next fields[i].addTarget(fields[i+1], action: "becomeFirstResponder", forControlEvents: .EditingDidEndOnExit) } last.returnKeyType = .Done last.addTarget(last, action: #selector(UIResponder.resignFirstResponder), forControlEvents: .EditingDidEndOnExit) } } </code></pre> <p>It's easy to use:</p> <pre><code>UITextField.connectFields([field1, field2, field3]) </code></pre> <p>The extension will set the return button to "Next" for all but the last field and to "Done" for the last field, and shift focus / dismiss the keyboard when these are tapped.</p> <p><strong>Swift &lt; 2.3</strong></p> <pre><code>extension UITextField { class func connectFields(fields:[UITextField]) -&gt; Void { guard let last = fields.last else { return } for var i = 0; i &lt; fields.count - 1; i += 1 { fields[i].returnKeyType = .Next fields[i].addTarget(fields[i+1], action: "becomeFirstResponder", forControlEvents: .EditingDidEndOnExit) } last.returnKeyType = .Done last.addTarget(last, action: "resignFirstResponder", forControlEvents: .EditingDidEndOnExit) } } </code></pre> <p><strong>SWIFT 3:</strong> use like this - </p> <pre><code>UITextField.connectFields(fields: [field1, field2]) Extension: extension UITextField { class func connectFields(fields:[UITextField]) -&gt; Void { guard let last = fields.last else { return } for i in 0 ..&lt; fields.count - 1 { fields[i].returnKeyType = .next fields[i].addTarget(fields[i+1], action: #selector(UIResponder.becomeFirstResponder), for: .editingDidEndOnExit) } last.returnKeyType = .go last.addTarget(last, action: #selector(UIResponder.resignFirstResponder), for: .editingDidEndOnExit) } } </code></pre>
<p>This is a simple solution in swift, with no tag using, no storyboard tricks...</p> <p>Just use this extension :</p> <pre><code>extension UITextField{ func nextTextFieldField() -&gt; UITextField?{ //field to return var returnField : UITextField? if self.superview != nil{ //for each view in superview for (_, view) in self.superview!.subviews.enumerate(){ //if subview is a text's field if view.isKindOfClass(UITextField){ //cast curent view as text field let currentTextField = view as! UITextField //if text field is after the current one if currentTextField.frame.origin.y &gt; self.frame.origin.y{ //if there is no text field to return already if returnField == nil { //set as default return returnField = currentTextField } //else if this this less far than the other else if currentTextField.frame.origin.y &lt; returnField!.frame.origin.y{ //this is the field to return returnField = currentTextField } } } } } //end of the mdethod return returnField } } </code></pre> <p>And call it like this (for example) with your textfield delegate:</p> <pre><code>func textFieldShouldReturn(textField: UITextField) -&gt; Bool { textField.resignFirstResponder() textField.nextTextFieldField()?.becomeFirstResponder() return true } </code></pre>