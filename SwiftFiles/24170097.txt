Unexpected result due to order in Swift's pattern matching
<p>Sorry for the "Shouldn't this work?" question. But I can't figure out a better way to phrase this.</p> <pre><code>enum MyEnum { case A, B, C } let tuple = (MyEnum.C, MyEnum.A) var x: String switch tuple { case (.A, _): x = "(A, something)" case (_, .A): x = "(something, A)" case (_, .B): x = "(something, B)" case (.C, .C): x = "(C, C)" default: x = "default" } x // -&gt; "default" </code></pre> <p><code>x</code> evaluates to <code>"default"</code>, which means the default branch was taken.</p> <p>However, I was expecting <code>"(something, A)"</code> and the second case statement to match. From what I understood <code>(_, .A)</code> should match anything in the first tuple element, and <code>.A</code> in the second.</p> <p>If I move the <code>(_, .A)</code> case to the top, it is matched as I expect it. Other tuples also match where I expect them to.</p> <p>What am I missing? Why isn't this matched by the second case?</p>
<p>This behavior has been corrected in beta 3. It now shows <code>(Something, A)</code> whatever the order is.</p>