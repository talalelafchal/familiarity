How to call ambiguous method?
<p>given this code</p> <pre><code>extension Array { func filter(includeElement: (T) -&gt; Bool) -&gt; T[] { var ret = T[]() for e in self { if includeElement(e) { ret += e } } return ret } } var a = [1,2] var b = a.filter() {i in print(i); return true} </code></pre> <p>it can't compile with error message </p> <pre><code>error: ambiguous use of 'filter' var b = a.filter() {i in print(i); return true} ^ Swift.Array&lt;T&gt;:84:8: note: found this candidate func filter(includeElement: (T) -&gt; Bool) -&gt; Array&lt;T&gt; ^ &lt;REPL&gt;:30:10: note: found this candidate func filter(includeElement: (T) -&gt; Bool) -&gt; T[] { ^ </code></pre> <p>so looks like I am allowed to create extension method with duplicated method and signature, but I somehow need a special way to call it </p> <hr> <p>BTW, default <code>Array.filter</code> is broken, it calls the closure twice for each element and crashes REPL or give your rubbish result in playground if the result is inconsistent</p> <pre><code>xiliangchen-imac:~ xiliangchen$ xcrun swift Welcome to Swift! Type :help for assistance. 1&gt; let arr = [1,2,3,4,5] arr: Int[] = size=5 { [0] = 1 [1] = 2 [2] = 3 [3] = 4 [4] = 5 } 2&gt; var i = 0 i: Int = 0 3&gt; let arr2 = arr.filter() { 4. println($0) 5. return i++ &lt; 5 6. } Segmentation fault: 11 </code></pre>
<p>There is no problem with defining ambiguous methods, I think. The problem arises when you <b>import</b> 2 ambiguos methods from different modules. Unfortunately, there is no way how to exclude the <code>Array.filter</code> from being imported.</p> <p>I did some tests and it appears to me the behavior for ambigious definitions is not well defined, for example:</p> <pre><code>extension NSString { func hasPrefix(aString: String!) -&gt; Bool { return false } } let string: NSString = "test" var hasPrefix = string.hasPrefix("t") println("Has prefix: \(hasPrefix)") //prints "true" var method = string.hasPrefix hasPrefix = method("t") println("Has prefix: \(hasPrefix)") //prints "false" </code></pre> <p>The behavior could be different for obj-c classes...</p> <p>For functions, it appears the definition from current module is preferred:</p> <pre><code>func NSStringFromCGPoint(point: CGPoint) -&gt; String! { return "My method" } var point = CGPoint(x: 10.0, y: 10.0) println("Point: \(NSStringFromCGPoint(point))") //Prints "My method" println("Point: \(UIKit.NSStringFromCGPoint(point))") //Prints "{10, 10}" </code></pre>