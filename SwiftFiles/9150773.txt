View interpretKeyEvents: but pass unwanted ones up the responder chain?
<p>I'd really like my custom view to work with <code>-moveLeft:</code>, <code>-deleteForward:</code>, <code>-selectAll:</code>, etc., but I'd also like to pass any keys I didn't care about onward up the responder chain. Right now I'm overriding <code>-keyDown:</code> to call <code>[self interpretKeyEvents:[NSArray arrayWithObject:event]];</code>, but this seems to hog all the key events, even ones my view doesn't respond to.</p> <p>Is there any way to pass unwanted events up the chain, but still respond to <code>-moveLeft:</code>, etc.? Or do I need to implement all my own actions in <code>-keyDown:</code> so that I know what I did and did not respond to?</p>
<p>Came across this trying to find a solution to this same problem. Never found anything online, but I came up with something that seems to work well so far. Here's what I'm doing: </p> <p>Subclass your NSTextView (or whatever you're using) and create an instance variable to temporarily store the key down event . . .</p> <pre><code>@interface MyTextView : NSTextView { NSEvent* _keyDownEvent; } @end </code></pre> <p>Then define your view's methods like so (take out the retain/release junk if you're using automatic reference counting):</p> <pre><code>@implementation MyTextView - (id)initWithFrame:(NSRect)frame { if (self = [super initWithFrame:frame]) { _keyDownEvent = nil; } return self; } - (void)keyDown:(NSEvent*)event { [_keyDownEvent release]; _keyDownEvent = [event retain]; [super keyDown:event]; } - (void)doCommandBySelector:(SEL)selector { if (_keyDownEvent &amp;&amp; selector == @selector(noop:)) { if ([self nextResponder]) { [[self nextResponder] keyDown:[_keyDownEvent autorelease]]; } else { [_keyDownEvent release]; } _keyDownEvent = nil; } else { [super doCommandBySelector:selector]; } } - (void)dealloc { [_keyDownEvent release]; [super dealloc]; } @end </code></pre> <p>Here's how I arrived at this. When a key press isn't handled, you hear a beeping tone. So, I set a breakpoint on NSBeep(), and when the program broke, I spit out a stack trace in GDB:</p> <pre><code>#0 0x00007fff96eb1c2d in NSBeep () #1 0x00007fff96e6d739 in -[NSResponder doCommandBySelector:] () #2 0x00007fff96e6d72b in -[NSResponder doCommandBySelector:] () #3 0x00007fff96fda826 in -[NSWindow doCommandBySelector:] () #4 0x00007fff96e6d72b in -[NSResponder doCommandBySelector:] () #5 0x00007fff96e6d72b in -[NSResponder doCommandBySelector:] () #6 0x00007fff96e6d72b in -[NSResponder doCommandBySelector:] () #7 0x00007fff96e6d72b in -[NSResponder doCommandBySelector:] () #8 0x00007fff96e6d72b in -[NSResponder doCommandBySelector:] () #9 0x00007fff96e6d72b in -[NSResponder doCommandBySelector:] () #10 0x00007fff96e6d72b in -[NSResponder doCommandBySelector:] () #11 0x00007fff96f486ce in -[NSTextView doCommandBySelector:] () #12 0x00007fff96da1c93 in -[NSKeyBindingManager(NSKeyBindingManager_MultiClients) interpretEventAsCommand:forClient:] () #13 0x00007fff970f5382 in -[NSTextInputContext handleEvent:] () #14 0x00007fff96fbfd2a in -[NSView interpretKeyEvents:] () #15 0x00007fff96f38a25 in -[NSTextView keyDown:] () #16 0x0000000100012889 in -[MyTextView keyDown:] (self=0x1004763a0, _cmd=0x7fff972b0234, event=0x100197320) at /path/MyTextView.m:24 #17 0x00007fff96a16b44 in -[NSWindow sendEvent:] () #18 0x00007fff969af16d in -[NSApplication sendEvent:] () #19 0x00007fff969451f2 in -[NSApplication run] () #20 0x00007fff96bc3b88 in NSApplicationMain () #21 0x00000001000015e2 in main (argc=3, argv=0x7fff5fbff8f0) at /path/main.m:12 </code></pre> <p>What's happening is this: When the key down event isn't used for text input, a "noop" command is sent up the response chain. By default this triggers a beep when it falls off the response chain. In my solution, the NSTextView subclass catches the noop command and instead throws the original keyDown event down the response chain. Then your NSWindow or other views will get any unused keyDown events as normal.</p>
<p>This is my swift implementation of @daxnitro's answer, and seems to work:</p> <pre><code>import Cocoa class EditorTextView: NSTextView { private var keyDownEvent: NSEvent? required init?(coder aCoder: NSCoder) { super.init(coder: aCoder) } override init() { super.init() } override init(frame frameRect: NSRect, textContainer aTextContainer: NSTextContainer!) { super.init(frame: frameRect, textContainer: aTextContainer) } override func keyDown(event: NSEvent) { keyDownEvent = event super.keyDown(event) } override func doCommandBySelector(aSelector: Selector) { if aSelector != NSSelectorFromString("noop:") { super.doCommandBySelector(aSelector) } else if keyDownEvent != nil { self.nextResponder?.keyDown(keyDownEvent!) } keyDownEvent = nil } } </code></pre>