dispatch_after - GCD in swift?
<p>I've gone through the <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/BuildingCocoaApps.pdf">iBook</a> from Apple, and couldn't find any definition of it :</p> <p>Can someone explain the structure of <code>dispatch_after</code>?</p> <pre><code>dispatch_after(&lt;#when: dispatch_time_t#&gt;, &lt;#queue: dispatch_queue_t?#&gt;, &lt;#block: dispatch_block_t?#&gt;) </code></pre>
<p>To expand on Cezary's answer, which will execute after 1 nanosecond, I had to do the following to execute after 4 and a half seconds.</p> <pre><code> let delay = 4.5 * Double(NSEC_PER_SEC) let time = dispatch_time(DISPATCH_TIME_NOW, Int64(delay)) dispatch_after(time, dispatch_get_main_queue(), block) </code></pre> <p>Edit: I discovered that my original code was slightly wrong. Implicit typing causes a compile error if you don't cast NSEC_PER_SEC to a Double.</p> <p>If anyone can suggest a more optimal solution I'd be keen to hear it.</p> <p><strong>== Update for Swift 3 ==</strong></p> <p>This is super-easy and elegant in Swift 3:</p> <pre><code> DispatchQueue.main.asyncAfter(deadline: .now() + 4.5) { // ... } </code></pre>
<p>A clearer idea of the structure:</p> <pre><code>dispatch_after(when: dispatch_time_t, queue: dispatch_queue_t, block: dispatch_block_t?) </code></pre> <p><code>dispatch_time_t</code> is a <code>UInt64</code>. The <code>dispatch_queue_t</code> is actually type aliased to an <code>NSObject</code>, but you should just use your familiar GCD methods to get queues. The block is a Swift closure. Specifically, <code>dispatch_block_t</code> is defined as <code>() -&gt; Void</code>, which is equivalent to <code>() -&gt; ()</code>.</p> <p>Example usage:</p> <pre><code>let delayTime = dispatch_time(DISPATCH_TIME_NOW, Int64(1 * Double(NSEC_PER_SEC))) dispatch_after(delayTime, dispatch_get_main_queue()) { print("test") } </code></pre> <p><strong>EDIT:</strong></p> <p>I recommend using <a href="http://stackoverflow.com/questions/24034544/dispatch-after-gcd-in-swift/24318861#24318861">@matt's really nice <code>delay</code> function</a>.</p> <p><strong>EDIT 2:</strong></p> <p>In Swift 3, there will be new wrappers for GCD. See here: <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md">https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md</a></p> <p>The original example would be written as follows in Swift 3:</p> <pre><code>let deadlineTime = DispatchTime.now() + .seconds(1) DispatchQueue.main.asyncAfter(deadline: deadlineTime) { print("test") } </code></pre> <p>Note that you can write the <code>deadlineTime</code> declaration as <code>DispatchTime.now() + 1.0</code> and get the same result because the <code>+</code> operator is overridden as follows (similarly for <code>-</code>):</p> <ul> <li><code>func +(time: DispatchTime, seconds: Double) -&gt; DispatchTime</code></li> <li><code>func +(time: DispatchWalltime, interval: DispatchTimeInterval) -&gt; DispatchWalltime</code></li> </ul> <p>This means that if you don't use the <code>DispatchTimeInterval</code> <code>enum</code> and just write a number, it is assumed that you are using seconds.</p>
<p>I use <code>dispatch_after</code> so often that I wrote a top-level utility function to make the syntax simpler:</p> <pre><code>func delay(delay:Double, closure:()-&gt;()) { dispatch_after( dispatch_time( DISPATCH_TIME_NOW, Int64(delay * Double(NSEC_PER_SEC)) ), dispatch_get_main_queue(), closure) } </code></pre> <p>And now you can talk like this:</p> <pre><code>delay(0.4) { // do stuff } </code></pre> <p>Wow, a language where you can improve the language. What could be better?</p> <hr> <h3>Update for Swift 3, Xcode 8 Seed 6</h3> <p>Seems almost not worth bothering with, now that they've improved the calling syntax:</p> <pre><code>func delay(_ delay:Double, closure:@escaping ()-&gt;()) { let when = DispatchTime.now() + delay DispatchQueue.main.asyncAfter(deadline: when, execute: closure) } </code></pre>
<p><a href="http://stackoverflow.com/questions/24034544/dispatch-after-gcd-in-swift/24318861#24318861">matt's syntax</a> is very nice and if you need to invalidate the block, you may want to use this :</p> <pre><code>typealias dispatch_cancelable_closure = (cancel : Bool) -&gt; Void func delay(time:NSTimeInterval, closure:()-&gt;Void) -&gt; dispatch_cancelable_closure? { func dispatch_later(clsr:()-&gt;Void) { dispatch_after( dispatch_time( DISPATCH_TIME_NOW, Int64(time * Double(NSEC_PER_SEC)) ), dispatch_get_main_queue(), clsr) } var closure:dispatch_block_t? = closure var cancelableClosure:dispatch_cancelable_closure? let delayedClosure:dispatch_cancelable_closure = { cancel in if closure != nil { if (cancel == false) { dispatch_async(dispatch_get_main_queue(), closure!); } } closure = nil cancelableClosure = nil } cancelableClosure = delayedClosure dispatch_later { if let delayedClosure = cancelableClosure { delayedClosure(cancel: false) } } return cancelableClosure; } func cancel_delay(closure:dispatch_cancelable_closure?) { if closure != nil { closure!(cancel: true) } } </code></pre> <p>Use as follow </p> <pre><code>let retVal = delay(2.0) { println("Later") } delay(1.0) { cancel_delay(retVal) } </code></pre> <p><a href="http://sebastienthiebaud.us/blog/ios/gcd/block/2014/04/09/diggint-into-gcd-1-cancel-dispatch-after.html">credits</a></p> <p><em>Link above seems to be down. <a href="https://github.com/SebastienThiebaud/dispatch_cancelable_block">Original Objc code from Github</a></em></p>
<p>Another way is to extend Double like this:</p> <pre><code>extension Double { var dispatchTime: dispatch_time_t { get { return dispatch_time(DISPATCH_TIME_NOW,Int64(self * Double(NSEC_PER_SEC))) } } } </code></pre> <p>Then you can use it like this:</p> <pre><code>dispatch_after(Double(2.0).dispatchTime, dispatch_get_main_queue(), { () -&gt; Void in self.dismissViewControllerAnimated(true, completion: nil) }) </code></pre> <p>I like matt's delay function but just out of preference I'd rather limit passing closures around.</p>
<p>Apple has a <em>dispatch_after snippet</em> for <strong>Objective-C</strong>:</p> <pre><code>dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(&lt;#delayInSeconds#&gt; * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ &lt;#code to be executed after a specified delay#&gt; }); </code></pre> <p>Here is the same snippet ported to <strong>Swift</strong>:</p> <pre><code>dispatch_after(dispatch_time(DISPATCH_TIME_NOW, Int64(&lt;#delayInSeconds#&gt; * NSEC_PER_SEC)), dispatch_get_main_queue()) { &lt;#code to be executed after a specified delay#&gt; } </code></pre> <p>If you want to use fractions of seconds:</p> <pre><code>dispatch_after(dispatch_time(DISPATCH_TIME_NOW, Int64(&lt;#delayInSeconds#&gt; * Double(NSEC_PER_SEC))), dispatch_get_main_queue()) { &lt;#code to be executed after a specified delay#&gt; } </code></pre>
<p>use this code to perform some UI related task after 2.0 seconds.</p> <pre><code> let delay = 2.0 let delayInNanoSeconds = dispatch_time(DISPATCH_TIME_NOW, Int64(delay * Double(NSEC_PER_SEC))) let mainQueue = dispatch_get_main_queue() dispatch_after(delayInNanoSeconds, mainQueue, { print("Some UI related task after delay") }) </code></pre> <p><strong>Swift 3.0 version</strong></p> <p>Following closure function execute some task after delay on main thread. </p> <pre><code>func performAfterDelay(delay : Double, onCompletion: @escaping() -&gt; Void){ DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + delay, execute: { onCompletion() }) } </code></pre> <p>Call this function like:</p> <pre><code>performAfterDelay(delay: 4.0) { print("test") } </code></pre>
<p>1) Add this method as a part of UIViewController Extension.</p> <pre><code>extension UIViewController{ func runAfterDelay(delay: NSTimeInterval, block: dispatch_block_t) { let time = dispatch_time(DISPATCH_TIME_NOW, Int64(delay * Double(NSEC_PER_SEC))) dispatch_after(time, dispatch_get_main_queue(), block) } } </code></pre> <p>Call this method on VC: </p> <pre><code> self.runAfterDelay(5.0, block: { //Add code to this block print("run After Delay Success") }) </code></pre> <p>2) performSelector("yourMethod Name", withObject: nil, afterDelay: 1)</p> <p>3) </p> <pre><code>override func viewWillAppear(animated: Bool) { dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 2), dispatch_get_main_queue(), { () -&gt; () in //Code Here }) </code></pre> <p>//Compact Form</p> <pre><code>dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 2), dispatch_get_main_queue()) { //Code here } </code></pre> <p>}</p>
<p>Although not the original question by the OP, certain <code>NSTimer</code> related questions have been marked as duplicates of this question, so it is worth including an <code>NSTimer</code> answer here.</p> <h1><code>NSTimer</code> vs <code>dispatch_after</code></h1> <ul> <li><code>NSTimer</code> is more high level while <code>dispatch_after</code> is more low level.</li> <li><code>NSTimer</code> is easier to cancel. Canceling <code>dispatch_after</code> requires writing <a href="http://stackoverflow.com/a/25120393/3681880">more code</a>.</li> </ul> <h1>Delaying a task with <code>NSTimer</code></h1> <p>Create an <code>NSTimer</code> instance.</p> <pre><code>var timer = NSTimer() </code></pre> <p>Start the timer with the delay that you need.</p> <pre><code>// invalidate the timer if there is any chance that it could have been called before timer.invalidate() // delay of 2 seconds timer = NSTimer.scheduledTimerWithTimeInterval(2.0, target: self, selector: #selector(delayedAction), userInfo: nil, repeats: false) </code></pre> <p>Add a function to be called after the delay (using whatever name you used for the <code>selector</code> parameter above).</p> <pre><code>func delayedAction() { print("Delayed action has now started." } </code></pre> <h1>Notes</h1> <ul> <li>If you need to cancel the action before it happens, simply call <code>timer.invalidate()</code>.</li> <li>For a repeated action use <code>repeats: true</code>. </li> <li><p>If you have a one time event with no need to cancel then there is no need to create the <code>timer</code> instance variable. The following will suffice:</p> <pre><code>NSTimer.scheduledTimerWithTimeInterval(2.0, target: self, selector: #selector(delayedAction), userInfo: nil, repeats: false) </code></pre></li> <li><p>See my fuller answer <a href="http://stackoverflow.com/a/34088708/3681880">here</a>.</p></li> </ul>
<p>Another helper to delay your code that is <strong>100% Swift in usage</strong> and optionally allows for <strong>choosing a different thread</strong> to run your delayed code from:</p> <pre><code>public func delay(bySeconds seconds: Double, dispatchLevel: DispatchLevel = .main, closure: @escaping () -&gt; Void) { let dispatchTime = DispatchTime.now() + seconds dispatchLevel.dispatchQueue.asyncAfter(deadline: dispatchTime, execute: closure) } public enum DispatchLevel { case main, userInteractive, userInitiated, utility, background var dispatchQueue: DispatchQueue { switch self { case .main: return DispatchQueue.main case .userInteractive: return DispatchQueue.global(qos: .userInteractive) case .userInitiated: return DispatchQueue.global(qos: .userInitiated) case .utility: return DispatchQueue.global(qos: .utility) case .background: return DispatchQueue.global(qos: .background) } } } </code></pre> <p>Now you simply <strong>delay your code on the Main thread</strong> like this:</p> <pre><code>delay(bySeconds: 1.5) { // delayed code } </code></pre> <p>If you want to <strong>delay your code to a different thread</strong>:</p> <pre><code>delay(bySeconds: 1.5, dispatchLevel: .background) { // delayed code that will run on background thread } </code></pre> <hr> <p>If you prefer a <strong>Framework</strong> that also has some more handy features then checkout <strong><a href="https://github.com/Flinesoft/HandySwift" rel="nofollow noreferrer">HandySwift</a></strong>. You can add it to your project <strong>via Carthage</strong> then use it exactly like in the examples above, e.g.:</p> <pre><code>import HandySwift delay(bySeconds: 1.5) { // delayed code } </code></pre>
<p><strong>In Swift 3.0</strong> </p> <p><strong>Dispatch queues</strong></p> <pre><code> DispatchQueue(label: "test").async { //long running Background Task for obj in 0...1000 { print("async \(obj)") } // UI update in main queue DispatchQueue.main.async(execute: { print("UI update on main queue") }) } DispatchQueue(label: "m").sync { //long running Background Task for obj in 0...1000 { print("sync \(obj)") } // UI update in main queue DispatchQueue.main.sync(execute: { print("UI update on main queue") }) } </code></pre> <p><strong>Dispatch after 5 seconds</strong></p> <pre><code> DispatchQueue.main.after(when: DispatchTime.now() + 5) { print("Dispatch after 5 sec") } </code></pre>
<p><strong>Simplest solution in Swift 3.0</strong></p> <pre><code>func delayWithSeconds(_ seconds: Double, completion: @escaping () -&gt; ()) { DispatchQueue.main.asyncAfter(deadline: .now() + seconds) { completion() } } </code></pre> <p>Usage</p> <pre><code>delayWithSeconds(1) { //Do something } </code></pre>
<p><strong>Swift 3.0 version</strong></p> <p>Following closure function execute some task after delay on main thread. </p> <pre><code>func performAfterDelay(delay : Double, onCompletion: @escaping() -&gt; Void){ DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + delay, execute: { onCompletion() }) } </code></pre> <p>Call this function like:</p> <pre><code>performAfterDelay(delay: 4.0) { print("test") } </code></pre>