Why no stored type properties for classes in swift?
<p>Working through The Swift Programming Language, I was surprised to see that, unlike structures and enumerations, classes do not support stored type properties.</p> <p>This is a common feature of other OO languages so I assume there was a good reason they decided not to allow it. But I'm not able to guess what that reason is, especially since structures (and enumerations) have them.</p> <p>Is it simply that it's early times for Swift and it just hasn't been implemented yet? Or is there a deeper reason behind language design decision?</p> <p>BTW, "stored type property" is Swift terminology. In other languages these might be called class variables. Example code:</p> <pre><code>struct FooStruct { static var storedTypeProp = "struct stored property is OK" } FooStruct.storedTypeProp // evaluates to "struct stored property is OK" class FooClass { class var computedClassProp: String { return "computed class property is OK" } // class var storedClassProp = "class property not OK" // this won't compile } FooClass.computedClassProp // evaluates to "computed class property is OK" </code></pre> <p>Edit:</p> <p>I now realize this limitation is trivial to work around, e.g., by using a nested structure with stored properties:</p> <pre><code>class Foo { struct Stored { static var prop1 = "a stored prop" } } Foo.Stored.prop1 // evaluates to "a stored prop" Foo.Stored.prop1 = "new value" Foo.Stored.prop1 // evaluates to "new value" </code></pre> <p>That seems to preclude their being some deep inscrutable language design reason for this limitation.</p> <p>Given that and the wording of the compiler message that Martin Gordon mentions, I have to conclude that this is simply something (minor) left out.</p>
<p>The compiler error is "Class variables not yet supported" so it seems like they just haven't implemented it yet.</p>
<blockquote> <p>“For value types (that is, structures and enumerations), you can define stored and computed type properties. For classes, you can define computed type properties only."</p> <p>Excerpt From: Apple Inc. “The Swift Programming Language.” iBooks. <a href="https://itun.es/cn/jEUH0.l" rel="nofollow">https://itun.es/cn/jEUH0.l</a></p> </blockquote> <p>I think it's easy for Apple's Engineers to add <strong>stored type properties</strong> to classes, but not yet we know, maybe never in my opinion. And that's why there are labels ( <strong>static</strong> and <strong>class</strong> ) to distinguish them. </p> <p>The most important reason may be it:</p> <p><strong>To avoid different objects have shared changeable variable</strong></p> <p>we know :</p> <pre><code>static let storedTypeProperty = "StringSample" // in struct or enum ... </code></pre> <p>can be replaced by</p> <pre><code>class var storedTypeProperty:String {return "StringSample" } // in class </code></pre> <p>but </p> <pre><code>static var storedTypeProperty = "StringSample" </code></pre> <p>is harder to be replaced by <em>class phrase</em> in class.</p> <p>// I am new to Swift Programming Language actually and it's my first answer in Stack OverFlow. Glad to discuss with you. ^^</p>
<p>Extending the OP's <em>nested struct trick</em> for simulating <em>stored type properties</em>, you can go further and make it look like a pure <em>stored type property</em> from outside the class.</p> <p>Use a computed <em>getter</em> and <em>setter</em> pair like:</p> <pre><code>class ClassWithTypeProperty { struct StoredTypeProperties { static var aTypeProperty: String = "hello world" } class var aTypeProperty: String { get { return self.StoredTypeProperties.aTypeProperty } set { self.StoredTypeProperties.aTypeProperty = newValue } } } </code></pre> <p>Then you can do:</p> <pre><code>println(ClassWithTypeProperty.aTypeProperty) // Prints "hello world" ClassWithTypeProperty.aTypeProperty = "goodbye cruel world" println(ClassWithTypeProperty.aTypeProperty) // Prints "goodbye cruel world" </code></pre>