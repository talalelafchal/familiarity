Class variables not yet supported
<p>I begin my project with a split view controller as initial view controller and start it automatically from storyboard.</p> <p>Generally, an app with this UI have <strong>one and only one</strong> split view controller as root, so I create a <strong>static variable</strong> in the subclass and set it when initialisation was done.</p> <p>So I want try this behaviour with swift.</p> <p>I read the Swift programming language guide book on iBook about Type properties (with static and class keyword) and trying a piece of code to the job: </p> <pre><code>import UIKit class SplitViewController: UISplitViewController { class func sharedInstance() -&gt; SplitViewController { return SplitViewController.instance } class let instance: SplitViewController = nil init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: NSBundle?) { super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil) self.initialization() } init(coder aDecoder: NSCoder!) { super.init(coder: aDecoder); self.initialization() } func initialization() { SplitViewController.instance = self; } } </code></pre> <p>but I figured out when Xcode say the class keyword for type properties wasn't supported yet.</p> <p><img src="https://i.stack.imgur.com/nIfLo.png" alt="error detail in image"></p> <p><strong>Did you have a solution to do this ?</strong></p>
<p>It seems to be possible to declare variables with static storage duration in file scope (as in C):</p> <pre><code>var sharedInstance: SplitViewController? = nil class SplitViewController: UISplitViewController { .... func initialization() { sharedInstance = self } } </code></pre>
<p>Ok, with the solution of Nikolai that do the work. I post my changes in this thread for information</p> <pre><code>var instance: SplitViewController? = nil class SplitViewController: UISplitViewController { class func sharedInstance() -&gt; SplitViewController? { return instance; } init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: NSBundle?) { super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil) self.initialization() } init(coder aDecoder: NSCoder!) { super.init(coder: aDecoder); self.initialization() } func initialization() { instance = self } } </code></pre> <p>and for example, in my appDelegate, I can access this static method like this </p> <pre><code>SplitViewController.sharedInstance()!.presentsWithGesture = false </code></pre>
<p><a href="http://stackoverflow.com/questions/24024549/dispatch-once-singleton-model-in-swift">dispatch_once singleton model in swift</a></p> <p>Seems to be the best answer so far, avoiding the use of a global variable.</p>
<p>The wording in the error heavily implies this will be a language feature in the future. </p> <p>You may want to resort temporarily to declaring a property variable in the Application Delegate and retrieve it from there. Not ideal, definitely an anti-pattern, but would give you a central place to retrieve the <code>UISplitViewController</code> when needed.</p>
<p>A solution enough similar than var in file scope but more customisable and near singleton is to use a struct which support static var as property of class</p> <pre><code>struct PersonSharedData { static var backstore = "" var data: String { get { return PersonSharedData.backstore } set { PersonSharedData.backstore = newValue } } } class Person { var shared=PersonSharedData() //&lt;&lt; pseudo class var var family: String { get { return shared.data } set { shared.data=newValue } } var firstname = "" var lastname = "" var sexe: Sexe = .Unknown } </code></pre>
<p>Embedding a struct can work just fine as a workaround:</p> <pre><code>class SomeClass { // class var classVariable: Int = 0 // "Class variables not yet supported." Weird. // Workaround: private struct SubStruct { static var staticVariable: Int = 0 } class var workaroundClassVariable: Int { get { return SubStruct.staticVariable } set { SubStruct.staticVariable = newValue } } } </code></pre> <p>The SomeClass.workaroundClassVariable computed type property can then be used as if it were a stored type property.</p>
<p>You have to wrap the class variables inside an inner struct variable</p> <pre><code>class Store{ var name:String var address:String var lat:Int var long:Int init(name:String, address:String, lat:Int, long:Int){ self.name = name self.address = address self.lat = lat self.long=long } private struct FACTORY_INITIALIZED_FLAG { static var initialized: Bool = false static var myStoreList:[Store]? static func getMyStoreList()-&gt;[Store]{ if !initialized{ println("INITIALIZING") myStoreList = [ Store(name: "Walmart", address: "abcd", lat: 10, long: 20), Store(name: "JCPenny", address: "kjfnv", lat: 23, long: 34) ] initialized = true } return myStoreList! } } } var a = Store.FACTORY_INITIALIZED_FLAG.getMyStoreList() var b = Store.FACTORY_INITIALIZED_FLAG.getMyStoreList() // only prints INITIALIZING once </code></pre>
<p>Try this:</p> <pre><code>class var instance: SplitViewController { return nil } </code></pre>
<p>My preferred method is to just use a private file scope var outside of the class and then implement class/static getters and setters:</p> <pre><code>private var _classVar: Int = 0; class SomeClass { public class var classVar: Int { get { return _classVar } set { _classVar = newValue } } } </code></pre>
<p>As of Swift 1.2 (available with Xcode 6.3b1 and onwards), <code>static</code> class properties and methods are supported.</p> <pre><code>class SomeClass { static var someVariable: Int = 0 } </code></pre>
<p>Swift now has support for static variables in classes. This is not exactly the same as a class variable (because they aren't inherited by subclasses), but it gets you pretty close:</p> <pre><code>class X { static let y: Int = 4 static var x: Int = 4 } println(X.x) println(X.y) X.x = 5 println(X.x) </code></pre>
<p>It is called <em>Type Property</em> in Swift.</p> <blockquote> <p>You define type properties with the static keyword. For computed type properties for class types, you can use the class keyword instead to allow subclasses to override the superclassâ€™s implementation. The example below shows the syntax for stored and computed type properties:</p> </blockquote> <pre><code>struct SomeStructure { static var storedTypeProperty = "Some value." static var computedTypeProperty: Int { return 1 } } enum SomeEnumeration { static var storedTypeProperty = "Some value." static var computedTypeProperty: Int { return 6 } } class SomeClass { static var storedTypeProperty = "Some value." static var computedTypeProperty: Int { return 27 } class var overrideableComputedTypeProperty: Int { return 107 } } </code></pre> <p>Read more at link below,</p> <p><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID254" rel="nofollow">https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID254</a></p>