Downloading and parsing json in swift
<p>I'm trying to get the JSON from a website and parse it before putting it inside of an iOS view. </p> <p>Here's my code;</p> <pre><code>func startConnection(){ let urlPath: String = "http://binaenaleyh.net/dusor/" var url: NSURL = NSURL(string: urlPath) var request: NSURLRequest = NSURLRequest(URL: url) var connection: NSURLConnection = NSURLConnection(request: request, delegate: self, startImmediately: false) connection.start() } func connection(connection: NSURLConnection!, didReceiveData data: NSData!){ self.data.appendData(data) } func buttonAction(sender: UIButton!){ startConnection() } func connectionDidFinishLoading(connection: NSURLConnection!) { var err: NSError // throwing an error on the line below (can't figure out where the error message is) var jsonResult: NSDictionary = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers, error: nil) as NSDictionary } </code></pre> <p>And this is the link for the JSON;</p> <pre><code>http://binaenaleyh.net/dusor/ </code></pre> <p>What am I doing wrong here?</p>
<p>This code works fine for me. Just init data property with <code>data = NSMutableData()</code> and write NSURLConnectionDelegate here <code>class ViewController: UIViewController, NSURLConnectionDelegate</code></p> <pre><code>import UIKit class ViewController: UIViewController, NSURLConnectionDelegate { @lazy var data = NSMutableData() override func viewDidLoad() { super.viewDidLoad() } override func viewWillAppear(animated: Bool) { super.viewWillAppear(animated) startConnection() } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() } func startConnection(){ let urlPath: String = "http://binaenaleyh.net/dusor/" var url: NSURL = NSURL(string: urlPath) var request: NSURLRequest = NSURLRequest(URL: url) var connection: NSURLConnection = NSURLConnection(request: request, delegate: self, startImmediately: false) connection.start() } func connection(connection: NSURLConnection!, didReceiveData data: NSData!){ self.data.appendData(data) } func buttonAction(sender: UIButton!){ startConnection() } func connectionDidFinishLoading(connection: NSURLConnection!) { var err: NSError // throwing an error on the line below (can't figure out where the error message is) var jsonResult: NSDictionary = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers, error: nil) as NSDictionary println(jsonResult) } } </code></pre> <p>here is output: </p> <pre><code>{ "ders sayisi" = 15; dersler = ( { 0 = "2013-2014"; 1 = BAHAR; 10 = TeacherHold; 11 = 2; 12 = ""; 2 = 2; 3 = "CEE 102"; 4 = "Logic Circuits"; 5 = 3; 6 = "6.00"; 7 = "YRD.DO\U00c7.DR.INDRIT MYDERRIZI"; 8 = 0; 9 = IA; }, { 0 = "2013-2014"; 1 = BAHAR; 10 = TeacherHold; 11 = 1; 12 = ""; 2 = 2; 3 = "CIP 102"; 4 = "Civic Involment Projects"; 5 = 0; 6 = "2.00"; 7 = "SE\U00c7\U0130L AVCI/BA\U015eAK CANSU AK\U00c7EL\U0130K/\U00c7A\U011eLA UNGUN"; 8 = 0; 9 = P; }, { 0 = "2013-2014"; 1 = BAHAR; 10 = TeacherHold; 11 = 2; 12 = ""; 2 = 2; 3 = "COME 108"; 4 = "Algorithms and Programming II"; 5 = 3; 6 = "6.00"; 7 = "\U00d6\U011eR.G\U00d6R.DR.B\U0130RSEN G\U00dcLDEN \U00d6ZDEM\U0130R"; 8 = 41; 9 = C; }, { 0 = "2013-2014"; 1 = BAHAR; 10 = TeacherHold; 11 = 1; 12 = ""; 2 = 2; 3 = "COME 335"; 4 = "Mobile Application Development"; 5 = 3; 6 = "5.00"; 7 = "\U00d6\U011eR.G\U00d6R.OZAN UYSAL"; 8 = TeacherHold; 9 = TeacherHold; }, { 0 = "2013-2014"; 1 = BAHAR; 10 = TeacherHold; 11 = 1; 12 = ""; 2 = 2; 3 = "ENG 112"; 4 = "Advanced English For Engineering and Natural Sciences I"; 5 = 2; 6 = "3.00"; 7 = "OKT.ERIC BEECHER"; 8 = 48; 9 = F; }, { 0 = "2013-2014"; 1 = BAHAR; 10 = TeacherHold; 11 = 1; 12 = ""; 2 = 2; 3 = "PHYS 102"; 4 = "Physics II"; 5 = 4; 6 = "5.00"; 7 = "YRD.DO\U00c7.DR.\U00d6ZG\U00dcL KURTULU\U015e \U00d6ZT\U00dcRK"; 8 = "-1"; 9 = F; }, { 0 = "2013-2014"; 1 = BAHAR; 10 = TeacherHold; 11 = 2; 12 = ""; 2 = 2; 3 = "T\U00dcRK 102"; 4 = "T\U00fcrk Dili II"; 5 = 2; 6 = "2.00"; 7 = "\U00d6\U011eR.G\U00d6R.\U015eER\U0130FE GEZG\U0130N"; 8 = 10; 9 = F; }, { 0 = "2013-2014"; 1 = "G\U00dcZ"; 10 = TeacherHold; 11 = 2; 12 = ""; 2 = 1; 3 = "CHEM 101"; 4 = Chemistry; 5 = 3; 6 = "5.00"; 7 = "YRD.DO\U00c7.DR.AY\U015eEN TULPAR"; 8 = TeacherHold; 9 = F; }, { 0 = "2013-2014"; 1 = "G\U00dcZ"; 10 = TeacherHold; 11 = 1; 12 = ""; 2 = 1; 3 = "CIP 101"; 4 = "Civic Involment Projects"; 5 = 0; 6 = "1.00"; 7 = "YRD.DO\U00c7.DR.FATMA G\U00dcL AYGEN/Staff CIP1/SE\U00c7\U0130L AVCI/D\U0130LAYDA EM\U0130R/BA\U015eAK CANSU AK\U00c7EL\U0130K/\U00c7A\U011eLA UNGUN"; 8 = TeacherHold; 9 = P; }, { 0 = "2013-2014"; 1 = "G\U00dcZ"; 10 = TeacherHold; 11 = 3; 12 = ""; 2 = 1; 3 = "COME 107"; 4 = "Algorithms and Programming I"; 5 = 4; 6 = "5.00"; 7 = "PROF.DR.M\U0130TAT UYSAL"; 8 = TeacherHold; 9 = "C+"; }, { 0 = "2013-2014"; 1 = "G\U00dcZ"; 10 = TeacherHold; 11 = 2; 12 = ""; 2 = 1; 3 = "ENG 101"; 4 = "Advanced English"; 5 = 2; 6 = "3.00"; 7 = "OKT.EZG\U0130 ARGUN"; 8 = TeacherHold; 9 = B; }, { 0 = "2013-2014"; 1 = "G\U00dcZ"; 10 = TeacherHold; 11 = 1; 12 = ""; 2 = 1; 3 = "IUL 100"; 4 = "Introduction to University Life"; 5 = 0; 6 = "1.00"; 7 = "YRD.DO\U00c7.DR.FATMA G\U00dcL AYGEN"; 8 = TeacherHold; 9 = F; }, { 0 = "2013-2014"; 1 = "G\U00dcZ"; 10 = TeacherHold; 11 = 2; 12 = ""; 2 = 1; 3 = "MATH 111"; 4 = "Calculus I"; 5 = 4; 6 = "5.00"; 7 = "DO\U00c7.DR.G\U00dcRSEL YE\U015e\U0130LOT"; 8 = TeacherHold; 9 = F; }, { 0 = "2013-2014"; 1 = "G\U00dcZ"; 10 = TeacherHold; 11 = 4; 12 = ""; 2 = 1; 3 = "PHYS 101"; 4 = "Physics I [CNE]"; 5 = 4; 6 = "5.00"; 7 = "YRD.DO\U00c7.DR.AR\U0130F \U00d6ZBAY"; 8 = TeacherHold; 9 = F; }, { 0 = "2013-2014"; 1 = "G\U00dcZ"; 10 = TeacherHold; 11 = 9; 12 = ""; 2 = 1; 3 = "T\U00dcRK 101"; 4 = "T\U00fcrk Dili I [CNE]"; 5 = 2; 6 = "2.00"; 7 = "\U00d6\U011eR.G\U00d6R.ARZU AYG\U00dcN"; 8 = TeacherHold; 9 = F; } ); } </code></pre>
<p>These two functions worked for me:</p> <pre><code> func getJSON(urlToRequest: String) -&gt; NSData{ return NSData(contentsOfURL: NSURL(string: urlToRequest)) } func parseJSON(inputData: NSData) -&gt; NSDictionary{ var error: NSError? var boardsDictionary: NSDictionary = NSJSONSerialization.JSONObjectWithData(inputData, options: NSJSONReadingOptions.MutableContainers, error: &amp;error) as NSDictionary return boardsDictionary } </code></pre>
<p>If the original JSON is an array, try this.</p> <pre><code>func parseJSON(inputData: NSData) -&gt; Array&lt;NSDictionary&gt;{ var error: NSError? var boardsDictionary = NSJSONSerialization.JSONObjectWithData(inputData, options: NSJSONReadingOptions.MutableContainers, error: &amp;error) as Array&lt;NSDictionary&gt; return boardsDictionary } </code></pre>
<p>The example below sends a request to fetch stock information - it's a bit more comprehensive, but has more cleanup and structure: </p> <pre><code>import Foundation private let kSNStockInfoFetchRequestPath:String = "http://dev.markitondemand.com/Api/v2/Quote/json" private func SNStockInfoFetchRequestURL(symbol:String) -&gt; NSURL? { if let components:NSURLComponents = NSURLComponents(string:kSNStockInfoFetchRequestPath) { components.queryItems = [NSURLQueryItem(name:"symbol", value:symbol)] return components.URL } return nil } private func SNStockInfoFetchRequestURLRequest(symbol:String) -&gt; NSURLRequest? { if let requestURL:NSURL = SNStockInfoFetchRequestURL(symbol) { var request:NSMutableURLRequest = NSMutableURLRequest(URL:requestURL) request.HTTPMethod = "GET" return request } return nil } private func SNStockInfoFetchRequestParseData(receivedData:NSData, error:NSErrorPointer) -&gt; NSDictionary? { return NSJSONSerialization.JSONObjectWithData(receivedData, options:NSJSONReadingOptions.MutableContainers, error:error) as? NSDictionary } class SNStockInfoFetchRequest: NSObject, NSURLConnectionDataDelegate { private let symbol:String private (set) var fetching:Bool private lazy var receivedData = NSMutableData() init(symbol:String) { self.symbol = symbol self.fetching = false } func start() { assert(!fetching, "Should not start a request that has already started!") fetching = true if let request:NSURLRequest = SNStockInfoFetchRequestURLRequest(symbol) { var connection:NSURLConnection = NSURLConnection(request:request, delegate:self, startImmediately:true)! connection.start() } } // MARK: NSURLConnectionDataDelegate func connection(connection:NSURLConnection, didReceiveData data:NSData) { assert(fetching, "Should only receive data while activly fetching!") self.receivedData.appendData(data) } func connectionDidFinishLoading(connection:NSURLConnection) { var error:NSError? if let result:NSDictionary = SNStockInfoFetchRequestParseData(receivedData, &amp;error) { println(result) } else { println(error) } } } </code></pre> <p>We can now use the request as such:</p> <pre><code>let fetcher:SNStockInfoFetchRequest = SNStockInfoFetchRequest(symbol:"MSFT") fetcher.start() </code></pre> <p>This should output the JSON in case of a success, or the error in case of a failure. Hope this helps! If you use the same structure, make sure to use a delegate to either return the parsed JSON (or even better, an immutable value object) or indicate a failure. </p>
<pre><code>// // ViewController.swift // Test2 // // Created by fingent on 11/08/15. // Copyright (c) 2015 fingent. All rights reserved. // import UIKit class ViewController: UIViewController,NSURLConnectionDelegate { lazy var data = NSMutableData() @IBAction func t1(sender: AnyObject) { } override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. startConnection() } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. } func startConnection(){ let urlPath: String = "https://api.github.com/users/mralexgray" var url: NSURL = NSURL(string: urlPath)! var request: NSURLRequest = NSURLRequest(URL: url) var connection: NSURLConnection = NSURLConnection(request: request, delegate: self, startImmediately: false)! connection.start() } func connection(connection: NSURLConnection!, didReceiveData data: NSData!){ self.data.appendData(data) } func buttonAction(sender: UIButton!){ startConnection() } func connectionDidFinishLoading(connection: NSURLConnection!) { var err: NSError // throwing an error on the line below (can't figure out where the error message is) var jsonResult: NSDictionary = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers, error: nil) as NSDictionary println(jsonResult) } } </code></pre>
<p>Here is how to do it with Swift 2 and NSURLSession: </p> <pre><code>// Asynchronous Http call to your api url, using NSURLSession: NSURLSession.sharedSession().dataTaskWithURL(NSURL(string: "http://api.site.com/json")!, completionHandler: { (data, response, error) -&gt; Void in // Check if data was received successfully if error == nil &amp;&amp; data != nil { do { // Convert NSData to Dictionary where keys are of type String, and values are of any type let json = try NSJSONSerialization.JSONObjectWithData(data!, options: NSJSONReadingOptions.MutableContainers) as! [String:AnyObject] // Access specific key with value of type String let str = json["key"] as! String } catch { // Something went wrong } } }).resume() </code></pre>
<p>The answer of @david72 worked perfectly for me. So here's the same in Swift 3 and URLSession for your convenience. Also with some added error printing for easier debugging. </p> <pre><code>func getHttpData(urlAddress : String) { // Asynchronous Http call to your api url, using NSURLSession: guard let url = URL(string: urlAddress) else { print("Url conversion issue.") return } URLSession.shared.dataTask(with: url, completionHandler: { (data, response, error) -&gt; Void in // Check if data was received successfully if error == nil &amp;&amp; data != nil { do { // Convert NSData to Dictionary where keys are of type String, and values are of any type let json = try JSONSerialization.jsonObject(with: data!, options: JSONSerialization.ReadingOptions.mutableContainers) as! [String:AnyObject] print(json) // Access specific key with value of type String // let str = json["key"] as! String } catch { print(error) // Something went wrong } } else if error != nil { print(error) } }).resume() } </code></pre>