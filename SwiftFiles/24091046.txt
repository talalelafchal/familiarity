Unable to use contains within a Swift Array extension
<p>I am trying to write a simple Array extension that provides a 'distinct' method. Here is what I have so far:</p> <pre><code>extension Array { func distinct() -&gt; T[] { var rtn = T[]() for x in self { var containsItem = contains(rtn, x) if !containsItem { rtn.append(x) } } return rtn } } </code></pre> <p>The problem is that the 'contains' statement fails as follows:</p> <p>Could not find an overload for 'contains' that accepts the supplied arguments</p> <p>I am pretty sure the type constraints are correct. Any ideas?</p>
<h3>Swift 1.x</h3> <p>The elements in an <code>array</code> don't have to be <code>Equatable</code>, i.e. they don't have be comparable with <code>==</code>.</p> <p>That means you can't write that function for <em>all</em> possible Arrays. And Swift doesn't allow you to extend just a subset of Arrays.</p> <p>That means you should write it as a separate function (and that's probably why <code>contains</code> isn't a method, either).</p> <pre><code>let array = ["a", "b", "c", "a"] func distinct&lt;T: Equatable&gt;(array: [T]) -&gt; [T] { var rtn = [T]() for x in array { var containsItem = contains(rtn, x) if !containsItem { rtn.append(x) } } return rtn } distinct(array) // ["a", "b", "c"] </code></pre> <h3>Update for Swift 2/Xcode 7 (Beta)</h3> <p>Swift 2 supports restricting extensions to a subset of protocol implementations, so the following is now allowed:</p> <pre><code>let array = ["a", "b", "c", "a"] extension SequenceType where Generator.Element: Comparable { func distinct() -&gt; [Generator.Element] { var rtn: [Generator.Element] = [] for x in self { if !rtn.contains(x) { rtn.append(x) } } return rtn } } array.distinct() // ["a", "b", "c"] </code></pre> <p>Note how apple added <code>SequenceType.contains</code> using the same syntax.</p>
<p>Finally found out how to do it:</p> <pre><code>extension Array { func contains&lt;T : Equatable&gt;(obj: T) -&gt; Bool { return self.filter({$0 as? T == obj}).count &gt; 0 } func distinct&lt;T : Equatable&gt;(_: T) -&gt; T[] { var rtn = T[]() for x in self { if !rtn.contains(x as T) { rtn += x as T } } return rtn } } </code></pre> <p>And usage/testing:</p> <pre><code>let a = [ 0, 1, 2, 3, 4, 5, 6, 1, 2, 3 ] a.contains(0) a.contains(99) a.distinct(0) </code></pre> <p>Unfortunately, I can't figure out a way to do it without having to specify an argument which is subsequently ignored. The only reason it's there is to invoke the correct form of distinct. The major advantage of this approach for <code>distinct</code> seems to be that it's not dumping a common term like <code>distinct</code> into the global namespace. For the contains case it does seem more natural.</p>
<p>Another solution is to use the find(Array:[T], obj:T) function. It will return an optional Int, so what you could do is </p> <pre><code>if let foundResult = find(arr, obj) as Int { //obj is contained in arr } else { //obj is not contained in arr. } </code></pre>
<p>As of Swift 2, this can be achieved with a <em>protocol extension method</em>, e.g. on all types conforming to <code>SequenceType</code> where the sequence elements conform to <code>Equatable</code>:</p> <pre><code>extension SequenceType where Generator.Element : Equatable { func distinct() -&gt; [Generator.Element] { var rtn : [Generator.Element] = [] for elem in self { if !rtn.contains(elem) { rtn.append(elem) } } return rtn } } </code></pre> <p>Example:</p> <pre><code>let items = [1, 2, 3, 2, 3, 4] let unique = items.distinct() print(unique) // [1, 2, 3, 4] </code></pre> <p>If the elements are further restricted to be <code>Hashable</code> then you can take advantage of the <code>Set</code> type:</p> <pre><code>extension SequenceType where Generator.Element : Hashable { func distinct() -&gt; [Generator.Element] { return Array(Set(self)) } } </code></pre>