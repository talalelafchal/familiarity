How do you add a Dictionary of items into another Dictionary
<p>Arrays in Swift support the += operator to add the contents of one Array to another. Is there an easy way to do that for a dictionary?</p> <p>eg:</p> <pre><code>var dict1 = ["a" : "foo"] var dict2 = ["b" : "bar"] var combinedDict = ... (some way of combining dict1 &amp; dict2 without looping) </code></pre>
<p>Currently, looking at the <a href="https://developer.apple.com/library/prerelease/ios/documentation/General/Reference/SwiftStandardLibraryReference/Dictionary.html#//apple_ref/doc/uid/TP40014608-CH4-SW1">Swift Standard Library Reference</a> for Dictionnay, there is no way to easy update a dictionary with another one.</p> <p>You can write an extension to do it</p> <pre><code>var dict1 = ["a" : "foo"] var dict2 = ["b" : "bar"] extension Dictionary { mutating func update(other:Dictionary) { for (key,value) in other { self.updateValue(value, forKey:key) } } } dict1.update(dict2) // dict1 is now ["a" : "foo", "b" : "bar] </code></pre>
<p>It's not built into the Swift library but you can add what you want with operator overloading, e.g:</p> <pre><code>func + &lt;K,V&gt;(left: Dictionary&lt;K,V&gt;, right: Dictionary&lt;K,V&gt;) -&gt; Dictionary&lt;K,V&gt; { var map = Dictionary&lt;K,V&gt;() for (k, v) in left { map[k] = v } for (k, v) in right { map[k] = v } return map } </code></pre> <p>This overloads the <code>+</code> operator for Dictionaries which you can now use to add dictionaries with the <code>+</code> operator, e.g:</p> <pre><code>var dict1 = ["a" : "foo"] var dict2 = ["b" : "bar"] var dict3 = dict1 + dict2 // ["a": "foo", "b": "bar"] </code></pre>
<p>You can define <code>+=</code> operator for <code>Dictionary</code>, e.g.,</p> <pre><code>func += &lt;K, V&gt; (inout left: [K:V], right: [K:V]) { for (k, v) in right { left.updateValue(v, forKey: k) } } </code></pre>
<p>You can use the bridgeToObjectiveC() function to make the dictionary a NSDictionary. </p> <p>Will be like the following:</p> <pre><code>var dict1 = ["a":"Foo"] var dict2 = ["b":"Boo"] var combinedDict = dict1.bridgeToObjectiveC() var mutiDict1 : NSMutableDictionary! = combinedDict.mutableCopy() as NSMutableDictionary var combineDict2 = dict2.bridgeToObjectiveC() var combine = mutiDict1.addEntriesFromDictionary(combineDict2) </code></pre> <p>Then you can convert the NSDictionary(combine) back or do whatever. </p>
<p>The <a href="https://github.com/pNre/ExSwift" rel="nofollow">ExSwift</a> library provides dictionary merging (called Union, and defined as the pipe operator '|'), as well as a ton of other convenience functions for the basic types.</p>
<p>You can try this </p> <pre><code> var dict1 = ["a" : "foo"] var dict2 = ["b" : "bar"] var temp = NSMutableDictionary(dictionary: dict1); temp .addEntriesFromDictionary(dict2) </code></pre>
<p>You can also use reduce to merge them. Try this in the playground</p> <pre><code>let d1 = ["a":"foo","b":"bar"] let d2 = ["c":"car","d":"door"] let d3 = d1.reduce(d2) { (var d, p) in d[p.0] = p.1 return d } </code></pre>
<p>Swift 2.0</p> <pre><code>extension Dictionary { mutating func unionInPlace(dictionary: Dictionary) { dictionary.forEach { self.updateValue($1, forKey: $0) } } func union(var dictionary: Dictionary) -&gt; Dictionary { dictionary.unionInPlace(self) return dictionary } } </code></pre>
<h1>Immutable</h1> <p>I prefer to combine/unite immutable dictionaries with <code>+</code> operator so I implemented it like:</p> <pre><code>// Swift 2 func + &lt;K,V&gt; (left: Dictionary&lt;K,V&gt;, right: Dictionary&lt;K,V&gt;?) -&gt; Dictionary&lt;K,V&gt; { guard let right = right else { return left } return left.reduce(right) { var new = $0 as [K:V] new.updateValue($1.1, forKey: $1.0) return new } } let moreAttributes: [String:AnyObject] = ["Function":"authenticate"] let attributes: [String:AnyObject] = ["File":"Auth.swift"] attributes + moreAttributes + nil //["Function": "authenticate", "File": "Auth.swift"] attributes + moreAttributes //["Function": "authenticate", "File": "Auth.swift"] attributes + nil //["File": "Auth.swift"] </code></pre> <h1>Mutable</h1> <pre><code>// Swift 2 func += &lt;K,V&gt; (inout left: Dictionary&lt;K,V&gt;, right: Dictionary&lt;K,V&gt;?) { guard let right = right else { return } right.forEach { key, value in left.updateValue(value, forKey: key) } } let moreAttributes: [String:AnyObject] = ["Function":"authenticate"] var attributes: [String:AnyObject] = ["File":"Auth.swift"] attributes += nil //["File": "Auth.swift"] attributes += moreAttributes //["File": "Auth.swift", "Function": "authenticate"] </code></pre>
<p>A more readable variant using an extension. </p> <pre><code>extension Dictionary { func merge(dict: Dictionary&lt;Key,Value&gt;) -&gt; Dictionary&lt;Key,Value&gt; { var mutableCopy = self for (key, value) in dict { // If both dictionaries have a value for same key, the value of the other dictionary is used. mutableCopy[key] = value } return mutableCopy } } </code></pre>
<p>My needs were different, I needed to merge incomplete nested data sets without clobbering.</p> <pre><code>merging: ["b": [1, 2], "s": Set([5, 6]), "a": 1, "d": ["x": 2]] with ["b": [3, 4], "s": Set([6, 7]), "a": 2, "d": ["y": 4]] yields: ["b": [1, 2, 3, 4], "s": Set([5, 6, 7]), "a": 2, "d": ["y": 4, "x": 2]] </code></pre> <p>This was harder than I wanted it to be. The challenge was in mapping from dynamic typing to static typing, and I used protocols to solve this.</p> <p>Also worthy of note is that when you use the dictionary literal syntax, you actually get the foundation types, which do not pick up the protocol extensions. I aborted my efforts to support those as I couldn't find an easy to to validate the uniformity of the collection elements.</p> <pre><code>import UIKit private protocol Mergable { func mergeWithSame&lt;T&gt;(right: T) -&gt; T? } public extension Dictionary { /** Merge Dictionaries - Parameter left: Dictionary to update - Parameter right: Source dictionary with values to be merged - Returns: Merged dictionay */ func merge(right:Dictionary) -&gt; Dictionary { var merged = self for (k, rv) in right { // case of existing left value if let lv = self[k] { if let lv = lv as? Mergable where lv.dynamicType == rv.dynamicType { let m = lv.mergeWithSame(rv) merged[k] = m } else if lv is Mergable { assert(false, "Expected common type for matching keys!") } else if !(lv is Mergable), let _ = lv as? NSArray { assert(false, "Dictionary literals use incompatible Foundation Types") } else if !(lv is Mergable), let _ = lv as? NSDictionary { assert(false, "Dictionary literals use incompatible Foundation Types") } else { merged[k] = rv } } // case of no existing value else { merged[k] = rv } } return merged } } extension Array: Mergable { func mergeWithSame&lt;T&gt;(right: T) -&gt; T? { if let right = right as? Array { return (self + right) as? T } assert(false) return nil } } extension Dictionary: Mergable { func mergeWithSame&lt;T&gt;(right: T) -&gt; T? { if let right = right as? Dictionary { return self.merge(right) as? T } assert(false) return nil } } extension Set: Mergable { func mergeWithSame&lt;T&gt;(right: T) -&gt; T? { if let right = right as? Set { return self.union(right) as? T } assert(false) return nil } } var dsa12 = Dictionary&lt;String, Any&gt;() dsa12["a"] = 1 dsa12["b"] = [1, 2] dsa12["s"] = Set([5, 6]) dsa12["d"] = ["c":5, "x": 2] var dsa34 = Dictionary&lt;String, Any&gt;() dsa34["a"] = 2 dsa34["b"] = [3, 4] dsa34["s"] = Set([6, 7]) dsa34["d"] = ["c":-5, "y": 4] //let dsa2 = ["a": 1, "b":a34] let mdsa3 = dsa12.merge(dsa34) print("merging:\n\t\(dsa12)\nwith\n\t\(dsa34) \nyields: \n\t\(mdsa3)") </code></pre>
<p>All of these responses are complicated. This is my solution for swift 2.2 :</p> <pre><code> //get first dictionnary let finalDictionnary : NSMutableDictionary = self.getBasicDict() //cast second dictionnary as [NSObject : AnyObject] let secondDictionnary : [NSObject : AnyObject] = self.getOtherDict() as [NSObject : AnyObject] //merge dictionnary into the first one finalDictionnary.addEntriesFromDictionary(secondDictionnary) </code></pre>
<pre><code>import Foundation let x = ["a":1] let y = ["b":2] let out = NSMutableDictionary(dictionary: x) out.addEntriesFromDictionary(y) </code></pre> <p>The result is an NSMutableDictionary not a Swift typed dictionary, but the syntax to use it is the same (<code>out["a"] == 1</code> in this case) so you'd only have a problem if you're using third-party code which expects a Swift dictionary, or really need the type checking.</p> <p>The short answer here is that you actually do have to loop. Even if you're not entering it explicitly, that's what the method you're calling (addEntriesFromDictionary: here) will do. I'd suggest if you're a bit unclear on why that would be the case you should consider how you would merge the leaf nodes of two B-trees.</p> <p>If you really actually need a Swift native dictionary type in return, I'd suggest:</p> <pre><code>let x = ["a":1] let y = ["b":2] var out = x for (k, v) in y { out[k] = v } </code></pre> <p>The downside of this approach is that the dictionary index - however it's done - may be rebuilt several times in the loop, so in practice this is about 10x slower than the NSMutableDictionary approach.</p>
<p>You can add a <strong><code>Dictionary</code> extension</strong> like this:</p> <pre><code>extension Dictionary { func mergedWith(otherDictionary: [Key: Value]) -&gt; [Key: Value] { var mergedDict: [Key: Value] = [:] [self, otherDictionary].forEach { dict in for (key, value) in dict { mergedDict[key] = value } } return mergedDict } } </code></pre> <p>Then <strong>usage</strong> is as <strong>simple</strong> as the following:</p> <pre><code>var dict1 = ["a" : "foo"] var dict2 = ["b" : "bar"] var combinedDict = dict1.mergedWith(dict2) // =&gt; ["a": "foo", "b": "bar"] </code></pre> <hr> <p>If you prefer a framework that also includes some <strong>more handy features</strong> then checkout <strong><a href="https://github.com/Flinesoft/HandySwift" rel="nofollow">HandySwift</a></strong>. Just <strong>import it to your project</strong> and you can use the above code <strong>without adding any extensions</strong> to the project yourself.</p>
<p>Swift 2.2</p> <pre><code>func + &lt;K,V&gt;(left: [K : V], right: [K : V]) -&gt; [K : V] { var result = [K:V]() for (key,value) in left { result[key] = value } for (key,value) in right { result[key] = value } return result } </code></pre>
<p>Swift 3:</p> <pre><code>extension Dictionary { mutating func merge(with dictionary: Dictionary) { dictionary.forEach { updateValue($1, forKey: $0) } } func merged(with dictionary: Dictionary) -&gt; Dictionary { var dict = self dict.merge(with: dictionary) return dict } } let a = ["a":"b"] let b = ["1":"2"] let c = a.merged(with: b) print(c) //["a": "b", "1": "2"] </code></pre>
<p>How about</p> <pre><code>dict2.forEach { (k,v) in dict1[k] = v } </code></pre> <p>That adds all of dict2's keys and values into dict1.</p>
<p>The same as @farhadf's answer but adopted for Swift 3:</p> <pre><code>let sourceDict1 = [1: "one", 2: "two"] let sourceDict2 = [3: "three", 4: "four"] let result = sourceDict1.reduce(sourceDict2) { (partialResult , pair) in var partialResult = partialResult //without this line we could not modify the dictionary partialResult[pair.0] = pair.1 return partialResult } </code></pre>
<p>I would just use the <strong>Dollar</strong> library.</p> <p><a href="https://github.com/ankurp/Dollar/#merge---merge-1" rel="nofollow noreferrer">https://github.com/ankurp/Dollar/#merge---merge-1</a></p> <p>Merges all of the dictionaries together and the latter dictionary overrides the value at a given key</p> <pre><code>let dict: Dictionary&lt;String, Int&gt; = ["Dog": 1, "Cat": 2] let dict2: Dictionary&lt;String, Int&gt; = ["Cow": 3] let dict3: Dictionary&lt;String, Int&gt; = ["Sheep": 4] $.merge(dict, dict2, dict3) =&gt; ["Dog": 1, "Cat": 2, "Cow": 3, "Sheep": 4] </code></pre>