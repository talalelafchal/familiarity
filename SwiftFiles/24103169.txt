Swift compiler error: &quot;non-modular header inside framework module&quot;
<p>Now I would like to migrate my ObjC framework to Swift and I got the following error:</p> <pre><code>include of non-modular header inside framework module 'SOGraphDB' </code></pre> <p>The references is to a header file which just define a protocol and I use this header file in some classes to use this protocol.</p> <p>Is seems related to the module feature but it is at the moment not quite clear how to fix, do you know a solution?</p> <p>UPDATE:</p> <p>This is a Swift compiler error.</p> <p>UPDATE 2:</p> <p>A quick fix (but not solving the root cause) is to set the following setting to yes: CLANG_ALLOW_NON_MODULAR_INCLUDES_IN_FRAMEWORK_MODULES = YES</p>
<p>The header file was allocated to the target but was only marked as project visible, just a change to public lead to the resolution of this error.</p>
<p>Is your header public?</p> <p>Select the header file in the project explorer. Then in the section on the right in xcode, you'll notice there is a dropdown next to the target. Change that from "project" to "public". This worked for me.</p> <p><img src="https://i.stack.imgur.com/OXRXL.png" alt="public header"></p>
<p>I think I got around this. I have some model code that uses sqlite3 in a framework. In my case, the culprit was &lt;sqlite3.h&gt;.</p> <p>The problem was that in my Module/Module.h header, I imported a public header that imported &lt;sqlite3.h&gt;. The solution was to hide all the sqlite3_xxx types and make sure they were not visible in any public .h. All direct references to sqlite3 were made private or project visibility. For example, I had a public singleton that had some sqlite3_stmt pointers hanging off it. I moved those to a separate class that is now only a forward declaration in that public header. Now I can build.</p> <p>Incidentally, the CLANG_ALLOW_NON_MODULAR_INCLUDES_IN_FRAMEWORK_MODULES setting didn't work. I tried setting it both in the framework and the dependent project. This workaround was necessary, though I'm not sure why.</p>
<p>I had this exact problem when including my own framework in a project. Fixed it by putting all imports of sqlite3.h in .m files not in public .h ones. I'm assuming that other libraries may flag similar issues with Xcode.</p>
<p><strong>This answer is out-dated.</strong></p> <p>When importing frameworks, you must import <strong>all header files</strong> that share dependencies with the root header. The easiest way to ensure this always works is to import all headers in the framework's "Headers" folder into your public headers path.</p> <p><img src="https://i.stack.imgur.com/buxON.png" alt="enter image description here"></p> <p>The Swift compiler uses this information to generate a map of non-mangled symbols along with their associated type information.</p>
<p>I had this problem importing the Parse framework. The only way I could fix it was to discard all my changes since my last commit (simply deleting the framework and cleaning the project did not work) and add Parse again (after a fresh download of the SDK) with its other required frameworks.</p>
<p>I had the specific problem with Facebook 4.02 sdk and FBSDKCoreKit.</p> <p>I did all the steps but still error about non modular header. i drag and dropped only the specific header from the framework to build phases-> header section.</p> <p>Then automatically created a copy of the header on the project navigator at the top.</p> <p>I removed it from the build phases -> header and deleted the new file and worked fine.</p> <p>Like it reseted or something.</p>
<p>Solution for me was to go on <strong>target-> build settings->Allow non-modular includes</strong> in Framework Modules switch to YES!</p>
<p>Here's how to automatically apply the quick fix so you don't have to change <code>Pods.xcodeproj</code> manually after each <code>pod install</code>.</p> <p>Add this snippet to the end of your Podfile:</p> <pre><code>post_install do |installer| installer.pods_project.build_configuration_list.build_configurations.each do |configuration| configuration.build_settings['CLANG_ALLOW_NON_MODULAR_INCLUDES_IN_FRAMEWORK_MODULES'] = 'YES' end end </code></pre>
<p>In <strong>Swift</strong>:</p> <p><strong>1. Modify your Xcode project and targets' Build Settings as mentioned below:</strong></p> <p>Allow Non-modular Includes In Framework Modules: No</p> <p>Enable Bitcode: Yes</p> <p><strong>2. Use the current latest version available for GoogleMaps iOS SDK (use CocoaPods for getting it):</strong></p> <p>GoogleMaps (1.10.4)</p> <p><strong>3. Comment the problematic import:</strong></p> <pre><code>//import GoogleMaps </code></pre> <p><strong>4. Create or modify your bridging header file, adding the problematic import:</strong></p> <p>[Your Xcode Project Name]-Bridging-Header.h</p> <pre><code>// Use this file to import your target's public headers // that you would like to expose to Swift. #import &lt;GoogleMaps/GoogleMaps.h&gt; </code></pre> <p><strong>5. Clean and re-build your Xcode project.</strong></p>
<p>Most commonly this error is caused by the chosen answer, yet I had this error appear once by accident when dragging framework files into my new project folder. I clicked to delete the frameworks but accidentally pressed to only 'Remove Reference' to the frameworks rather than to actually delete the files completely. At this point if I opened my project folder in Finder I saw files like 'CoreLocation' and 'AudioToolbox' there. Deleting these files from the project folder and cleaning the project fixed the issue.</p>
<p>This is an expected compiler behaviour and for a very good reason. </p> <p>I think the majority of people running into this issues is caused after they switch from <code>Application Target</code> to <code>Framework Target</code> and start adding C and Objective C headers into framework's <strong>umbrella header</strong> expecting it to have a same behaviour as <strong>application's Bridging Header</strong>, which behaves differently. The umbrella header is actually designated for mixed swift, obj-c framework and its purpose is exposing the APIs to the outer world that your framework has in objective-c or c. That means the headers we put there should be in the public scope. </p> <p>It should not be used as a place that exposes Objective-C/C headers that are not a part of your framework to your framework's swift code. Because in that case these headers will be also exposed as the part of our framework module to the outer world, which is often not what we want to do since it breaks the modularity. (And that is exactly why <strong>Allows Non-modular Includes in Framework Modules</strong> defaults to <strong>NO</strong>)</p> <p>In order to expose Objective-C/C library to your framework swift code, we should define a separate swift module for such library. Then a standard swift <code>import YourLegacyLibrary</code> can be used. </p> <p>Let me demonstrate this on some typical scenario: embedding <code>libxml2</code> into our framework. </p> <p><strong>1.</strong> Your first need to create a <code>module.modulemap</code> file which looks would look in this way:</p> <p><strong>For OSX framework:</strong></p> <pre><code>module SwiftLibXML2 [system] { header "/usr/include/libxml2/libxml/xpath.h" export * } </code></pre> <p><strong>For iOS framework:</strong></p> <pre><code>module SwiftLibXML2 [system] { header "/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/include/libxml2/libxml/xpath.h" export * } </code></pre> <p>All it does is that it wrap ups the header and any other headers it references inside swift module, so that swift will then be able to generate the swift bindings for these C interfaces. </p> <p><strong>2.</strong> Then in your xcode project directory create a folder <code>SwiftLibXML2</code> and put this module.modulemap there</p> <p><strong>3.</strong> In <strong>Build Settings</strong>, add <code>$(SDKROOT)/usr/include/libxml2</code> to <strong>Header Search Paths</strong></p> <p><strong>4.</strong> In <strong>Build Settings</strong>, add <code>$(SRCROOT)/SwiftLibXML2</code> to <strong>Import Paths</strong></p> <p><strong>5.</strong> Under Project's <strong>General</strong> tab, add <code>libxml2.tbd</code> to <strong>Linked Frameworks and Libraries</strong>.</p> <p>Now you import this module where needed with:</p> <pre><code>import SwiftLibXML2 </code></pre> <p>(if you want to look a more complete module.map example, I would suggest referencing Darwin's module.modulemap at <code>/usr/include/module.modulemap</code>, you would need to have Xcode command-line tools installed to go there, reference <a href="http://superuser.com/questions/995360/missing-usr-include-in-os-x-el-capitan">Missing /usr/include in OS X El Capitan</a>)</p>
<p>I know that this is an old question, but I had the same issue and nothing from above helped me. So I hope my answer will be helpful for somebody. In my case the problem was in ALWAYS_SEARCH_USER_PATHS setting. When it was set to NO project built and worked ok. But as far as one of the pod required it to be set to YES I was receiving an error </p> <blockquote> <p>Include of non-modular header inside framework module</p> </blockquote> <p>After couple cups of coffee and all day researching I found out that according to known issues of <a href="http://adcdownload.apple.com/Developer_Tools/Xcode_7.1_beta_2/Xcode_7.1_beta_2_Release_Notes.pdf" rel="nofollow">Xcode 7.1 Beta 2 release notes</a>:</p> <blockquote> <p>â€¢ If you get an error stating "Include of non-modular header inside framework module" for a framework that previously compiled, make sure the "Always Search User Paths" build setting is set to "No". The default is "Yes" only for legacy reasons. (22784786)</p> </blockquote> <p>I was using XCode 7.3 though, but seems like this bug hasn't been fixed yet.</p>
<p>After allowing to import non modular includes, you could try to import that module using Objective-C Bridging header:</p> <pre><code>#import &lt;YandexMobileMetrica/YandexMobileMetrica.h&gt; </code></pre>
<p>I would like to add my experience with the problem as well.</p> <p>Just to summarize :</p> <ul> <li>@ambientlight's answer is great and it fixes most of the problems.</li> <li>allowing non-modular headers is another solution ( see some of the answers above )</li> <li>marking the framework's headers as public ( only the once that You want to expose ) and importing them in the umbrella header</li> <li>here are my 2 additions to the answer</li> <li>carefully check the imports in your project for headers which import your frameworks directly in them ( instead if using forward declaration if possible ), it is not a good practice to include a header file into another header file, sometimes this causes a problems, because if not done properly this may lead to multiple including of one header and linker issues</li> <li>and lastly after doing all of the above, I still kept bumping onto that error, so I dug a little more and found ( in apple developer forums, but lost the link :( ), that if You include the headers in the umbrella header not like this <code>&lt;framework/headerName.h&gt;</code>, but only like this <code>"headerName.h"</code>, the problem goes away, I tried this and for now I haven't experienced this problem anymore, however I think that this solution is valid only if You have applied some of the top answers ( they are not all compatible with each other, for example the module approach and the allowing of non modular header includes )</li> </ul> <p>ADDITION : check the architectures of the library and that of the target that You want to link it to</p>