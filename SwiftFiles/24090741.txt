How do you create an immutable array in Swift?
<p>How do I create an immutable array in Swift?</p> <p>A superficial reading of the docs would suggest you can just do </p> <pre><code>let myArray = [1,2,3] </code></pre> <p>But sadly this actually produces a mutable, fixed-size array. This mutability creates the usual puzzles with unsuspected aliasing and functions mutating their arguments:</p> <pre><code>let outterArray = [myArray, myArray] outterArray[0][0] = 2000 outterArray //=&gt; [[2000,2,3],[2000,2,3]] surprise! func notReallyPure(arr:Int[]) -&gt; () { arr[0] = 3000 } notReallyPure(myArray) myArray // =&gt; [3000,2,3] </code></pre> <p>Not much better than C.</p> <p>If I want immutability, is the best option really to wrap it in an <code>NSArray</code> like so:</p> <pre><code>let immutableArray = NSArray(myArray: [1,2,3]) </code></pre> <p>That seems nuts. What am I missing here?</p> <p><strong>UPDATE (2015-07-26):</strong></p> <p>This question dates from the very early days of Swift. Swift has since then been updated so that immutable arrays are actually immutable, as answers below indicate.</p>
<p>This has changed with Xcode 6 beta 3. While arrays used to be semi-mutable, as you describe, with their elements changeable but their length fixed, now immutable arrays share the same value semantics as Dictionaries:</p> <p>From the Xcode 6 beta 3 release notes:</p> <blockquote> <p>• Array in Swift has been completely redesigned to have full value semantics like Dictionary and String have always had in Swift. This resolves various mutability problems – now a 'let' array is completely immutable, and a 'var' array is completely mutable – composes properly with Dictionary and String, and solves other deeper problems. Value semantics may be surprising if you are used to NSArray or C arrays: a copy of the array now produces a full and independent copy of all of the elements using an efficient lazy copy implementation. This is a major change for Array, and there are still some performance issues to be addressed. Please !see the Swift Programming Language for more information. (17192555)</p> </blockquote> <p>The original information on arrays in the Swift book was updated on 7th July 2014 to reflect the beta 3 changes. (If you're using iBooks on a Mac, as I was, you may need to delete and re-download it to pick up the 7th July update—I couldn't get the thing to update automatically.)</p>
<p>There is not a great answer for this, and it is bizarre.</p> <p>You can, however, prevent accidental mutation of arrays as they flow through your program by calling <code>yourArray.unshare()</code>. This causes the array to be copied when it's assigned to a new variable.</p>
<p>Seems to be a bug and to be fixed soon.</p> <p>Cited from <a href="https://devforums.apple.com/message/989920#989920">Apple dev forum</a>:</p> <p>Question:</p> <blockquote> <p>Inconsistency with let for Array and Dictionary</p> </blockquote> <p>Final answer:</p> <blockquote> <p>This is considered to be a bug, not a feature, and will be fixed in a later Beta.<br> -Chris</p> </blockquote>
<p>IMHO the simplest workaround is simply wrap it in the closure as follows:</p> <pre><code>let mutableElements = [0,1,2,3] let reallyImmutable = {[0,1,2,3]} println(mutableElements) for i in 0..mutableElements.count { mutableElements[i] *= -1 } println(mutableElements) // [0, -1, -2, -3] println(reallyImmutable()) for i in 0..reallyImmutable().count { reallyImmutable()[i] *= -1 } println(reallyImmutable()) // [0, 1, 2, 3] println(reallyImmutable()[2]) // 2 let anotherImmutable = { reallyImmutable().map{ $0 * $0 } } println(anotherImmutable()) // [0, 1, 4, 9] </code></pre> <p>You pay extra {} on declaration and () for each access but that also makes your code speak for itself.</p> <p>Dan the Mutable Programmer</p> <p>P.S. Wrote a wrapper class <a href="https://github.com/dankogai/swift-immutablearray" rel="nofollow">ImmutableArray</a>.</p>
<p>It is now possible.</p> <p>From <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/CollectionTypes.html" rel="nofollow">Apple Developer</a></p> <blockquote> <p>If you assign an array or a dictionary to a constant, that array or dictionary is immutable, and its size and contents cannot be changed.</p> </blockquote> <p>So now</p> <pre><code>let myArray = [1,2,3] </code></pre> <p>produces <strong>completely immutable</strong> array. Yay!</p>