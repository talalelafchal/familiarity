Swift language NSClassFromString
<p>How to achieve <a href="http://en.wikipedia.org/wiki/Reflection_%28computer_programming%29#Objective-C">reflection</a> in Swift Language?</p> <p>How can I instantiate a class </p> <pre><code>[[NSClassFromString(@"Foo") alloc] init]; </code></pre>
<p>It's almost the same</p> <pre><code>func NSClassFromString(_ aClassName: String!) -&gt; AnyClass! </code></pre> <p>Check this doc:</p> <p><a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_Functions/#//apple_ref/c/func/NSClassFromString">https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_Functions/#//apple_ref/c/func/NSClassFromString</a></p>
<p>I was able to instantiate an object dynamically</p> <pre><code>var clazz: NSObject.Type = TestObject.self var instance : NSObject = clazz() if let testObject = instance as? TestObject { println("yes!") } </code></pre> <p>I haven't found a way to create <code>AnyClass</code> from a <code>String</code> (without using Obj-C). I think they don't want you to do that because it basically breaks the type system.</p>
<p>You must put <code>@objc(SwiftClassName)</code> above your swift class.<br> Like: </p> <pre><code>@objc(SubClass) class SubClass: SuperClass {...} </code></pre>
<p>I think I'm right in saying that you can't, at least not with the current beta (2). Hopefully this is something that will change in future versions.</p> <p>You can use <code>NSClassFromString</code> to get a variable of type <code>AnyClass</code> but there appears to be no way in Swift to instantiate it. You can use a <a href="http://ijoshsmith.com/2014/06/05/instantiating-classes-by-name-in-swift/" rel="nofollow">bridge to Objective C and do it there</a> or -- if it works in your case -- <a href="http://www.zx81.org.uk/computing/programming/learning-swift.html" rel="nofollow">fall back to using a switch statement</a>.</p>
<p>Here is a good example: </p> <pre><code>class EPRocks { @require init() { } } class EPAwesome : EPRocks { func awesome() -&gt; String { return "Yes"; } } var epawesome = EPAwesome.self(); print(epawesome.awesome); </code></pre>
<p>UPDATE: Starting with beta 6 NSStringFromClass will return your bundle name plus class name separated by a dot. So it will be something like MyApp.MyClass</p> <p>Swift classes will have a constructed internal name that is build up of the following parts:</p> <ul> <li>It will start with _TtC,</li> <li>followed by a number that is the length of your application name,</li> <li>followed by your application name, </li> <li>folowed by a number that is the length of your class name,</li> <li>followed by your class name.</li> </ul> <p>So your class name will be something like _TtC5MyApp7MyClass</p> <p>You can get this name as a string by executing:</p> <pre><code>var classString = NSStringFromClass(self.dynamicType) </code></pre> <p>Using that string, you can create an instance of your Swift class by executing:</p> <pre><code>var anyobjectype : AnyObject.Type = NSClassFromString(classString) var nsobjectype : NSObject.Type = anyobjectype as NSObject.Type var rec: AnyObject = nsobjectype() </code></pre>
<p>Less hacky solution here: <a href="http://stackoverflow.com/a/32265287/308315">http://stackoverflow.com/a/32265287/308315</a></p> <p>Note that Swift classes are namespaced now so instead of "MyViewController" it'd be "AppName.MyViewController"</p> <hr> <blockquote> <p>Deprecated since XCode6-beta 6/7</p> <p>Solution developed using XCode6-beta 3</p> </blockquote> <p>Thanks to the answer of Edwin Vermeer I was able to build something to instantiate Swift classes into an Obj-C class by doing this:</p> <pre><code>// swift file // extend the NSObject class extension NSObject { // create a static method to get a swift class for a string name class func swiftClassFromString(className: String) -&gt; AnyClass! { // get the project name if var appName: String? = NSBundle.mainBundle().objectForInfoDictionaryKey("CFBundleName") as String? { // generate the full name of your class (take a look into your "YourProject-swift.h" file) let classStringName = "_TtC\(appName!.utf16count)\(appName)\(countElements(className))\(className)" // return the class! return NSClassFromString(classStringName) } return nil; } } // obj-c file #import "YourProject-Swift.h" - (void)aMethod { Class class = NSClassFromString(key); if (!class) class = [NSObject swiftClassFromString:(key)]; // do something with the class } </code></pre> <p><strong>EDIT</strong></p> <p>You can also do it in pure obj-c:</p> <pre><code>- (Class)swiftClassFromString:(NSString *)className { NSString *appName = [[NSBundle mainBundle] objectForInfoDictionaryKey:@"CFBundleName"]; NSString *classStringName = [NSString stringWithFormat:@"_TtC%d%@%d%@", appName.length, appName, className.length, className]; return NSClassFromString(classStringName); } </code></pre> <p>I hope this will help somebody !</p>
<p>This will get you the name of the class that you want to instantiate. Then you can use <a href="http://stackoverflow.com/a/24524077/292145">Edwins answer</a> to instantiate a new object of your class.</p> <p>As of beta 6 <code>_stdlib_getTypeName</code> gets the mangled type name of a variable. Paste this into an empty playground:</p> <pre><code>import Foundation class PureSwiftClass { } var myvar0 = NSString() // Objective-C class var myvar1 = PureSwiftClass() var myvar2 = 42 var myvar3 = "Hans" println( "TypeName0 = \(_stdlib_getTypeName(myvar0))") println( "TypeName1 = \(_stdlib_getTypeName(myvar1))") println( "TypeName2 = \(_stdlib_getTypeName(myvar2))") println( "TypeName3 = \(_stdlib_getTypeName(myvar3))") </code></pre> <p>The output is:</p> <pre><code>TypeName0 = NSString TypeName1 = _TtC13__lldb_expr_014PureSwiftClass TypeName2 = _TtSi TypeName3 = _TtSS </code></pre> <p>Ewan Swick's blog entry helps to decipher these strings: <a href="http://www.eswick.com/2014/06/inside-swift/">http://www.eswick.com/2014/06/inside-swift/</a></p> <p>e.g. <code>_TtSi</code> stands for Swift's internal <code>Int</code> type.</p>
<p>Apparently, it is not possible (anymore) to instantiate an object in Swift when the name of the class is only known at runtime. An Objective-C wrapper is possible for subclasses of NSObject. </p> <p>At least you can instantiate an object of the same class as another object given at runtime without an Objective-C wrapper (using xCode Version 6.2 - 6C107a):</p> <pre><code> class Test : NSObject {} var test1 = Test() var test2 = test1.dynamicType.alloc() </code></pre>
<p>In Swift 2.0 (tested in the beta2 of Xcode 7) it works like this:</p> <pre><code>protocol Init { init() } var type = NSClassFromString(className) as? Init.Type let obj = type!.init() </code></pre> <p>For sure the type coming from <code>NSClassFromString</code> have to implement this init protocol.</p> <p>I expect it is clear, <code>className</code> is a String containing the Obj-C runtime name of the class which is by default NOT just "Foo", but this discussion is IMHO not the major topic of your question.</p> <p>You need this protocol because be default all Swift classes don't implement an <code>init</code> method.</p>
<p>Looks like the correct incantation would be...</p> <pre><code>func newForName&lt;T:NSObject&gt;(p:String) -&gt; T? { var result:T? = nil if let k:AnyClass = NSClassFromString(p) { result = (k as! T).dynamicType.init() } return result } </code></pre> <p>...where "p" stands for "packaged" – a distinct issue.</p> <p>But the critical cast from AnyClass to T currently causes a compiler crash, so in the meantime one must bust initialization of k into a separate closure, which compiles fine.</p>
<p>xcode 7 beta 5:</p> <pre><code>class MyClass { required init() { print("Hi!") } } if let classObject = NSClassFromString("YOURAPPNAME.MyClass") as? MyClass.Type { let object = classObject.init() } </code></pre>
<p>This is the way I init derived UIViewController by class name</p> <pre><code>var className = "YourAppName.TestViewController" let aClass = NSClassFromString(className) as! UIViewController.Type let viewController = aClass() </code></pre> <p>More information is <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WritingSwiftClassesWithObjective-CBehavior.html">here</a></p> <p>In iOS 9</p> <pre><code>var className = "YourAppName.TestViewController" let aClass = NSClassFromString(className) as! UIViewController.Type let viewController = aClass.init() </code></pre>
<p>I use different targets, and in this case the swift class is not found. You should replace CFBundleName with CFBundleExecutable. I also fixed the warnings:</p> <pre><code>- (Class)swiftClassFromString:(NSString *)className { NSString *appName = [[NSBundle mainBundle] objectForInfoDictionaryKey:@"CFBundleExecutable"]; NSString *classStringName = [NSString stringWithFormat:@"_TtC%lu%@%lu%@", (unsigned long)appName.length, appName, (unsigned long)className.length, className]; return NSClassFromString(classStringName); } </code></pre>
<p>Also in Swift 2.0 (possibly before?) You can access the type directly with the <code>dynamicType</code> property</p> <p>i.e.</p> <pre><code>class User { required init() { // class must have an explicit required init() } var name: String = "" } let aUser = User() aUser.name = "Tom" print(aUser) let bUser = aUser.dynamicType.init() print(bUser) </code></pre> <p>Output</p> <pre><code>aUser: User = { name = "Tom" } bUser: User = { name = "" } </code></pre> <p>Works for my use case</p>
<h2>In Swift 2.0 (tested in the Xcode 7.01) _20150930</h2> <pre><code>let vcName = “HomeTableViewController" let ns = NSBundle.mainBundle().infoDictionary!["CFBundleExecutable"] as! String // Convert string to class let anyobjecType: AnyObject.Type = NSClassFromString(ns + "." + vcName)! if anyobjecType is UIViewController.Type { // vc is instance let vc = (anyobjecType as! UIViewController.Type).init() print(vc) } </code></pre>
<p><strong>For swift2, I created a very simple extension to do this more quickly</strong> <a href="https://github.com/damienromito/NSObject-FromClassName">https://github.com/damienromito/NSObject-FromClassName</a></p> <pre><code>extension NSObject { class func fromClassName(className : String) -&gt; NSObject { let className = NSBundle.mainBundle().infoDictionary!["CFBundleName"] as! String + "." + className let aClass = NSClassFromString(className) as! UIViewController.Type return aClass.init() } } </code></pre> <hr> <p>In my case, i do this to load the ViewController I want:</p> <pre><code>override func viewDidLoad() { super.viewDidLoad() let controllers = ["SettingsViewController", "ProfileViewController", "PlayerViewController"] self.presentController(controllers.firstObject as! String) } func presentController(controllerName : String){ let nav = UINavigationController(rootViewController: NSObject.fromClassName(controllerName) as! UIViewController ) nav.navigationBar.translucent = false self.navigationController?.presentViewController(nav, animated: true, completion: nil) } </code></pre>
<p>Try this.</p> <pre><code>let className: String = String(ControllerName.classForCoder()) print(className) </code></pre>
<p>I have implemented like this,</p> <pre><code>if let ImplementationClass: NSObject.Type = NSClassFromString(className) as? NSObject.Type{ ImplementationClass.init() } </code></pre>
<p>string from class </p> <pre><code>let classString = NSStringFromClass(TestViewController.self) </code></pre> <p>or</p> <pre><code>let classString = NSStringFromClass(TestViewController.classForCoder()) </code></pre> <p><strong>init a UIViewController class from string:</strong></p> <pre><code>let vcClass = NSClassFromString(classString) as! UIViewController.Type let viewController = vcClass.init() </code></pre>