How do you ignore generic type information and enable covariance of properties?
i.e. struct Child<Type> { var item: Type } class Parent { var children = [Child<**ANY subclass of UIView, for example**>]() } so if I have let one = Child(item: UIView()) let two = Child(item: UITableView()) I'd like to have let parent = Parent() parent.children += [one,two] If you type the Parent class's children property with [Child<UIView>] it will ONLY accept Child of the type UIView and not covariant types (i.e. UITableView.) I need to handle a generic type that can have any subclass of UIView, but the Parent class doesn't even care about this property, it only touches other non-generic properties of the Child class. Is there anyway of doing this that doesn't require Objective-C era dynamic type casting?
var children = [Child<**ANY subclass of UIView, for example**>] Wouldn't that be nice? But forget it. Generics that you create are not covariant on the parameterized type, and nothing you can do will make them so. Where generics are, polymorphism is not. You might object: But look at Optional! Look at Array! Yes, look at them. They get some sort of special dispensation from Apple. Even generics imported from Objective-C may now be covariant. But not your generics. However, you might be able to make an array of differently parameterized Child objects by using type erasure. This would have nothing to do with the inheritance of the parameterized types, however. It would just be a way of allowing multiple Child structs to go into one array.