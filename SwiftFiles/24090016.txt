Sort Dictionary by values in Swift
<p>Is there are analog of - (NSArray *)keysSortedByValueUsingSelector:(SEL)comparator in swift?</p> <p>How to do this without casting to NSDictionary?</p> <p>I tried this, but it seems to be not a good solution.</p> <pre><code>var values = Array(dict.values) values.sort({ $0 &gt; $1 }) for number in values { for (key, value) in dict { if value == number { println(key + " : \(value)"); dict.removeValueForKey(key); break } } } </code></pre> <p>Example:</p> <pre><code>var dict = ["cola" : 10, "fanta" : 12, "sprite" : 8] dict.sortedKeysByValues(&gt;) // fanta (12), cola(10), sprite(8) </code></pre>
<p>Just cast it to NSDictionary and then call the method. Anywhere you use <code>@selector</code> in ObjC you can just use a String in Swift. So it would look like this:</p> <pre><code>var dict = ["cola" : 10, "fanta" : 12, "sprite" : 8] let sortedKeys = (dict as NSDictionary).keysSortedByValueUsingSelector("compare:") </code></pre> <p>or </p> <pre><code>let sortedKeys2 = (dict as NSDictionary).keysSortedByValueUsingComparator { ($0 as NSNumber).compare($1 as NSNumber) } </code></pre>
<p>Try:</p> <pre><code>let dict = ["a":1, "c":3, "b":2] extension Dictionary { func sortedKeys(isOrderedBefore:(Key,Key) -&gt; Bool) -&gt; [Key] { return Array(self.keys).sort(isOrderedBefore) } // Slower because of a lot of lookups, but probably takes less memory (this is equivalent to Pascals answer in an generic extension) func sortedKeysByValue(isOrderedBefore:(Value, Value) -&gt; Bool) -&gt; [Key] { return sortedKeys { isOrderedBefore(self[$0]!, self[$1]!) } } // Faster because of no lookups, may take more memory because of duplicating contents func keysSortedByValue(isOrderedBefore:(Value, Value) -&gt; Bool) -&gt; [Key] { return Array(self) .sort() { let (_, lv) = $0 let (_, rv) = $1 return isOrderedBefore(lv, rv) } .map { let (k, _) = $0 return k } } } dict.keysSortedByValue(&lt;) dict.keysSortedByValue(&gt;) </code></pre> <p>Updated:</p> <p>Updated to the new array syntax and sort semantics from beta 3. Note that I'm using <code>sort</code> and not <code>sorted</code> to minimize array copying. The code could be made more compact, by looking at the earlier version and replacing <code>sort</code> with <code>sorted</code> and fixing the <code>KeyType[]</code> to be <code>[KeyType]</code></p> <p>Updated to Swift 2.2:</p> <p>Changed types from <code>KeyType</code> to <code>Key</code> and <code>ValueType</code> to <code>Value</code>. Used new <code>sort</code> builtin to <code>Array</code> instead of <code>sort(Array)</code> Note performance of all of these could be slightly improved by using <code>sortInPlace</code> instead of <code>sort</code></p>
<p>You could use something like this perhaps:</p> <pre><code>var dict = ["cola" : 10, "fanta" : 12, "sprite" : 8] var myArr = Array(dict.keys) var sortedKeys = sort(myArr) { var obj1 = dict[$0] // get ob associated w/ key 1 var obj2 = dict[$1] // get ob associated w/ key 2 return obj1 &gt; obj2 } myArr // ["fanta", "cola", "sprite"] </code></pre>
<p>This is how I did it - sorting in this case by a key called position. Try this in a playground:</p> <pre class="lang-swift prettyprint-override"><code>var result: [[String: AnyObject]] = [] result.append(["name" : "Ted", "position": 1]) result.append(["name" : "Bill", "position": 0]) result result = sorted(result, positionSort) func positionSort(dict1: [String: AnyObject], dict2: [String: AnyObject]) -&gt; Bool { let position1 = dict1["position"] as? Int ?? 0 let position2 = dict2["position"] as? Int ?? 0 return position1 &lt; position2 } </code></pre>
<p>This should give you the sorted keys based on value, and is a little more cleaner:</p> <pre><code>var sortedKeys = Array(dict.keys).sorted({dict[$0] &lt; dict[$1]}) </code></pre>
<p>Sorting your keys by the dictionary's value is actually simpler than it appears at first:</p> <pre><code>let yourDict = ["One": "X", "Two": "B", "Three": "Z", "Four": "A"] let sortedKeys = yourDict.keys.sort({ (firstKey, secondKey) -&gt; Bool in return yourDict[firstKey] &lt; yourDict[secondKey] }) </code></pre> <p>And that's it! There's really nothing more to it. I have yet to find a quicker method.</p>
<p>I think this is the easiest way to sort Swift dictionary by value.</p> <pre><code>let dict = ["apple":1, "cake":3, "banana":2] let byValue = { (elem1:(key: String, val: Int), elem2:(key: String, val: Int))-&gt;Bool in if elem1.val &lt; elem2.val { return true } else { return false } } let sortedDict = dict.sort(byValue) </code></pre>
<p>As of Swift 3, to sort your keys based on values, the below looks promising:</p> <pre><code>var keys = Array(dict.keys) keys.sortInPlace { (o1, o2) -&gt; Bool in return dict[o1]! as! Int &gt; dict[o2]! as! Int } </code></pre>
<p>Lots of answers, here's a one-liner. I like it because it makes full use of native Swift iterative functions and doesn't use variables. This should help the optimiser do its magic.</p> <pre><code>return dictionary.keys.sort({ $0 &lt; $1 }).flatMap({ dictionary[$0] }) </code></pre> <p>Note the use of flatMap, because subscripting a dictionary returns an optional value. In practice this should never return nil since we get the key from the dictionary itself. <code>flatMap</code> is there only to ensure that the result is not an array of optionals. If your array's associated value should BE an optional you can use <code>map</code> instead.</p>
<p>In Swift 3.0, assuming you have a NSDictionary of type [String:Float], and you want to sort it according to ascending order.</p> <pre><code>["Apple": 0.50] ["Grapes": 1.0] ["Strawberry": 5.0] let ascendingPrices = Array(fruitTypes.keys).sorted(by: &gt;) </code></pre> <p>Alternatively, descending order you just have to change the <code>&gt;</code> to <code>&lt;</code>. It is also applicable to other data types such as <code>String</code>, <code>Int</code>, <code>Double</code>, <code>Date</code>.</p>