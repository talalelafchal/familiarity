Memory leaks in the swift playground / deinit{} not called consistently
<p>ARC object deletion seems to be inconsistent in the Swift Playground. Is it a bug or by design?</p> <p>Consider this class:</p> <pre><code>class Test { var name: String init(name:String){ self.name = name println("\(name) initialized") } deinit{ println("\(name) deinitialized") } } </code></pre> <p>When I call it from the playground (not the command line REPL, see comment below):</p> <pre><code>var t1 = Test(name: "t1") var t2 : Test? = Test(name: "t2") t2 = nil </code></pre> <p>I see only initialization messages in the console:</p> <pre><code>t1 initialized t2 initialized </code></pre> <p>What's missing is deinit of t2.</p> <p>When I run it in an app (e.g. entry of app delegate), I the output is consistent with ARC deletion (i.e. t1 init, then t2, and t2 deinit and then t1, since the entire invocation block goes out of scope):</p> <pre><code>t1 initialized t2 initialized t2 deinitialized t1 deinitialized </code></pre> <p>Finally, in the command line REPL (see comment below for accessing the REPL), the results are consisent, i.e.: t1 is alive due to its top level scope, but t2 is ARC deleted, as one would expect.</p> <pre><code> 1&gt; class Test { 2. var name: String 3. init(name:String){ 4. self.name = name 5. println("\(name) initialized") 6. } 7. deinit{ 8. println("\(name) deinitialized") 9. } 10. } 11&gt; var t1 = Test(name: "t1") t1 initialized t1 initialized t1 deinitialized t1: Test = { name = "t1" } 12&gt; var t2 : Test? = Test(name: "t2") t2 initialized t2 initialized t2 deinitialized t2: Test? = (name = "t2") 13&gt; t2 = nil t2 deinitialized 14&gt; t1 $R2: Test = { name = "t1" } 15&gt; t2 $R3: Test? = nil </code></pre>
<p>(Answering own question, in accordance with SO guidelines):</p> <p>We compared ARC/deletion of objection in an app scenario and within the Playground. Our test code used object created inside and outside a particular scope. We also nested the tester object to test multi-nested scoping. </p> <p>We saw that the app scenario deletes objects right on cue (zeroth reference) whereas the Playground scenario deletes a few, but holds on to a <em>majority</em> of objects (irrespective of scope, but apparently consistent over multiple runs). </p> <p>The Playground probably holds on to objects in order to service its assistant GUI output (and/or its playback feature). </p> <p>See blog post <a href="http://pvdev.wordpress.com/2014/06/03/memory-leaks-in-the-swift-playground/">here</a> .</p>
<p>I found that I could trigger the call to deinit{} in a playground (Xcode version 6.0 (6A313)) by adding an outer layer of optional:</p> <pre><code>struct MetaTest { var t3: Test? = Test(name: "t3") } var mt3: MetaTest? = MetaTest() mt3!.t3 = nil </code></pre> <p>which creates this output:</p> <pre><code>t3 initialized t3 deinitialized </code></pre>