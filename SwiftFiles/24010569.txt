Error-Handling in Swift-Language
<p>I haven't read too much into Swift but one thing I noticed is that there are no exceptions. So how do they do error handling in Swift? Has anyone found anything related to error-handling?</p>
<p>There are no Exceptions in Swift, similar to Objective-C's approach.</p> <p>In development, you can use <code>assert</code> to catch any errors which might appear, and need to be fixed before going to production.</p> <p>The classic <code>NSError</code> approach isn't altered, you send an <code>NSErrorPointer</code>, which gets populated.</p> <p>Brief example: </p> <pre><code>var error: NSError? var contents = NSFileManager.defaultManager().contentsOfDirectoryAtPath("/Users/leandros", error: &amp;error) if let error = error { println("An error occurred \(error)") } else { println("Contents: \(contents)") } </code></pre>
<h2>Swift 1.x</h2> <p><strong>Runtime errors:</strong></p> <p>As Leandros suggests for handling runtime errors (like network connectivity problems, parsing data, opening file, etc) you should use <code>NSError</code> like you did in ObjC, because the Foundation, AppKit, UIKit, etc report their errors in this way. So it's more framework thing than language thing.</p> <p>Another frequent pattern that is being used are separator success/failure blocks like in AFNetworking:</p> <pre><code>var sessionManager = AFHTTPSessionManager(baseURL: NSURL(string: "yavin4.yavin.planets")) sessionManager.HEAD("/api/destoryDeathStar", parameters: xwingSquad, success: { (NSURLSessionDataTask) -&gt; Void in println("Success") }, failure:{ (NSURLSessionDataTask, NSError) -&gt; Void in println("Failure") }) </code></pre> <p>Still the failure block frequently received <code>NSError</code> instance, describing the error.</p> <p><strong>Programmer errors:</strong></p> <p>For programmer errors (like out of bounds access of array element, invalid arguments passed to a function call, etc) you used exceptions in ObjC. Swift language does not seem to have any language support for exceptions (like <code>throw</code>, <code>catch</code>, etc keyword). However, as documentation suggests it is running on the same runtime as ObjC, and therefore you are still able to throw <code>NSExceptions</code> like this:</p> <pre><code>NSException(name: "SomeName", reason: "SomeReason", userInfo: nil).raise() </code></pre> <p>You just cannot catch them in pure Swift, although you may opt for catching exceptions in ObjC code.</p> <p>The questions is whether you should throw exceptions for programmer errors, or rather use assertions as Apple suggests in the language guide.</p> <hr> <h2>Swift 2.0 update</h2> <p>Things have changed a bit in Swift 2.0, as there is a new error-handling mechanism, that is somewhat more similar to exceptions but different in detail.</p> <ol> <li>Indicating error possibility</li> </ol> <p>If function/method wants to indicate that it may throw an error, it should contain <code>throws</code> keyword like this </p> <pre><code>func rideTheDragon() throws { ... } </code></pre> <p>Note: there is no specification of what function actually can throw, it is either throwing any error or not throwing anything at all.</p> <ol start="2"> <li>Invoking function that may throw errors</li> </ol> <p>In order to invoke function you need to use try keyword, like this</p> <pre><code>try rideTheDragon(dragon: Dragon) </code></pre> <p>this line should normally be present do-catch block like this</p> <pre><code>do { try rideTheDragon(redDragon) } catch DragonError.DragonIsMissing { // Error-handling } catch DragonError.NotEnoughMana(let manaRequired) { // More error-handlng } catch { // Catch all error-handling } </code></pre> <p>Note: catch clause use all the powerful features of Swift pattern matching so you are very flexible here.</p> <p>Alternatively in function that is itself marked with <code>throws</code> keyword like this</p> <pre><code>func fullFillQuest(quest: Quest) throws { try rideTheDragon(quest.dragon) } </code></pre> <p>Last but not least, you can decide that you know that error will not actually occur, e.g. because you have already checked are prerequisites, and use <code>try!</code> keyword.</p> <pre><code>try! rideTheDragon(goldenDragon) </code></pre> <p>If the function actually throws the error, then you'll get a runtime error in your application.</p> <ol start="3"> <li>Throwing an error</li> </ol> <p>In order to throw an error you use throw keyword like this</p> <pre><code>throw DragonError.DragonIsMissing </code></pre> <p>You can throw anything that conforms to <code>ErrorType</code> protocol. For starters <code>NSError</code> conforms to this protocol but you probably would like to go with enum-based <code>ErrorType</code> which enables you to group multiple related errors, potentially with additional pieces of data, like this</p> <pre><code>enum DragonError: ErrorType { case DragonIsMissing case NotEnoughMana(manaRequired: Int) ... } </code></pre> <hr> <p>Main differences between new Swift 2.0 error mechanism and Java/C#/C++ style exceptions are follows:</p> <ul> <li>Syntax is a bit different: <code>do-catch</code> + <code>try</code> + <code>defer</code> vs traditional <code>try-catch-finally</code> syntax.</li> <li>Exception handling usually incurs much higher execution time in exception path than in success path. This is not the case with Swift 2.0 errors, where success path and error path cost roughly the same.</li> <li>All error throwing code must be declared, while exceptions might have been thrown from anywhere. All errors are "checked exceptions" in Java nomenclature. However, in contrast to Java, you do not specify potentially thrown errors.</li> <li>Swift exceptions are not compatible with ObjC exceptions. Your <code>do-catch</code> block will not catch any NSException, and vice versa, for that you must use ObjC.</li> <li>Swift exceptions are compatible with Cocoa <code>NSError</code> method conventions of returning either <code>false</code> (for <code>Bool</code> returning functions) or <code>nil</code> (for <code>AnyObject</code> returning functions) and passing <code>NSErrorPointer</code> with error details.</li> </ul> <p>As an extra syntatic-sugar to ease error handling, there are two more concepts</p> <ul> <li>deferred actions (using <code>defer</code> keyword) which let you achieve the same effect as finally blocks in Java/C#/etc</li> <li>guard statement (using <code>guard</code> keyword) which let you write little less if/else code than in normal error checking/signaling code.</li> </ul>
<p><strong><em>Edit:</strong> Although this answer works, it is little more than Objective-C transliterated into Swift. It has been made obsolete by changes in Swift 2.0. Guilherme Torres Castro's answer above is a very good introduction to the preferred way of handling errors in Swift. VOS</em></p> <p>It took a bit of figuring it out but I think I've sussed it. It seems ugly though. Nothing more than a thin skin over the Objective-C version.</p> <p>Calling a function with an NSError parameter...</p> <pre><code>var fooError : NSError ? = nil let someObject = foo(aParam, error:&amp;fooError) // Check something was returned and look for an error if it wasn't. if !someObject { if let error = fooError { // Handle error NSLog("This happened: \(error.localizedDescription)") } } else { // Handle success }` </code></pre> <p>Writing the function that takes an error parameter...</p> <pre><code>func foo(param:ParamObject, error: NSErrorPointer) -&gt; SomeObject { // Do stuff... if somethingBadHasHappened { if error { error.memory = NSError(domain: domain, code: code, userInfo: [:]) } return nil } // Do more stuff... } </code></pre>
<p><strong>Update June 9th 2015 - Very important</strong></p> <p>Swift 2.0 comes with <code>try</code>, <code>throw</code>, and <code>catch</code> keywords and the most exciting is: </p> <blockquote> <p>Swift automatically translates Objective-C methods that produce errors into methods that throw an error according to Swift's native error handling functionality.</p> <p>Note: Methods that consume errors, such as delegate methods or methods that take a completion handler with an NSError object argument, do not become methods that throw when imported by Swift.</p> </blockquote> <p><sub>Excerpt From: Apple Inc. “Using Swift with Cocoa and Objective-C (Swift 2 Prerelease).” iBooks.</sub></p> <p>Example: (from the book)</p> <pre><code>NSFileManager *fileManager = [NSFileManager defaultManager]; NSURL *URL = [NSURL fileURLWithPath:@"/path/to/file"]; NSError *error = nil; BOOL success = [fileManager removeItemAtURL:URL error:&amp;error]; if (!success &amp;&amp; error){ NSLog(@"Error: %@", error.domain); } </code></pre> <p>The equivalent in swift will be:</p> <pre><code>let fileManager = NSFileManager.defaultManager() let URL = NSURL.fileURLWithPath("path/to/file") do { try fileManager.removeItemAtURL(URL) } catch let error as NSError { print ("Error: \(error.domain)") } </code></pre> <p>Throwing an Error:</p> <pre><code>*errorPtr = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorCannotOpenFile userInfo: nil] </code></pre> <p>Will be automatically propagated to the caller:</p> <pre><code>throw NSError(domain: NSURLErrorDomain, code: NSURLErrorCannotOpenFile, userInfo: nil) </code></pre> <hr> <p>From Apple books, The Swift Programming Language it's seems errors should be handle using enum.</p> <p>Here is an example from the book.</p> <pre><code>enum ServerResponse { case Result(String, String) case Error(String) } let success = ServerResponse.Result("6:00 am", "8:09 pm") let failure = ServerResponse.Error("Out of cheese.") switch success { case let .Result(sunrise, sunset): let serverResponse = "Sunrise is at \(sunrise) and sunset is at \(sunset)." case let .Error(error): let serverResponse = "Failure... \(error)" } </code></pre> <p><sub>From: Apple Inc. “The Swift Programming Language.” iBooks. <a href="https://itun.es/br/jEUH0.l" rel="nofollow">https://itun.es/br/jEUH0.l</a></sub></p> <p><strong>Update</strong></p> <p>From Apple news books, "Using Swift with Cocoa and Objective-C". Runtime exceptions not occur using swift languages, so that's why you don't have try-catch. Instead you use <a href="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/OptionalChaining.html" rel="nofollow">Optional Chaining</a>.</p> <p>Here is a stretch from the book:</p> <blockquote> <p>For example, in the code listing below, the first and second lines are not executed because the length property and the characterAtIndex: method do not exist on an NSDate object. The myLength constant is inferred to be an optional Int, and is set to nil. You can also use an if–let statement to conditionally unwrap the result of a method that the object may not respond to, as shown on line three</p> </blockquote> <pre><code>let myLength = myObject.length? let myChar = myObject.characterAtIndex?(5) if let fifthCharacter = myObject.characterAtIndex(5) { println("Found \(fifthCharacter) at index 5") } </code></pre> <p><sub>Excerpt From: Apple Inc. “Using Swift with Cocoa and Objective-C.” iBooks. <a href="https://itun.es/br/1u3-0.l" rel="nofollow">https://itun.es/br/1u3-0.l</a></sub></p> <hr> <p>And the books also encourage you to use cocoa error pattern from Objective-C (NSError Object) </p> <blockquote> <p>Error reporting in Swift follows the same pattern it does in Objective-C, with the added benefit of offering optional return values. In the simplest case, you return a Bool value from the function to indicate whether or not it succeeded. When you need to report the reason for the error, you can add to the function an NSError out parameter of type NSErrorPointer. This type is roughly equivalent to Objective-C’s NSError **, with additional memory safety and optional typing. You can use the prefix &amp; operator to pass in a reference to an optional NSError type as an NSErrorPointer object, as shown in the code listing below.</p> </blockquote> <pre><code>var writeError : NSError? let written = myString.writeToFile(path, atomically: false, encoding: NSUTF8StringEncoding, error: &amp;writeError) if !written { if let error = writeError { println("write failure: \(error.localizedDescription)") } } </code></pre> <p><sub>Excerpt From: Apple Inc. “Using Swift with Cocoa and Objective-C.” iBooks. <a href="https://itun.es/br/1u3-0.l" rel="nofollow">https://itun.es/br/1u3-0.l</a></sub></p>
<p>Basic wrapper around objective C that gives you the try catch feature. <a href="https://github.com/williamFalcon/SwiftTryCatch" rel="nofollow">https://github.com/williamFalcon/SwiftTryCatch</a></p> <p>Use like:</p> <pre><code>SwiftTryCatch.try({ () -&gt; Void in //try something }, catch: { (error) -&gt; Void in //handle error }, finally: { () -&gt; Void in //close resources }) </code></pre>
<p>The recommended 'Swift Way' is:</p> <pre><code>func write(path: String)(#error: NSErrorPointer) -&gt; Bool { // Useful to curry error parameter for retrying (see below)! return "Hello!".writeToFile(path, atomically: false, encoding: NSUTF8StringEncoding, error: error) } var writeError: NSError? let written = write("~/Error1")(error: &amp;writeError) if !written { println("write failure 1: \(writeError!.localizedDescription)") // assert(false) // Terminate program } </code></pre> <p>However I prefer try/catch as I find it easier to follow because it moves the error handling to a separate block at the end, this arrangement is sometimes called "Golden Path". Lucky you can do this with closures:</p> <pre><code>TryBool { write("~/Error2")(error: $0) // The code to try }.catch { println("write failure 2: \($0!.localizedDescription)") // Report failure // assert(false) // Terminate program } </code></pre> <p>Also it is easy to add a retry facility:</p> <pre><code>TryBool { write("~/Error3")(error: $0) // The code to try }.retry { println("write failure 3 on try \($1 + 1): \($0!.localizedDescription)") return write("~/Error3r") // The code to retry }.catch { println("write failure 3 catch: \($0!.localizedDescription)") // Report failure // assert(false) // Terminate program } </code></pre> <p>The listing for TryBool is:</p> <pre><code>class TryBool { typealias Tryee = NSErrorPointer -&gt; Bool typealias Catchee = NSError? -&gt; () typealias Retryee = (NSError?, UInt) -&gt; Tryee private var tryee: Tryee private var retries: UInt = 0 private var retryee: Retryee? init(tryee: Tryee) { self.tryee = tryee } func retry(retries: UInt, retryee: Retryee) -&gt; Self { self.retries = retries self.retryee = retryee return self } func retry(retryee: Retryee) -&gt; Self { return self.retry(1, retryee) } func retry(retries: UInt) -&gt; Self { // For some reason you can't write the body as "return retry(1, nil)", the compiler doesn't like the nil self.retries = retries retryee = nil return self } func retry() -&gt; Self { return retry(1) } func catch(catchee: Catchee) { var error: NSError? for numRetries in 0...retries { // First try is retry 0 error = nil let result = tryee(&amp;error) if result { return } else if numRetries != retries { if let r = retryee { tryee = r(error, numRetries) } } } catchee(error) } } </code></pre> <p>You can write a similar class for testing an Optional returned value instead of Bool value:</p> <pre><code>class TryOptional&lt;T&gt; { typealias Tryee = NSErrorPointer -&gt; T? typealias Catchee = NSError? -&gt; T typealias Retryee = (NSError?, UInt) -&gt; Tryee private var tryee: Tryee private var retries: UInt = 0 private var retryee: Retryee? init(tryee: Tryee) { self.tryee = tryee } func retry(retries: UInt, retryee: Retryee) -&gt; Self { self.retries = retries self.retryee = retryee return self } func retry(retryee: Retryee) -&gt; Self { return retry(1, retryee) } func retry(retries: UInt) -&gt; Self { // For some reason you can't write the body as "return retry(1, nil)", the compiler doesn't like the nil self.retries = retries retryee = nil return self } func retry() -&gt; Self { return retry(1) } func catch(catchee: Catchee) -&gt; T { var error: NSError? for numRetries in 0...retries { error = nil let result = tryee(&amp;error) if let r = result { return r } else if numRetries != retries { if let r = retryee { tryee = r(error, numRetries) } } } return catchee(error) } } </code></pre> <p>The TryOptional version enforces a non-Optional return type that makes subsequent programming easier, e.g. 'Swift Way:</p> <pre><code>struct FailableInitializer { init?(_ id: Int, error: NSErrorPointer) { // Always fails in example if error != nil { error.memory = NSError(domain: "", code: id, userInfo: [:]) } return nil } private init() { // Empty in example } static let fallback = FailableInitializer() } func failableInitializer(id: Int)(#error: NSErrorPointer) -&gt; FailableInitializer? { // Curry for retry return FailableInitializer(id, error: error) } var failError: NSError? var failure1Temp = failableInitializer(1)(error: &amp;failError) if failure1Temp == nil { println("failableInitializer failure code: \(failError!.code)") failure1Temp = FailableInitializer.fallback } let failure1 = failure1Temp! // Unwrap </code></pre> <p>Using TryOptional:</p> <pre><code>let failure2 = TryOptional { failableInitializer(2)(error: $0) }.catch { println("failableInitializer failure code: \($0!.code)") return FailableInitializer.fallback } let failure3 = TryOptional { failableInitializer(3)(error: $0) }.retry { println("failableInitializer failure, on try \($1 + 1), code: \($0!.code)") return failableInitializer(31) }.catch { println("failableInitializer failure code: \($0!.code)") return FailableInitializer.fallback } </code></pre> <p>Note auto-unwrapping.</p>
<p>Nice and simple lib to handle exception: <a href="https://github.com/kongtomorrow/TryCatchFinally-Swift" rel="nofollow">TryCatchFinally-Swift</a></p> <p>Like a few others it wraps around the objective C exception features.</p> <p>Use it like this:</p> <pre><code>try { println(" try") }.catch { e in println(" catch") }.finally { println(" finally") } </code></pre>
<p>Error handling is a new feature of Swift 2.0. It uses the <code>try</code>, <code>throw</code> and <code>catch</code> keywords.</p> <p>See the <a href="https://developer.apple.com/swift/blog/?id=29" rel="nofollow">Apple Swift 2.0 announcement on the official Apple Swift blog</a></p>
<p>What I have seen is that because of the nature of the device you don't want to be throwing a bunch of cryptic error handling messages at the user. That is why most functions return optional values then you just code to ignore the optional. If a function comes back nil meaning it failed you can pop a message or whatever.</p>
<p>This is an update answer for swift 2.0. I am looking forward feature rich Error handling model like in java. Finally, they announced the good news. <a href="https://developer.apple.com/swift/blog/?id=29" rel="nofollow">here</a></p> <blockquote> <p>Error handling model: The new error handling model in Swift 2.0 will instantly feel natural, with familiar <strong>try, throw, and catch keywords</strong>. Best of all, it was designed to work perfectly with the Apple SDKs and NSError. In fact, NSError conforms to a Swift’s ErrorType. You’ll definitely want to watch the WWDC session on What’s New in Swift to hear more about it.</p> </blockquote> <p>e.g :</p> <pre><code>func loadData() throws { } func test() { do { try loadData() } catch { print(error) }} </code></pre>
<p>As Guilherme Torres Castro said, in Swift 2.0, <code>try</code>, <code>catch</code>, <code>do</code> can be used in the programming.</p> <p>For example, In CoreData fetch data method, instead of put <code>&amp;error</code> as a parameter into the <code>managedContext.executeFetchRequest(fetchRequest, error: &amp;error)</code>, now we only need to use use <code>managedContext.executeFetchRequest(fetchRequest)</code> and then handle the error with <code>try</code>, <code>catch</code> (<a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/CoreDataFramework/Classes/NSManagedObjectContext_Class/index.html#//apple_ref/occ/instm/NSManagedObjectContext/executeFetchRequest:error:" rel="nofollow">Apple Document Link</a>) </p> <pre><code>do { let fetchedResults = try managedContext.executeFetchRequest(fetchRequest) as? [NSManagedObject] if let results = fetchedResults{ people = results } } catch { print("Could not fetch") } </code></pre> <p>If you have already download the xcode7 Beta. Try to search <em>throwing errors</em> in <em>Documentations and API Reference</em> and choose the first showing result, it gives a basic idea what can be done for this new syntax. However, fully documentation is not post for many APIs yet. </p> <p>More fancy Error Handling techniques can be found in </p> <blockquote> <p>What's New in Swift (2015 Session 106 28m30s)</p> </blockquote>
<p>Starting with Swift 2, as others have already mentioned, error handling is best accomplished through the use of do/try/catch and ErrorType enums. This works quite well for synchronous methods, but a little cleverness is required for asynchronous error handling.</p> <p>This article has a great approach to this problem:</p> <p><a href="https://jeremywsherman.com/blog/2015/06/17/using-swift-throws-with-completion-callbacks/" rel="nofollow">https://jeremywsherman.com/blog/2015/06/17/using-swift-throws-with-completion-callbacks/</a></p> <p>To summarize:</p> <pre><code>// create a typealias used in completion blocks, for cleaner code typealias LoadDataResult = () throws -&gt; NSData // notice the reference to the typealias in the completionHandler func loadData(someID: String, completionHandler: LoadDataResult -&gt; Void) { completionHandler() } </code></pre> <p>then, the call to the above method would be as follows:</p> <pre><code>self.loadData("someString", completionHandler: { result: LoadDataResult in do { let data = try result() // success - go ahead and work with the data } catch { // failure - look at the error code and handle accordingly } }) </code></pre> <p>This seems a bit cleaner than having a separate errorHandler callback passed to the asynchronous function, which was how this would be handled prior to Swift 2.</p>