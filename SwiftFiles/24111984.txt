How do you test functions and closures for equality?
<p><a href="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-XID_117">The book says that "functions and closures are reference types".</a> So, how do you find out if the references are equal? == and === don't work.</p> <pre><code>func a() { } let å = a let b = å === å // Could not find an overload for === that accepts the supplied arguments </code></pre> <p>Here is how the Catterwauls are dealing with this:</p> <p><a href="https://github.com/Catterwaul/HemiprocneMystacea/blob/develop/HemiprocneMystacea/Swift/MultiClosure.swift">MultiClosures &amp; Equatable Closures</a></p> <p><a href="https://github.com/Catterwaul/HemiprocneMystacea/blob/develop/HemiprocneMystaceaTests/Swift/MultiClosureTestCase.swift">tests</a> </p>
<p>Well it's been 2 days and nobody has chimed in with a solution, so I'll change my comment to an answer:</p> <p>As far as I can tell, you can't check equality or identity of functions (like your example) and metaclasses (e.g., <code>MyClass.self</code>):</p> <p>But – and this is just an idea – I can't help but notice that the <a href="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-XID_250" rel="nofollow"><code>where</code> clause in generics</a> appears to be able to check equality of types. So maybe you can leverage that, at least for checking identity?</p>
<p>I've been looking for the answer, too. And I've found it at last.</p> <ul> <li><a href="https://gist.github.com/dankogai/b03319ce427544beb5a4" rel="nofollow">https://gist.github.com/dankogai/b03319ce427544beb5a4</a></li> </ul> <p>What you need is the actual function pointer and its context hidden in the function object.</p> <pre><code>func peekFunc&lt;A,R&gt;(f:A-&gt;R)-&gt;(fp:Int, ctx:Int) { typealias IntInt = (Int, Int) let (hi, lo) = unsafeBitCast(f, IntInt.self) let offset = sizeof(Int) == 8 ? 16 : 12 let ptr = UnsafePointer&lt;Int&gt;(lo+offset) return (ptr.memory, ptr.successor().memory) } @infix func === &lt;A,R&gt;(lhs:A-&gt;R,rhs:A-&gt;R)-&gt;Bool { let (tl, tr) = (peekFunc(lhs), peekFunc(rhs)) return tl.0 == tr.0 &amp;&amp; tl.1 == tr.1 } </code></pre> <p>And here is the demo:</p> <pre><code>// simple functions func genericId&lt;T&gt;(t:T)-&gt;T { return t } func incr(i:Int)-&gt;Int { return i + 1 } var f:Int-&gt;Int = genericId var g = f; println("(f === g) == \(f === g)") f = genericId; println("(f === g) == \(f === g)") f = g; println("(f === g) == \(f === g)") // closures func mkcounter()-&gt;()-&gt;Int { var count = 0; return { count++ } } var c0 = mkcounter() var c1 = mkcounter() var c2 = c0 println("peekFunc(c0) == \(peekFunc(c0))") println("peekFunc(c1) == \(peekFunc(c1))") println("peekFunc(c2) == \(peekFunc(c2))") println("(c0() == c1()) == \(c0() == c1())") // true : both are called once println("(c0() == c2()) == \(c0() == c2())") // false: because c0() means c2() println("(c0 === c1) == \(c0 === c1)") println("(c0 === c2) == \(c0 === c2)") </code></pre> <p>See the URLs below to find why and how it works:</p> <ul> <li><a href="https://github.com/rodionovd/SWRoute/wiki/Function-hooking-in-Swift" rel="nofollow">https://github.com/rodionovd/SWRoute/wiki/Function-hooking-in-Swift</a></li> <li><a href="https://github.com/rodionovd/SWRoute/blob/master/SWRoute/rd_get_func_impl.c" rel="nofollow">https://github.com/rodionovd/SWRoute/blob/master/SWRoute/rd_get_func_impl.c</a></li> </ul> <p>As you see it is capable of checking identity only (the 2nd test yields <code>false</code>). But that should be good enough.</p>
<p>Simplest way is designate the block type as <code>@objc_block</code>, and now you can cast it to an AnyObject which is comparable with <code>===</code>. Example:</p> <pre><code> typealias Ftype = @objc_block (s:String) -&gt; () let f : Ftype = { ss in println(ss) } let ff : Ftype = { sss in println(sss) } let obj1 = unsafeBitCast(f, AnyObject.self) let obj2 = unsafeBitCast(ff, AnyObject.self) let obj3 = unsafeBitCast(f, AnyObject.self) println(obj1 === obj2) // false println(obj1 === obj3) // true </code></pre>
<p>Chris Lattner wrote on the developer forums:</p> <blockquote> <p>This is a feature we intentionally do not want to support. There are a variety of things that will cause pointer equality of functions (in the swift type system sense, which includes several kinds of closures) to fail or change depending on optimization. If "===" were defined on functions, the compiler would not be allowed to merge identical method bodies, share thunks, and perform certain capture optimizations in closures. Further, equality of this sort would be extremely surprising in some generics contexts, where you can get reabstraction thunks that adjust the actual signature of a function to the one the function type expects.</p> </blockquote> <p><a href="https://devforums.apple.com/message/1035180#1035180">https://devforums.apple.com/message/1035180#1035180</a></p> <p>This means that you should not even try to compare closures for equality because optimizations may affect the outcome.</p>
<p>I searched a lot. There seems to be no way of function pointer comparison. The best solution I got is to encapsulate the function or closure in an hashable object. Like:</p> <pre><code>var handler:Handler = Handler(callback: { (message:String) in //handler body })) </code></pre>
<p>This is a great question and while Chris Lattner intentionally doesn't want to support this feature I, like many developers, also can't let go of my feelings coming from other languages where this is a trivial task. There are plenty of <code>unsafeBitCast</code> examples, most of them don't show the full picture, <a href="https://gist.github.com/ianbytchek/49a46b785518fb72f0b2" rel="nofollow">here's a more detailed one</a>:</p> <pre><code>typealias SwfBlock = () -&gt; () typealias ObjBlock = @convention(block) () -&gt; () func testSwfBlock(a: SwfBlock, _ b: SwfBlock) -&gt; String { let objA = unsafeBitCast(a as ObjBlock, AnyObject.self) let objB = unsafeBitCast(b as ObjBlock, AnyObject.self) return "a is ObjBlock: \(a is ObjBlock), b is ObjBlock: \(b is ObjBlock), objA === objB: \(objA === objB)" } func testObjBlock(a: ObjBlock, _ b: ObjBlock) -&gt; String { let objA = unsafeBitCast(a, AnyObject.self) let objB = unsafeBitCast(b, AnyObject.self) return "a is ObjBlock: \(a is ObjBlock), b is ObjBlock: \(b is ObjBlock), objA === objB: \(objA === objB)" } func testAnyBlock(a: Any?, _ b: Any?) -&gt; String { if !(a is ObjBlock) || !(b is ObjBlock) { return "a nor b are ObjBlock, they are not equal" } let objA = unsafeBitCast(a as! ObjBlock, AnyObject.self) let objB = unsafeBitCast(b as! ObjBlock, AnyObject.self) return "a is ObjBlock: \(a is ObjBlock), b is ObjBlock: \(b is ObjBlock), objA === objB: \(objA === objB)" } class Foo { lazy var swfBlock: ObjBlock = self.swf func swf() { print("swf") } @objc func obj() { print("obj") } } let swfBlock: SwfBlock = { print("swf") } let objBlock: ObjBlock = { print("obj") } let foo: Foo = Foo() print(testSwfBlock(swfBlock, swfBlock)) // a is ObjBlock: false, b is ObjBlock: false, objA === objB: false print(testSwfBlock(objBlock, objBlock)) // a is ObjBlock: false, b is ObjBlock: false, objA === objB: false print(testObjBlock(swfBlock, swfBlock)) // a is ObjBlock: true, b is ObjBlock: true, objA === objB: false print(testObjBlock(objBlock, objBlock)) // a is ObjBlock: true, b is ObjBlock: true, objA === objB: true print(testAnyBlock(swfBlock, swfBlock)) // a nor b are ObjBlock, they are not equal print(testAnyBlock(objBlock, objBlock)) // a is ObjBlock: true, b is ObjBlock: true, objA === objB: true print(testObjBlock(foo.swf, foo.swf)) // a is ObjBlock: true, b is ObjBlock: true, objA === objB: false print(testSwfBlock(foo.obj, foo.obj)) // a is ObjBlock: false, b is ObjBlock: false, objA === objB: false print(testAnyBlock(foo.swf, foo.swf)) // a nor b are ObjBlock, they are not equal print(testAnyBlock(foo.swfBlock, foo.swfBlock)) // a is ObjBlock: true, b is ObjBlock: true, objA === objB: true </code></pre> <p>The interesting part is how swift freely casts SwfBlock to ObjBlock, yet in reality two casted SwfBlock blocks will always be different values, while ObjBlocks won't. When we cast ObjBlock to SwfBlock, the same thing happens to them, they become two different values. So, in order to preserve the reference, this sort of casting should be avoided.</p> <p>I'm still comprehending this whole subject, but one thing I left wishing for is ability to use <code>@convention(block)</code> on class / struct methods, so I filed a <a href="https://bugs.swift.org/browse/SR-664" rel="nofollow">feature request</a> that needs up-voting or explaining why it's a bad idea. I also get a sense this approach might be bad all together, if so, can anyone explain why?</p>