How in Swift specify type constraint to be enum?
<p>I want to specify a type constraint that the type should be a raw value enum:</p> <pre><code>enum SomeEnum: Int { case One, Two, Three } class SomeProtocol&lt;E: enum&lt;Int&gt;&gt; { // &lt;- won't compile func doSomething(e: E) { compute(e.toRaw()) } } </code></pre> <p>How can I do it in Swift? (I used the F# syntax for example)</p>
<p>AFAIK, Swift does not support type constraint to be specified with enums. </p> <p>Cited from <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-XID_234" rel="nofollow">Swift Manual</a></p> <blockquote> <p>Type Constraint Syntax</p> <p>You write type constraints by placing <strong>a single class or protocol</strong> constraint after a type parameterâ€™s name, separated by a colon, as part of the type parameter list. The basic syntax for type constraints on a generic function is shown below (although the syntax is the same for generic types):</p> </blockquote> <p>Strictly limited to a class or protocol unless there's some hidden features which is not mentioned in manual. As far as I tested, <code>struct</code> or <code>enum</code> are all prohibited by the compiler. </p> <pre><code>enum Test1 : Int { case AAA = 0 } func test1f&lt;T:Test1&gt;(a: Test1) {} // error: Inheritance from non-protocol, non-class type 'Test1' struct Test2 { var aaa:Int = 0 } func test2f&lt;T:Test2&gt;(a: Test2) {} // error: Inheritance from non-protocol, non-class type 'Test1' class Test3 { } func test3f&lt;T:Test3&gt;(a: Test3) {} // OK </code></pre>
<p>While you can place enums into a generic type without contraints (<code>&lt;T&gt;</code>), it's not possible to create constraints for all enums or all structs. All the constraints are based on interfaces (subclassing, protocols). Unfortunately, there is nothing in common between two random structs or two random enums.</p> <p>Structs and enums can't inherit from other structs/enums so the only constraints for enums must be based on protocols.</p> <pre><code>protocol EnumProtocol { func method() } enum TestEnum : Int, EnumProtocol { case A case B func method() { } } enum TestEnum2 : Int, EnumProtocol { case C func method() { } } class EnumGeneric &lt;T : EnumProtocol&gt; { func method(a: T) { a.method() } } let test = EnumGeneric&lt;TestEnum&gt;() test.method(TestEnum.A) </code></pre> <p>Also note that all enums "inheriting" from a primitive type like <code>Int</code> conform to <code>RawRepresentable</code>, so you could</p> <pre><code>class EnumGeneric &lt;T : RawRepresentable&gt; { func method(a: T) { println("\(a.toRaw())"); } } </code></pre> <p>but that won't work for enums declared as <code>enum TestEnum {</code></p>
<pre><code>enum SomeEnum: Int { case One, Two, Three } class SomeClass&lt;E: RawRepresentable where E.RawValue == Int&gt;{ func doSomething(e: E) { print(e.rawValue) } } class SomeEnumClass : SomeClass&lt;SomeEnum&gt; { } </code></pre> <p>or directly</p> <pre><code>class SomeOtherClass{ func doSomething&lt;E: RawRepresentable where E.RawValue == Int&gt;(e: E) { print(e.rawValue) } } </code></pre> <p><strong>UPDATE for swift3:</strong></p> <pre><code>enum SomeEnum: Int { case One, Two, Three } class SomeClass&lt;E: RawRepresentable&gt; where E.RawValue == Int { func doSomething(e: E) { print(e.rawValue) } } class SomeEnumClass : SomeClass&lt;SomeEnum&gt; { } </code></pre> <p>resp.</p> <pre><code>class SomeOtherClass{ func doSomething&lt;E: RawRepresentable&gt;(e: E) where E.RawValue == Int { print(e.rawValue) } } </code></pre>