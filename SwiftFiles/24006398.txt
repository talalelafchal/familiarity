How does Apple's new programming language Swift handle blocks and asynchronous requests?
<p>C.f. Apple's website page on Swift: <a href="https://developer.apple.com/swift/">https://developer.apple.com/swift/</a></p> <p>Are there blocks in Swift like in objective-c? How are they created and called? </p> <p>How would do an asynchronous request in Swift?</p> <p>Is it easy to create block related memory leaks in swift? If yes, how would you avoid them?</p>
<p>Blocks in Swift are called closures. They operate much the same as blocks (though are more flexible, and operate in more places). Reference cycles are possible with closures in Swift, and can be avoided with closure capture lists.</p> <p>“Swift provides an elegant solution to this problem, known as a closure capture list. However, before you learn how to break a strong reference cycle with a closure capture list, it is useful to understand how such a cycle can be caused”</p> <p>Excerpt From: Apple Inc. “The Swift Programming Language.” iBooks. <a href="https://itun.es/us/jEUH0.l">https://itun.es/us/jEUH0.l</a></p>
<p>The Swift equivalent of an (Objective-)C block is called a closure. There's <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-XID_117">a whole chapter</a> about them in The Swift Programming Language book.</p> <p>Depending on the context where you use a closure, you can declare/use it with very concise syntax. For example, a method that takes a completion handler whose signature is <code>(success: Bool, error: NSError) - &gt; Void</code> can be called like this:</p> <pre><code>someMethod(otherParameters: otherValues, completionHandler:{ success, error in if !success { NSLog("I am a leaf on the wind: %@", error) } }) </code></pre> <p>There's also a trailing closure syntax that reads nicely in cases where a closure essentially provides flow control. And you can drop the parameter names when you want to be really brief (at some cost to readability, but that's okay in some obvious cases like the below). Often a <code>return</code> statement is implicit, too.</p> <pre><code>myArray.sort { $0 &lt; $1 } let squares = myArray.map { value in value * 2 } </code></pre> <p>Swift itself doesn't have anything for asynchronous requests, so you use existing API for that. You can use the trailing closure syntax, though:</p> <pre><code>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) { // do some async stuff NSOperationQueue.mainQueue().addOperationWithBlock { // do some main thread stuff stuff } } </code></pre> <p>In most cases, you don't need to worry about creating reference cycles with Swift closures the way you do with ObjC blocks. To put it simply, the capture semantics are similar enough to "just work" the way you want it to for most stuff, but different enough that the common patterns for block/closure uses (e.g. dispatch to background/main thread and referencing <code>self</code>'s properties) don't cause cycles.</p> <p>Cycles are still possible, though, and there is a solution for them. This answer's a bit long already, so check out <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html#//apple_ref/doc/uid/TP40014097-CH20-XID_61">Strong Reference Cycles for Closures</a> in the docs for the complete explanation.</p>
<p>As I said in another question, you have many ways offered to pass a block equivalent to function in Swift. </p> <p>I found three.</p> <p>To understand this I suggest you to test in playground this little piece of code.</p> <pre><code>func test(function:String -&gt; String) -&gt; String { return function("test") } func funcStyle(s:String) -&gt; String { return "FUNC__" + s + "__FUNC" } let resultFunc = test(funcStyle) let blockStyle:(String) -&gt; String = {s in return "BLOCK__" + s + "__BLOCK"} let resultBlock = test(blockStyle) let resultAnon = test({(s:String) -&gt; String in return "ANON_" + s + "__ANON" }) println(resultFunc) println(resultBlock) println(resultAnon) </code></pre> <p>Update: There are 2 special cases to the Anonymous function.</p> <p>The first is that function signature can be inferred so you don't have to rewrite it. </p> <pre><code>let resultShortAnon = test({return "ANON_" + $0 + "__ANON" }) </code></pre> <p>The second special case works only if the block is the last argument, it's called <em>trailing closure</em></p> <p>Here is an example (merged with inferred signature to show Swift power)</p> <pre><code>let resultTrailingClosure = test { return "TRAILCLOS_" + $0 + "__TRAILCLOS" } </code></pre> <p>Finally, as an example:</p> <p>Using all this power what I'd do is mixing trailing closure and type inference (with naming for readability)</p> <pre><code>PFFacebookUtils.logInWithPermissions(permissions) { user, error in if (!user) { println("Uh oh. The user cancelled the Facebook login.") } else if (user.isNew) { println("User signed up and logged in through Facebook!") } else { println("User logged in through Facebook!") } } </code></pre>