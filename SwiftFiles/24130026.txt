Swift how to sort array of custom objects by property value
<p>lets say we have a custom class named imageFile and this class contains two properties. </p> <pre><code>class imageFile { var fileName = String() var fileID = Int() } </code></pre> <p>lots of them stored in Array</p> <pre><code>var images : Array = [] var aImage = imageFile() aImage.fileName = "image1.png" aImage.fileID = 101 images.append(aImage) aImage = imageFile() aImage.fileName = "image1.png" aImage.fileID = 202 images.append(aImage) </code></pre> <p>question is: how can i sort images array by 'fileID' ASC or DESC?</p>
<p>[<em>Updated for Swift 3 with sort(by:)</em>] This, exploiting a trailing closure:</p> <pre><code>images.sorted { $0.fileID &lt; $1.fileID } </code></pre> <p>where you use <code>&lt;</code> or <code>&gt;</code> depending on ASC or DESC, respectively. <strong>If you want to modify the <code>images</code> array</strong>, then use the following:</p> <pre><code>images.sort { $0.fileID &lt; $1.fileID } </code></pre> <p>If you are going to do this repeatedly and prefer to define a function, one way is:</p> <pre><code>func sorterForFileIDASC(this:imageFile, that:imageFile) -&gt; Bool { return this.fileID &gt; that.fileID } </code></pre> <p>and then use as:</p> <pre><code>images.sort(by: sorterForFileIDASC) </code></pre>
<p>First, declare your Array as a typed array so that you can call methods when you iterate:</p> <pre><code>var images : [imageFile] = [] </code></pre> <p>Then you can simply do:</p> <pre><code>images.sort({ $0.fileID &gt; $1.fileID }) </code></pre> <p>The example above gives <strong>desc</strong> sort order</p>
<p>You can also do something like</p> <pre><code>images = sorted(images) {$0.fileID &gt; $1.fileID} </code></pre> <p>so your images array will be stored as sorted</p>
<p>If you are going to be sorting this array in more than one place, it may make sense to make your array type Comparable.</p> <pre><code>class MyImageType: Comparable, Printable { var fileID: Int // For Printable var description: String { get { return "ID: \(fileID)" } } init(fileID: Int) { self.fileID = fileID } } // For Comparable func &lt;(left: MyImageType, right: MyImageType) -&gt; Bool { return left.fileID &lt; right.fileID } // For Comparable func ==(left: MyImageType, right: MyImageType) -&gt; Bool { return left.fileID == right.fileID } let one = MyImageType(fileID: 1) let two = MyImageType(fileID: 2) let twoA = MyImageType(fileID: 2) let three = MyImageType(fileID: 3) let a1 = [one, three, two] // return a sorted array println(sorted(a1)) // "[ID: 1, ID: 2, ID: 3]" var a2 = [two, one, twoA, three] // sort the array 'in place' sort(&amp;a2) println(a2) // "[ID: 1, ID: 2, ID: 2, ID: 3]" </code></pre>
<p>Nearly everyone gives <em>how</em> directly, let me show the evolvement:</p> <p>you can use the instance methods of Array:</p> <pre><code>// general form of closure images.sortInPlace({ (image1: imageFile, image2: imageFile) -&gt; Bool in return image1.fileID &gt; image2.fileID }) // types of closure's parameters and return value can be inferred by Swift, so they are omitted along with the return arrow (-&gt;) images.sortInPlace({ image1, image2 in return image1.fileID &gt; image2.fileID }) // Single-expression closures can implicitly return the result of their single expression by omitting the "return" keyword images.sortInPlace({ image1, image2 in image1.fileID &gt; image2.fileID }) // closure's argument list along with "in" keyword can be omitted, $0, $1, $2, and so on are used to refer the closure's first, second, third arguments and so on images.sortInPlace({ $0.fileID &gt; $1.fileID }) // the simplification of the closure is the same images = images.sort({ (image1: imageFile, image2: imageFile) -&gt; Bool in return image1.fileID &gt; image2.fileID }) images = images.sort({ image1, image2 in return image1.fileID &gt; image2.fileID }) images = images.sort({ image1, image2 in image1.fileID &gt; image2.fileID }) images = images.sort({ $0.fileID &gt; $1.fileID }) </code></pre> <p>For elaborate explanation about the working principle of sort, see <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-ID95">The Sorted Function</a>.</p>
<p>If you are not using custom objects, but value types instead that implements Comparable protocol (Int, String etc..) you can simply do this:</p> <pre><code>myArray.sort(&gt;) //sort descending order </code></pre> <p>An example:</p> <pre><code>struct MyStruct: Comparable { var name = "Untitled" } func &lt;(lhs: MyStruct, rhs: MyStruct) -&gt; Bool { return lhs.name &lt; rhs.name } // Implementation of == required by Equatable func ==(lhs: MyStruct, rhs: MyStruct) -&gt; Bool { return lhs.name == rhs.name } let value1 = MyStruct() var value2 = MyStruct() value2.name = "A New Name" var anArray:[MyStruct] = [] anArray.append(value1) anArray.append(value2) anArray.sort(&gt;) // This will sort the array in descending order </code></pre>
<p>Swift provides two methods called <code>sort()</code> and <code>sort(_:)</code> for types that conform to <code>MutableCollectionType</code> protocol.</p> <p>The first method, <code>sort()</code>, has the following <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Reference/Swift_MutableCollectionType_Protocol/index.html#//apple_ref/swift/intfm/MutableCollectionType/s:FeRq_Ss21MutableCollectionTypeqqq_Ss14CollectionType9GeneratorSs13GeneratorType7ElementSs10Comparable_SsS_4sortuRq_S_qqq_S0_9GeneratorS1_7ElementS2__Fq_FT_GSaqqq_S0_9GeneratorS1_7Element_" rel="nofollow">declaration</a>:</p> <pre><code>func sort() -&gt; [Self.Generator.Element] </code></pre> <blockquote> <p>Return an <code>Array</code> containing the sorted elements of <code>source</code>.</p> </blockquote> <p>Apple also states about <code>sort()</code> in <em>Swift Standard Library Reference</em>:</p> <blockquote> <p>Requires: The less-than operator (<code>func &lt;</code>) defined in the <code>Comparable</code> conformance is a strict weak ordering over the elements in <code>self</code>.</p> </blockquote> <p>The second method, <code>sort(_:)</code>, has the following <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Reference/Swift_MutableCollectionType_Protocol/index.html#//apple_ref/swift/intfm/MutableCollectionType/s:FeRq_Ss21MutableCollectionType_SsS_4sortuRq_S__Fq_FFTqqq_Ss14CollectionType9GeneratorSs13GeneratorType7Elementqqq_S0_9GeneratorS1_7Element_SbGSaqqq_S0_9GeneratorS1_7Element_" rel="nofollow">declaration</a>:</p> <pre><code>func sort(@noescape _ isOrderedBefore: (Self.Generator.Element, Self.Generator.Element) -&gt; Bool) -&gt; [Self.Generator.Element] </code></pre> <blockquote> <p>Return an <code>Array</code> containing the sorted elements of <code>source</code> according to <code>isOrderedBefore</code>.</p> </blockquote> <hr> <h1>Sort with an ascending order for comparable objects</h1> <p>If the element type inside your collection (<code>imageFile</code>, in your case) conforms to <code>Comparable</code> protocol, you will be able to use <code>sort()</code> to sort your elements with an ascending order. For example:</p> <pre><code>class ImageFile: CustomStringConvertible, Comparable { let fileName: String let fileID: Int var description: String { return "ImageFile with ID: \(fileID)" } init(fileName: String, fileID: Int) { self.fileName = fileName self.fileID = fileID } } func ==(lhs: ImageFile, rhs: ImageFile) -&gt; Bool { return lhs.fileID == rhs.fileID } func &lt;(lhs: ImageFile, rhs: ImageFile) -&gt; Bool { return lhs.fileID &lt; rhs.fileID } let images = [ ImageFile(fileName: "Car", fileID: 300), ImageFile(fileName: "Boat", fileID: 100), ImageFile(fileName: "Plane", fileID: 200) ] let sortedImages = images.sort() print(sortedImages) /* prints: [ImageFile with ID: 100, ImageFile with ID: 200, ImageFile with ID: 300] */ </code></pre> <hr> <h1>Sort with a descending order for comparable objects</h1> <p>If the element type inside your collection conforms to <code>Comparable</code> protocol, you will have to use <code>sort(_:)</code> to sort your elements with a descending order. For example:</p> <pre><code>class ImageFile: CustomStringConvertible, Comparable { let fileName: String let fileID: Int var description: String { return "ImageFile with ID: \(fileID)" } init(fileName: String, fileID: Int) { self.fileName = fileName self.fileID = fileID } } func ==(lhs: ImageFile, rhs: ImageFile) -&gt; Bool { return lhs.fileID == rhs.fileID } func &lt;(lhs: ImageFile, rhs: ImageFile) -&gt; Bool { return lhs.fileID &lt; rhs.fileID } let images = [ ImageFile(fileName: "Car", fileID: 300), ImageFile(fileName: "Boat", fileID: 100), ImageFile(fileName: "Plane", fileID: 200) ] let sortedImages = images.sort({ (img0: ImageFile, img1: ImageFile) -&gt; Bool in return img0 &gt; img1 }) // let sortedImages = images.sort { $0 &gt; $1 } // also works // let sortedImages = images.sort(&gt;) // also works print(sortedImages) /* prints: [ImageFile with ID: 300, ImageFile with ID: 200, ImageFile with ID: 100] */ </code></pre> <hr> <h1>Sort with an ascending or descending order for non-comparable objects</h1> <p>If the element type inside your collection DOES NOT conform to <code>Comparable</code> protocol, you will have to use <code>sort(_:)</code> to sort your elements with an ascending or descending order. For example:</p> <pre><code>class ImageFile: CustomStringConvertible { let fileName: String let fileID: Int var description: String { return "ImageFile with ID: \(fileID)" } init(fileName: String, fileID: Int) { self.fileName = fileName self.fileID = fileID } } let images = [ ImageFile(fileName: "Car", fileID: 300), ImageFile(fileName: "Boat", fileID: 100), ImageFile(fileName: "Plane", fileID: 200) ] let sortedImages = images.sort({ (img0: ImageFile, img1: ImageFile) -&gt; Bool in return img0.fileID &lt; img1.fileID }) // let sortedImages = images.sort { $0.fileID &lt; $1.fileID } // also works print(sortedImages) /* prints: [ImageFile with ID: 300, ImageFile with ID: 200, ImageFile with ID: 100] */ </code></pre> <hr> <p>Notice that Swift also provides two methods called <code>sortInPlace()</code> (<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Reference/Swift_MutableCollectionType_Protocol/index.html#//apple_ref/swift/intfm/MutableCollectionType/s:FeRq_Ss21MutableCollectionTypeqq_Ss16MutableIndexable5IndexSs21RandomAccessIndexTypeqqq_Ss14CollectionType9GeneratorSs13GeneratorType7ElementSs10Comparable_SsS_11sortInPlaceuRq_S_qq_S0_5IndexS1_qqq_S2_9GeneratorS3_7ElementS4__FRq_FT_T_" rel="nofollow">declaration</a>) and <code>sortInPlace(_:)</code> (<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Reference/Swift_MutableCollectionType_Protocol/index.html#//apple_ref/swift/intfm/MutableCollectionType/s:FeRq_Ss21MutableCollectionTypeqq_Ss16MutableIndexable5IndexSs21RandomAccessIndexType_SsS_11sortInPlaceuRq_S_qq_S0_5IndexS1__FRq_FFTqqq_Ss14CollectionType9GeneratorSs13GeneratorType7Elementqqq_S2_9GeneratorS3_7Element_SbT_" rel="nofollow">declaration</a>) as counterparts of <code>sort()</code> and <code>sort(_:)</code> if you need to sort your collection in-place.</p>
<p>If you want to sort original array of custom objects. Here is another way to do so in Swift 2.1</p> <pre><code>var myCustomerArray = [Customer]() myCustomerArray.sortInPlace {(customer1:Customer, customer2:Customer) -&gt; Bool in customer1.id &lt; customer2.id } </code></pre> <p>Where <code>id</code> is an Integer. You can use the same <code>&lt;</code> operator for <code>String</code> properties as well.</p> <p>You can learn more about its use by looking at an example here: <a href="https://github.com/HannyTufail/Swift2-Nearby-Customers" rel="nofollow">Swift2: Nearby Customers </a></p>
<p><strong>In Swift 2.0</strong></p> <p>There are two ways to order an array of objects:</p> <p>1) Ordering the original array with sortInPlace</p> <pre><code>self.assignments.sortInPlace({ $0.order &lt; $1.order }) self.printAssignments(assignments) </code></pre> <p>2) Using an alternative array to store the ordered array</p> <pre><code>var assignmentsO = [Assignment] () assignmentsO = self.assignments.sort({ $0.order &lt; $1.order }) self.printAssignments(assignmentsO) </code></pre>
<p><strong>Swift 3</strong></p> <pre><code>people = people.sorted(by: { $0.email &gt; $1.email }) </code></pre>