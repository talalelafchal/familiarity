How is a return value of AnyObject! different from AnyObject
<p>The <code>NSMetadataItem</code> class in the Cocoa framework under Swift contains the following function:</p> <p><code>func valueForAttribute(key: String!) -&gt; AnyObject!</code></p> <p>I'm still learning the difference (and details) between forced unwrapping and optional chaining. In the above function, does this mean:</p> <ol> <li><p>The <code>key</code> parameter must have a value, and</p></li> <li><p>The return value is guaranteed to have a value?</p></li> </ol> <p>My primary concern is with <em>the exclamation point following</em> the return value - once I have assigned the return value:</p> <pre><code>var isDownloadedVal = item.valueForAttribute(NSMetadataUbiquitousItemIsDownloadedKey) </code></pre> <p>Do I need to include an <code>if let</code> block when examining it, or am I guaranteed that it will have a value I can examine safely?</p>
<p>According to the Swift-eBook, which states the following</p> <p><em>„Trying to use ! to access a non-existent optional value triggers a runtime error. Always make sure that an optional contains a non-nil value before using ! to force-unwrap its value.“</em></p> <p>I would answer to your first two questions with <strong>Yes</strong>.</p> <blockquote> <p>Do I need to include an if let block when examining it...</p> </blockquote> <p><strong>No</strong>, this is not necessary.</p>
<p>TLDR: Treat <code>Foo!</code> as if it were <code>Foo</code>.</p> <p>Many Cocoa calls include implicitly unwrapped optionals, and their need for it is very likely the reason the feature even exists. Here's how I recommend thinking about it.</p> <p>First, let's think about a simpler case that doesn't involve <code>AnyObject</code>. I think <code>UIDevice</code> makes a good example.</p> <pre><code>class func currentDevice() -&gt; UIDevice! </code></pre> <p>What's going on here? Well, there is always a <code>currentDevice</code>. If this returned <code>nil</code> that would indicate some kind of deep error in the system. So if we were building this interface in Swift, this would likely just return <code>UIDevice</code> and be done with it. But we need to bridge to Objective-C, which returns <code>UIDevice*</code>. Now that should never be <code>nil</code>, but it syntactically <em>could</em> be <code>nil</code>. Now in ObjC, we typically ignore that fact and don't <code>nil</code>-check here (particularly because <code>nil</code>-messaging is typically safe).</p> <p>So how would we express this situation in Swift? Well, technically it's an <code>Optional&lt;UIDevice&gt;</code>, and you'd wind up with:</p> <pre><code>class func currentDevice() -&gt; UIDevice? </code></pre> <p>And you'd need to explicitly unwrap that every time you used it (ideally with an <code>if let</code> block). That would very quickly drive you insane, and for nothing. <code>currentDevice()</code> always returns a value. The <code>Optional</code> is an artifact of bridging to ObjC.</p> <p>So they invented a hack to work around that (and I think it really is a hack; I can't imagine building this feature if ObjC weren't in the mix). That hack says, yes, it's an <code>Optional</code>, but you can pretend it's not, and we promise it's always going to be a value.</p> <p>And that's <code>!</code>. For this kind of stuff, you basically ignore the <code>!</code> and pretend that it's handing you back a <code>UIDevice</code> and roll along. If they lied to you and return <code>nil</code>, well, that's going to crash. They shouldn't have lied to you.</p> <p>This suggests a rule: don't use <code>!</code> unless you really need to (and you pretty much only need to when bridging to ObjC).</p> <p>In your specific example, this works in both directions:</p> <pre><code>func valueForAttribute(key: String!) -&gt; AnyObject! </code></pre> <p>Technically it takes an <code>Optional&lt;String&gt;</code>, but only because it's bridged to <code>NSString*</code>. You <em>must</em> pass non-<code>nil</code> here. And it technically returns you <code>Optional&lt;AnyObject&gt;</code>, but only because it's bridged to <code>id</code>. It promises that it won't be <code>nil</code>.</p>