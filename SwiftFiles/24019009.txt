&quot;Memory is managed automatically&quot; - how?
<p>I know that the biggest difference between <a href="http://www.ibm.com/developerworks/library/j-jtp10283/" rel="nofollow">GC</a> and <a href="http://en.wikipedia.org/wiki/Automatic_Reference_Counting" rel="nofollow">ARC</a> is that <strong>GC</strong> is run time process while <strong>ARC</strong> is operates in compile time. So when working with <strong>ARC</strong> the developer need to take care of memory in some scenarios.</p> <p>How ever according to <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html" rel="nofollow">this</a>, there is no place left for developer interaction in <a href="https://developer.apple.com/swift/" rel="nofollow">SWFT</a> memory management architecture.</p> <p>So how they do this? Do they have a run time process for cleaning up the memory, or there some thing else?</p>
<p>Swift uses ARC in a similar way as Objective-C does. ARC <a href="http://stackoverflow.com/q/6385212/104790">has been discussed</a> extensively.</p> <p>In short:</p> <ol> <li>There is no garbage collector.</li> <li>Objects live as long as (strong) references exist.</li> <li>Strong references can't be cyclic, otherwise you leak memory. Use weak references to break cycles.</li> </ol>
<blockquote> <p><strong>How ARC Works</strong></p> <p>Every time you create a new instance of a class, ARC allocates a chunk of memory to store information about that instance. This memory holds information about the type of the instance, together with the values of any stored properties associated with that instance.</p> <p>Additionally, when an instance is no longer needed, ARC frees up the memory used by that instance so that the memory can be used for other purposes instead. This ensures that class instances do not take up space in memory when they are no longer needed.</p> <p>However, if ARC were to deallocate an instance that was still in use, it would no longer be possible to access that instance’s properties, or call that instance’s methods. Indeed, if you tried to access the instance, your app would most likely crash.</p> <p>To make sure that instances don’t disappear while they are still needed, ARC tracks how many properties, constants, and variables are currently referring to each class instance. ARC will not deallocate an instance as long as at least one active reference to that instance still exists.</p> <p>To make this possible, whenever you assign a class instance to a property, constant, or variable, that property, constant, or variable makes a strong reference to the instance. The reference is called a “strong“ reference because it keeps a firm hold on that instance, and does not allow it to be deallocated for as long as that strong reference remains.</p> </blockquote> <p><a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html" rel="nofollow">https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html</a></p>
<blockquote> <p>I know that the biggest difference between GC and ARC is that GC</p> </blockquote> <p>Note that ARC is a form of GC.</p> <blockquote> <p>is run time process while ARC is operates in compile time.</p> </blockquote> <p>Both tracing GC and ARC do things at both compile time and at run time. ARC injects code that increments and decrements reference counts and, when the count falls to zero, collects the object and decrements all of the references it was pointing to recursively (potentially causing an unbounded amount of work to be done at run time as an arbitrarily large object graph is collected).</p> <blockquote> <p>So when working with ARC the developer need to take care of memory in some scenarios.</p> </blockquote> <p>Yes. You must always be careful to avoid cycles because they will never be collected.</p>