Pointers, Pointer Arithmetic, and Raw Data in Swift
<p>My application uses a somewhat complex inmutable data structure that is encoded in a binary file. I need to have access to it at the byte level, avoiding any copying. Normally, I would use C or C++ pointer arithmetic and typecasts, to access and interpret the raw byte values. I would like to do the same with Swift.</p> <p>I have found that the following works:</p> <pre><code>class RawData { var data: NSData! init(rawData: NSData) { data = rawData } func read&lt;T&gt;(byteLocation: Int) -&gt; T { let bytes = data.subdataWithRange(NSMakeRange(byteLocation, sizeof(T))).bytes return UnsafePointer&lt;T&gt;(bytes).memory } func example_ReadAnIntAtByteLocation5() -&gt; Int { return read(5) as Int } } </code></pre> <p>However, I am not sure how efficient it is. Do <code>data.subdataWithRange</code> and <code>NSMakeRange</code> allocate objects every time I call them, or are they just syntactic sugar for dealing with pointers?</p> <p>Is there a better way to do this in Swift?</p> <p><strong>EDIT:</strong></p> <p>I have created a small Objective-C class that just encapsulates a function to offset a pointer by a given number of bytes:</p> <pre><code>@implementation RawDataOffsetPointer inline void* offsetPointer(void* ptr, int bytes){ return (char*)ptr + bytes; } @end </code></pre> <p>If I include this class in the bridging header, then I can change my <code>read</code> method to</p> <pre><code>func read&lt;T&gt;(byteLocation: Int) -&gt; T { let ptr = offsetPointer(data.bytes, CInt(byteLocation)) return UnsafePointer&lt;T&gt;(ptr).memory } </code></pre> <p>which will not copy data from my buffer, or allocate other objects.</p> <p>However, it would still be nice to do some pointer arithmetic from Swift, if it were possible.</p>
<p>I would recommend looking into <code>NSInputStream</code>, which allows you to read <code>NSData</code> as a series of bytes (<code>UInt8</code> in Swift).</p> <p>Here is a little sample I put together in the playground:</p> <pre><code>func generateRandomData(count:Int) -&gt; NSData { var array = Array&lt;UInt8&gt;(count: count, repeatedValue: 0) arc4random_buf(&amp;array, UInt(count)) return NSData(bytes: array, length: count) } let randomData = generateRandomData(256 * 1024) let stream = NSInputStream(data: randomData) stream.open() // IMPORTANT var readBuffer = Array&lt;UInt8&gt;(count: 16 * 1024, repeatedValue: 0) var totalBytesRead = 0 while (totalBytesRead &lt; randomData.length) { let numberOfBytesRead = stream.read(&amp;readBuffer, maxLength: readBuffer.count) // Do something with the data totalBytesRead += numberOfBytesRead } </code></pre> <p>You can create an <code>extension</code> to read primitive types like so:</p> <pre><code>extension NSInputStream { func readInt32() -&gt; Int { var readBuffer = Array&lt;UInt8&gt;(count:sizeof(Int32), repeatedValue: 0) var numberOfBytesRead = self.read(&amp;readBuffer, maxLength: readBuffer.count) return Int(readBuffer[0]) &lt;&lt; 24 | Int(readBuffer[1]) &lt;&lt; 16 | Int(readBuffer[2]) &lt;&lt; 8 | Int(readBuffer[3]) } } </code></pre>
<p>I would recommend the simple way to use UnsafeArray.</p> <pre><code>let data = NSData(contentsOfFile: filename) let ptr = UnsafePointer&lt;UInt8&gt;(data.bytes) let bytes = UnsafeBufferPointer&lt;UInt8&gt;(start:ptr, count:data.length) </code></pre>
<p>If you just want to do it directly, <code>UnsafePointer&lt;T&gt;</code> can be manipulated arithmetically:</p> <pre><code> let oldPointer = UnsafePointer&lt;()&gt; let newPointer = oldPointer + 10 </code></pre> <p>You can also cast a pointer like so (<code>UnsafePointer&lt;()&gt;</code> is equivalent to <code>void *</code>)</p> <pre><code> let castPointer = UnsafePointer&lt;MyStruct&gt;(oldPointer) </code></pre>