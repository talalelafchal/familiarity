NSOperation property overrides (isExecuting / isFinished)
<p>I am subclassing <code>NSOperation</code> in Swift and need to override the <code>isExecuting</code> and <code>isFinished</code> properties since I am overriding the <code>start</code> method.</p> <p>The problem I run into is how to preserve key-value observing (KVO) while also being able to override these properties.</p> <p>Normally in Obj-C this would be rather easy to redeclare the properties as <code>readwrite</code> in the class extension <code>JSONOperation ()</code> definition. However, I don't see this same capability in Swift.</p> <p>Example:</p> <pre><code>class JSONOperation : NSOperation, NSURLConnectionDelegate { var executing : Bool { get { return super.executing } set { super.executing } // ERROR: readonly in the superclass } // Starts the asynchronous NSURLConnection on the main thread override func start() { self.willChangeValueForKey("isExecuting") self.executing = true self.didChangeValueForKey("isExecuting") NSOperationQueue.mainQueue().addOperationWithBlock( { self.connection = NSURLConnection(request: self.request, delegate: self, startImmediately: true) }) } } </code></pre> <p>So here is the solution I have come up with, but it feels awfully ugly and hacky:</p> <pre><code>var state = Operation() struct Operation { var executing = false var finished = false } override var executing : Bool { get { return state.executing } set { state.executing = newValue } } override var finished : Bool { get { return state.finished } set { state.finished = newValue } } </code></pre> <p>Please tell me there is a better way. I know I could make a <code>var isExecuting</code> instead of the whole <code>struct</code>, but then I have two similarly named properties which introduces ambiguity and also makes it publicly writable (which I do not want).</p> <p>Oh what I would do for some access modifier keywords...</p>
<p>From the swift book:</p> <blockquote> <p>You can present an inherited read-only property as a read-write property by providing both a getter and a setter in your subclass property override.</p> </blockquote> <p>I think you'll find that this works:</p> <pre><code>override var executing : Bool { get { return _executing } set { willChangeValueForKey("isExecuting") _executing = newValue didChangeValueForKey("isExecuting") } } private var _executing : Bool </code></pre>
<p>As David said, you can implement both a getter and setter in the subclass property override. </p> <p>But, when defining <code>asynchronous</code>/<code>concurrent</code> operations (i.e. those operations that will complete asynchronously), it is critical to call the <code>will</code>/<code>didChangeValueForKey</code> for <code>isFinished</code> and <code>isExecuting</code>. If you don't, operations won't be released, dependencies won't be honored, you'll have problems is <code>maxConcurrentOperationCount</code>, etc.).</p> <p>So I would therefore suggest:</p> <pre><code>private var _executing: Bool = false override var executing: Bool { get { return _executing } set { if _executing != newValue { willChangeValueForKey("isExecuting") _executing = newValue didChangeValueForKey("isExecuting") } } } private var _finished: Bool = false; override var finished: Bool { get { return _finished } set { if _finished != newValue { willChangeValueForKey("isFinished") _finished = newValue didChangeValueForKey("isFinished") } } } </code></pre> <p>By the way, checking to see if <code>_executing</code> and <code>_finished</code> have changed is not critical, but it can sometimes be useful when writing custom <code>cancel</code> methods or the like.</p> <hr> <p><strong>Update:</strong></p> <p>More than once, people have pointed to the new <code>finished</code>/<code>executing</code> properties in <code>NSOperation.h</code> and concluded that the appropriate KVO keys would be <code>finished</code>/<code>executing</code>. Generally, when writing KVO-compliant properties, that would be correct.</p> <p><em>But <code>NSOperationQueue</code> does not observe the <code>finished</code>/<code>executing</code> keys.</em> It observes the <code>isFinished</code>/<code>isExecuting</code> keys. If you don't perform the KVO calls for the <code>isFinished</code>/<code>isExecuting</code> keys, you can have problems (notably dependencies between asynchronous operations will fail). It's annoying, but that's how it works. The <em>Configuring Operations for Concurrent Execution</em> section of the <a href="https://developer.apple.com/library/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW1">Operation Queues</a> chapter of the <em>Concurrency Programming Guide</em> is very clear on the topic of needing to perform the <code>isFinished</code>/<code>isExecuting</code> KVO calls. </p> <p>While the <em>Concurrency Programming Guide</em> is dated, it's quite explicit regarding the <code>isFinished</code>/<code>isExecuting</code> KVO. And one can easily empirically validate that the guide still reflects the actual <code>NSOperation</code> implementation. By way of demonstration, see the unit tests in <a href="https://github.com/robertmryan/Operation-Test-Swift">this Github demonstration of the appropriate KVO</a> when using asynchronous/concurrent <code>NSOperation</code> subclass in <code>NSOperationQueue</code>.</p>
<p><strong>Swift 3.0 Answer Update:</strong></p> <pre><code>private var _executing : Bool = false override var isExecuting : Bool { get { return _executing } set { guard _executing != newValue else { return } willChangeValue(forKey: "isExecuting") _executing = newValue didChangeValue(forKey: "isExecuting") } } private var _finished : Bool = false override var isFinished : Bool { get { return _finished } set { guard _finished != newValue else { return } willChangeValue(forKey: "isFinished") _finished = newValue didChangeValue(forKey: "isFinished") } } </code></pre>