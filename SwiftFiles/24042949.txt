Block retain cycles in Swift?
<p>Traditionally in Objc, we do weakSelf to prevent additional retain count for blocks.</p> <p>How does swift internally manage retain cycles that occur in blocks for Objc?</p>
<p>To prevent a block from holding a strong reference to an object, you must define a capture list for the block.</p> <p>The closure expression syntax is defined as follows:</p> <pre><code>{ ( /*parameters*/ ) -&gt; /*return type*/ in // statements } </code></pre> <p>But this is extended later in the documentation to include a capture list. This effectively equates to the expression syntax being defined as follows:</p> <pre><code>{ [ /*reference type*/ /*object*/, ... ] ( /*parameters*/ ) -&gt; /*return type*/ in // statements } </code></pre> <p>...where <code>/*reference type*/</code> can be either <code>weak</code> or <code>unowned</code>.</p> <p>The capture list is the first thing to appear in the closure and it is optional. The syntax, as shown above is defined as one or more pairs of reference type followed by object; each pair is separated by a comma. For example:</p> <pre><code>[unowned self, weak otherObject] </code></pre> <p>Complete example:</p> <pre><code>var myClosure = { [unowned self] in print(self.description) } </code></pre> <p>Note that an <code>unowned</code> reference is non-optional, so you don't need to unwrap it.</p> <p>Hopefully that answers your question. You can read up more about ARC in Swift in the relevant section of the <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html#//apple_ref/doc/uid/TP40014097-CH20-XID_61">documentation</a>.</p> <p>You should pay particular attention to the difference between <code>weak</code> and <code>unowned</code>. It could be safer in your implementation to use <code>weak</code>, because using <code>unowned</code> assumes the object will never be nil. This may lead to your app crashing if the object has actually been deallocated before being used in your closure.</p> <p>Using <code>weak</code> as the reference type, you should unwrap with <code>?</code>, as follows:</p> <pre><code>var myClosure = { [weak self] in print(self?.description) } </code></pre>
<p>The only thing that threw me off with capture lists was when to use weak vs unowned. </p> <p>The book distilled it down to these rules:</p> <p><strong>If self could be nil in the closure use [weak self].</strong></p> <p><strong>If self will never be nil in the closure use [unowned self].</strong></p> <p>See the section <em>Weak and Unowned References</em> in <a href="https://developer.apple.com/library/ios/documentation/swift/conceptual/swift_programming_language/AutomaticReferenceCounting.html">The Swift Programming Language book</a> for a deeper explanation.</p>
<p>As described above there are 2 possibilities to avoid retain cycles in Swift and these are <code>weak</code> and <code>unowned</code> as described below:</p> <pre><code>var sampleClosure = { [unowned self] in self.doSomething() } </code></pre> <p>where the <code>self</code> never can be <code>nil</code>.</p> <pre><code>var sampleClosure = { [weak self] in self?.doSomething() } </code></pre> <p>where <code>self</code> need to be unwrapped using <code>?</code>. Here there is a important observation to do, if there are more instructions that use self and can be share the results etc, a possible correct way can be:</p> <pre><code>var sampleClosure = { [weak self] in if let this = self{ this.doSomething() this.doOtherThings() } } </code></pre> <p>or</p> <pre><code>var sampleClosure = { [weak self] in guard let strongSelf = self else{ return } strongSelf.doSomething() strongSelf.doOtherThings() } </code></pre>