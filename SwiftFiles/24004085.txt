Automatic Type Conversion with extension: What is happening here?
<p>I'm going through the first chapter of <code>The Swift Programming Language</code> book and I'm at the part where it's describing the <code>extension</code> keyword.</p> <p>I had a go at the "Experiment":</p> <blockquote> <p>“Write an extension for the Double type that adds an absoluteValue property.”</p> </blockquote> <p>I got it working like this:</p> <pre><code>extension Double { var absoluteValue: Double { if(self &lt; 0) { return self * -1 } return self } } (-10.5).absoluteValue // 10.5 </code></pre> <p>But it also seems to work for integers:</p> <pre><code>(-4).absoluteValue // 4.0 </code></pre> <p>What is happening here? Is the compiler changing the type from <code>Int</code> to <code>Double</code> because it sees that there is a <code>absoluteValue</code> extension on <code>Double</code> but not <code>Int</code>?</p> <p>This appears to be the case because if I add another <code>extension</code> of the same name on <code>Int</code> like so:</p> <pre><code>extension Int { var absoluteValue: Int { return 42 } } </code></pre> <p>That overrides the <code>extension</code> on <code>Double</code>. And <code>(-4).absoluteValue</code> returns <code>42</code></p> <p>Is there a way to add an <code>extension</code> that <em>only</em> works on <code>Double</code>s but not <code>Int</code>s?</p> <p>Edit: Looks like it's doing a conversion at compile-time and since I didn't define a type for my literal it converted it. The following produces an error</p> <pre><code>var i:Int = -4; i.absoluteValue </code></pre> <blockquote> <p>"Playground execution failed: error: :12:1: error: 'Int' does not have a member named 'absoluteValue' i.absoluteValue ^ ~~~~~~~~~~~~~"</p> </blockquote> <p>Edit 2: It appears to only apply to literals; the following also produces an error:</p> <pre><code>var i = -4; i.absoluteValue </code></pre>
<p>Yes, the extension you wrote is actually only for <code>Double</code>s, not for <code>Int</code>s. Take a look at this example:</p> <pre><code>extension Double { var absoluteValue: Double { if (self &lt; 0) { return self * -1 } return self } } var double: Int = 10 double.absoluteValue // Int does not have a member named absoluteValue </code></pre> <p>But, in your code the compiler is implicitly converting your <code>Int</code> to a <code>Double</code>.</p>
<p>In case anyone would like an answer that conforms to the example protocol:</p> <pre><code>protocol ExampleProtocol { var simpleDescription: String { get } mutating func adjust() } extension Double: ExampleProtocol { var simpleDescription: String { return "The number \(self)" } var absoluteValue: Double { return fabs(self) } mutating func adjust() { self = round(self) } } var double: Double = -12.34 double.simpleDescription double.absoluteValue </code></pre>