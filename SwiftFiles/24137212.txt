&quot;initialize&quot; class method for classes in Swift?
<p>I'm looking for behavior similar to Objective-C's <code>+(void)initialize</code> class method, in that the method is called once when the class is initialized, and never again thereafter.</p> <p>A simple <code>class init () {}</code> in a <code>class</code> closure would be really sleek! And obviously when we get to use "<code>class var</code>s" instead of "<code>static var</code>s in a struct closure", this will all match really well!</p>
<p>If you have an Objective-C class, it's easiest to just override <code>+initialize</code>. However, make sure <strong>subclasses</strong> of your class also override <code>+initialize</code> or else your class's <code>+initialize</code> may get called more than once! If you want, you can use <code>dispatch_once()</code> (mentioned below) to safeguard against multiple calls.</p> <pre><code>class MyView : UIView { override class func initialize () { // Do stuff } } </code></pre> <p>&nbsp;</p> <p>If you have a Swift class, the best you can get is <code>dispatch_once()</code> inside the <code>init()</code> statement.</p> <pre><code>private var once = dispatch_once_t() class MyObject { init () { dispatch_once(&amp;once) { // Do stuff } } } </code></pre> <p>This solution differs from <code>+initialize</code> (which is called the first time an Objective-C class is messaged) and thus isn't a true answer to the question. But it works good enough, IMO.</p>
<p>There is no <em>type initializer</em> in Swift.</p> <blockquote> <p>“Unlike stored instance properties, you must always give stored type properties a default value. This is because the <strong>type itself does not have an initializer</strong> that can assign a value to a stored type property at initialization time.”</p> </blockquote> <p>Excerpt From: Apple Inc. “The Swift Programming Language.” <a href="https://itun.es/de/jEUH0.l">iBooks</a>. </p> <hr> <p>You could use a <em>type property</em> which default value is a closure. So the code in the closure would be executed when the <em>type property</em> (or class variable) is set.</p> <pre><code>class FirstClass { class var someProperty = { // you can init the class member with anything you like or perform any code return SomeType }() } </code></pre> <p>But <code>class stored properties not yet supported</code> (tested in Xcode 7.3).</p> <p>One answer is to use <code>static</code>, it is the same as <code>class final</code>.</p> <p>Good link for that is</p> <blockquote> <p>Setting a Default Property Value with a Closure or Function</p> </blockquote> <p>Excerpt From: Apple Inc. “The Swift Programming Language.” <a href="https://itun.es/de/jEUH0.l">iBooks</a>. </p> <hr> <h3>Code example:</h3> <pre><code>class FirstClass { static let someProperty = { () -&gt; [Bool] in var temporaryBoard = [Bool]() var isBlack = false for i in 1...8 { for j in 1...8 { temporaryBoard.append(isBlack) isBlack = !isBlack } isBlack = !isBlack } print("setting default property value with a closure") return temporaryBoard }() } print("start") FirstClass.someProperty </code></pre> <p>Prints</p> <blockquote> <p>start</p> <p>setting default property value with a closure</p> </blockquote> <p>So it is lazy evaluated.</p>
<p>I can't find any valid use case to have something like <code>+[initialize]</code> in Swift. Maybe this explains way it does not exist</p> <h3>Why do we need <code>+[initialize]</code> in ObjC?</h3> <p>To initialize some global variable </p> <pre><code>static NSArray *array; + (void)initialize { array = @[1,2,3]; } </code></pre> <p>which in Swift</p> <pre><code>struct Foo { static let array = [1,2,3] } </code></pre> <hr> <p>To do some hack</p> <pre><code>+ (void)initialize { swizzle_methodImplementation() } </code></pre> <p>which is not supported by Swift (I can't figure out how to do it for pure Swift class/struct/enum)</p>
<p>For <code>@objc</code> classes, <code>class func initialize()</code> definitely works, since <code>+initialize</code> is implemented by the Objective-C runtime. But for "native" Swift classes, you'll have to see the other answers.</p>