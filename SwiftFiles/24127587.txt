How do I declare an array of weak references in Swift?
<p>I'd like to store an array of weak references in Swift. The array itself should not be a weak reference - its elements should be. I think Cocoa <code>NSPointerArray</code> offers a non-typesafe version of this.</p>
<p>Create a generic wrapper as:</p> <pre><code>class Weak&lt;T: AnyObject&gt; { weak var value : T? init (value: T) { self.value = value } } </code></pre> <p>Add instances of this class to your array.</p> <pre><code>class Stuff {} var weakly : [Weak&lt;Stuff&gt;] = [Weak(value: Stuff()), Weak(value: Stuff())] </code></pre> <p>When defining <code>Weak</code> you can use either <code>struct</code> or <code>class</code>.</p> <p>Also, to help with reaping array contents, you could do something along the lines of:</p> <pre><code>extension Array where Element:Weak&lt;AnyObject&gt; { mutating func reap () { self = self.filter { nil != $0.value } } } </code></pre> <p>The use of <code>AnyObject</code> above should be replaced with <code>T</code> - but I don't think the current Swift language allows an extension defined as such.</p>
<p>You can do this by creating a wrapper object to hold a weak pointer.</p> <pre><code>struct WeakThing&lt;T: AnyObject&gt; { weak var value: T? init (value: T) { self.value = value } } </code></pre> <p>And then using these in the array</p> <pre><code>var weakThings = WeakThing&lt;Foo&gt;[]() </code></pre>
<p><strong>This is not my solution. <a href="https://devforums.apple.com/message/981472#981472">I found it on the Apple Developer Forums</a>.</strong></p> <p>@GoZoner has a good answer, but it crashes the Swift compiler.</p> <p>Here's a version of a weak-object container doesn't crash the current released compiler.</p> <pre><code>struct WeakContainer&lt;T where T: AnyObject&gt; { weak var _value : T? init (value: T) { _value = value } func get() -&gt; T? { return _value } } </code></pre> <p>You can then create an array of these containers:</p> <pre><code>let myArray: Array&lt;WeakContainer&lt;MyClass&gt;&gt; = [myObject1, myObject2] </code></pre>
<p>How about functional style wrapper?</p> <pre><code>class Class1 {} func captureWeakly&lt;T&gt; (_ target:T) -&gt; (() -&gt; T?) where T: AnyObject { return { [weak target] in return target } } let obj1 = Class1() let obj2 = Class1() let obj3 = Class1() let captured1 = captureWeakly(obj1) let captured2 = captureWeakly(obj2) let captured3 = captureWeakly(obj3) </code></pre> <p>Just call returned closure to check the target is still alive.</p> <pre><code>let isAlive = captured1() != nil let theValue = captured1()! </code></pre> <p>And you can store this closures into an array.</p> <pre><code>let array1 = Array&lt;() -&gt; (Class1?)&gt;([captured1, captured2, captured3]) </code></pre> <p>And you can retrieve the weakly captured values by mapping calling the closures.</p> <pre><code>let values = Array(array1.map({ $0() })) </code></pre>
<p>You can use the NSHashTable with weakObjectsHashTable. (NSHashTable.weakObjectsHashTable())</p> <p><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/NSHashTable_class/index.html#//apple_ref/occ/clm/NSHashTable/weakObjectsHashTable">NSHashTable Class Reference</a></p> <blockquote> <p>Available in OS X v10.5 and later.</p> <p>Available in iOS 6.0 and later.</p> </blockquote>
<p>Other answers have covered the generics angle. Thought I'd share some simple code covering the <code>nil</code> angle.</p> <p>I wanted a static array (read occasionally) of all the <code>Label</code>s that currently exist in the app, but didn't want to see <code>nil</code>'s where the old ones used to be.</p> <p>Nothing fancy, this is my code...</p> <pre><code>public struct WeakLabel { public weak var label : Label? public init(_ label: Label?) { self.label = label } } public class Label : UILabel { static var _allLabels = [WeakLabel]() public static var allLabels:[WeakLabel] { get { _allLabels = _allLabels.filter{$0.label != nil} return _allLabels.filter{$0.label != nil}.map{$0.label!} } } public required init?(coder: NSCoder) { super.init(coder: coder) Label._allLabels.append(WeakLabel(self)) } public override init(frame: CGRect) { super.init(frame: frame) Label._allLabels.append(WeakLabel(self)) } } </code></pre>
<p>The existing example of the WeakContainer is helpful, but it doesn't really help one use weak references in existing swift containers such as Lists and Dictionaries.</p> <p>If you want to use List methods such as contains, then the WeakContainer will need to implement Equatable. So I added the code to allow the WeakContainer to be equatable.</p> <p>In case you wanted to use the WeakContainer in dictionaries, I also made it hashable so it can be used as dictionary keys.</p> <p>I also renamed it to WeakObject to stress that this is only for class types and to differentiate it from the WeakContainer examples:</p> <pre><code>struct WeakObject&lt;TYPE where TYPE:AnyObject&gt; : Equatable, Hashable { weak var _value : TYPE? let _originalHashValue : Int init (value: TYPE) { _value = value // We keep around the original hash value so that we can return it to represent this // object even if the value became Nil out from under us because the object went away. _originalHashValue = ObjectIdentifier(value).hashValue } var value : TYPE? { return _value } var hashValue: Int { return _originalHashValue } } func ==&lt;T&gt;(lhs: WeakObject&lt;T&gt;, rhs: WeakObject&lt;T&gt;) -&gt; Bool { if lhs.value == nil &amp;&amp; rhs.value == nil { return true } else if lhs.value == nil || rhs.value == nil { return false } // If the objects are the same, then we are good to go return lhs.value! === rhs.value! } </code></pre> <p>This allows you to do some cool stuff like use a Dictionary of weak references:</p> <pre><code>private var m_observerDict : Dictionary&lt;WeakObject&lt;AnyObject&gt;,FLObservationBlock&gt; = Dictionary() func addObserver( observer:AnyObject, block:FLObservationBlock ) { let weakObserver = WeakObject(value:observer) m_observerDict[weakObserver] = block } func removeObserver( observer:AnyObject ) { let weakObserver = WeakObject(value:observer) m_observerDict.removeValueForKey(weakObserver) } </code></pre>
<p>I had the same idea to create weak container with generics.<br> As result I created wrapper for <code>NSHashTable</code>: </p> <pre><code>class WeakSet&lt;ObjectType&gt;: SequenceType { var count: Int { return weakStorage.count } private let weakStorage = NSHashTable.weakObjectsHashTable() func addObject(object: ObjectType) { guard object is AnyObject else { fatalError("Object (\(object)) should be subclass of AnyObject") } weakStorage.addObject(object as? AnyObject) } func removeObject(object: ObjectType) { guard object is AnyObject else { fatalError("Object (\(object)) should be subclass of AnyObject") } weakStorage.removeObject(object as? AnyObject) } func removeAllObjects() { weakStorage.removeAllObjects() } func containsObject(object: ObjectType) -&gt; Bool { guard object is AnyObject else { fatalError("Object (\(object)) should be subclass of AnyObject") } return weakStorage.containsObject(object as? AnyObject) } func generate() -&gt; AnyGenerator&lt;ObjectType&gt; { let enumerator = weakStorage.objectEnumerator() return anyGenerator { return enumerator.nextObject() as! ObjectType? } } } </code></pre> <p>Usage: </p> <pre><code>protocol MyDelegate : AnyObject { func doWork() } class MyClass: AnyObject, MyDelegate { fun doWork() { // Do delegated work. } } var delegates = WeakSet&lt;MyDelegate&gt;() delegates.addObject(MyClass()) for delegate in delegates { delegate.doWork() } </code></pre> <p>It's not the best solution, because <code>WeakSet</code> can be initialized with any type, and if this type doesn't conform to <code>AnyObject</code> protocol then app will crash with detailed reason. But I don't see any better solution right now. </p> <p>Original solution was to define <code>WeakSet</code> in this way: </p> <pre><code>class WeakSet&lt;ObjectType: AnyObject&gt;: SequenceType {} </code></pre> <p>But in this case <code>WeakSet</code> can't be initialized with protocol: </p> <pre><code>protocol MyDelegate : AnyObject { func doWork() } let weakSet = WeakSet&lt;MyDelegate&gt;() </code></pre> <p>Currently above code can't be compiled (Swift 2.1, Xcode 7.1).<br> That's why I dropped conforming to <code>AnyObject</code> and added additional guards with <code>fatalError()</code> assertions.</p>
<p>Yet another solution to the same problem... the focus of this one is on storing a weak reference to an object but allowing you to store a struct too.</p> <p>[I'm not sure how useful it is, but it did take a while to get the syntax right]</p> <pre><code>class WeakWrapper : Equatable { var valueAny : Any? weak var value : AnyObject? init(value: Any) { if let valueObj = value as? AnyObject { self.value = valueObj } else { self.valueAny = value } } func recall() -&gt; Any? { if let value = value { return value } else if let value = valueAny { return value } return nil } } func ==(lhs: WeakWrapper, rhs: WeakWrapper) -&gt; Bool { return ObjectIdentifier(lhs) == ObjectIdentifier(rhs) } class Stuff {} var weakArray : [WeakWrapper] = [WeakWrapper(value: Stuff()), WeakWrapper(value: CGRectZero)] extension Array where Element : WeakWrapper { mutating func removeObject(object: Element) { if let index = self.indexOf(object) { self.removeAtIndex(index) } } mutating func compress() { for obj in self { if obj.recall() == nil { self.removeObject(obj) } } } } weakArray[0].recall() weakArray[1].recall() == nil weakArray.compress() weakArray.count </code></pre>
<p>Here's how to make @GoZoner's great answer conform to <code>Hashable</code>, so it can be indexed in Container objects like: <code>Set</code>, <code>Dictionary</code>, <code>Array</code>, etc.</p> <pre><code>private class Weak&lt;T: AnyObject&gt;: Hashable { weak var value : T! init (value: T) { self.value = value } var hashValue : Int { // ObjectIdentifier creates a unique hashvalue for objects. return ObjectIdentifier(self.value).hashValue } } // Need to override so we can conform to Equitable. private func == &lt;T&gt;(lhs: Weak&lt;T&gt;, rhs: Weak&lt;T&gt;) -&gt; Bool { return lhs.hashValue == rhs.hashValue } </code></pre>
<p>It's kind of late for party, but try mine. I implemented as a Set not an Array.</p> <h2>WeakObjectSet</h2> <pre><code>class WeakObject&lt;T: AnyObject&gt;: Equatable, Hashable { weak var object: T? init(object: T) { self.object = object } var hashValue: Int { if let object = self.object { return unsafeAddressOf(object).hashValue } else { return 0 } } } func == &lt;T&gt; (lhs: WeakObject&lt;T&gt;, rhs: WeakObject&lt;T&gt;) -&gt; Bool { return lhs.object === rhs.object } class WeakObjectSet&lt;T: AnyObject&gt; { var objects: Set&lt;WeakObject&lt;T&gt;&gt; init() { self.objects = Set&lt;WeakObject&lt;T&gt;&gt;([]) } init(objects: [T]) { self.objects = Set&lt;WeakObject&lt;T&gt;&gt;(objects.map { WeakObject(object: $0) }) } var allObjects: [T] { return objects.flatMap { $0.object } } func contains(object: T) -&gt; Bool { return self.objects.contains(WeakObject(object: object)) } func addObject(object: T) { self.objects.unionInPlace([WeakObject(object: object)]) } func addObjects(objects: [T]) { self.objects.unionInPlace(objects.map { WeakObject(object: $0) }) } } </code></pre> <h2>Usage</h2> <pre><code>var alice: NSString? = "Alice" var bob: NSString? = "Bob" var cathline: NSString? = "Cathline" var persons = WeakObjectSet&lt;NSString&gt;() persons.addObject(bob!) print(persons.allObjects) // [Bob] persons.addObject(bob!) print(persons.allObjects) // [Bob] persons.addObjects([alice!, cathline!]) print(persons.allObjects) // [Alice, Cathline, Bob] alice = nil print(persons.allObjects) // [Cathline, Bob] bob = nil print(persons.allObjects) // [Cathline] </code></pre> <p>Beware that WeakObjectSet won't take String type but NSString. Because, String type is not an AnyType. My swift version is <code>Apple Swift version 2.2 (swiftlang-703.0.18.1 clang-703.0.29)</code>.</p> <p>Code can be grabbed from Gist. <a href="https://gist.github.com/codelynx/30d3c42a833321f17d39" rel="nofollow">https://gist.github.com/codelynx/30d3c42a833321f17d39</a></p> <p>Have a happy coding!</p>