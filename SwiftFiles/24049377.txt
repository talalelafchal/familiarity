Why would I use if and let together, instead of just checking if the original variable is nil? (Swift)
<p>In <a href="https://itun.es/us/jEUH0.l" rel="nofollow">“The Swift Programming Language.”</a> book, Apple mentions using <code>if</code> and <code>let</code> together when accessing an optional variable.</p> <p>The book gives the following code for example:</p> <pre><code>var optionalString: String? = "Hello" optionalString == nil var optionalName: String? = "John Appleseed" var greeting = "Hello!" if let name = optionalName { greeting = "Hello, \(name)" } </code></pre> <p>What is the advantage of using <code>if let name = optionalName</code>, rather than <code>if optionalName != nil</code> (and always referring to it as, <code>optionalName</code>)? Is there any difference, or is it simply convention?</p>
<p>Because it also unwraps the optional value, so this code:</p> <pre><code>if let name = optionalName { greeting = "Hello, \(name)" } </code></pre> <p>is equivalent to:</p> <pre><code>if optionalName != nil { let name:String = optionalName! greeting = "Hello, \(name)" } </code></pre> <p>This language sugar is known as <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-XID_432">Optional Binding</a> in Swift.</p> <h2>Optional Types</h2> <p>In Swift <code>T</code> and <code>T?</code> are not the same types, but the underlying value of an optional <code>T?</code> type can easily be realized by using the <code>!</code> postfix operator, e.g:</p> <pre><code>let name:String = optionalName! </code></pre> <p>Which now can be used where a <code>String</code> is expected, e.g:</p> <pre><code>func greet(name:String) -&gt; String { return "Hello, \(name)" } greet(name) </code></pre> <p>Although as its safe to do so, Swift does let you implicitly cast to an optional type:</p> <pre><code>let name = "World" let optionalName: String? = name func greet(optionalName:String?) -&gt; String? { if optionalName != nil { return "Hello, \(optionalName)" } return nil } //Can call with either String or String? greet(optionalName) greet(name) </code></pre>
<p>It isn't actually needed in that case. You could just use optionalName in the if. But if optionalName was a calculated property it would have to be calculated in the conditional then again in the body. Assigning it to name just makes sure it is only calculated once.</p>