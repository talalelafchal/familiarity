How to make an HTTP request in Swift?
<p>I read The Programming Language Swift by Apple in iBooks, but cannot figure out how to make an http request (something like CURL) in Swift. Do I need to import Obj-C classes or do I just need to import default libraries? Or is it not possible to make an HTTP request based on native swift code?</p>
<p>You can use <code>NSURL</code>, <code>NSURLRequest</code> and <code>NSURLSession</code> or <code>NSURLConnection</code> as you'd normally do in Objective-C. Note that for iOS 7.0 and later, <code>NSURLSession</code> is preferred.</p> <h2>Using <code>NSURLSession</code></h2> <p>Initialize an <code>NSURL</code> object and an <code>NSURLSessionDataTask</code> from <code>NSURLSession</code>. Then run the task with <code>resume()</code>.</p> <pre><code>let url = NSURL(string: "http://www.stackoverflow.com") let task = NSURLSession.sharedSession().dataTaskWithURL(url!) {(data, response, error) in print(NSString(data: data!, encoding: NSUTF8StringEncoding)) } task.resume() </code></pre> <h2>Using <code>NSURLConnection</code></h2> <p>First, initialize an <code>NSURL</code> and an <code>NSURLRequest</code>:</p> <pre><code>let url = NSURL(string: "http://www.stackoverflow.com") let request = NSURLRequest(URL: url!) </code></pre> <p>Then, you can load the request asynchronously with:</p> <pre><code>NSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue.mainQueue()) {(response, data, error) in print(NSString(data: data!, encoding: NSUTF8StringEncoding)) } </code></pre> <p>Or you can initialize an <code>NSURLConnection</code>:</p> <pre><code>let connection = NSURLConnection(request: request, delegate:nil, startImmediately: true) </code></pre> <p>Just make sure to set your delegate to something other than <code>nil</code> and use the delegate methods to work with the response and data received. </p> <p>For more detail, check the <a href="https://developer.apple.com/library/prerelease/ios/documentation/Foundation/Reference/NSURLConnectionDataDelegate_protocol/index.html">documentation for the <code>NSURLConnectionDataDelegate</code> protocol</a></p> <h2>Testing on an Xcode playground</h2> <p>If you want to try this code on a Xcode playground, add <code>import XCPlayground</code> to your playground, as well as the following call:</p> <pre><code>XCPSetExecutionShouldContinueIndefinitely() </code></pre> <p>This will allow you to use asynchronous code in playgrounds.</p>
<p>I am using this guy's wrapper with good results so far <a href="https://github.com/daltoniam/swiftHTTP">https://github.com/daltoniam/swiftHTTP</a>. No big <a href="http://en.wikipedia.org/wiki/Leaky_abstraction">leaky abstractions</a> so far</p> <p>Example</p> <pre><code> do { let opt = try HTTP.GET("https://google.com") opt.start { response in if let err = response.error { print("error: \(err.localizedDescription)") return //also notify app of failure as needed } print("opt finished: \(response.description)") //print("data is: \(response.data)") access the response of the data with response.data } } catch let error { print("got an error creating the request: \(error)") } </code></pre>
<pre><code> var post:NSString = "api=myposts&amp;userid=\(uid)&amp;page_no=0&amp;limit_no=10" NSLog("PostData: %@",post); var url1:NSURL = NSURL(string: url)! var postData:NSData = post.dataUsingEncoding(NSASCIIStringEncoding)! var postLength:NSString = String( postData.length ) var request:NSMutableURLRequest = NSMutableURLRequest(URL: url1) request.HTTPMethod = "POST" request.HTTPBody = postData request.setValue(postLength, forHTTPHeaderField: "Content-Length") request.setValue("application/x-www-form-urlencoded", forHTTPHeaderField: "Content-Type") request.setValue("application/json", forHTTPHeaderField: "Accept") var reponseError: NSError? var response: NSURLResponse? var urlData: NSData? = NSURLConnection.sendSynchronousRequest(request, returningResponse:&amp;response, error:&amp;reponseError) if ( urlData != nil ) { let res = response as NSHTTPURLResponse!; NSLog("Response code: %ld", res.statusCode); if (res.statusCode &gt;= 200 &amp;&amp; res.statusCode &lt; 300) { var responseData:NSString = NSString(data:urlData!, encoding:NSUTF8StringEncoding)! NSLog("Response ==&gt; %@", responseData); var error: NSError? let jsonData:NSDictionary = NSJSONSerialization.JSONObjectWithData(urlData!, options:NSJSONReadingOptions.MutableContainers , error: &amp;error) as NSDictionary let success:NSInteger = jsonData.valueForKey("error") as NSInteger //[jsonData[@"success"] integerValue]; NSLog("Success: %ld", success); if(success == 0) { NSLog("Login SUCCESS"); self.dataArr = jsonData.valueForKey("data") as NSMutableArray self.table.reloadData() } else { NSLog("Login failed1"); ZAActivityBar.showErrorWithStatus("error", forAction: "Action2") } } else { NSLog("Login failed2"); ZAActivityBar.showErrorWithStatus("error", forAction: "Action2") } } else { NSLog("Login failed3"); ZAActivityBar.showErrorWithStatus("error", forAction: "Action2") } </code></pre> <p>it will help you surely</p>
<blockquote> <p>I am calling the json on login button click</p> </blockquote> <pre><code>@IBAction func loginClicked(sender : AnyObject) { var request = NSMutableURLRequest(URL: NSURL(string: kLoginURL)) // Here, kLogin contains the Login API. var session = NSURLSession.sharedSession() request.HTTPMethod = "POST" var err: NSError? request.HTTPBody = NSJSONSerialization.dataWithJSONObject(self.criteriaDic(), options: nil, error: &amp;err) // This Line fills the web service with required parameters. request.addValue("application/json", forHTTPHeaderField: "Content-Type") request.addValue("application/json", forHTTPHeaderField: "Accept") var task = session.dataTaskWithRequest(request, completionHandler: {data, response, error -&gt; Void in var strData = NSString(data: data, encoding: NSUTF8StringEncoding) var err1: NSError? var json2 = NSJSONSerialization.JSONObjectWithData(strData.dataUsingEncoding(NSUTF8StringEncoding), options: .MutableLeaves, error:&amp;err1 ) as NSDictionary println("json2 :\(json2)") if(err) { println(err!.localizedDescription) } else { var success = json2["success"] as? Int println("Success: \(success)") } }) task.resume() } </code></pre> <p>Here, I have made a seperate dictionary for the parameters.</p> <pre><code>var params = ["format":"json", "MobileType":"IOS","MIN":"f8d16d98ad12acdbbe1de647414495ec","UserName":emailTxtField.text,"PWD":passwordTxtField.text,"SigninVia":"SH"]as NSDictionary return params } // You can add your own sets of parameter here. </code></pre>
<p>Check Below Codes :</p> <p><strong>1. SynchonousRequest</strong></p> <p><strong>Swift 1.2</strong></p> <pre><code> let urlPath: String = "YOUR_URL_HERE" var url: NSURL = NSURL(string: urlPath)! var request1: NSURLRequest = NSURLRequest(URL: url) var response: AutoreleasingUnsafeMutablePointer&lt;NSURLResponse?&gt;=nil var dataVal: NSData = NSURLConnection.sendSynchronousRequest(request1, returningResponse: response, error:nil)! var err: NSError println(response) var jsonResult: NSDictionary = NSJSONSerialization.JSONObjectWithData(dataVal, options: NSJSONReadingOptions.MutableContainers, error: &amp;err) as? NSDictionary println("Synchronous\(jsonResult)") </code></pre> <p><strong>Swift 2.0 +</strong></p> <pre><code>let urlPath: String = "YOUR_URL_HERE" let url: NSURL = NSURL(string: urlPath)! let request1: NSURLRequest = NSURLRequest(URL: url) let response: AutoreleasingUnsafeMutablePointer&lt;NSURLResponse?&gt;=nil do{ let dataVal = try NSURLConnection.sendSynchronousRequest(request1, returningResponse: response) print(response) do { if let jsonResult = try NSJSONSerialization.JSONObjectWithData(dataVal, options: []) as? NSDictionary { print("Synchronous\(jsonResult)") } } catch let error as NSError { print(error.localizedDescription) } }catch let error as NSError { print(error.localizedDescription) } </code></pre> <p><strong>2. AsynchonousRequest</strong></p> <p><strong>Swift 1.2</strong></p> <pre><code>let urlPath: String = "YOUR_URL_HERE" var url: NSURL = NSURL(string: urlPath)! var request1: NSURLRequest = NSURLRequest(URL: url) let queue:NSOperationQueue = NSOperationQueue() NSURLConnection.sendAsynchronousRequest(request1, queue: queue, completionHandler:{ (response: NSURLResponse!, data: NSData!, error: NSError!) -&gt; Void in var err: NSError var jsonResult: NSDictionary = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers, error: nil) as NSDictionary println("Asynchronous\(jsonResult)") }) </code></pre> <p><strong>Swift 2.0 +</strong></p> <pre><code>let urlPath: String = "YOUR_URL_HERE" let url: NSURL = NSURL(string: urlPath)! let request1: NSURLRequest = NSURLRequest(URL: url) let queue:NSOperationQueue = NSOperationQueue() NSURLConnection.sendAsynchronousRequest(request1, queue: queue, completionHandler:{ (response: NSURLResponse?, data: NSData?, error: NSError?) -&gt; Void in do { if let jsonResult = try NSJSONSerialization.JSONObjectWithData(data!, options: []) as? NSDictionary { print("ASynchronous\(jsonResult)") } } catch let error as NSError { print(error.localizedDescription) } }) </code></pre> <p><strong>3. As usual URL connection</strong></p> <p><strong>Swift 1.2</strong></p> <pre><code> var dataVal = NSMutableData() let urlPath: String = "YOUR URL HERE" var url: NSURL = NSURL(string: urlPath)! var request: NSURLRequest = NSURLRequest(URL: url) var connection: NSURLConnection = NSURLConnection(request: request, delegate: self, startImmediately: true)! connection.start() </code></pre> <p>Then</p> <pre><code> func connection(connection: NSURLConnection!, didReceiveData data: NSData!){ self.dataVal?.appendData(data) } func connectionDidFinishLoading(connection: NSURLConnection!) { var error: NSErrorPointer=nil var jsonResult: NSDictionary = NSJSONSerialization.JSONObjectWithData(dataVal!, options: NSJSONReadingOptions.MutableContainers, error: error) as NSDictionary println(jsonResult) } </code></pre> <p><strong>Swift 2.0 +</strong></p> <pre><code> var dataVal = NSMutableData() let urlPath: String = "YOUR URL HERE" var url: NSURL = NSURL(string: urlPath)! var request: NSURLRequest = NSURLRequest(URL: url) var connection: NSURLConnection = NSURLConnection(request: request, delegate: self, startImmediately: true)! connection.start() </code></pre> <p>Then</p> <pre><code>func connection(connection: NSURLConnection!, didReceiveData data: NSData!){ dataVal.appendData(data) } func connectionDidFinishLoading(connection: NSURLConnection!) { do { if let jsonResult = try NSJSONSerialization.JSONObjectWithData(dataVal, options: []) as? NSDictionary { print(jsonResult) } } catch let error as NSError { print(error.localizedDescription) } } </code></pre> <p><strong>4. Asynchonous POST Request</strong></p> <p><strong>Swift 1.2</strong></p> <pre><code> let urlPath: String = "YOUR URL HERE" var url: NSURL = NSURL(string: urlPath)! var request1: NSMutableURLRequest = NSMutableURLRequest(URL: url) request1.HTTPMethod = "POST" var stringPost="deviceToken=123456" // Key and Value let data = stringPost.dataUsingEncoding(NSUTF8StringEncoding) request1.timeoutInterval = 60 request1.HTTPBody=data request1.HTTPShouldHandleCookies=false let queue:NSOperationQueue = NSOperationQueue() NSURLConnection.sendAsynchronousRequest(request1, queue: queue, completionHandler:{ (response: NSURLResponse!, data: NSData!, error: NSError!) -&gt; Void in var err: NSError var jsonResult: NSDictionary = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers, error: nil) as NSDictionary println("AsSynchronous\(jsonResult)") }) </code></pre> <p><strong>Swift 2.0 +</strong></p> <pre><code>let urlPath: String = "YOUR URL HERE" let url: NSURL = NSURL(string: urlPath)! let request1: NSMutableURLRequest = NSMutableURLRequest(URL: url) request1.HTTPMethod = "POST" let stringPost="deviceToken=123456" // Key and Value let data = stringPost.dataUsingEncoding(NSUTF8StringEncoding) request1.timeoutInterval = 60 request1.HTTPBody=data request1.HTTPShouldHandleCookies=false let queue:NSOperationQueue = NSOperationQueue() NSURLConnection.sendAsynchronousRequest(request1, queue: queue, completionHandler:{ (response: NSURLResponse?, data: NSData?, error: NSError?) -&gt; Void in do { if let jsonResult = try NSJSONSerialization.JSONObjectWithData(data!, options: []) as? NSDictionary { print("ASynchronous\(jsonResult)") } } catch let error as NSError { print(error.localizedDescription) } }) </code></pre> <p><strong>5. Asynchonous GET Request</strong></p> <p><strong>Swift 1.2</strong></p> <pre><code> let urlPath: String = "YOUR URL HERE" var url: NSURL = NSURL(string: urlPath)! var request1: NSMutableURLRequest = NSMutableURLRequest(URL: url) request1.HTTPMethod = "GET" request1.timeoutInterval = 60 let queue:NSOperationQueue = NSOperationQueue() NSURLConnection.sendAsynchronousRequest(request1, queue: queue, completionHandler:{ (response: NSURLResponse!, data: NSData!, error: NSError!) -&gt; Void in var err: NSError var jsonResult: NSDictionary = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers, error: nil) as NSDictionary println("AsSynchronous\(jsonResult)") }) </code></pre> <p><strong>Swift 2.0 +</strong></p> <pre><code>let urlPath: String = "YOUR URL HERE" let url: NSURL = NSURL(string: urlPath)! let request1: NSMutableURLRequest = NSMutableURLRequest(URL: url) request1.HTTPMethod = "GET" let queue:NSOperationQueue = NSOperationQueue() NSURLConnection.sendAsynchronousRequest(request1, queue: queue, completionHandler:{ (response: NSURLResponse?, data: NSData?, error: NSError?) -&gt; Void in do { if let jsonResult = try NSJSONSerialization.JSONObjectWithData(data!, options: []) as? NSDictionary { print("ASynchronous\(jsonResult)") } } catch let error as NSError { print(error.localizedDescription) } }) </code></pre> <p><strong>6. Image(File) Upload</strong></p> <p><strong>Swift 2.0 +</strong></p> <pre><code> let mainURL = "YOUR_URL_HERE" let url = NSURL(string: mainURL) let request = NSMutableURLRequest(URL: url!) let boundary = "78876565564454554547676" request.addValue("multipart/form-data; boundary=\(boundary)", forHTTPHeaderField: "Content-Type") request.HTTPMethod = "POST" // POST OR PUT What you want let session = NSURLSession(configuration:NSURLSessionConfiguration.defaultSessionConfiguration(), delegate: nil, delegateQueue: nil) let imageData = UIImageJPEGRepresentation(UIImage(named: "Test.jpeg")!, 1) var body = NSMutableData() body.appendData("--\(boundary)\r\n".dataUsingEncoding(NSUTF8StringEncoding)!) // Append your parameters body.appendData("Content-Disposition: form-data; name=\"name\"\r\n\r\n".dataUsingEncoding(NSUTF8StringEncoding)!) body.appendData("PREMKUMAR\r\n".dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: true)!) body.appendData("--\(boundary)\r\n".dataUsingEncoding(NSUTF8StringEncoding)!) body.appendData("Content-Disposition: form-data; name=\"description\"\r\n\r\n".dataUsingEncoding(NSUTF8StringEncoding)!) body.appendData("IOS_DEVELOPER\r\n".dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: true)!) body.appendData("--\(boundary)\r\n".dataUsingEncoding(NSUTF8StringEncoding)!) // Append your Image/File Data var imageNameval = "HELLO.jpg" body.appendData("--\(boundary)\r\n".dataUsingEncoding(NSUTF8StringEncoding)!) body.appendData("Content-Disposition: form-data; name=\"profile_photo\"; filename=\"\(imageNameval)\"\r\n".dataUsingEncoding(NSUTF8StringEncoding)!) body.appendData("Content-Type: image/jpeg\r\n\r\n".dataUsingEncoding(NSUTF8StringEncoding)!) body.appendData(imageData!) body.appendData("\r\n".dataUsingEncoding(NSUTF8StringEncoding)!) body.appendData("--\(boundary)--\r\n".dataUsingEncoding(NSUTF8StringEncoding)!) request.HTTPBody = body let dataTask = session.dataTaskWithRequest(request) { (data, response, error) -&gt; Void in if error != nil { //handle error } else { let outputString : NSString = NSString(data:data!, encoding:NSUTF8StringEncoding)! print("Response:\(outputString)") } } dataTask.resume() </code></pre>
<p>You can use <a href="https://github.com/justhttp/Just" rel="nofollow">Just</a>, a <code>python-requests</code> style HTTP library.</p> <p>Some example of sending HTTP request with Just:</p> <pre><code>// synchronous GET request with URL query a=1 let r = Just.get("https://httpbin.org/get", params:["a":1]) // asynchronous POST request with form value and file uploads Just.post( "http://justiceleauge.org/member/register", data: ["username": "barryallen", "password":"ReverseF1ashSucks"], files: ["profile_photo": .URL(fileURLWithPath:"flash.jpeg", nil)] ) { (r) if (r.ok) { /* success! */ } } </code></pre> <p>In both cases, the result of a request <code>r</code> can be accessed in ways similar to <code>python-request</code>:</p> <pre><code>r.ok // is the response successful? r.statusCode // status code of response r.content // response body as NSData? r.text // response body as text? r.json // response body parsed by NSJSONSerielization </code></pre> <p>You can find more examples in this <a href="https://raw.githubusercontent.com/JustHTTP/Just/master/Docs/QuickStart.zip" rel="nofollow">playground</a></p> <p>Using this library in synchronous mode in a playground is the closest thing to cURL one can get in Swift.</p>
<p>Another option is the <strong>Alamofire</strong> lib that offers Chainable Request / Response methods.</p> <p><a href="https://github.com/Alamofire/Alamofire">https://github.com/Alamofire/Alamofire</a></p> <p><strong>Making a Request</strong></p> <pre><code>import Alamofire Alamofire.request(.GET, "http://httpbin.org/get") </code></pre> <p><strong>Response Handling</strong></p> <pre><code>Alamofire.request(.GET, "http://httpbin.org/get", parameters: ["foo": "bar"]) .response { request, response, data, error in print(request) print(response) print(error) } </code></pre>
<p>I have done <strong>HTTP</strong> Request <strong>Both</strong> methods <strong>GET</strong> &amp; <strong>POST</strong> with <strong>JSON Parsing</strong> this way:</p> <p>on <strong>viewDidLoad()</strong>:</p> <pre><code>override func viewDidLoad() { super.viewDidLoad() makeGetRequest() makePostRequest() } func makePostRequest(){ let urlPath: String = "http://www.swiftdeveloperblog.com/http-post-example-script/" var url: NSURL = NSURL(string: urlPath)! var request: NSMutableURLRequest = NSMutableURLRequest(URL: url) request.HTTPMethod = "POST" var stringPost="firstName=James&amp;lastName=Bond" // Key and Value let data = stringPost.dataUsingEncoding(NSUTF8StringEncoding) request.timeoutInterval = 60 request.HTTPBody=data request.HTTPShouldHandleCookies=false let queue:NSOperationQueue = NSOperationQueue() NSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue(), completionHandler:{ (response:NSURLResponse!, data: NSData!, error: NSError!) -&gt; Void in var error: AutoreleasingUnsafeMutablePointer&lt;NSError?&gt; = nil let jsonResult: NSDictionary! = NSJSONSerialization.JSONObjectWithData(data, options:NSJSONReadingOptions.MutableContainers, error: error) as? NSDictionary if (jsonResult != nil) { // Success println(jsonResult) let message = jsonResult["Message"] as! NSString println(message) }else { // Failed println("Failed") } }) } func makeGetRequest(){ var url : String = "http://api.androidhive.info/contacts/" var request : NSMutableURLRequest = NSMutableURLRequest() request.URL = NSURL(string: url) request.HTTPMethod = "GET" request.timeoutInterval = 60 NSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue(), completionHandler:{ (response:NSURLResponse!, data: NSData!, error: NSError!) -&gt; Void in var error: AutoreleasingUnsafeMutablePointer&lt;NSError?&gt; = nil let jsonResult: NSDictionary! = NSJSONSerialization.JSONObjectWithData(data, options:NSJSONReadingOptions.MutableContainers, error: error) as? NSDictionary if (jsonResult != nil) { // Success println(jsonResult) let dataArray = jsonResult["contacts"] as! NSArray; for item in dataArray { // loop through data items let obj = item as! NSDictionary for (key, value) in obj { println("Key: \(key) - Value: \(value)") let phone = obj["phone"] as! NSDictionary; let mobile = phone["mobile"] as! NSString println(mobile) let home = phone["home"] as! NSString println(home) let office = phone["office"] as! NSString println(office) } } } else { // Failed println("Failed") } }) } </code></pre> <p><strong>Done</strong></p>
<p>//Here is an example that worked for me </p> <p>//Swift function that post a request to a server with key values </p> <pre><code>func insertRecords() { let usrID = txtID.text let checkin = lblInOut.text let comment = txtComment.text // The address of the web service let urlString = "http://your_url/checkInOut_post.php" // These are the keys that your are sending as part of the post request let keyValues = "id=\(usrID)&amp;inout=\(checkin)&amp;comment=\(comment)" // 1 - Create the session by getting the configuration and then // creating the session let config = NSURLSessionConfiguration.defaultSessionConfiguration() let session = NSURLSession(configuration: config, delegate: nil, delegateQueue: nil) // 2 - Create the URL Object if let url = NSURL(string: urlString){ // 3 - Create the Request Object var request = NSMutableURLRequest(URL: url) request.HTTPMethod = "POST" // set the key values request.HTTPBody = keyValues.dataUsingEncoding(NSUTF8StringEncoding); // 4 - execute the request let taskData = session.dataTaskWithRequest(request, completionHandler: { (data:NSData!, response:NSURLResponse!, error:NSError!) -&gt; Void in println("\(data)") // 5 - Do something with the Data back if (data != nil) { // we got some data back println("\(data)") let result = NSString(data: data , encoding: NSUTF8StringEncoding) println("\(result)") if result == "OK" { let a = UIAlertView(title: "OK", message: "Attendece has been recorded", delegate: nil, cancelButtonTitle: "OK") println("\(result)") dispatch_async(dispatch_get_main_queue()) { a.show() } } else { // display error and do something else } } else { // we got an error println("Error getting stores :\(error.localizedDescription)") } }) taskData.resume() } } </code></pre> <p>PHP Code to get the key values </p> <p>$empID = $_POST['id'];</p> <p>$inOut = $_POST['inout'];</p> <p>$comment = $_POST['comment'];</p>
<p>A simple Swift 2.0 approach to making a HTTP GET request</p> <p>The HTTP request is asynchronous so you need a way to get the returned value from the HTTP Request. This approach uses Notifiers and is spread over two classes. </p> <p>The example is to check the username and password for an identifier token using the website <a href="http://www.example.com/handler.php?do=CheckUserJson&amp;json=" rel="nofollow">http://www.example.com/handler.php?do=CheckUserJson&amp;json=</a> That is the file is called handler.php and has a switch statement on the do parameter to get a RESTful approach.</p> <p>In the viewDidLoad we setup the NotifierObserver, set up the json and make the call to the getHTTPRequest function. It will return to the function checkedUsernameAndPassword with the returned parameter from the http request.</p> <pre><code>override func viewDidLoad() { super.viewDidLoad() // setup the Notification observer to catch the result of check username and password NSNotificationCenter.defaultCenter().addObserver(self, selector: "checkedUsernameAndPassword:", name: CHECK_USERNAME_AND_PASSWORD, object: nil) let username = GlobalVariables.USER_NAME let password = GlobalVariables.PASSWORD // check username and password if let jsonString = Utility.checkUsernameAndPasswordJson(username, password:password){ print("json string returned = \(jsonString)") let url = CHECKUSERJSON+jsonString // CHECKUSERJSON = http://www.example.com/handler.php?do=CheckUserJson&amp;json= // jsonString = {\"username\":\"demo\",\"password\":\"demo\"}" // the php script handles a json request and returns a string identifier Utility.getHTTPRequest(url,notifierId: CHECK_USERNAME_AND_PASSWORD) // the returned identifier is sent to the checkedUsernaeAndPassword function when it becomes availabel. } } </code></pre> <p>There are two static functions in Utility.swift first to encode the json and then to do the HTTP call.</p> <pre><code> static func checkUsernameAndPasswordJson(username: String, password: String) -&gt; String?{ let para:NSMutableDictionary = NSMutableDictionary() para.setValue("demo", forKey: "username") para.setValue("demo", forKey: "password") let jsonData: NSData do{ jsonData = try NSJSONSerialization.dataWithJSONObject(para, options: NSJSONWritingOptions()) let jsonString = NSString(data: jsonData, encoding: NSUTF8StringEncoding) as! String return jsonString } catch _ { print ("UH OOO") return nil } } </code></pre> <p>and the Http request</p> <pre><code> static func getHTTPRequest (url:String , notifierId: String) -&gt; Void{ let urlString = url let config = NSURLSessionConfiguration.defaultSessionConfiguration() let session = NSURLSession(configuration: config, delegate: nil, delegateQueue: nil) let safeURL = urlString.stringByAddingPercentEncodingWithAllowedCharacters(NSCharacterSet.URLQueryAllowedCharacterSet())! if let url = NSURL(string: safeURL){ let request = NSMutableURLRequest(URL: url) request.HTTPMethod = "GET" request.timeoutInterval = 60 let taskData = session.dataTaskWithRequest(request, completionHandler: { (data:NSData?, response:NSURLResponse?, error:NSError?) -&gt; Void in if (data != nil) { let result = NSString(data: data! , encoding: NSUTF8StringEncoding) sendNotification (notifierId, message: String(result), num: 0) }else{ sendNotification (notifierId, message: String(UTF8String: nil), num: -1) } }) taskData.resume() }else{ print("bad urlString = \(urlString)") } } </code></pre> <p>The sendNotification function completes the circle. Notice that in teh Observer there is a ":" at the end of the selector string. This allows the notification to carry a payload in userInfo. I give this a String and an Int.</p> <pre><code> static func sendNotification (key: String, message:String?, num: Int?){ NSNotificationCenter.defaultCenter().postNotificationName( key, object: nil, userInfo: (["message": message!, "num": "\(num!)"]) ) } </code></pre> <p>Note that using HTTP is oldFashioned, prefer HTTPS see <a href="http://stackoverflow.com/questions/30731785/how-do-i-load-an-http-url-with-app-transport-security-enabled-in-ios-9">How do I load an HTTP URL with App Transport Security enabled in iOS 9?</a></p>
<p><strong>Basic Swift 3 Solution</strong></p> <pre><code>let url = URL(string: "http://www.stackoverflow.com") let task = URLSession.shared.dataTask(with: url! as URL) { data, response, error in guard let data = data, error == nil else { return } print(NSString(data: data, encoding: String.Encoding.utf8.rawValue)) } task.resume() </code></pre>
<p><strong>Swift 3 Data Request using URLSession API</strong></p> <pre><code> //create the url with NSURL let url = URL(string: "https://jsonplaceholder.typicode.com/todos/1")! //change the url //create the session object let session = URLSession.shared //now create the URLRequest object using the url object let request = URLRequest(url: url) //create dataTask using the session object to send data to the server let task = session.dataTask(with: request as URLRequest, completionHandler: { data, response, error in guard error == nil else { return } guard let data = data else { return } do { //create json object from data if let json = try JSONSerialization.jsonObject(with: data, options: .mutableContainers) as? [String: Any] { print(json) } } catch let error { print(error.localizedDescription) } }) task.resume() </code></pre>
<p><strong>Swift 3 Data Request using URLSession API</strong></p> <pre><code> //create the url with NSURL let url = URL(string: "https://jsonplaceholder.typicode.com/todos/1")! //change the url //create the session object let session = URLSession.shared //now create the URLRequest object using the url object let request = URLRequest(url: url) //create dataTask using the session object to send data to the server let task = session.dataTask(with: request as URLRequest, completionHandler: { data, response, error in guard error == nil else { return } guard let data = data else { return } do { //create json object from data if let json = try JSONSerialization.jsonObject(with: data, options: .mutableContainers) as? [String: Any] { print(json) } } catch let error { print(error.localizedDescription) } }) task.resume() </code></pre>