What's the cleanest way of applying map() to a dictionary in Swift?
<p>I'd like to map a function on all keys in the dictionary. I was hoping something like the following would work, but filter cannot be applied to dictionary directly. What's the cleanest way of achieving this?</p> <p>In this example, I'm trying to increment each value by 1. However this is incidental for the example - the main purpose is to figure out how to apply map() to a dictionary.</p> <pre><code>var d = ["foo" : 1, "bar" : 2] d.map() { $0.1 += 1 } </code></pre>
<p>According to the Swift Standard Library Reference, map is a function of arrays. Not for dictionaries.</p> <p>But you could iterate your dictionary to modify the keys:</p> <pre><code>var d = ["foo" : 1, "bar" : 2] for (name, key) in d { d[name] = d[name]! + 1 } </code></pre>
<p>It turns out you can do this. What you have to do is create an array from the <code>MapCollectionView&lt;Dictionary&lt;KeyType, ValueType&gt;, KeyType&gt;</code> returned from the dictionaries <code>keys</code> method. (<a href="https://developer.apple.com/library/prerelease/ios/documentation/General/Reference/SwiftStandardLibraryReference/SwiftStandardLibraryReference.pdf" rel="nofollow">Info here</a>) You can then map this array, and pass the updated values back to the dictionary.</p> <pre><code>var dictionary = ["foo" : 1, "bar" : 2] Array(dictionary.keys).map() { dictionary.updateValue(dictionary[$0]! + 1, forKey: $0) } dictionary </code></pre>
<p>The cleanest way is to just add <code>map</code> to Dictionary:</p> <pre><code>extension Dictionary { mutating func map(transform: (key:KeyType, value:ValueType) -&gt; (newValue:ValueType)) { for key in self.keys { var newValue = transform(key: key, value: self[key]!) self.updateValue(newValue, forKey: key) } } } </code></pre> <p>Checking that it works:</p> <pre><code>var dic = ["a": 50, "b": 60, "c": 70] dic.map { $0.1 + 1 } println(dic) dic.map { (key, value) in if key == "a" { return value } else { return value * 2 } } println(dic) </code></pre> <p>Output:</p> <pre><code>[c: 71, a: 51, b: 61] [c: 142, a: 51, b: 122] </code></pre>
<p><strong>Updated for Swift 2</strong></p> <p><code>map</code> is an extension method on <code>SequenceType</code> and <code>CollectionType</code>. It's defined like this:</p> <pre><code>func map&lt;T&gt;(@noescape transform: (Self.Generator.Element) throws -&gt; T) rethrows -&gt; [T] </code></pre> <p>If we remove some clutter, we get this simplified definition:</p> <pre><code>func map&lt;T&gt;(transform: (Self.Generator.Element) -&gt; T) -&gt; [T] </code></pre> <p>Since <code>Dictionary</code> conforms to <code>CollectionType</code>, and its <code>Element</code> typealias is a (key, value) tuple, that means you ought to be able to do something like this:</p> <pre><code>result = dict.map { (key, value) in (key, value.uppercaseString) } </code></pre> <p>However, that won't actually assign to a <code>Dictionary</code>-typed variable. The <code>map</code> method is defined to always return an array (the <code>[T]</code>), even for other types like dictionaries. If you write a constructor that'll turn an array of two-tuples into a <code>Dictionary</code> and all will be right with the world:</p> <pre><code>extension Dictionary { init(_ pairs: [Element]) { self.init() for (k, v) in pairs { self[k] = v } } } result = Dictionary(dict.map { (key, value) in (key, value.uppercaseString) }) </code></pre> <p>You may even want to write a Dictionary-specific version of <code>map</code> just to avoid explicitly calling the constructor. Here I've also included an implementation of <code>filter</code>:</p> <pre><code>extension Dictionary { func mapPairs&lt;OutKey: Hashable, OutValue&gt;(@noescape transform: Element throws -&gt; (OutKey, OutValue)) rethrows -&gt; [OutKey: OutValue] { return Dictionary&lt;OutKey, OutValue&gt;(try map(transform)) } func filterPairs(@noescape includeElement: Element throws -&gt; Bool) rethrows -&gt; [Key: Value] { return Dictionary(try filter(includeElement)) } } </code></pre> <p>I used different names because otherwise only the return values would distinguish the two methods, which can make code very ambiguous.</p> <p>Use it like this:</p> <pre><code>result = dict.mapPairs { (key, value) in (key, value.uppercaseString) } </code></pre> <p>Incidentally, for many purposes, you may instead want to map only the values:</p> <pre><code>extension Dictionary { func map&lt;OutValue&gt;(@noescape transform: Value throws -&gt; OutValue) rethrows -&gt; [Key: OutValue] { return Dictionary&lt;Key, OutValue&gt;(try map { (k, v) in (k, try transform(v)) }) } } </code></pre> <p>The reason is that <code>mapPairs</code> can lose pairs if two end up being mapped to the same key. <code>map(Value -&gt; OutValue)</code>, on the other hand, always preserves the keys, so this isn't a danger.</p> <p><strong>What about Swift 3?</strong></p> <p>Swift Evolution proposal <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0100-add-sequence-based-init-and-merge-to-dictionary.md">SE-0100</a> would add to Swift 3 a more elaborate version of my <code>Dictionary.init(_:)</code> initializer; it would support initializing a <code>Dictionary</code> from any compatible <code>Sequence</code> and return <code>nil</code> if any keys conflict. It also includes an even <em>more</em> elaborate version which allows you to choose how conflicting keys should be handled; this would let you (for instance) ignore, concatenate, sum, or choose the largest or smallest value present. The core team has agreed to run a public review for SE-0100, but it has not yet been scheduled.</p> <p>Every Swift proposal goes through a one-week public review period, during which you can send your comments on the proposal to the Swift core team to help them make their decision. If you've benefited from reading this post, your experience may be relevant. You can find out when the SE-0100 review—and all other Swift Evolution proposal reviews—starts by subscribing to the <a href="https://lists.swift.org/mailman/listinfo/swift-evolution-announce">swift-evolution-announce</a> list. Once the review starts, you can email your comments privately to the review manager.</p> <p>A <code>mapValues</code> method (like my <code>Dictionary.map(transform: Value -&gt; OutValue) -&gt; [Key: OutValue]</code> method) has come up several times in discussion, but has not yet been formally proposed.</p>
<p>I was looking for a way to map a dictionary right into a typed Array with custom objects. Found the solution in this extension:</p> <pre><code>extension Dictionary { func mapKeys&lt;U&gt; (transform: Key -&gt; U) -&gt; Array&lt;U&gt; { var results: Array&lt;U&gt; = [] for k in self.keys { results.append(transform(k)) } return results } func mapValues&lt;U&gt; (transform: Value -&gt; U) -&gt; Array&lt;U&gt; { var results: Array&lt;U&gt; = [] for v in self.values { results.append(transform(v)) } return results } func map&lt;U&gt; (transform: Value -&gt; U) -&gt; Array&lt;U&gt; { return self.mapValues(transform) } func map&lt;U&gt; (transform: (Key, Value) -&gt; U) -&gt; Array&lt;U&gt; { var results: Array&lt;U&gt; = [] for k in self.keys { results.append(transform(k as Key, self[ k ]! as Value)) } return results } func map&lt;K: Hashable, V&gt; (transform: (Key, Value) -&gt; (K, V)) -&gt; Dictionary&lt;K, V&gt; { var results: Dictionary&lt;K, V&gt; = [:] for k in self.keys { if let value = self[ k ] { let (u, w) = transform(k, value) results.updateValue(w, forKey: u) } } return results } } </code></pre> <p>Using it as followed:</p> <pre><code>self.values = values.map({ (key:String, value:NSNumber) -&gt; VDLFilterValue in return VDLFilterValue(name: key, amount: value) }) </code></pre>
<p>You can also use <code>reduce</code> instead of map. <code>reduce</code> is capable of doing anything <code>map</code> can do and more!</p> <pre><code>let oldDict = ["old1": 1, "old2":2] let newDict = reduce(oldDict, [String:Int]()) { dict, pair in var d = dict d["new\(pair.1)"] = pair.1 return d } println(newDict) // ["new1": 1, "new2": 2] </code></pre> <p>It would be fairly easy to wrap this in an extension, but even without the extension it lets you do what you want with one function call.</p>
<p>While most of the answers here focus on how to map the entire dictionary (keys <em>and</em> values), the question really only wanted to map the values. This is an important distinction since mapping values allows you to guarantee the same number of entries, whereas mapping both key and value might result in duplicate keys.</p> <p>Here’s an extension, <code>mapValues</code>, that allows you to map just the values. Note it also extends dictionary with an <code>init</code> from a sequence of key/value pairs, which is a bit more general than initializing it from an array:</p> <pre><code>extension Dictionary { init&lt;S: SequenceType where S.Generator.Element == Element&gt; (_ seq: S) { self.init() for (k,v) in seq { self[k] = v } } func mapValues&lt;T&gt;(transform: Value-&gt;T) -&gt; Dictionary&lt;Key,T&gt; { return Dictionary&lt;Key,T&gt;(zip(self.keys, self.values.map(transform))) } } </code></pre>
<p>I assume the problem is to keep the keys of our original dictionary and map all its values in some way.</p> <p>Let us generalize and say that we may want to map all the values <em>to another type</em>.</p> <p>So what we'd like to start with is a dictionary and a closure (a function) and end up with a new dictionary. The problem is, of course, that Swift's strict typing gets in the way. A closure needs to specify what type goes in and what type comes out, and thus we cannot make a method that takes a <em>general</em> closure — except in the context of a generic. Thus we need a generic function.</p> <p>Other solutions have concentrated on doing this within the generic world of the Dictionary generic struct itself, but I find it easier to think in terms of a top-level function. For example, we could write this, where K is the key type, V1 is the value type of the starting dictionary, and V2 is the value type of the ending dictionary:</p> <pre><code>func mapValues&lt;K,V1,V2&gt;(d1:[K:V1], closure:(V1)-&gt;V2) -&gt; [K:V2] { var d2 = [K:V2]() for (key,value) in zip(d1.keys, d1.values.map(closure)) { d2.updateValue(value, forKey: key) } return d2 } </code></pre> <p>Here's a simple example of calling it, just to prove that the generic does indeed resolve itself at compile time:</p> <pre><code>let d : [String:Int] = ["one":1, "two":2] let result = mapValues(d) { (i : Int) -&gt; String in String(i) } </code></pre> <p>We started with a dictionary of <code>[String:Int]</code> and ended up with a dictionary of <code>[String:String]</code> by transforming the values of the first dictionary through a closure.</p> <p>(EDIT: I see now that this is effectively the same as AirspeedVelocity's solution, except that I didn't add the extra elegance of a Dictionary initializer that makes a Dictionary out of a zip sequence.)</p>
<p>Another approach is to <code>map</code> to a dictionary and <code>reduce</code>, where functions <code>keyTransform</code> and <code>valueTransform</code> are functions.</p> <pre><code>let dictionary = ["a": 1, "b": 2, "c": 3] func keyTransform(key: String) -&gt; Int { return Int(key.unicodeScalars.first!.value) } func valueTransform(value: Int) -&gt; String { return String(value) } dictionary.map { (key, value) in [keyTransform(key): valueTransform(value)] }.reduce([Int:String]()) { memo, element in var m = memo for (k, v) in element { m.updateValue(v, forKey: k) } return m } </code></pre>
<p><strong>Swift 3</strong></p> <p>Usage:</p> <pre><code>let bob = ["a": "AAA", "b": "BBB", "c": "CCC"] bob.mapDictionary { ($1, $0) } // ["BBB": "b", "CCC": "c", "AAA": "a"] </code></pre> <p>Extension:</p> <pre><code>extension Dictionary { func mapDictionary(transform: (Key, Value) -&gt; (Key, Value)?) -&gt; Dictionary&lt;Key, Value&gt; { var dict = [Key: Value]() for key in keys { guard let value = self[key], let keyValue = transform(key, value) else { continue } dict[keyValue.0] = keyValue.1 } return dict } } </code></pre>