Error using associated types and generics
<p>The following code gives me an error on line <code>return p.foo(self)</code>. The error says: <code>'P' does not have a member named 'foo'</code>.</p> <pre><code>protocol P { typealias T func foo(c: C&lt;T&gt;) -&gt; T func foo2() -&gt; T } class C&lt;T&gt; { var p: P init (p: P) { self.p = p } func bar() -&gt; T { return p.foo(self); } } </code></pre> <p>The protocol <code>P</code> defines an associated type which should match correctly with any specialized C type. Am I missing something? Or not?</p>
<p>From <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-XID_345" rel="nofollow">The Swift Programming Language</a>:</p> <blockquote> <p>Protocols do not actually implement any functionality themselves. Nonetheless, any protocol you create will become a fully-fledged type for use in your code.</p> </blockquote> <p>In order to use the <code>.foo</code> method, you need a <code>struct</code> or <code>class</code> that implements your <code>protocol</code>.</p>
<p>You never required that the two <code>T</code>s match. They are each in their own scope. Therefore the compiler looks for a <code>foo</code> function with the wrong parameter types.</p> <p>I believe something like this would be correct:</p> <pre><code>protocol P { typealias T func foo&lt;ConcreteP&gt;(c: C&lt;T, ConcreteP&gt;) -&gt; T func foo2() -&gt; T } class C&lt;T, ConcreteP: P where T == ConcreteP.T&gt; { var p: ConcreteP init (p: ConcreteP) { self.p = p } func bar() -&gt; T { return p.foo(self); } } </code></pre> <p>At least I don't get any syntax errors. However on compilation I get:</p> <pre><code>error: unimplemented IR generation feature non-fixed class layout var p: ConcreteP ^ LLVM ERROR: unimplemented IRGen feature! non-fixed class layout </code></pre> <p>That sounds like a compiler bug.</p>
<p>I'll rename the types a bit before answering the question to make the problem a bit clearer:</p> <pre><code>protocol P { typealias ElementType func foo(c: C&lt;ElementType&gt;) -&gt; ElementType func foo2() -&gt; ElementType } class C&lt;T&gt; { var p: P init (p: P) { self.p = p } func bar() -&gt; T { return p.foo(self) } } </code></pre> <p>In that case you get three compiler errors:</p> <pre><code>error: &lt;EXPR&gt;:8:12: error: protocol 'P' can only be used as a generic constraint because it has Self or associated type requirements var p: P ^ &lt;EXPR&gt;:9:14: error: protocol 'P' can only be used as a generic constraint because it has Self or associated type requirements init (p: P) { ^ &lt;EXPR&gt;:13:16: error: 'P' does not have a member named 'foo' return p.foo(self) ^ ~~~ </code></pre> <p>The interesting one is the first/second one (they point out the same problem): "protocol 'P' can only be used as a generic constraint because it has Self or <strong>associated type</strong> requirements". So the problem is the associated type. In the current configuration, you specify that the parameter for the initializer and the variable are of type P. But because you specified an associated type for P, that type is not specific enough to be used as a proper type. Only subtypes that actually specify what the <code>ElementType</code> is can be used. However, you can specific a generic parameter that has to be a subtype of P. In the case of the initializer you could write</p> <pre><code>init &lt;S:P&gt;(p: S) { self.p = p } </code></pre> <p>which would eliminate the compiler error for the initializer. Now the compiler knows the parameter has to be a subtype of P and a valid subtype always specifies what the ElementType is, so it is happy.</p> <p>But this doesn't help you with this line:</p> <pre><code>var p: P </code></pre> <p>You still can't use the incomplete type <code>P</code> here. You would probably want to use <code>S</code>, but at the moment there is no connection between the <code>S</code> in the initializer and an S you would use as the type for you variable but they obviously need to be the same. Time to introduce a second generic parameter to your class:</p> <pre><code>class C&lt;T, S:P&gt; { var p: S init (p: S) { self.p = p } func bar() -&gt; T { return p.foo(self) } } </code></pre> <p>Almost done, now you have a properly specified type to use for your variable. But no your protocol specification is incorrect:</p> <pre><code>func foo(c: C&lt;ElementType&gt;) -&gt; ElementType </code></pre> <p>C now takes two parameters and you need to specify these here. We would like to use `C here, but we can't:</p> <p>error: :3:17: error</p> <pre><code>: type 'P' does not conform to protocol 'P' func foo(c: C&lt;ElementType, P&gt;) -&gt; ElementType ^ &lt;EXPR&gt;:2:15: note: associated type 'ElementType' prevents protocol from conforming to itself typealias ElementType </code></pre> <p>Since <code>P</code> does not specify the associated type <code>ElementType</code> it does not properly conform to <code>P</code> and can't be used in a place where a type conforming to <code>P</code> is needed. But there is a nice special type: <code>Self</code>. That references the actual type of the implementing protocol, so we can write the following:</p> <pre><code>protocol P { typealias ElementType func foo(c: C&lt;ElementType, Self&gt;) -&gt; ElementType func foo2() -&gt; ElementType } </code></pre> <p>Now we specified that the foo-function that is implemented by any confirming type actually takes a C with the specified ElementType and the implementing type itself. Fancy, isn't it?</p> <p>But we aren't fully done yet, one last error remains:</p> <pre><code>error: &lt;EXPR&gt;:13:18: error: cannot convert the expression's type 'T' to type 'S.ElementType' return p.foo(self) </code></pre> <p>At this point the compiler knows the following:</p> <ul> <li>p.foo(self) returns something of the <code>ElementType</code> of <code>S</code></li> <li>The function bar() should return something of type <code>T</code></li> </ul> <p>But there is nothing to tell it, that <code>ElementType</code> and <code>T</code> are actually the same, so it can't be sure whether this works and complains. So what we actually want is that the <code>ElementType</code> of <code>S</code> is always the same as <code>T</code> and we can specify this:</p> <pre><code>class C&lt;T, S:P where S.ElementType == T&gt; { </code></pre> <p>Complete code:</p> <pre><code>protocol P { typealias ElementType func foo(c: C&lt;ElementType, Self&gt;) -&gt; ElementType func foo2() -&gt; ElementType } class C&lt;T, S:P where S.ElementType == T&gt; { var p: S init (p: S) { self.p = p } func bar() -&gt; T { return p.foo(self); } } </code></pre>