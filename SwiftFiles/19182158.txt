Sign a string with an RSA private key
<p>In my app i have to sign a message with an RSA private key i already have. After this done, i want to use the signature later. I've checked several libraries, but all of them do much more that i need. This is what i'd like to do:</p> <pre><code>NSString *message = @"This is a message"; NSString *privateKey = ...; NSString *signature = [self signMessage:message withPrivateKey:privateKey]; </code></pre> <p>How would</p> <pre><code>(NSString *)signMessage:(NSString *)message withPrivateKey:(NSString *)privateKey { } </code></pre> <p>look like?</p>
<p>iOS has a C API for doing this. I've never used it myself, but it looks like you need a PKCS12 formatted file with the private key in it which you import with <a href="https://developer.apple.com/library/ios/documentation/Security/Reference/certifkeytrustservices/Reference/reference.html#//apple_ref/doc/uid/TP30000157-CH1g-SW35" rel="nofollow">SecKeyPKCS12Imort</a> and get the private key out of. Then the function is <a href="https://developer.apple.com/library/ios/documentation/Security/Reference/certifkeytrustservices/Reference/reference.html#//apple_ref/doc/uid/TP30000157-CH1g-SW5" rel="nofollow">SecKeyRawSign</a> to sign your string.</p> <p>The string should first be converted to an NSData object using a known character encoding - probably UTF-8 and the bytes in the NSData signed.</p> <p>If you use non-ASCII characters in your string, as well as making sure you use a well defined encoding, you also need to be careful of how some characters are represented. For instance é can be represented as a single Unicode number or as the Unicode acute accent followed by the letter e.</p> <p><a href="http://en.wikipedia.org/wiki/Precomposed_character" rel="nofollow">http://en.wikipedia.org/wiki/Precomposed_character</a></p>
<p>I've tried millions of signing methods, that include Keychain, extracting SecKeyRef's, certificates (.p12), .pem key-files, but still didn't manage to achieve my main goal:</p> <ul> <li>Sign a string-digest using PKCS#1 v1.5 and SHA1</li> <li>Use string base64 key received from server (JSON) instead of using certificate-files.</li> </ul> <p>My private key is a PKCS#1 private key formatted like this:</p> <pre><code>-----BEGIN RSA PRIVATE KEY----- MIICXAIBAAKBgQCx9YWznzT3irAArr+INM5m0i6UCNICq4E8yrWwPbGh8/kdU/oh ..... ..... ..... ..... ..... ..... ..... ..... eF9lWooBNGgSh5vmkgECQGJwmDLKohSKEtVwGOIp3S3j+CHs0vVnznmtmC9sfrj4 ef48Sx1KFI8iQa3Nfv5bokaJkiIVVx/eMaa96Vracjc= -----END RSA PRIVATE KEY----- </code></pre> <p>Eventually I moved to OpenSSL and things got much brighter. So the whole process looks like the following:</p> <ol> <li>Download and build <a href="https://github.com/x2on/OpenSSL-for-iPhone" rel="nofollow">iOS OpenSSL library</a>.</li> <li>Add the lib to the project.</li> <li>Use OpenSSL to finally sign the message.</li> </ol> <hr> <h2>Step 1: OpenSSL library</h2> <p>Download the library from <a href="https://github.com/x2on/OpenSSL-for-iPhone" rel="nofollow">https://github.com/x2on/OpenSSL-for-iPhone</a></p> <p>Copy build-libssl.sh to your project folder Using Terminal run the following:</p> <pre><code>cd [your project folder] /build-libssl.sh </code></pre> <h2>Step 2: adding OpenSSL</h2> <p>Copy the “include” folder from OpenSSL into your project-folder</p> <p>Drag-copy the libcrypto*.a and libss*.a files into your XCode Folder</p> <p>Open the Build Settings of your “Target”</p> <p>Change <code>Library Search Paths</code> to <code>$(inherited) “$(SRCROOT)”</code></p> <p>Change <code>User Header Search Paths</code> to <code>include</code></p> <p>Activate <code>Always Search User Paths</code></p> <h2>Step 3: Signing</h2> <pre><code>#include &lt;openssl/pem.h&gt; #include &lt;openssl/engine.h&gt; #include &lt;iomanip&gt; - (NSString*) signHeader:(NSString*) pTextString withPrivateKey: (NSString*) pPrivateKey { int retEr; char* text = (char*) [pTextString UTF8String]; unsigned char *data; unsigned int dataLen; // converting nsstring base64 private key to openssl RSA key BIO *mem = NULL; RSA *rsa_private = NULL; char *private_key = (char*)[pPrivateKey UTF8String]; mem = BIO_new_mem_buf(private_key, strlen(private_key)); if (mem == NULL) { char buffer[120]; ERR_error_string(ERR_get_error(), buffer); fprintf(stderr, "OpenSSL error: %s", buffer); exit(0); } rsa_private = PEM_read_bio_RSAPrivateKey(mem, NULL, NULL, NULL); BIO_free (mem); if (rsa_private == NULL) { char buffer[120]; ERR_error_string(ERR_get_error(), buffer); fprintf(stderr, "OpenSSL error: %s", buffer); exit(0); } // end of convertion data = (unsigned char *) text; dataLen = strlen(text); //// creating signature // sha1 unsigned char hash[SHA_DIGEST_LENGTH]; unsigned char sign[128]; unsigned int signLen; SHA1(data, dataLen, hash); // signing retEr = RSA_sign(NID_sha1, hash, SHA_DIGEST_LENGTH, sign, &amp;signLen, rsa_private); // printf("Signature len gth = %d\n", signLen); printf("RSA_sign: %s\n", (retEr == 1) ? "RSA_sign success" : "RSA_sign error"); // convert unsigned char -&gt; std:string std::stringstream buffer; for (int i = 0; i &lt; 128; i++) { buffer &lt;&lt; std::hex &lt;&lt; std::setfill('0'); buffer &lt;&lt; std::setw(2) &lt;&lt; static_cast&lt;unsigned&gt;(sign[i]); } std::string signature = buffer.str(); // convert std:string -&gt; nsstring NSString *signedMessage = [NSString stringWithCString:signature.c_str() encoding:[NSString defaultCStringEncoding]]; RSA_free(rsa_private); return signedMessage; } </code></pre> <p>If you want to use SHA256 or any other SHA you must change the following:</p> <pre><code>SHA_DIGEST_LENGTH =&gt; SHA256_DIGEST_LENGTH sign[128] =&gt; sign[256] SHA1(data, dataLen, hash) =&gt; SHA256(data, dataLen, hash) NID_sha1 =&gt; NID_sha256 </code></pre> <h2>Alternative Step 3: Signing (Swift)</h2> <p>Since Swift language isn't a superset of C++ it can't be combined with C++ directly, therefore you need to create a Objective-C wrapper of C++ code and then call it (Obj-C) from your Swift code.</p> <h3>Step 3.1</h3> <p>Create an Obj-C class for your C++ code. <strong>IMPORTANT:</strong> the file must be either with .mm extension or set type to <code>Objective-C++ Source</code> </p> <p><strong>OpenSSLWrapper.h</strong></p> <pre><code>#import &lt;Foundation/Foundation.h&gt; @interface OpenSSLWrapper : NSObject + (NSString*) signHeader:(NSString*) pTextString withPrivateKey: (NSString*) pPrivateKey; @end </code></pre> <p><strong>OpenSSLWrapper.mm</strong></p> <pre><code>#import "OpenSSLWrapper.h" #include &lt;openssl/pem.h&gt; #include &lt;openssl/engine.h&gt; #include &lt;iomanip&gt; @implementation OpenSSLWrapper + (NSString*) signHeader:(NSString*) pTextString withPrivateKey: (NSString*) pPrivateKey { int retEr; char* text = (char*) [pTextString UTF8String]; unsigned char *data; unsigned int dataLen; // converting nsstring base64 private key to openssl RSA key BIO *mem = NULL; RSA *rsa_private = NULL; char *private_key = (char*)[pPrivateKey UTF8String]; mem = BIO_new_mem_buf(private_key, strlen(private_key)); if (mem == NULL) { char buffer[120]; ERR_error_string(ERR_get_error(), buffer); fprintf(stderr, "OpenSSL error: %s", buffer); exit(0); } rsa_private = PEM_read_bio_RSAPrivateKey(mem, NULL, NULL, NULL); BIO_free (mem); if (rsa_private == NULL) { char buffer[120]; ERR_error_string(ERR_get_error(), buffer); fprintf(stderr, "OpenSSL error: %s", buffer); exit(0); } // end of convertion data = (unsigned char *) text; dataLen = strlen(text); //// creating signature // sha1 unsigned char hash[SHA_DIGEST_LENGTH]; unsigned char sign[128]; unsigned int signLen; SHA1(data, dataLen, hash); // signing retEr = RSA_sign(NID_sha1, hash, SHA_DIGEST_LENGTH, sign, &amp;signLen, rsa_private); // printf("Signature len gth = %d\n", signLen); printf("RSA_sign: %s\n", (retEr == 1) ? "RSA_sign success" : "RSA_sign error"); // convert unsigned char -&gt; std:string std::stringstream buffer; for (int i = 0; i &lt; 128; i++) { buffer &lt;&lt; std::hex &lt;&lt; std::setfill('0'); buffer &lt;&lt; std::setw(2) &lt;&lt; static_cast&lt;unsigned&gt;(sign[i]); } std::string signature = buffer.str(); // convert std:string -&gt; nsstring NSString *signedMessage = [NSString stringWithCString:signature.c_str() encoding:[NSString defaultCStringEncoding]]; RSA_free(rsa_private); return signedMessage; } @end </code></pre> <h3>Step 3.2</h3> <p>Create a Bridging-Header file.</p> <p><strong>YourProject-Bridging-Header.h</strong></p> <pre><code>#import "OpenSSLWrapper.h" </code></pre> <h3>Step 3.3</h3> <p>Use the method from Obj-C in your Swift file.</p> <p><strong>DigestSignature.swift</strong></p> <pre><code>import Cocoa class DigestSignature: NSObject { let privateKey = "-----BEGIN RSA PRIVATE KEY-----MIICXAIBAAKBgQCx9YWznzT3irAArr+INM5m0i6UCNICq4E8yrWwPbGh8/kdU/oh ..... ..... eF9lWooBNGgSh5vmkgECQGJwmDLKohSKEtVwGOIp3S3j+CHs0vVnznmtmC9sfrj4ef48Sx1KFI8iQa3Nfv5bokaJkiIVVx/eMaa96Vracjc=-----END RSA PRIVATE KEY-----" var digest: String = OpenSSLWrapper.signHeader("Hello World", withPrivateKey: privateKey) ; } </code></pre> <h3>In the result, you have a hex NSString* signed digest.</h3> <p>Hope that helps</p>