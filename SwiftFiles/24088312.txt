Does Swift not work with function pointers?
<p>I'm trying to use a C library in Swift, and I'm having trouble calling any function that takes a function pointer as one of it's arguments. For example, part of the lua.h file that I'm trying to use in Swift looks like this:</p> <pre><code>LUA_API void (lua_setuservalue) (lua_State *L, int idx); typedef int (*lua_CFunction) (lua_State *L); LUA_API void (lua_callk) (lua_State *L, int nargs, int nresults, int ctx, lua_CFunction k); </code></pre> <p>I use the bridging header to get access to the library, and from my Swift code I can call <strong>lua_setuservalue</strong> without any trouble. But if I try to call <strong>lua_callk</strong> I get "use of unresolved identifier 'lua_callk'". If I remove the function pointer from the declaration for <strong>lua_callk</strong>, I no longer get this error. Any help is quite appreciated.</p>
<p>In the Apple <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-XID_13" rel="nofollow">documentation</a> it is noted that <code>C function pointers are not imported in Swift</code>.</p>
<p><strong>This answer refers to an earlier version of the Swift language and may no longer be reliable.</strong></p> <p>While C function pointers are <em>not</em> available in Swift, you can still use swift closures which are passed to C functions as blocks.</p> <p>Doing so requires a few "shim" routines in C to take the block and wrap it in a C function. The following demonstrates how it works.</p> <p>Swift:</p> <pre><code>func foo(myInt: CInt) -&gt; CInt { return myInt } var closure: (CInt) -&gt; CInt = foo; my_c_function(closure) </code></pre> <p>C:</p> <pre><code>void my_c_function(int (^closure)(int)) { int x = closure(10); printf("x is %d\n", x); } </code></pre> <p>Of course what you choose to do with the closure, and how you store and recall it for use is up to you. But this should give you a start.</p>
<p>Apple has made function pointers available as of beta 3, however they can only be referenced not called.</p> <p><a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-XID_16">Using Swift with Cocoa and Objective-C</a></p> <blockquote> <h3>Function Pointers</h3> <p>C function pointers are imported into Swift as <code>CFunctionPointer&lt;Type&gt;</code>, where <code>Type</code> is a Swift function type. For example, a function pointer that has the type <code>int (*)(void)</code> in C is imported into Swift as <code>CFunctionPointer&lt;() -&gt; Int32&gt;</code></p> </blockquote> <p><a href="http://adcdownload.apple.com//Developer_Tools/xcode_6_beta_3_lpw27r/xcode_6_beta_3_release_notes__.pdf">Beta 3 Release Notes</a> (PDF)</p> <blockquote> <p>Function pointers are also imported now, and can be referenced and passed around. However, you cannot call a C function pointer or convert a closure to C function pointer type.</p> </blockquote>