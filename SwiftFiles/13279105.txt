Access Container View Controller from Parent iOS
<p>in iOS6 I noticed the new Container View but am not quite sure how to access it's controller from the containing view.</p> <p>Scenario:</p> <p><img src="https://i.stack.imgur.com/aNOLJ.png" alt="example"></p> <p>I want to access the labels in Alert view controller from the view controller that houses the container view.</p> <p>There's a segue between them, can I use that?</p>
<p>Yes, you can use the segue to get access the child view controller (and its view and subviews). Give the segue an identifier (such as <code>alertview_embed</code>), using the Attributes inspector in Storyboard. Then have the parent view controller (the one housing the container view) implement a method like this:</p> <pre><code>- (void) prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender { NSString * segueName = segue.identifier; if ([segueName isEqualToString: @"alertview_embed"]) { AlertViewController * childViewController = (AlertViewController *) [segue destinationViewController]; AlertView * alertView = childViewController.view; // do something with the AlertView's subviews here... } } </code></pre>
<p>You can do that simply with <code>self.childViewControllers.lastObject</code> (assuming you only have one child, otherwise use <code>objectAtIndex:</code>). </p>
<p><code>self.childViewControllers</code> is more relevant when you need control from the parent. For instance, if the child controller is a table view and you want to reload it forcefully or change a property via a button tap or any other event on Parent View Controller, you can do it by accessing ChildViewController's instance and not via prepareForSegue. Both have their applications in different ways.</p>
<p>for Swift Programming</p> <p>you can write like this</p> <pre><code>var containerViewController: ExampleViewController? override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) { // you can set this name in 'segue.embed' in storyboard if segue.identifier == "checkinPopupIdentifierInStoryBoard" { let connectContainerViewController = segue.destinationViewController as ExampleViewController containerViewController = connectContainerViewController } } </code></pre>
<p>The <code>prepareForSegue</code> approach works, but it relies on the segue identifier magic string. Maybe there's a better way.</p> <p>If you know the class of the VC you're after, you can do this very neatly with a computed property:</p> <pre><code>var camperVan: CamperVanViewController? { return childViewControllers.flatMap({ $0 as? CamperVanViewController }).first // This works because `flatMap` removes nils } </code></pre> <p>This relies on <code>childViewControllers</code>. While I agree it could be fragile to rely on the first one, naming the class you seek makes this seem quite solid.</p>
<p>I use Code like:</p> <pre><code>- (IBAction)showCartItems:(id)sender{ ListOfCartItemsViewController *listOfItemsVC=[self.storyboard instantiateViewControllerWithIdentifier:@"ListOfCartItemsViewController"]; [self addChildViewController:listOfItemsVC]; } </code></pre>
<p>you can write like this</p> <pre><code>- (IBAction)showDetail:(UIButton *)sender { DetailViewController *detailVc = [self.childViewControllers firstObject]; detailVc.lable.text = sender.titleLabel.text; } } </code></pre>
<p>An updated answer for Swift 3, using a computed property:</p> <pre><code>var jobSummaryViewController: JobSummaryViewController { get { let ctrl = childViewControllers.first(where: { $0 is JobSummaryViewController }) return ctrl as! JobSummaryViewController } } </code></pre> <p>This only iterates the list of children until it reaches the first match.</p>
<p>In case someone is looking for <strong>Swift 3.0</strong>,</p> <p><strong>viewController1</strong>, <strong>viewController2</strong> and so on will then be accessible.</p> <pre><code>let viewController1 : OneViewController! let viewController2 : TwoViewController! // Safety handling of optional String if let identifier: String = segue.identifier { switch identifier { case "segueName1": viewController1 = segue.destination as! OneViewController break case "segueName2": viewController2 = segue.destination as! TwoViewController break // ... More cases can be inserted here ... default: // A new segue is added in the storyboard but not yet including in this switch print("A case missing for segue identifier: \(identifier)") break } } else { // Either the segue or the identifier is inaccessible print("WARNING: identifier in segue is not accessible") } </code></pre>