Using operator functions outside the context of an argument in Swift
<p>So, when declaring a closure, we can get pretty abstract. For example, we could do a sort with an inline closure like:</p> <pre><code>var arr = sort(["a", "b", "c"], { $0 &gt; $1 }) // Shows ["c", "b", "a"] arr </code></pre> <p>Which could then be simplified to an operator function like this:</p> <pre><code>var arr = sort(["a", "b", "c"], &gt;) // Shows ["c", "b", "a"] arr </code></pre> <p>Because:</p> <blockquote> <p>Swift’s String type defines its string-specific implementation of the greater-than operator (>) as a function that has two parameters of type String, and returns a value of type Bool. This exactly matches the function type needed for the sort function’s second parameter. Therefore, you can simply pass in the greater-than operator, and Swift will infer that you want to use its string-specific implementation</p> </blockquote> <p>However, I can't seem to find a way to do this outside of the context of that argument. When it's being passed as an argument, '>' is almost like the name of a function that is associated with 'String'. In that way, I would think it should be possible to assign outside the context of the argument. For example, is there some way I could do this:</p> <pre><code>var inlineClosure: (String, String) -&gt; Bool = { &gt; } // or var inlineClosure: (String, String) -&gt; Bool = &gt; </code></pre> <p>This is purely experimental, I am just curious if it is possible.</p> <h3> Note </h3> <p>This question isn't about how to assign an inline closure in any way other than as an operator. I'm already familiar with various declaration types, including shorthand arguments &amp; trailing closures. I'm specifically looking for a way to do this by only assigning an operator. </p>
<p>This seems to be a bug with Xcode. You can get it to work though. Type out the whole line like you did:</p> <pre><code>var inlineClosure: (String, String) -&gt; Bool = { &gt; } </code></pre> <p>Then delete and retype the operator. For some reason that allows the parser to understand what you're trying to do.</p>
<p>Like this?</p> <pre><code>var inlineClosure: (String, String) -&gt; Bool = { $0 &gt; $1 } </code></pre>
<p>Assign <code>inlineClosure</code> with an actual closure with:</p> <pre><code> 7&gt; var inlineClosure = { (a:String, b:String) -&gt; Bool in return a &gt; b } inlineClosure: (String, String) -&gt; Bool = 8&gt; inlineClosure ("a", "b") $R3: Bool = false 9&gt; inlineClosure ("c", "b") $R4: Bool = true </code></pre> <p>BTW, there is special syntax for a method that has a closure as the last argument:</p> <pre><code>var answer = sort ([1,3,2]) { (a:Int, b:Int) -&gt; Bool in return a &lt; b } </code></pre> <p>Convenient that.</p>
<p>You can do this:</p> <pre><code>let f : (String, String) -&gt; Bool = (&gt;) </code></pre>