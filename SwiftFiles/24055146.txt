How to find NSDocumentDirectory in swift?
<p>I'm trying to get path to Documents folder with code:</p> <pre><code>var documetsPath = NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory:0,NSSearchPathDomainMask:0,true) </code></pre> <p>but xcode gives error: Cannot convert expression's type 'AnyObject[]!' to type 'NSSearchPathDirectory'</p> <p>I'm trying to understand what is wrong in code?</p>
<p>Apparently, the compiler thinks <code>NSSearchPathDirectory:0</code> is an array, and of course it expects the type <code>NSSearchPathDirectory</code> instead. Certainly not a helpful error message.</p> <p>But as to the reasons:</p> <p>First, you are confusing the argument names and types. Take a look at the function definition:</p> <pre><code>func NSSearchPathForDirectoriesInDomains( directory: NSSearchPathDirectory, domainMask: NSSearchPathDomainMask, expandTilde: Bool) -&gt; AnyObject[]! </code></pre> <ul> <li><code>directory</code> and <code>domainMask</code> are the names, you are using the types, but you should leave them out for functions anyway. They are used primarily in methods.</li> <li>Also, Swift is strongly typed, so you shouldn't just use 0. Use the enum's value instead.</li> <li>And finally, it returns an array, not just a single path.</li> </ul> <p>So that leaves us with (updated for Swift 2.0):</p> <pre><code>let documentsPath = NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true)[0] </code></pre> <p>and for Swift 3:</p> <pre><code>let documentsPath = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true)[0] </code></pre>
<p>The modern recommendation is to use NSURLs for files and directories instead of NSString based paths:</p> <p><img src="https://i.stack.imgur.com/ymPwO.png" alt="enter image description here"></p> <p>So to get the Document directory for the app as an NSURL:</p> <pre><code>func databaseURL() -&gt; NSURL? { let fileManager = NSFileManager.defaultManager() let urls = fileManager.URLsForDirectory(.DocumentDirectory, inDomains: .UserDomainMask) if let documentDirectory: NSURL = urls.first as? NSURL { // This is where the database should be in the documents directory let finalDatabaseURL = documentDirectory.URLByAppendingPathComponent("items.db") if finalDatabaseURL.checkResourceIsReachableAndReturnError(nil) { // The file already exists, so just return the URL return finalDatabaseURL } else { // Copy the initial file from the application bundle to the documents directory if let bundleURL = NSBundle.mainBundle().URLForResource("items", withExtension: "db") { let success = fileManager.copyItemAtURL(bundleURL, toURL: finalDatabaseURL, error: nil) if success { return finalDatabaseURL } else { println("Couldn't copy file to final location!") } } else { println("Couldn't find initial database in the bundle!") } } } else { println("Couldn't get documents directory!") } return nil } </code></pre> <p>This has rudimentary error handling, as that sort of depends on what your application will do in such cases. But this uses file URLs and a more modern api to return the database URL, copying the initial version out of the bundle if it does not already exist, or a nil in case of error.</p>
<p>For everyone who looks example that works with Swift 2.2, Abizern code with modern do try catch handle of error </p> <pre><code>func databaseURL() -&gt; NSURL? { let fileManager = NSFileManager.defaultManager() let urls = fileManager.URLsForDirectory(.DocumentDirectory, inDomains: .UserDomainMask) if let documentDirectory:NSURL = urls.first { // No use of as? NSURL because let urls returns array of NSURL // This is where the database should be in the documents directory let finalDatabaseURL = documentDirectory.URLByAppendingPathComponent("OurFile.plist") if finalDatabaseURL.checkResourceIsReachableAndReturnError(nil) { // The file already exists, so just return the URL return finalDatabaseURL } else { // Copy the initial file from the application bundle to the documents directory if let bundleURL = NSBundle.mainBundle().URLForResource("OurFile", withExtension: "plist") { do { try fileManager.copyItemAtURL(bundleURL, toURL: finalDatabaseURL) } catch let error as NSError {// Handle the error print("Couldn't copy file to final location! Error:\(error.localisedDescription)") } } else { print("Couldn't find initial database in the bundle!") } } } else { print("Couldn't get documents directory!") } return nil } </code></pre> <p><strong>Update</strong> I've missed that new swift 2.0 have guard(Ruby unless analog), so with guard it is much shorter and more readable </p> <pre><code>func databaseURL() -&gt; NSURL? { let fileManager = NSFileManager.defaultManager() let urls = fileManager.URLsForDirectory(.DocumentDirectory, inDomains: .UserDomainMask) // If array of path is empty the document folder not found guard urls.count != 0 else { return nil } let finalDatabaseURL = urls.first!.URLByAppendingPathComponent("OurFile.plist") // Check if file reachable, and if reacheble just return path guard finalDatabaseURL.checkResourceIsReachableAndReturnError(nil) else { // Check if file is exists in bundle folder if let bundleURL = NSBundle.mainBundle().URLForResource("OurFile", withExtension: "plist") { // if exist we will copy it do { try fileManager.copyItemAtURL(bundleURL, toURL: finalDatabaseURL) } catch let error as NSError { // Handle the error print("File copy failed! Error:\(error.localizedDescription)") } } else { print("Our file not exist in bundle folder") return nil } return finalDatabaseURL } return finalDatabaseURL } </code></pre>
<p><strong>Xcode 7.1.1 â€¢ Swift 2.1</strong></p> <pre><code>let documentDirectoryURL = try! NSFileManager().URLForDirectory(.DocumentDirectory, inDomain: .UserDomainMask, appropriateForURL: nil, create: true) </code></pre>
<p>Usually I prefeer to use this extension:</p> <pre><code>extension NSFileManager { class func documentsDir() -&gt; String { var paths = NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true) as [String] return paths[0] } class func cachesDir() -&gt; String { var paths = NSSearchPathForDirectoriesInDomains(.CachesDirectory, .UserDomainMask, true) as [String] return paths[0] } } </code></pre>
<p><strong>Xcode 8b4 Swift 3.0</strong></p> <pre><code>let paths = NSSearchPathForDirectoriesInDomains(FileManager.SearchPathDirectory.documentDirectory, FileManager.SearchPathDomainMask.userDomainMask, true) </code></pre>
<p>More convenient <strong>Swift 3</strong> method:</p> <pre><code>let documentsUrl = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first! </code></pre>