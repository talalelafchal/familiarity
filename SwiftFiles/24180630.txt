Why does the Swift language guide suggest using Int &quot;even when values are known to be non-negative&quot;?
<p>This is a question about programming style in Swift, specifically <code>Int</code> vs <code>UInt</code>.</p> <p>The Swift Programming Language Guide advises programmers to use the generic signed integer type <code>Int</code> even when variables are known to be non-negative. From <a href="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-XID_411">the guide</a>:</p> <blockquote> <p>Use UInt only when you specifically need an unsigned integer type with the same size as the platformâ€™s native word size. If this is not the case, Int is preferred, even when the values to be stored are known to be non-negative. A consistent use of Int for integer values aids code interoperability, avoids the need to convert between different number types, and matches integer type inference, as described in Type Safety and Type Inference.</p> </blockquote> <p>However, <code>UInt</code> will be 32-bit unsigned on 32-bit architectures and 64-bit unsigned on 64-bit architectures so there is no performance benefit to using <code>Int</code> over <code>UInt</code>.</p> <p>By contrast, the Swift guide gives a later example:</p> <blockquote> <p>let age = -3<br> assert(age >= 0, "A person's age cannot be less than zero")<br> // this causes the assertion to trigger, because age is not >= 0 </p> </blockquote> <p>Here, a <em>runtime</em> issue could be caught at <em>compile</em> time if the code had been written as:</p> <pre><code>let age:UInt = -3 // this causes a compiler error because -3 is negative </code></pre> <p>There are many other cases (for example anything that will index a collection) where using a <code>UInt</code> would catch issues at compile time rather than runtime.</p> <p>So the question: is the advice in the Swift Programming Language guide sound, and do the benefits of using <code>Int</code> "even when the values to be stored are known to be non-negative" outweigh the safety advantages of using <code>UInt</code>?</p> <p><strong>Additional note:</strong> Having used Swift for a couple of weeks now its clear that for interoperability with <em>Cocoa</em> <code>UInt</code> is required. For example the <code>AVFoundation</code> framework uses unsigned integers anywhere a "count" is required (number of samples / frames / channels etc). Converting these values to <code>Int</code> could lead to serious bugs where values are greater than <code>Int.max</code></p>
<p>It says in your question.. "A consistent use of Int for integer values aids code interoperability, avoids the need to convert between different number types, and matches integer type inference, as described in Type Safety and Type Inference."</p> <p>This avoids issues such as assigning an Int to an UInt. Negative Int values assigned to UInts result in large values instead of the intended negative value. The binary representation of both doesn't differentiate one type from the other. </p> <p>Also, both are classes, one not descended from the other. Classes built receive Ints cannot receive UInts without overloading, meaning converting between the two would be a common task of UInts are being used when most of the framework receives Ints. Converting between the two can become a non-trival task as well. </p> <p>The two previous paragraphs speak to "interoperability" and "converting between different number types". Issues that are avoided if UInts aren't used.</p>
<p>I don't think using UInt is as safe as you think it is. As you noted:</p> <pre><code>let age:UInt = -3 </code></pre> <p>results in a compiler error. I also tried:</p> <pre><code>let myAge:Int = 1 let age:UInt = UInt(myAge) - 3 </code></pre> <p>which also resulted in a compiler error. However the following (in my opinion much more common in real programs) scenarios had no compiler error, but actually resulted in runtime errors of <code>EXC_BAD_INSTRUCTION</code>:</p> <pre><code>func sub10(num: Int) -&gt; UInt { return UInt(num - 10) //Runtime error when num &lt; 10 } sub10(4) </code></pre> <p>as well as:</p> <pre><code>class A { var aboveZero:UInt init() { aboveZero = 1 } } let a = A() a.aboveZero = a.aboveZero - 10 //Runtime error </code></pre> <p>Had these been plain <code>Int</code>s, instead of crashing, you could add code to check your conditions:</p> <pre><code>if a.aboveZero &gt; 0 { //Do your thing } else { //Handle bad data } </code></pre> <p>I might even go so far as to equate their advice against using <code>UInt</code>s to their advice against using implicitly unwrapped optionals: Don't do it unless you are certain you won't get any negatives, because otherwise you'll get runtime errors (except in the simplest of cases).</p>