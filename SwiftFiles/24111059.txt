Translate just 4 lines of code from objective c to swift (Pointers)
<p>I have been stuck since two days translating a piece of code from Objective-C to Swift:</p> <pre><code>CFArrayRef keyref = NULL; CFDictionaryRef identityDict = CFArrayGetValueAtIndex(keyref, 0); SecIdentityRef identityRef = (SecIdentityRef)CFDictionaryGetValue(identityDict, kSecImportItemIdentity); </code></pre> <p>Yes, that's all! I simply can't satisfy the compiler with those pointers. Please help :-)</p> <p>This is the whole objective c code to translate:</p> <pre><code>// Read .p12 file NSString *path = [[NSBundle mainBundle] pathForResource:@"SSLKeyStoreClient" ofType:@"p12"]; NSData *pkcs12data = [[NSData alloc] initWithContentsOfFile:path]; // Import .p12 data CFArrayRef keyref = NULL; OSStatus sanityChesk = SecPKCS12Import((__bridge CFDataRef)pkcs12data, (__bridge CFDictionaryRef)[NSDictionary dictionaryWithObject:@"wed-zzz" forKey:(__bridge id)kSecImportExportPassphrase], &amp;keyref); if (sanityChesk != noErr) { NSLog(@"Error while importing pkcs12 [%d]", (int)sanityChesk); } else NSLog(@"Success opening p12 certificate."); // Identity CFDictionaryRef identityDict = CFArrayGetValueAtIndex(keyref, 0); SecIdentityRef identityRef = (SecIdentityRef)CFDictionaryGetValue(identityDict, kSecImportItemIdentity); // Cert SecCertificateRef cert = NULL; OSStatus status = SecIdentityCopyCertificate(identityRef, &amp;cert); if (status) NSLog(@"SecIdentityCopyCertificate failed."); // the certificates array, containing the identity then the root certificate NSArray *myCerts = [[NSArray alloc] initWithObjects:(__bridge id)identityRef, (__bridge id)cert, nil]; NSMutableDictionary *SSLOptions; [SSLOptions setObject:[NSNumber numberWithBool:YES] forKey:(NSString *)kCFStreamSSLAllowsExpiredRoots]; NSDictionary *settings = [[NSDictionary alloc] initWithObjectsAndKeys: [NSNumber numberWithBool:YES], kCFStreamSSLAllowsExpiredCertificates, [NSNumber numberWithBool:YES], kCFStreamSSLAllowsAnyRoot, [NSNumber numberWithBool:NO], kCFStreamSSLValidatesCertificateChain, kCFNull,kCFStreamSSLPeerName, myCerts,kCFStreamSSLCertificates, nil]; CFReadStreamSetProperty((CFReadStreamRef)self.inputStream, kCFStreamPropertySSLSettings, (CFTypeRef)settings); CFWriteStreamSetProperty((CFWriteStreamRef)self.outputStream, kCFStreamPropertySSLSettings, (CFTypeRef)settings); </code></pre> <p>And this is what i got so far:</p> <pre><code>// Read .p12 file var path = NSBundle.mainBundle().pathForResource("SSLKeyStoreClient", ofType: "p12") var pkcs12data: NSData = NSData.dataWithContentsOfFile(path, options: nil, error: nil) // Import .p12 data var keyref: Unmanaged&lt;CFArray&gt;? var optionDict: NSMutableDictionary = NSMutableDictionary() optionDict.setValue("wed-zzz", forKey: kSecImportExportPassphrase!.takeRetainedValue()) var sanityChesk = SecPKCS12Import(pkcs12data,optionDict,&amp;keyref) if sanityChesk != 0{ //noErr println("Error while importing pkcs12 \(sanityChesk)") } else { println("Success opening p12 certificate.") } // Identity var key = keyref! var identityDict: CFDictionary = CFArrayGetValueAtIndex(keyref, 0) var identityRef:COpaquePointer = CFDictionaryGetValue(identityDict,nil) // Cert var cert: Unmanaged&lt;SecCertificate&gt;? var status: OSStatus = SecIdentityCopyCertificate(identityRef, &amp;cert) if status == 0{ println("SecIdentityCopyCertificate failed.") } // the certificates array, containing the identity then the root certificate var sslOptions = Dictionary&lt;NSObject, NSObject&gt;() sslOptions[kCFStreamSSLAllowsExpiredRoots] = NSNumber.numberWithBool(true) var settings = Dictionary&lt;NSObject, NSObject&gt;() settings[kCFStreamSSLAllowsExpiredCertificates] = NSNumber.numberWithBool(true) settings[kCFStreamSSLAllowsAnyRoot] = NSNumber.numberWithBool(true) settings[kCFStreamSSLValidatesCertificateChain] = NSNumber.numberWithBool(false) settings[kCFStreamSSLPeerName] = kCFNull //settings[kCFStreamSSLCertificates] = myCerts CFReadStreamSetProperty(self.inputStream, kCFStreamPropertySSLSettings, settings) CFReadStreamSetProperty(self.inputStream, kCFStreamPropertySSLSettings, settings) </code></pre> <p>The Problem starts at:</p> <pre><code>var identityDict: CFDictionary = CFArrayGetValueAtIndex(keyref, 0) </code></pre> <p>Error: "unmanaged CFArray not convertible to CFArray".</p> <p>This is my best try so far.</p>
<p>Presumably the first line is a placeholder for an actual array? If you're actually working with a <code>NULL</code> array pointer, the rest of your code does nothing.</p> <p>Assuming you're starting from a real <code>CFArrayRef</code>, you can take advantage of bridging: CoreFoundation types are automatically treated like Swift objects, so you don't need to work with <code>CFArrayRef</code> and <code>CFDictionaryRef</code> pointers. The same goes for any other C API that uses the CF type system, so it should also apply to <code>SecIdentity</code>.</p> <p>There seems to be some weirdness with automatic bridging of CF collections â€” you can implicitly bridge a <code>CFArray</code> to an <code>NSArray</code> and an <code>NSArray</code> to a Swift <code>Array&lt;T&gt;</code>, you can't just subscript a <code>CFArray</code>.</p> <p>So your conversion looks something like this (wrapped in a function that handles your assumed array):</p> <pre><code>func getIdentity(keychainArray: NSArray) -&gt; SecIdentity? { let dict = keychainArray[0] as Dictionary&lt;String,AnyObject&gt; let key = kSecImportItemIdentity.takeRetainedValue() return dict[key] as SecIdentity? } </code></pre> <p>If you have a <code>CFArray</code> you can pass it to this function and it'll automatically bridge/cast to <code>NSArray</code>, which then automatically casts to a Swift array for subscripting. Treat item 0 as a Swift dictionary, and you can subscript the dictionary to get the identity out. For the key, you'll need to pull it out of an <code>Unmanaged&lt;CFString&gt;</code> because the Security framework isn't set up for implicit bridging of that constant's declaration.</p> <p>I've left this function returning an optional, since I don't know wether the array+dictionary you're passing in actually contains an identity. If you're sure it does, you could take out the two question marks.</p> <p>(This compiles in playground, but I don't have an array containing a dictionary containing an identity handy for testing with, so <em>caveat emptor</em>.)</p>