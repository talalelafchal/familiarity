Use a function to find common elements in two sequences in Swift
<p>I'm trying to complete the exercise on page 46 of Apple's new book "The Swift Programming Language". It gives the following code:</p> <pre><code>func anyCommonElements &lt;T, U where T: Sequence, U: Sequence, T.GeneratorType.Element: Equatable, T.GeneratorType.Element == U.GeneratorType.Element&gt; (lhs: T, rhs: U) -&gt; Bool { for lhsItem in lhs { for rhsItem in rhs { if lhsItem == rhsItem { return true } } } return false } anyCommonElements([1, 2, 3], [3]) </code></pre> <p>The exercise is to change the function so that all elements that both sequences have are returned. To do this I tried to use the following code:</p> <pre><code>func anyCommonElements &lt;T, U where T: Sequence, U: Sequence, T.GeneratorType.Element: Equatable, T.GeneratorType.Element == U.GeneratorType.Element&gt; (lhs: T, rhs: U) -&gt; T.GeneratorType[] { var toReturn = T.GeneratorType[]() for lhsItem in lhs { for rhsItem in rhs { if lhsItem == rhsItem { toReturn.append(lhsItem) } } } return toReturn } anyCommonElements([1, 2, 3], [3]) </code></pre> <p>But on line 2, I get the error: Could not find the member 'subscript'</p> <p>What is the reason for this error and what is the best solution to this problem?</p>
<p>I was able to get it to work by making the return value an Array of T.GeneratorType.Element.</p> <pre><code>func anyCommonElements &lt;T, U where T: SequenceType, U: SequenceType, T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element&gt; (lhs: T, rhs: U) -&gt; Array&lt;T.Generator.Element&gt; { var toReturn = Array&lt;T.Generator.Element&gt;() for lhsItem in lhs { for rhsItem in rhs { if lhsItem == rhsItem { toReturn.append(lhsItem) } } } return toReturn } anyCommonElements([1, 2, 3], [3]) </code></pre>
<p>I had compiler errors with the above two solutions, I am running the guide from the iBook in the Xcode 6.01 playground. I had consistent compiler complaints about array declarations I found here so I am assuming the posters may be using an earlier version of swift. If I'm wrong, it would be great to know.</p> <p>For array declarations, I have found that </p> <pre><code> var thingList : [ThingType] = [] </code></pre> <p>has worked consistently, so I tended to go with that, forsaking </p> <pre><code> var thing[],thing[]() // gave compiler errors/warnings </code></pre> <p>My environment never was able to resolve a thing called <em>T.GeneratorType[.Element]</em></p> <p>The solution I came up for this experiment is </p> <hr> <pre><code>func anyCommonElements &lt;T, U where T: SequenceType, U: SequenceType, T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element&gt; (lhs: T, rhs: U) -&gt; [T.Generator.Element] { var returnValue: [T.Generator.Element] = [] for lhsItem in lhs { for rhsItem in rhs { if lhsItem == rhsItem { returnValue.append(lhsItem) } } } return returnValue } let commonNumberList = anyCommonElements([1, 2, 3,4,5,6,7,8], [2,3,9,14,8,21]) println("common Numbers = \(commonNumberList)") let commonStringList = anyCommonElements(["a","b","c"],["d","e","f","c","b"]) println("common Strings = \(commonStringList)") </code></pre> <hr> <p>The tutorial text really did not properly prepare me at all to actually solve the experiments without a lot of additional reading. Thanks to everyone here for contributing their solutions, it has really helped me get a great introduction to Swift.</p>
<p>The problem was to define the return value as an array so that was possible to add element to it.</p> <pre><code>func anyCommonElements&lt;T, U where T:SequenceType, U:SequenceType, T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element &gt;(lhs: T, rhs: U) -&gt; Array &lt;T.Generator.Element&gt; { var result = Array &lt;T.Generator.Element&gt;(); for lhsItem in lhs { for rhsItem in rhs { if lhsItem == rhsItem { result.append(lhsItem); } } } return result; } print(anyCommonElements([1,3,7,9,6,8],rhs:[4,6,8])); </code></pre>
<p>Although this question has been answered, and the original question was about working with generic arrays, there is a way using <code>Set</code> and improving the stackoverflow knowledge base I still want to post it.</p> <p>The swift class <code>Set</code> contains these four methods:</p> <pre><code>Set.union(sequence:) Set.subtract(sequence:) Set.intersect(sequence:) Set.exclusiveOr(sequence:) </code></pre> <p>which are documented here: <a href="https://developer.apple.com/library/ios/documentation/Swift/Reference/Swift_Set_Structure/index.html" rel="nofollow">https://developer.apple.com/library/ios/documentation/Swift/Reference/Swift_Set_Structure/index.html</a></p> <p>You can convert two arrays into sets and use these methods:</p> <pre><code>let array1 = [1, 2, 3] let array2 = [3, 4] let set1 = Set&lt;Int&gt;(array1) let set2 = Set&lt;Int&gt;(array2) let union = set1.union(set2) // [2, 3, 1, 4] let subtract = set1.subtract(set2) // [2, 1] let intersect = set1.intersect(set2) // [3] let exclusiveOr = set1.exclusiveOr(set2) // [2, 4, 1] </code></pre> <hr> <p><em>Edit 1:</em></p> <p>Like Martin R mentioned in a comment, the type of <code>Set&lt;T&gt;</code> has to inherit the protocol <code>Hashable</code>, which is slightly more restrictive than <code>Equatable</code>. And also the order of elements is not preserved, therefore consider the relevance of ordered elements!</p>
<p>From Swift 3, <strong>Generator</strong> protocol is renamed <strong>Iterator</strong> protocol : <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md" rel="nofollow">(link to github proposal)</a></p> <p>So, the function need to be written:</p> <pre><code>func commonElements&lt;T: Sequence, U: Sequence&gt;(_ lhs: T, _ rhs: U) -&gt; [T.Iterator.Element] where T.Iterator.Element: Equatable, T.Iterator.Element == U.Iterator.Element { var common: [T.Iterator.Element] = [] for lhsItem in lhs { for rhsItem in rhs { if lhsItem == rhsItem { common.append(lhsItem) } } } return common } </code></pre>