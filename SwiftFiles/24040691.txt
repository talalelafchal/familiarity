BAD_INSTRUCTION within swift closure
<pre><code>func loadMe() -&gt; Void { println(me.initUrl()); let url:NSURL = NSURL(string:me.initUrl()) let request:NSURLRequest = NSURLRequest(URL:url) let queue:NSOperationQueue = NSOperationQueue() NSURLConnection.sendAsynchronousRequest(request, queue:queue, completionHandler:{response, data, error in if data { var jerr:NSError? var json:NSDictionary = NSJSONSerialization.JSONObjectWithData(data, options:NSJSONReadingOptions.MutableContainers, error:&amp;jerr) as NSDictionary if !jerr { println(json.description) let time:String = json.valueForKey("time") as String println(time) // self.me.setDictionary(json) } } }) } </code></pre> <p>The code above works fine up to the point where i want to assign a value from an NSDictionary to a variable. </p> <pre><code>let time:String = json.valueForKey("time") as String </code></pre> <p>is followed by EXC_BAD_INSTRUCTION(code=EXC_I386_INVOP,subcode=0x0) but </p> <pre><code>println(json.description) </code></pre> <p>prints out a valid NSDictionary. Does anybody know a solution to this problem?</p>
<p>I solved my problem with casting to the correct type of the original NSDictionary value after i realised that not all values of the NSDictionary were NSStrings. If your service returns a mixed type JSON object like this </p> <pre><code>{"id":2, "name":"AC Vent Temp", ...} </code></pre> <p>you'll have to fetch it's values like that.</p> <pre><code>var id:int = sensor.valueForKey("id") as Int; var name:String? = sensor.valueForKey("name") as String; </code></pre>
<p>The <code>valueForKey()</code> method returns an optional value; you are forcing that value to a String and apparently that is causing the crash. I can get the Swift REPL to crash with:</p> <pre><code> 1&gt; var json = ["a": "1", "b": "2"] json: Dictionary&lt;String, String&gt; = { [0] = { key = "a" value = "1" } [1] = { key = "b" value = "2" } } 2&gt; let data:String = json["b"] as String Bitcast requires both operands to be pointer or neither %58 = bitcast i8* %57 to %SS.232 Bitcast requires both operands to be pointer or neither %110 = bitcast i8* %109 to %SS.232 Stored value type does not match pointer operand type! store %SS.232 %110, i8** %.core7._baseAddress.value, align 8 i8*LLVM ERROR: Broken function found, compilation aborted! Assertion failed: (err == 0), function ~Mutex, file /SourceCache/lldb_KLONDIKE/lldb_KLONDIKE-320.3.100/source/Host/common/Mutex.cpp, line 246. Abort trap: 6 </code></pre> <p>The solution is to forgo the String coercion. In my example:</p> <pre><code> 2&gt; let data:String? = json["b"] data: String? = "2" 3&gt; let data:String? = json["c"] data: String? = nil </code></pre> <p>I suspect you added the 'as String' 1) knowing that the value is actually a String and 2) to avoid a compiler error. The proper approach is to use <code>?</code> to indicate an optional value.</p>