lazy attribute in Swift equivalent to lazy Init getter in Objective C
<p>Is the lazy attribute in Swift equivalent to overriding the getter with a lazy loading pattern in Objective C? </p>
<p>mainly yes-- it can't be a computed property though</p>
<p>From the docs:</p> <blockquote> <p>A lazy stored property is a property whose initial value is not calculated until the first time it is used. You indicate a lazy stored property by writing the lazy attribute before its declaration.</p> </blockquote> <p>So, mostly, yes.</p> <blockquote> <p>You must always declare a lazy property as a variable (with the var keyword), because its initial value may not be retrieved until after instance initialization completes. Constant properties must always have a value before initialization completes, and therefore cannot be declared as lazy.‚Äù</p> </blockquote> <p>Remember that on Swift you have the option to declare custom getters and setters for your properties:</p> <pre><code>var name : String?{ get{ return "Oscar" } set(newValue){ } } </code></pre>
<p>Referring to this:</p> <pre><code>lazy var x = SomeFunction() </code></pre> <p>The closest equivalent in Objective-C would be something like:</p> <pre><code>@property BOOL xHasBeenSet; @property id x; - (id)x { if (!self.xHasBeenSet) { self.x = SomeFunction(); } return x; } - (void)setX:(id)x { _x = x; self.xHasBeenSet = YES; } </code></pre> <p>Here you would only see <code>SomeFunction</code> called the first time you read <code>x</code>, but only if you don't set <code>x</code> first. It's important to note that there is only one code path where the right side gets called and it never resets back to <code>xHasBeenSet = NO</code>.</p>