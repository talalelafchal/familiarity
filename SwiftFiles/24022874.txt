Custom equality in swift objects preserving compatibility with legacy Objective-C code
<p>In Objective-C you would do something along the lines of</p> <pre><code>- (BOOL)isEqual:(id)other { if (other == self) return YES; if (!other || ![other isKindOfClass:[self class]]) return NO; return [self.customProperty isEqual:other.customProperty]; } </code></pre> <p>My first naive attempt in swift goes as follows</p> <pre><code>func isEqual(other: AnyObject) -&gt; Boolean { if self === other { return true } if let otherTyped = other as? MyType { return self.myProperty == otherTyper.myProperty } return false } </code></pre> <p>But I'm far from being happy with it. I don't even know whether the signature is right or whether we're supposed to use anything different than <code>isEqual</code>.</p> <p>Any thoughts?</p> <p>EDIT: I'd also like to keep Objective-C compatibility (my class is used in both legacy Obj-C code and new Swift code). So I think only overriding <code>==</code> isn't enough. Am I wrong?</p>
<p>In Swift you can override infix operators (and even make your own). See <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AdvancedOperators.html#//apple_ref/doc/uid/TP40014097-CH27-XID_43" rel="nofollow">here</a>.</p> <p>So rather than using isEqual you could do:</p> <pre><code>myType == anotherType </code></pre>
<p>To archive Objective-C compatibility you have to override isEqual method as described on page 16 of this document: <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/BuildingCocoaApps.pdf" rel="nofollow">https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/BuildingCocoaApps.pdf</a> </p>
<p>Yes, you need to override <code>isEqual</code> (and <code>hash</code>) to make your objects fully Objective-C compatible. Here's a Playground-ready example for the syntax:</p> <pre><code>import Foundation class MyClass: NSObject { var value = 5 override func isEqual(object: AnyObject?) -&gt; Bool { if let object = object as? MyClass { return value == object.value } else { return false } } override var hash: Int { return value.hashValue } } var x = MyClass() var y = MyClass() var set = NSMutableSet() x.value = 10 y.value = 10 set.addObject(x) x.isEqual(y) // true set.containsObject(y) // true </code></pre> <p>(syntax current as of Xcode 6.3)</p>
<p>You could also implement a custom equatable, for instance:</p> <pre><code>func == (lhs: CustomClass, rhs: CustomClass) -&gt; Bool { return lhs.variable == rhs.variable } </code></pre> <p>This will allow you to simply check equality like this:</p> <pre><code>let c1: CustomClass = CustomClass(5) let c2: CustomClass = CustomClass(5) if c1 == c2 { // do whatever } </code></pre> <p>Be sure your custom equatable is outside the class scope!</p>