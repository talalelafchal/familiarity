Can I mix Swift with C++? Like the Objective - C .mm files
<p>I just changed my .m files to .mm and use C++. Is there a way to do the same with Swift?</p>
<p>No. When you switch from .m to .mm you are actually switching from Objective-C to a different language (which has many subtle differences) called Objective-C++. So you're not really using C++; you're using Objective-C++ which accepts most C++ as input (in the same way that C++ accepts most but not all C as input). When I say it's not quite C++, consider a C++ file that includes a variable named <code>nil</code> (which is legal C++) and then try to compile that as Objective-C++.</p> <p>Swift doesn't have the same relationship. It is not a superset of C or C++, and you can't directly use either in a <code>.swift</code> file.</p> <p><a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html">"Using Swift with Cocoa and Objective-C"</a> also tells us:</p> <blockquote> <p>You cannot import C++ code directly into Swift. Instead, create an Objective-C or C wrapper for C++ code.</p> </blockquote>
<p>Swift is not directly compatible with C++. You can work around the issue by wrapping your C++ code with Objective-C, and using the Objective C wrapper in Swift.</p>
<p>I have just made a little example project using Swift, Objective-C and C++. It's a demo of how to use OpenCV stitching in iOS. The OpenCV API is C++ so we can't talk to it directly from Swift. I use a small wrapper class who's implementation file is Objective-C++. The <em>Header</em> file is clean Objective-C, so Swift can talk to this directly. You have to take care not to indirectly import any C++-ish files into the the headers that Swift interacts with.</p> <p>The project is here: <a href="https://github.com/foundry/OpenCVSwiftStitch">https://github.com/foundry/OpenCVSwiftStitch</a></p>
<p>I wrote a simple Xcode 6 project that show how to mix C++, Objective C and Swift code:</p> <p><a href="https://github.com/romitagl/shared/tree/master/C-ObjC-Swift/Performance_Console">https://github.com/romitagl/shared/tree/master/C-ObjC-Swift/Performance_Console</a></p> <p>In particular the example call an Objective C and a C++ function from the Swift.</p> <p>The key is to create a shared header Project-Bridging-Header.h and put the Objective C headers there.</p> <p>Please download the project as a complete example.</p>
<p>Here's my attempt at a clang tool to automate C++/swift communication. You can instanciate C++ classes from swift, inherit from C++ class and even override virtual methods in swift.<br> It will parse the C++ class you want to export to swift and generate the Objective-C/Objective-C++ bridge automatically.</p> <p><a href="https://github.com/sandym/swiftpp">https://github.com/sandym/swiftpp</a></p>
<p>I also have a demo program for swift combining opencv.</p> <p>You can download it from <a href="https://github.com/russj/swift_opencv3_demo" rel="nofollow">https://github.com/russj/swift_opencv3_demo</a>.</p> <p>More information about the demo <a href="http://flopalm.com/opencv-with-swift/" rel="nofollow">http://flopalm.com/opencv-with-swift/</a>.</p>
<p>No, not in a single file. </p> <p>However, you may use C++ in Swift Projects without needing a static library or framework. Like others have said, the key is to make an Objective-C bridging header that #includes C-compatible C++ headers that are marked as C compatible with the <em>extern "C" {}</em> trick. </p> <p>Video tutorial: <a href="https://www.youtube.com/watch?v=0x6JbiphNS4" rel="nofollow">https://www.youtube.com/watch?v=0x6JbiphNS4</a></p>
<p>You can also <strong>skip the Objective-C</strong> file in between. Just add a C header file with a .cpp source file. Have only C declarations in the header file and include any C++ code in the source file. Then include the C header file in the **-Bridging-Header.h.</p> <p>The following example returns a pointer to a C++ object (struct Foo) so Swift can store in a COpaquePointer instead of having struct Foo defined in the global space. </p> <p>Foo.h file (seen by Swift - included in the bridging file)</p> <pre><code>#ifndef FOO_H #define FOO_H // Strictly C code here. // 'struct Foo' is opaque (the compiler has no info about it except that // it's a struct we store addresses (pointers) to it. struct Foo* foo_create(); void foo_destroy(struct Foo* foo); #endif </code></pre> <p>Inside source file Foo.cpp (not seen by Swift):</p> <pre><code>extern "C" { #include "Foo.h" } #include &lt;vector&gt; using namespace std; // C++ code is fine here. Can add methods, constructors, destructors, C++ data members, etc. struct Foo { vector&lt;int&gt; data; }; struct Foo* foo_create() { return new Foo; } void foo_destroy(struct Foo* foo) { delete foo; } </code></pre>
<hr> <p><em>I am utterly confused by the general, accepted answer, which is no.</em> It may come from the assumption that merely changing a file extension from <code>.m</code> to <code>.mm</code> is all you need to bridge the languages, when, in reality, it does nothing of that sort. It is not the <code>.mm</code> that causes friction with <code>.cpp</code>, it is the <code>.h</code> header which must positively not be a <strong>C++</strong> header.</p> <hr> <h1>Same project: YES.</h1> <p>In the <em>same</em> project, you can happily mix <strong>C</strong>, <strong>C++</strong>, <strong>Objective-C</strong>, <strong>Objective C++</strong>, <strong>Swift</strong>, and even <strong>Assembly</strong>.</p> <ol> <li><code>...Bridging-Header.h</code>: you expose <strong>C</strong>, <strong>Objective-C</strong> and <strong>Objective-C++</strong> to <strong>Swift</strong> using this bridge</li> <li><code>&lt;ProductModuleName&gt;.Swift.h</code>: exposes <em>automatically</em> your <strong>Swift</strong> classes marked with <code>@objc</code> to <strong>Objective-C</strong></li> <li><code>.h</code>: this is the tricky part, since they are ambiguously used for all flavors of <strong>C</strong>, <strong>++</strong> or not, <strong>Objective</strong> or not. When a <code>.h</code> does not contain a single <strong>C++</strong> keyword, like <code>class</code>, it can be added to the <code>...Bridging-Header.h</code>, and will expose whatever function the corresponding <code>.c</code> <strong>or</strong> <code>.cpp</code> functionalities it declares. Otherwise, that header must be wrapped in either a pure <strong>C</strong> or <strong>Objective-C</strong> API.</li> </ol> <hr> <h1>Same file: NO.</h1> <p>In the <em>same</em> file, you can't mix all 5. In the same <strong>source file</strong>:</p> <ol> <li><code>.swift</code>: you <em>can't</em> mix <strong>Swift</strong> with anything</li> <li><code>.m</code>: you can mix <strong>Objective-C</strong> with <strong>C</strong>. (<a href="http://stackoverflow.com/users/356411/vinzzz">@Vinzzz</a>)</li> <li><code>.mm</code>: you can mix <strong>Objective-C</strong> with <strong>C++</strong>. This bridge is <strong>Objective-C++</strong>. (<a href="http://stackoverflow.com/users/356411/vinzzz">@Vinzzz</a>).</li> <li><code>.c</code>: pure <strong>C</strong></li> <li><code>.cpp</code>: you can mix <strong>C++</strong> &amp; <strong>Assembly</strong> (<a href="http://stackoverflow.com/users/3323096/vality">@Vality</a>)</li> <li><code>.h</code>: ubiquitous and ambiguous <strong>C</strong>, <strong>C++</strong>, <strong>Objective-C</strong> or <strong>Objective-C++</strong>, so the answer is <em>it depends.</em></li> </ol> <hr> <p><em>References</em></p> <ul> <li><a href="http://stackoverflow.com/a/24639313/218152">Invoke Assembly from C++</a> (<a href="http://stackoverflow.com/users/906839/brett-hale">Brett Hale</a>)</li> <li><a href="http://stackoverflow.com/a/26756530/218152">Invoke Swift from Objective-C</a> (<a href="http://stackoverflow.com/users/2999739/svitlana">Svitlana</a>)</li> <li><a href="http://stackoverflow.com/a/32546879/218152">Invoke C, C++, Obj-C, Obj-C++ from Swift</a> (<a href="http://stackoverflow.com/users/218152/swiftarchitect">SwiftArchitect</a>, self)</li> <li>To download a full iOS 9, Xcode 7 project, search for <a href="http://swiftarchitect.com/">SO-32541268</a> in Swift Recipes.</li> </ul>
<p>In case this is helpful to anyone, I also have a brief tutorial on calling a simple C++ static library from a trivial Swift command line utility. This is a really bare-bones proof of concept piece of code. </p> <p>No Objective-C involved, just Swift and C++. Code in a C++ library is called by a C++ wrapper that implements a function with extern "C" linkage. That function is then referenced in the bridging header and called from Swift.</p> <p>See <a href="http://www.swiftprogrammer.info/swift_call_cpp.html" rel="nofollow">http://www.swiftprogrammer.info/swift_call_cpp.html</a> </p>
<p>I am providing a link to <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0038-swiftpm-c-language-targets.md" rel="nofollow">SE-0038</a> in the official resource, described as <em>This maintains proposals for changes and user-visible enhancements to the Swift Programming Language.</em> </p> <p>The status as of today is that this is the feature request which has been accepted but not yet scheduled. </p> <p>This link is intended to steer anyone looking for this feature in the right direction</p>