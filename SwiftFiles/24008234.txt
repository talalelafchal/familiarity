Swift language statically or dynamically dispatched?
<p>Reading Swift language guide I cannot find explicit information whether Swift is statically dispatched (like basic C++, Java, C#) or dynamically dispatched (like Objective-C). </p> <p>The documentation of language features (like classes, extensions, generics, etc) seems to suggest that it is statically typed, which might be the source of supposed speed improvements. However, Apple stated on the WWDC 2014 keynote that the language uses the same runtime as Objective-C, and is very compatible with Cocoa/Cocoa Touch, which suggest dynamic dispatch.</p>
<p>Describing C++, Java, and C# as statically dispatched is not particularly accurate. All three languages can and often do use dynamic dispatch.</p> <p>Swift, similarly, can do both. It does differ from ObjC in that it does not <em>always</em> dynamically dispatch. Methods marked @final can be statically dispatched, as can struct and enum methods. I believe non-final methods can be statically dispatched if the runtime type can be proven at compile time (similar to C++ devirtualization), but I'm not certain about the details there.</p>
<p>According to this excerpt from Y Combinator (<a href="https://news.ycombinator.com/item?id=7835099" rel="nofollow">https://news.ycombinator.com/item?id=7835099</a>):</p> <blockquote> <p>From a user's point of view, it's basically straight out of the Rust book, all the gravy with also relaxed ownership and syntax.</p> <p>It has it all [1]: static typing, type inference, explicit mutability, closures, pattern matching, optionals (with own syntax! also "any"), generics, interfaces, weak ownership, tuples, plus other nifty things like shorthand syntax, final and explicit override...</p> <p>It screams "modern!", has all the latest circlejerk features. It even comes with a light-table/bret-victor style playground. But is still a practical language which looks approachable and straightforward.</p> </blockquote> <p>Edit: [1]: well, almost. I don't think I've caught anything about generators, first-class concurrency and parallelism, or tail-call optimization, among others.</p>