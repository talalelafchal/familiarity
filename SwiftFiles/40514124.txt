Find all the generated values of an array of numbers in a given range
Imagine this scenario: Input array of numbers and a boundary range for the output: numbers = [20, 50] range = [0, 200] Output all possible combination of the sums of the elements of the input array restricted to the boundary range: output = [20, 40, 50, 70, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200] So my question isHow can I achieve this?
Given an array of Int(s) and a closed range let numbers = [20, 50] let range: ClosedRange = 0...200 The following function returns a Set of every possible integer which satisfy the following conditions: it is within the range can be expressed as sum of some values (repeated if needed) in numbers Code func combs(range:ClosedRange<Int>, numers: [Int], value: Int = 0) -> Set<Int> { guard value <= range.upperBound else { return [] } return numbers.reduce(Set<Int>()) { results, num -> Set<Int> in var results = results let newValue = value + num if range ~= value { results.insert(value) } return results.union(combs(range: range, numers: numbers, value: newValue)) } } Usage let nums = Array(combs(range: range, numers: numbers)).sorted() [0, 20, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200]
Here is a possible method which gives the numbers in increasing order. It uses two arrays ("queues") to keep track of values which still have to be added to the output sequence. (This is essentially the same method as the "Dynamic Programming Method" in "Ugly Numbers" to generate the so-called Hamming numbers.) let x = 20 let y = 50 let limit = 200 var xq: [Int] = [] var yq: [Int] = [] var current = 0 while current <= limit { print(current, terminator: ", ") xq.append(current + x) yq.append(current + y) current = min(xq[0], yq[0]) if xq[0] == current { xq.remove(at: 0) } if yq[0] == current { yq.remove(at: 0) } } print() Output: 0, 20, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200,