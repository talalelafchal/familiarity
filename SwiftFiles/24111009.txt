Bound value in a conditional binding must be of Optional Type
<p>I have a protocol defined:</p> <pre><code>protocol Usable { func use() } </code></pre> <p>and a class that conforms to that protocol</p> <pre><code>class Thing: Usable { func use () { println ("you use the thing") } } </code></pre> <p>I would like to programmatically test whether or not the Thing class conforms to the Usable protocol.</p> <pre><code>let thing = Thing() // Check whether or not a class is useable if let usableThing = thing as Usable { // error here usableThing.use() } else { println("can't use that") } </code></pre> <p>But I get the error</p> <pre><code>Bound value in a conditional binding must be of Optional Type </code></pre> <p>If I try</p> <pre><code>let thing:Thing? = Thing() </code></pre> <p>I get the error</p> <pre><code>Cannot downcast from 'Thing?' to non-@objc protocol type 'Usable' </code></pre> <p>I then add <code>@objc</code> to the protocol and get the error</p> <pre><code>Forced downcast in conditional binding produces non-optional type 'Usable' </code></pre> <p>At which point I add <code>?</code> after the <code>as</code>, which finally fixes the error.</p> <p>How can I achieve this functionality with conditional binding with a non-@objc protocol, the same as in the "Advanced Swift" 2014 WWDC Video?</p>
<p>You can get it to compile by making the cast as Usable? instead of as Usable, like this:</p> <pre><code>// Check whether or not a class is useable if let usableThing = thing as Usable? { // error here usableThing.use() } else { println("can't use that") } </code></pre>
<p>You are getting </p> <pre><code>Bound value in a conditional binding must be of Optional Type </code></pre> <p>because <code>thing as Usable</code> must return an optional type so making it <code>as?</code> should solved the problem. Unfortunately, the error still persisted for some odd reason. Anyway, a workaround I found to get it to work is to extract out the variable assignment inside the if statement</p> <pre><code>let thing = Thing() let usableThing = thing as? Usable if useableThing { usableThing!.use() } else { println("can't use that") } </code></pre>
<p>As metioned in the Swift doc, the <code>is</code> operator is the guy you need for the job:</p> <blockquote> <p>The is operator checks at runtime to see whether the expression is of the specified type. If so, it returns true; otherwise, it returns false.</p> <p>The check must not be known to be true or false at compile time.</p> </blockquote> <p>Therefore, the following test would normally be what you need:</p> <pre><code>if thing is Usable { usableThing.use() } else { println("can't use that") } </code></pre> <p>However, as the doc specifies, Swift can detect at compile time that the expression is always true and declares an error to help the developer. </p>
<p>swift protocols does not work in Playgrounds in the first beta, try to build a real project instead.</p>
<p>This works for me in the playground</p> <pre><code>protocol Usable { func use() } class Thing: Usable { func use () { println ("you use the thing") } } let thing = Thing() let testThing : AnyObject = thing as AnyObject if let otherThing = testThing as? Thing { otherThing.use() } else { println("can't use that") } </code></pre>