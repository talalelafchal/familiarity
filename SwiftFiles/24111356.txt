Swift - class method which must be overridden by subclass
<p>Is there a standard way to make a "pure virtual function" in Swift, ie. one that <strong>must</strong> be overridden by every subclass, and which, if it is not, causes a compile time error?</p>
<p>There isn't any support for abstract class/ virtual functions, but you could probably use a protocol for most cases:</p> <pre><code>protocol SomeProtocol { func someMethod() } class SomeClass: SomeProtocol { func someMethod() {} } </code></pre> <p>If SomeClass doesn't implement someMethod, you'll get this compile time error:</p> <pre><code>error: type 'SomeClass' does not conform to protocol 'SomeProtocol' </code></pre>
<p>You have two options:</p> <h1>1. Use a Protocol</h1> <p>Define the superclass as a Protocol instead of a Class</p> <p><strong>Pro</strong>: Compile time check for if each "subclass" (not an actual subclass) implements the required method(s)</p> <p><strong>Con</strong>: The "superclass" (protocol) cannot implement methods or properties</p> <h1>2. Assert in the super version of the method</h1> <p>Example:</p> <pre><code>class SuperClass { func someFunc() { fatalError("Must Override") } } class Subclass : SuperClass { override func someFunc() { } } </code></pre> <p><strong>Pro</strong>: Can implement methods and properties in superclass</p> <p><strong>Con</strong>: No compile time check</p>
<p>Another workaround, if you don't have too many "virtual" methods, is to have the subclass pass the "implementations" into the base class constructor as function objects:</p> <pre><code>class MyVirtual { // 'Implementation' provided by subclass let fooImpl: (() -&gt; String) // Delegates to 'implementation' provided by subclass func foo() -&gt; String { return fooImpl() } init(fooImpl: (() -&gt; String)) { self.fooImpl = fooImpl } } class MyImpl: MyVirtual { // 'Implementation' for super.foo() func myFoo() -&gt; String { return "I am foo" } init() { // pass the 'implementation' to the superclass super.init(myFoo) } } </code></pre>