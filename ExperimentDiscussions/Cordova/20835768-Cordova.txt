addEventListener on custom object
<p>I've created an object that has several methods. Some of these methods are asynchronous and thus I want to use events to be able to perfom actions when the methods are done. To do this I tried to add the addEventListener to the object.</p> <p><a href="http://jsfiddle.net/9d7nN/">jsfiddle</a></p> <pre><code>var iSubmit = { addEventListener: document.addEventListener || document.attachEvent, dispatchEvent: document.dispatchEvent, fireEvent: document.fireEvent, //the method below is added for completeness, but is not causing the problem. test: function(memo) { var name = "test"; var event; if (document.createEvent) { event = document.createEvent("HTMLEvents"); event.initEvent(name, true, true); } else { event = document.createEventObject(); event.eventType = name; } event.eventName = name; event.memo = memo || { }; if (document.createEvent) { try { document.dispatchEvent(event); } catch (ex) { iAlert.debug(ex, 'iPushError'); } } else { document.fireEvent("on" + event.eventType, event); } } } iSubmit.addEventListener("test", function(e) { console.log(e); }, false); //This call is added to have a complete test. The errors is already triggered with the line before this one. iSubmit.test(); </code></pre> <p>This will return an error: <code>Failed to add eventlisterens: TypeError: 'addEventListener' called on an object that does not implement interface EventTarget."</code></p> <p>Now this code will be used in a phonegap app and when I do, it is working on android/ios. During testing however, it would be nice if I could get it to work in at least a single browser.</p> <p>PS> I know I could enable bubbling and then listen to the document root, but I would like to have just a little bit OOP where each object can work on its own.</p>
<p>This article explains creating custom events: <a href="http://www.sitepoint.com/javascript-custom-events/" rel="nofollow">http://www.sitepoint.com/javascript-custom-events/</a></p> <p>here is an example:</p> <p>create the event -</p> <pre><code>var event = new CustomEvent( "newMessage", { detail: { message: "Hello World!", time: new Date(), }, bubbles: true, cancelable: true } ); </code></pre> <p>assign the event to something - </p> <pre><code>document.getElementById("msgbox").dispatchEvent(event); </code></pre> <p>subscribe to the event - </p> <pre><code>document.addEventListener("newMessage", newMessageHandler, false); </code></pre>
<p>I think you can use Object $Deferred and promises. It'll let you do something like this:</p> <p>Stacked: bind multiple handlers anywhere in the application to the same promise event.</p> <pre><code> var request = $.ajax(url); request.done(function () { console.log('Request completed'); }); </code></pre> <p>// Somewhere else in the application</p> <pre><code> request.done(function (retrievedData) { $('#contentPlaceholder').html(retrievedData); }); </code></pre> <p>Parallel tasks: ask multiple promises to return a promise which alerts of their mutual completion.</p> <pre><code>$.when(taskOne, taskTwo).done(function () { console.log('taskOne and taskTwo are finished'); }); </code></pre> <p>Sequential tasks: execute tasks in sequential order.</p> <pre><code> var step1, step2, url; url = 'http://fiddle.jshell.net'; step1 = $.ajax(url); step2 = step1.then( function (data) { var def = new $.Deferred(); setTimeout(function () { console.log('Request completed'); def.resolve(); },2000); return def.promise(); }, function (err) { console.log('Step1 failed: Ajax request'); } ); step2.done(function () { console.log('Sequence completed') setTimeout("console.log('end')",1000); }); </code></pre> <p>Source here: <a href="http://blog.mediumequalsmessage.com/promise-deferred-objects-in-javascript-pt2-practical-use" rel="nofollow">http://blog.mediumequalsmessage.com/promise-deferred-objects-in-javascript-pt2-practical-use</a></p>
<p><code>addEventListener</code> is intended for DOM Elements that implements certain event-related interfaces. If you want an event system on pure JavaScript objects, you are looking for a custom event system. An example would be <code>Backbone.Events</code> in Backbone.js. The basic idea is using an object as a hash to keep track of registered callbacks.</p> <p>Personally I use this: <a href="https://github.com/component/emitter">https://github.com/component/emitter</a></p> <p>It's a fairly simple and elegant solution - with sweet short method names like <code>on()</code>, <code>off()</code> and <code>emit()</code>. you can either create new instances with <code>new Emitter()</code>, or use <code>Emitter(obj)</code> to mix event capabilities into existing objects. Note this library is written for use with a CommonJS module system, but you can use it anywhere else by removing the <code>module.exports = ...</code> line.</p>
<p>There are two problems.</p> <p>First, the <code>iSubmit.addEventListener()</code> method is actually a method on the <code>EventTarget</code> DOM interface:</p> <ul> <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget">EventTarget</a></li> <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget.addEventListener">EventTarget # addEventListener()</a></li> </ul> <p>These are inteded for use only on DOM elements. By adding it to the <code>iSubmit</code> object as a method, you're calling it on an object that is not an <code>EventTarget</code>. This is why Chrome throws an <em><code>Uncaught TypeError: Illegal invocation</code></em> JavaScript error.</p> <p>The first problem is critical, but if you could use <code>EventTarget#addEventListener()</code> your code would not work because the event is being added to <code>iSubmit</code> but dispatched from <code>document</code>. Generally, the same object's methods need to be used when attaching event listeners and dispatching events (unless you're using bubbling events, which is a <a href="http://stackoverflow.com/questions/4616694/what-is-event-bubbling-and-capturing">different story</a> - Note: bubbling is not restricted to JavaScript or DOM related events, <a href="https://users.cs.jmu.edu/bernstdh/web/common/lectures/slides_event-listening-and-bubbling.php">for example</a>).</p> <p>Using custom events with your own objects is very normal. As <a href="http://stackoverflow.com/a/20912559/1888292">Evan Yu mentioned</a>, there are libraries for this. Here are a couple:</p> <ul> <li><a href="https://github.com/millermedeiros/js-signals">millermedeiros / js-signals</a></li> <li><a href="https://github.com/Wolfy87/EventEmitter">Wolfy87 / EventEmitter</a></li> </ul> <p>I have used <code>js-signals</code> and like it quite a bit. I have never used <code>Wolfy87/EventEmitter</code>, but it has a nice look to it.</p> <p>Your example might look something like the following if you used <code>js-signals</code></p> <p><a href="http://jsfiddle.net/2XFbt/">jsFiddle</a></p> <pre><code>var iSubmit = { finished: new signals.Signal(), test: function test(memo) { this.finished.dispatch(memo || {}); } }; iSubmit.finished.add(function(data) { console.log('finished:', data); }); iSubmit.test('this is the finished data'); // alternatively iSubmit.finished.dispatch('this is dispatched directly from the signal'); </code></pre>
<p>If you want to listen a javascript object you have three ways:</p> <ul> <li>Use <a href="http://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern" rel="nofollow">sub/pub pattren</a> which has a lot of <a href="https://gist.github.com/search?q=sub%20pub%20javascript" rel="nofollow">implementations</a> in javascript</li> <li>Or use native implementation via <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/get" rel="nofollow"><code>Object get/set operators</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" rel="nofollow"><code>Object.defineProperty</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/watch" rel="nofollow"><code>Object.prototype.watch</code></a> or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" rel="nofollow"><code>Proxy API</code></a></li> <li>Use <a href="http://updates.html5rocks.com/2012/11/Respond-to-change-with-Object-observe" rel="nofollow"><code>Object.observe</code></a>. Works Chrome 25+(Jan 2014). But became <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe" rel="nofollow">deprecated</a> in 2016</li> </ul> <p><strong>About sup/pub pattern:</strong></p> <p>You need to publish events.</p> <p><strong>About native implementations:</strong></p> <ul> <li><code>Object get/set operators</code> is enough to listen add, remove, change, get events. Operators have good <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/get#Browser_compatibility" rel="nofollow">support</a>. Problems only in IE8-. But if you want to use get/set in IE8 use <code>Object.defineProperty</code> but on DOM objects or use Object.defineProperty <a href="https://github.com/es-shims/es5-shim/blob/master/es5-sham.js" rel="nofollow">sham</a>.</li> <li><code>Object.prototype.watch</code> has the good ES5 <a href="https://gist.github.com/eligrey/384583" rel="nofollow">polyfill</a>.</li> <li><code>Proxy API</code> needs ES Harmony support.</li> </ul> <p><strong>Object.observe example</strong></p> <pre><code>var o = {}; Object.observe(o, function (changes) { changes.forEach(function (change) { // change.object contains changed object version console.log('property:', change.name, 'type:', change.type); }); }); o.x = 1 // property: x type: add o.x = 2 // property: x type: update delete o.x // property: x type: delete </code></pre>
<p>If you don't need true event features(such as bubbling, stopPropagation), then you can implement your own events. addEventListener is just an API of the DOM, so you don't really need it for your own objects outside the DOM. If you want to create an evented pattern around an object, here's a good way to do it that does not require any extra browser APIs and should be very backwards-compatible. </p> <p>Let's say you have an object where you want a bunch of events to be triggered when the dispatch method is called:</p> <pre><code>var OurDispatcher, dispatcher; OurDispatcher = (function() { function OurDispatcher() { this.dispatchHandlers = []; } OurDispatcher.prototype.on = function(eventName, handler) { switch (eventName) { case "dispatch": return this.dispatchHandlers.push(handler); case "somethingElse": return alert('write something for this event :)'); } }; OurDispatcher.prototype.dispatch = function() { var handler, i, len, ref; ref = this.dispatchHandlers; for (i = 0, len = ref.length; i &lt; len; i++) { handler = ref[i]; setTimeout(handler, 0); } }; return OurDispatcher; })(); dispatcher = new OurDispatcher(); dispatcher.on("dispatch", function() { return document.body.innerHTML += "DISPATCHED&lt;/br&gt;"; }); dispatcher.on("dispatch", function() { return document.body.innerHTML += "DISPATCHED AGAIN&lt;/br&gt;"; }); dispatcher.dispatch(); </code></pre> <p>It really doesn't have to be more complicated than that, for the most part. This way you have some decent control over your events and you don't need to worry about backward-compatibility or external libraries because everything there is widely supported. Technically, you could even do without setTimeout and handle your callbacks without any APIs. Anything else like stopPropagation() would have to be handled yourself.</p> <p><a href="https://jsfiddle.net/ozsywxer/" rel="nofollow">https://jsfiddle.net/ozsywxer/</a></p> <p>There are, of course, polyfills for CustomEvent, but unless I need advanced event features, I prefer to wrap my own eventing system into a "class" and extending other classes/functions with it.</p> <p>Here's the CoffeeScript version, which is what the JavaScript is derived from: <a href="https://jsfiddle.net/vmkkbbxq/1/" rel="nofollow">https://jsfiddle.net/vmkkbbxq/1/</a></p> <p><em>^^ A bit easier to understand.</em></p>