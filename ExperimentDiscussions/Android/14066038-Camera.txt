Why does an image captured using camera intent gets rotated on some devices on Android?
<p>I'm capturing an image and setting it to image view.</p> <pre><code>public void captureImage() { Intent intentCamera = new Intent("android.media.action.IMAGE_CAPTURE"); File filePhoto = new File(Environment.getExternalStorageDirectory(), "Pic.jpg"); imageUri = Uri.fromFile(filePhoto); MyApplicationGlobal.imageUri = imageUri.getPath(); intentCamera.putExtra(MediaStore.EXTRA_OUTPUT, imageUri); startActivityForResult(intentCamera, TAKE_PICTURE); } @Override protected void onActivityResult(int requestCode, int resultCode, Intent intentFromCamera) { super.onActivityResult(requestCode, resultCode, intentFromCamera); if (resultCode == RESULT_OK &amp;&amp; requestCode == TAKE_PICTURE) { if (intentFromCamera != null) { Bundle extras = intentFromCamera.getExtras(); if (extras.containsKey("data")) { bitmap = (Bitmap) extras.get("data"); } else { bitmap = getBitmapFromUri(); } } else { bitmap = getBitmapFromUri(); } // imageView.setImageBitmap(bitmap); imageView.setImageURI(imageUri); } else { } } public Bitmap getBitmapFromUri() { getContentResolver().notifyChange(imageUri, null); ContentResolver cr = getContentResolver(); Bitmap bitmap; try { bitmap = android.provider.MediaStore.Images.Media.getBitmap(cr, imageUri); return bitmap; } catch (Exception e) { e.printStackTrace(); return null; } } </code></pre> <p>But the problem is, the image on some devices every time it gets rotated. For example, on a Samsung device it works good, but on a <a href="https://en.wikipedia.org/wiki/Sony_Xperia" rel="nofollow noreferrer">Sony Xperia</a> the image gets rotated by 90 degrees and on <a href="https://en.wikipedia.org/wiki/Toshiba_Thrive" rel="nofollow noreferrer">Toshiba Thrive</a> (tablet) by 180 degrees.</p>
<p>Better try to take the picture in a specific orientation.</p> <pre><code>android:screenOrientation="landscape" android:configChanges="orientation|keyboardHidden" </code></pre> <p>For best results give landscape orientation in the cameraview activity.</p>
<p>Most phone cameras are landscape, meaning if you take the photo in portrait, the resulting photos will be rotated 90 degrees. In this case, the camera software should populate the <a href="https://en.wikipedia.org/wiki/Exif" rel="nofollow noreferrer">Exif</a> data with the orientation that the photo should be viewed in.</p> <p>Note that the below solution depends on the camera software/device manufacturer populating the Exif data, so it will work in most cases, but it is not a 100% reliable solution.</p> <pre><code>ExifInterface ei = new ExifInterface(photoPath); int orientation = ei.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_UNDEFINED); switch(orientation) { case ExifInterface.ORIENTATION_ROTATE_90: rotateImage(bitmap, 90); break; case ExifInterface.ORIENTATION_ROTATE_180: rotateImage(bitmap, 180); break; case ExifInterface.ORIENTATION_ROTATE_270: rotateImage(bitmap, 270); break; case ExifInterface.ORIENTATION_NORMAL: default: break; } </code></pre> <p>Here is the <code>rotateImage</code> method:</p> <pre><code>public static Bitmap rotateImage(Bitmap source, float angle) { Matrix matrix = new Matrix(); matrix.postRotate(angle); return Bitmap.createBitmap(source, 0, 0, source.getWidth(), source.getHeight(), matrix, true); } </code></pre>
<p>Normally it is recommended to solve the problem with the <a href="http://developer.android.com/reference/android/media/ExifInterface.html" rel="nofollow">ExifInterface</a>, like @Jason Robinson did suggest. If this approach doesn't work, you could try to look up the <a href="http://developer.android.com/reference/android/provider/MediaStore.Images.ImageColumns.html#ORIENTATION" rel="nofollow">Orientation</a> of the latest image taken...</p> <pre><code>private int getImageOrientation(){ final String[] imageColumns = { MediaStore.Images.Media._ID, MediaStore.Images.ImageColumns.ORIENTATION }; final String imageOrderBy = MediaStore.Images.Media._ID+" DESC"; Cursor cursor = getContentResolver().query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, imageColumns, null, null, imageOrderBy); if(cursor.moveToFirst()){ int orientation = cursor.getInt(cursor.getColumnIndex(MediaStore.Images.ImageColumns.ORIENTATION)); cursor.close(); return orientation; } else { return 0; } } </code></pre>
<p>It's easy to detect the image orientation and replace the bitmap using:</p> <pre><code> /** * Rotate an image if required. * @param img * @param selectedImage * @return */ private static Bitmap rotateImageIfRequired(Context context,Bitmap img, Uri selectedImage) { // Detect rotation int rotation = getRotation(context, selectedImage); if (rotation != 0) { Matrix matrix = new Matrix(); matrix.postRotate(rotation); Bitmap rotatedImg = Bitmap.createBitmap(img, 0, 0, img.getWidth(), img.getHeight(), matrix, true); img.recycle(); return rotatedImg; } else{ return img; } } /** * Get the rotation of the last image added. * @param context * @param selectedImage * @return */ private static int getRotation(Context context,Uri selectedImage) { int rotation = 0; ContentResolver content = context.getContentResolver(); Cursor mediaCursor = content.query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, new String[] { "orientation", "date_added" }, null, null, "date_added desc"); if (mediaCursor != null &amp;&amp; mediaCursor.getCount() != 0) { while(mediaCursor.moveToNext()){ rotation = mediaCursor.getInt(0); break; } } mediaCursor.close(); return rotation; } </code></pre> <p>To avoid Out of memories with big images, I'd recommend you to rescale the image using:</p> <pre><code>private static final int MAX_HEIGHT = 1024; private static final int MAX_WIDTH = 1024; public static Bitmap decodeSampledBitmap(Context context, Uri selectedImage) throws IOException { // First decode with inJustDecodeBounds=true to check dimensions final BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; InputStream imageStream = context.getContentResolver().openInputStream(selectedImage); BitmapFactory.decodeStream(imageStream, null, options); imageStream.close(); // Calculate inSampleSize options.inSampleSize = calculateInSampleSize(options, MAX_WIDTH, MAX_HEIGHT); // Decode bitmap with inSampleSize set options.inJustDecodeBounds = false; imageStream = context.getContentResolver().openInputStream(selectedImage); Bitmap img = BitmapFactory.decodeStream(imageStream, null, options); img = rotateImageIfRequired(img, selectedImage); return img; } </code></pre> <p>It's not posible to use ExifInterface to get the orientation because an Android OS issue: <a href="https://code.google.com/p/android/issues/detail?id=19268" rel="nofollow noreferrer">https://code.google.com/p/android/issues/detail?id=19268</a></p> <p>And here is <code>calculateInSampleSize</code></p> <pre><code>/** * Calculate an inSampleSize for use in a {@link BitmapFactory.Options} object when decoding * bitmaps using the decode* methods from {@link BitmapFactory}. This implementation calculates * the closest inSampleSize that will result in the final decoded bitmap having a width and * height equal to or larger than the requested width and height. This implementation does not * ensure a power of 2 is returned for inSampleSize which can be faster when decoding but * results in a larger bitmap which isn't as useful for caching purposes. * * @param options An options object with out* params already populated (run through a decode* * method with inJustDecodeBounds==true * @param reqWidth The requested width of the resulting bitmap * @param reqHeight The requested height of the resulting bitmap * @return The value to be used for inSampleSize */ public static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) { // Raw height and width of image final int height = options.outHeight; final int width = options.outWidth; int inSampleSize = 1; if (height &gt; reqHeight || width &gt; reqWidth) { // Calculate ratios of height and width to requested height and width final int heightRatio = Math.round((float) height / (float) reqHeight); final int widthRatio = Math.round((float) width / (float) reqWidth); // Choose the smallest ratio as inSampleSize value, this will guarantee a final image // with both dimensions larger than or equal to the requested height and width. inSampleSize = heightRatio &lt; widthRatio ? heightRatio : widthRatio; // This offers some additional logic in case the image has a strange // aspect ratio. For example, a panorama may have a much larger // width than height. In these cases the total pixels might still // end up being too large to fit comfortably in memory, so we should // be more aggressive with sample down the image (=larger inSampleSize). final float totalPixels = width * height; // Anything more than 2x the requested pixels we'll sample down further final float totalReqPixelsCap = reqWidth * reqHeight * 2; while (totalPixels / (inSampleSize * inSampleSize) &gt; totalReqPixelsCap) { inSampleSize++; } } return inSampleSize; } </code></pre>
<pre><code>// Try this way,hope this will help you to solve your problem... </code></pre> <p><strong>activity_main.xml</strong></p> <pre><code>&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" &gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1" android:gravity="center"&gt; &lt;ImageView android:id="@+id/imgFromCameraOrGallery" android:layout_width="wrap_content" android:layout_height="wrap_content" android:adjustViewBounds="true" android:src="@drawable/ic_launcher"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;Button android:id="@+id/btnCamera" android:layout_width="0dp" android:layout_weight="1" android:layout_height="wrap_content" android:text="Camera"/&gt; &lt;Button android:id="@+id/btnGallery" android:layout_width="0dp" android:layout_weight="1" android:layout_marginLeft="5dp" android:layout_height="wrap_content" android:text="Gallery"/&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; </code></pre> <p><strong>MainActivity.java</strong></p> <pre><code> public class MainActivity extends Activity { private ImageView imgFromCameraOrGallery; private Button btnCamera; private Button btnGallery; private String imgPath; final private int PICK_IMAGE = 1; final private int CAPTURE_IMAGE = 2; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); imgFromCameraOrGallery = (ImageView) findViewById(R.id.imgFromCameraOrGallery); btnCamera = (Button) findViewById(R.id.btnCamera); btnGallery = (Button) findViewById(R.id.btnGallery); btnCamera.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { final Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); intent.putExtra(MediaStore.EXTRA_OUTPUT, setImageUri()); startActivityForResult(intent, CAPTURE_IMAGE); } }); btnGallery.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(); intent.setType("image/*"); intent.setAction(Intent.ACTION_GET_CONTENT); startActivityForResult(Intent.createChooser(intent, ""), PICK_IMAGE); } }); } @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); if (resultCode == Activity.RESULT_OK) { if (requestCode == CAPTURE_IMAGE) { setCapturedImage(getImagePath()); } else if (requestCode == PICK_IMAGE) { imgFromCameraOrGallery.setImageBitmap(BitmapFactory.decodeFile(getAbsolutePath(data.getData()))); } } } private String getRightAngleImage(String photoPath) { try { ExifInterface ei = new ExifInterface(photoPath); int orientation = ei.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL); int degree = 0; switch (orientation) { case ExifInterface.ORIENTATION_NORMAL: degree = 0; break; case ExifInterface.ORIENTATION_ROTATE_90: degree = 90; break; case ExifInterface.ORIENTATION_ROTATE_180: degree = 180; break; case ExifInterface.ORIENTATION_ROTATE_270: degree = 270; break; case ExifInterface.ORIENTATION_UNDEFINED: degree = 0; break; default: degree = 90; } return rotateImage(degree,photoPath); } catch (Exception e) { e.printStackTrace(); } return photoPath; } private String rotateImage(int degree, String imagePath){ if(degree&lt;=0){ return imagePath; } try{ Bitmap b= BitmapFactory.decodeFile(imagePath); Matrix matrix = new Matrix(); if(b.getWidth()&gt;b.getHeight()){ matrix.setRotate(degree); b = Bitmap.createBitmap(b, 0, 0, b.getWidth(), b.getHeight(), matrix, true); } FileOutputStream fOut = new FileOutputStream(imagePath); String imageName = imagePath.substring(imagePath.lastIndexOf("/") + 1); String imageType = imageName.substring(imageName.lastIndexOf(".") + 1); FileOutputStream out = new FileOutputStream(imagePath); if (imageType.equalsIgnoreCase("png")) { b.compress(Bitmap.CompressFormat.PNG, 100, out); }else if (imageType.equalsIgnoreCase("jpeg")|| imageType.equalsIgnoreCase("jpg")) { b.compress(Bitmap.CompressFormat.JPEG, 100, out); } fOut.flush(); fOut.close(); b.recycle(); }catch (Exception e){ e.printStackTrace(); } return imagePath; } private void setCapturedImage(final String imagePath){ new AsyncTask&lt;Void,Void,String&gt;(){ @Override protected String doInBackground(Void... params) { try { return getRightAngleImage(imagePath); }catch (Throwable e){ e.printStackTrace(); } return imagePath; } @Override protected void onPostExecute(String imagePath) { super.onPostExecute(imagePath); imgFromCameraOrGallery.setImageBitmap(decodeFile(imagePath)); } }.execute(); } public Bitmap decodeFile(String path) { try { // Decode deal_image size BitmapFactory.Options o = new BitmapFactory.Options(); o.inJustDecodeBounds = true; BitmapFactory.decodeFile(path, o); // The new size we want to scale to final int REQUIRED_SIZE = 1024; // Find the correct scale value. It should be the power of 2. int scale = 1; while (o.outWidth / scale / 2 &gt;= REQUIRED_SIZE &amp;&amp; o.outHeight / scale / 2 &gt;= REQUIRED_SIZE) scale *= 2; // Decode with inSampleSize BitmapFactory.Options o2 = new BitmapFactory.Options(); o2.inSampleSize = scale; return BitmapFactory.decodeFile(path, o2); } catch (Throwable e) { e.printStackTrace(); } return null; } public String getAbsolutePath(Uri uri) { if(Build.VERSION.SDK_INT &gt;= 19){ String id = ""; if(uri.getLastPathSegment().split(":").length &gt; 1) id = uri.getLastPathSegment().split(":")[1]; else if(uri.getLastPathSegment().split(":").length &gt; 0) id = uri.getLastPathSegment().split(":")[0]; if(id.length() &gt; 0){ final String[] imageColumns = {MediaStore.Images.Media.DATA }; final String imageOrderBy = null; Uri tempUri = getUri(); Cursor imageCursor = getContentResolver().query(tempUri, imageColumns, MediaStore.Images.Media._ID + "=" + id, null, imageOrderBy); if (imageCursor.moveToFirst()) { return imageCursor.getString(imageCursor.getColumnIndex(MediaStore.Images.Media.DATA)); }else{ return null; } }else{ return null; } }else{ String[] projection = { MediaStore.MediaColumns.DATA }; Cursor cursor = getContentResolver().query(uri, projection, null, null, null); if (cursor != null) { int column_index = cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.DATA); cursor.moveToFirst(); return cursor.getString(column_index); } else return null; } } private Uri getUri() { String state = Environment.getExternalStorageState(); if(!state.equalsIgnoreCase(Environment.MEDIA_MOUNTED)) return MediaStore.Images.Media.INTERNAL_CONTENT_URI; return MediaStore.Images.Media.EXTERNAL_CONTENT_URI; } public Uri setImageUri() { Uri imgUri; String state = Environment.getExternalStorageState(); if (Environment.MEDIA_MOUNTED.equals(state)) { File file = new File(Environment.getExternalStorageDirectory() + "/DCIM/",getString(R.string.app_name) + Calendar.getInstance().getTimeInMillis() + ".png"); imgUri = Uri.fromFile(file); imgPath = file.getAbsolutePath(); }else { File file = new File(getFilesDir() ,getString(R.string.app_name) + Calendar.getInstance().getTimeInMillis()+ ".png"); imgUri = Uri.fromFile(file); this.imgPath = file.getAbsolutePath(); } return imgUri; } public String getImagePath() { return imgPath; } } </code></pre>
<p>If somebody experiences problems with <code>ExifInterface</code> on <a href="https://en.wikipedia.org/wiki/Android_version_history#Android_4.4_KitKat_.28API_level_19.29" rel="nofollow noreferrer">Android 4.4</a> (KitKat) for getting the orientation, it might be because of wrong <strong>path</strong> got from the URI. See a solution for propoer <code>getPath</code> in Stack Overflow question <em><a href="http://stackoverflow.com/questions/20067508/get-real-path-from-uri-android-kitkat-new-storage-access-framework/20559175#20559175">Get real path from URI, Android KitKat new storage access framework</a></em></p>
<p>Try the following, if you're are facing a problem with S4.</p> <pre><code>android:configChanges="locale|touchscreen|orientation|screenLayout|screenSize|keyboardHidden|uiMode" </code></pre>
<p>By combining <em>Jason Robinson</em>'s <a href="http://stackoverflow.com/a/21754321/1364896">answer</a> with <em>Felix</em>'s <a href="http://stackoverflow.com/a/14066265/1364896">answer</a> and filling the missing parts, <strong>here is the final complete solution for this issue</strong> that will do the following after testing it on Android <a href="https://en.wikipedia.org/wiki/Android_version_history#Android_4.1_Jelly_Bean_.28API_level_16.29" rel="nofollow noreferrer">Android&nbsp;4.1</a> (<em>Jelly Bean</em>), <a href="https://en.wikipedia.org/wiki/Android_version_history#Android_4.4_KitKat_.28API_level_19.29" rel="nofollow noreferrer">Android 4.4</a> (<em>KitKat</em>) and <a href="https://en.wikipedia.org/wiki/Android_Lollipop" rel="nofollow noreferrer">Android 5.0</a> (<em>Lollipop</em>).</p> <p><strong>Steps</strong></p> <ol> <li><p>Scale down the image if it was bigger than 1024x1024.</p></li> <li><p>Rotate the image to the right orientation <em>only</em> if it was rotate 90, 180 or 270 degree.</p></li> <li><p>Recycle the rotated image for memory purposes.</p></li> </ol> <p><strong>Here is the code part:</strong></p> <p>Call the following method with the current <code>Context</code> and the image <code>URI</code> that you want to fix</p> <pre><code>/** * This method is responsible for solving the rotation issue if exist. Also scale the images to * 1024x1024 resolution * * @param context The current context * @param selectedImage The Image URI * @return Bitmap image results * @throws IOException */ public static Bitmap handleSamplingAndRotationBitmap(Context context, Uri selectedImage) throws IOException { int MAX_HEIGHT = 1024; int MAX_WIDTH = 1024; // First decode with inJustDecodeBounds=true to check dimensions final BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; InputStream imageStream = context.getContentResolver().openInputStream(selectedImage); BitmapFactory.decodeStream(imageStream, null, options); imageStream.close(); // Calculate inSampleSize options.inSampleSize = calculateInSampleSize(options, MAX_WIDTH, MAX_HEIGHT); // Decode bitmap with inSampleSize set options.inJustDecodeBounds = false; imageStream = context.getContentResolver().openInputStream(selectedImage); Bitmap img = BitmapFactory.decodeStream(imageStream, null, options); img = rotateImageIfRequired(img, selectedImage); return img; } </code></pre> <p>Here is the <code>CalculateInSampleSize</code> method from the pre mentioned <a href="https://gist.github.com/anonymous/b7ea25fc2bbc54e43616" rel="nofollow noreferrer">source</a>:</p> <pre><code>/** * Calculate an inSampleSize for use in a {@link BitmapFactory.Options} object when decoding * bitmaps using the decode* methods from {@link BitmapFactory}. This implementation calculates * the closest inSampleSize that will result in the final decoded bitmap having a width and * height equal to or larger than the requested width and height. This implementation does not * ensure a power of 2 is returned for inSampleSize which can be faster when decoding but * results in a larger bitmap which isn't as useful for caching purposes. * * @param options An options object with out* params already populated (run through a decode* * method with inJustDecodeBounds==true * @param reqWidth The requested width of the resulting bitmap * @param reqHeight The requested height of the resulting bitmap * @return The value to be used for inSampleSize */ private static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) { // Raw height and width of image final int height = options.outHeight; final int width = options.outWidth; int inSampleSize = 1; if (height &gt; reqHeight || width &gt; reqWidth) { // Calculate ratios of height and width to requested height and width final int heightRatio = Math.round((float) height / (float) reqHeight); final int widthRatio = Math.round((float) width / (float) reqWidth); // Choose the smallest ratio as inSampleSize value, this will guarantee a final image // with both dimensions larger than or equal to the requested height and width. inSampleSize = heightRatio &lt; widthRatio ? heightRatio : widthRatio; // This offers some additional logic in case the image has a strange // aspect ratio. For example, a panorama may have a much larger // width than height. In these cases the total pixels might still // end up being too large to fit comfortably in memory, so we should // be more aggressive with sample down the image (=larger inSampleSize). final float totalPixels = width * height; // Anything more than 2x the requested pixels we'll sample down further final float totalReqPixelsCap = reqWidth * reqHeight * 2; while (totalPixels / (inSampleSize * inSampleSize) &gt; totalReqPixelsCap) { inSampleSize++; } } return inSampleSize; } </code></pre> <p>Then comes the method that will check the current image orientation to decide the rotation angle</p> <pre><code> /** * Rotate an image if required. * * @param img The image bitmap * @param selectedImage Image URI * @return The resulted Bitmap after manipulation */ private static Bitmap rotateImageIfRequired(Bitmap img, Uri selectedImage) throws IOException { ExifInterface ei = new ExifInterface(selectedImage.getPath()); int orientation = ei.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL); switch (orientation) { case ExifInterface.ORIENTATION_ROTATE_90: return rotateImage(img, 90); case ExifInterface.ORIENTATION_ROTATE_180: return rotateImage(img, 180); case ExifInterface.ORIENTATION_ROTATE_270: return rotateImage(img, 270); default: return img; } } </code></pre> <p>Finally the rotation method itself</p> <pre><code>private static Bitmap rotateImage(Bitmap img, int degree) { Matrix matrix = new Matrix(); matrix.postRotate(degree); Bitmap rotatedImg = Bitmap.createBitmap(img, 0, 0, img.getWidth(), img.getHeight(), matrix, true); img.recycle(); return rotatedImg; } </code></pre> <p>-Don't forget to vote up for those guys answers for their efforts and <em>Shirish Herwade</em> who asked this helpful question.</p>
<p>One line solution:</p> <pre><code>Picasso.with(context).load("http://i.imgur.com/DvpvklR.png").into(imageView); </code></pre> <p>Or </p> <pre><code>Picasso.with(context).load("file:" + photoPath).into(imageView); </code></pre> <p>This will autodetect rotation and place image in correct orientation</p> <p>Picasso is a very powerful library for handling images in your app includes: <strong>Complex image transformations with minimal memory use.</strong></p>
<p>You can just read the orientation of the camera sensor like indicated by Google in the documentation: <em><a href="https://developer.android.com/reference/android/hardware/camera2/CameraCharacteristics.html" rel="nofollow noreferrer">https://developer.android.com/reference/android/hardware/camera2/CameraCharacteristics.html</a></em></p> <pre><code>SENSOR_ORIENTATION Added in API level 21 Key&lt;Integer&gt; SENSOR_ORIENTATION Clockwise angle through which the output image needs to be rotated to be upright on the device screen in its native orientation. Also defines the direction of rolling shutter readout, which is from top to bottom in the sensor's coordinate system. Units: Degrees of clockwise rotation; always a multiple of 90 Range of valid values: 0, 90, 180, 270 This key is available on all devices. </code></pre> <p>Sample code:</p> <pre><code>CameraManager manager = (CameraManager) getSystemService(Context.CAMERA_SERVICE); int orientation = 0; try { String cameraId = manager.getCameraIdList()[0]; CameraCharacteristics characteristics = manager.getCameraCharacteristics(cameraId); orientation = characteristics.get(CameraCharacteristics.SENSOR_ORIENTATION); } catch (Exception e) { } </code></pre>
<p>Sadly, @jason-robinson answer above didn't work for me. </p> <p>Although the rotate function works perfectly:</p> <pre><code>public static Bitmap rotateImage(Bitmap source, float angle) { Matrix matrix = new Matrix(); matrix.postRotate(angle); return Bitmap.createBitmap(source, 0, 0, source.getWidth(), source.getHeight(), matrix, true); } </code></pre> <p>I had to do the following to get the orientation as the Exif orientation was always 0</p> <pre><code>protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode,resultCode,data); if (requestCode == RESULT_LOAD_IMAGE &amp;&amp; resultCode == RESULT_OK &amp;&amp; data != null) { Uri selectedImage = data.getData(); String[] orientationColumn = {MediaStore.Images.Media.ORIENTATION}; Cursor cur = managedQuery(imageUri, orientationColumn, null, null, null); int orientation = -1; if (cur != null &amp;&amp; cur.moveToFirst()) { orientation = cur.getInt(cur.getColumnIndex(orientationColumn[0])); } InputStream imageStream = getContentResolver().openInputStream(selectedImage); Bitmap bitmap = BitmapFactory.decodeStream(imageStream); switch(orientation) { case 90: bitmap = rotateImage(chosen_image_bitmap, 90); break; case 180: bitmap = rotateImage(chosen_image_bitmap, 180); break; case 270: bitmap = rotateImage(chosen_image_bitmap, 270); break; default: break; } imageView.setImageBitmap(bitmap ); </code></pre>
<p>The selected answer uses the most common method answered to this and similar questions. However, it does not work with both front and back cameras on Samsung. For those looking for a solution which works across both front and back cameras for Samsung and other major manufacturers, this answer by nvhausid is awesome:</p> <p><a href="http://stackoverflow.com/a/18915443/6080472">http://stackoverflow.com/a/18915443/6080472</a></p> <p>For those who don't want to click through, the relevant magic is to use the CameraInfo rather then relying on EXIF. </p> <pre><code>Bitmap realImage = BitmapFactory.decodeByteArray(data, 0, data.length); android.hardware.Camera.CameraInfo info = new android.hardware.Camera.CameraInfo(); android.hardware.Camera.getCameraInfo(mCurrentCameraId, info); Bitmap bitmap = rotate(realImage, info.orientation); </code></pre> <p>Full code in the link.</p>