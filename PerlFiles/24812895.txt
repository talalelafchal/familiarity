Mininum and maximum values for Perl hash of hashes
<p>This is a variation from another question asked on perlmonks and is similar to the problem I'm trying to figure out. I have the following hash of hashes.</p> <pre><code>%Year = ( 2007 =&gt; { ID1 =&gt; 07, ID4 =&gt; 34, ID2 =&gt; 24, ID9 =&gt; 14, ID3 =&gt; 05, }, 2008 =&gt; { ID7 =&gt; 11, ID9 =&gt; 64, ID10 =&gt; 20, ID5 =&gt; 13, ID8 =&gt; 22, } ) </code></pre> <p>I would like to find the <em>two</em> smallest and <em>two</em> largest values together with their corresponding IDs for each year. Can this be done using <a href="https://metacpan.org/module/List::Util" rel="nofollow"><code>List::Util qw (min max)</code></a>?</p> <p>Desired results:</p> <pre><code>2007 - max1:ID4,34 max2:ID2,24 min1:ID3,05 min2:ID1,07 2008 - max1:ID9,64 max2:ID10,20 min1:ID7,11 min2:ID5,13 </code></pre>
<p>Unless the lists are huge, it is probably best to find the <em>two</em> largest and <em>two</em> smallest hash values just by sorting the entire hash and picking the first two and last two elements.</p> <p>You seem to have incorrect expectations for your output. For 2008 the hash data sorted by value looks like</p> <pre><code>ID7 =&gt; 11 ID5 =&gt; 13 ID10 =&gt; 20 ID8 =&gt; 22 ID9 =&gt; 64 </code></pre> <p>so <code>max1</code> and <code>max2</code> are <code>ID9</code> and <code>ID8</code>, while <code>min1</code> and <code>min2</code> are are <code>ID7</code> and <code>ID5</code>. But your question says that you expect <code>max2</code> to be <code>ID10</code>, whose value is 20 - right in the middle of the sorted range. I think <code>max2</code> should be <code>ID8</code> which has a value of 22 - the second largest value in the 2008 hash.</p> <p>I suggest this solution to produce the output that I think you want</p> <pre><code>use strict; use warnings; use 5.010; my %year = ( 2007 =&gt; { ID1 =&gt; 7, ID2 =&gt; 24, ID3 =&gt; 5, ID4 =&gt; 34, ID9 =&gt; 14 }, 2008 =&gt; { ID10 =&gt; 20, ID5 =&gt; 13, ID7 =&gt; 11, ID8 =&gt; 22, ID9 =&gt; 64 }, ); for my $year (sort { $a &lt;=&gt; $b } keys %year) { my $data = $year{$year}; my @sorted_keys = sort { $data-&gt;{$a} &lt;=&gt; $data-&gt;{$b} } keys %$data; printf "%4d - max1:%s,%02d max2:%s,%02d min1:%s,%02d min2:%s,%02d\n", $year, map { $_ =&gt; $data-&gt;{$_} } @sorted_keys[-1,-2,0,1]; } </code></pre> <p><strong>output</strong></p> <pre><code>2007 - max1:ID4,34 max2:ID2,24 min1:ID3,05 min2:ID1,07 2008 - max1:ID9,64 max2:ID8,22 min1:ID7,11 min2:ID5,13 </code></pre>
<p>You have hashes, and <a href="http://perldoc.perl.org/List/Util.html" rel="nofollow">List::Util</a> works on lists/arrays. That disqualifies you right there since both the keys and the data are still important for you.</p> <p>It's possible to create a second hash that's keyed by the data, then I could use something from <code>List::Util</code> or <code>List::MoreUtils</code> on that to pull up the data you want, and then look up the keys for that data. However, that's a lot of work just to get the information you want.</p> <p>In reality, you're not sorting the hash of hashes, but just the data in each year. This makes the job a lot easier.</p> <p>Normally, when you sort a hash, you're sorting on the keys. However, you can specify a subroutine inside the sort command to change the way Perl sorts. Perl will hand you two items <code>$a</code> and <code>$b</code> which represents the keys to your hash. You figure out which is the bigger one, and pass that back to Perl. Perl gives you <code>&lt;=&gt;</code> for numbers and <code>cmp</code> for non-numeric data. </p> <p>All I have to do is specify <code>sort { $array{$a} cmp $array{$b} } keys %array</code> to sort by the data and not the keys. I simply toss the sorted keys into another array, then use index positioning to pull out the data I want.</p> <pre><code>#! /usr/bin/env perl use warnings; use strict; use autodie; use feature qw(say); use Data::Dumper; my %year; # # Data # $year{2007}-&gt;{ID1} = "07"; $year{2007}-&gt;{ID2} = "24"; $year{2007}-&gt;{ID3} = "05"; $year{2007}-&gt;{ID4} = "34"; $year{2007}-&gt;{ID9} = "14"; $year{2008}-&gt;{ID7} = "11"; $year{2008}-&gt;{ID9} = "64"; $year{2008}-&gt;{ID10} = "20"; $year{2008}-&gt;{ID5} = "13"; $year{2008}-&gt;{ID8} = "22"; # # For Each Year... # for my $year ( sort keys %year ) { print "$year - "; # # No need to do this dereferencing, but it makes the rest of the code cleaner # my %id_hash = %{ $year{$year} }; # # Now I sort my IDs by their data and not the key names # my @keys = sort { $id_hash{$a} cmp $id_hash{$b} } keys %id_hash; # # And print them out # print "max1:$keys[-1],$id_hash{$keys[-1]} "; print "max2:$keys[-2],$id_hash{$keys[-2]} "; print "min1:$keys[0],$id_hash{$keys[0]}, "; print "min2:$keys[1],$id_hash{$keys[1]}\n"; } </code></pre> <p>The output is:</p> <pre><code>2007 - max1:ID4,34 max2:ID2,24 min1:ID3,05, min2:ID1,07 2008 - max1:ID9,64 max2:ID8,22 min1:ID7,11, min2:ID5,13 </code></pre>
<p><strong>TIMTOWDI:</strong> You've mentioned hash of hash, so you can sort your inner hash by values and take a slice (that is first two and last two elements). </p> <pre><code>#!/usr/bin/perl use strict; use warnings; my %Year = ( 2007 =&gt; { ID1 =&gt; 7, ID2 =&gt; 24, ID3 =&gt; 5, ID4 =&gt; 34, ID9 =&gt; 14 }, 2008 =&gt; { ID10 =&gt; 20, ID5 =&gt; 13, ID7 =&gt; 11, ID8 =&gt; 22, ID9 =&gt; 64 }, ); for my $year (keys %Year) { printf "%4d - max1:%s,%02d max2:%s,%02d min1:%s,%02d min2:%s,%02d\n", $year, map { $_, $Year{$year}{$_} } ( sort { $Year{$year}{$b} &lt;=&gt; $Year{$year}{$a} } keys %{$Year{$year}} )[0,1,-1,-2]; } </code></pre> <p><strong>Output:</strong></p> <pre><code>2007 - max1:ID4,34 max2:ID2,24 min1:ID3,05 min2:ID1,07 2008 - max1:ID9,64 max2:ID8,22 min1:ID7,11 min2:ID5,13 </code></pre>