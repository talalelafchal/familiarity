How can I check whether all Perl modules are imported?
<p>Say I have a Perl module:</p> <pre><code>use Foo::Bar; sub add { return Foo::Bar::func() + Foo::Buzz::func(); } </code></pre> <p>There is an error in this module, because it forgets to <code>use Foo::Buzz</code>. This error will not always be catched by my unit tests, for example if the test for <code>Foo::Buzz</code> runs earlier and imports <code>Foo::Buzz</code> before <code>add()</code> is run. If I use this module in production code, it will fail with the error that <code>Foo::Buzz</code> is not imported.</p> <p>How can I check whether all modules that I use in the code are also imported?</p> <p>Edit: I want to check the code before deploying it in production, to avoid that any errors occur. The example will fail in production, and I want to catch the error before that, for example when I run my unit tests. I want a tool or some code that I can run before deployment that catches this error, like flake8 for python.</p>
<p>The short answer is <em>you can't</em>. Since Perl is a dynamic language, you can't check whether you load all modules before runtime as you can't check whether there are some other bugs in your code.</p> <p>You still can use some static code analysis, trying to find <code>This::Pattern</code> in files where <code>use This::Pattern;</code> is not presented, but it doesn't guarantee anything.</p>
<p>If Perl was strictly a dynamic language, you could easily check whether or not a module is installed in the program. The problem is that Perl isn't 100% dynamic. It does some compilation and part of that compilation work is done after modules are checked.</p> <p><a href="http://stackoverflow.com/a/24699674/368630">Bulrush</a> is on the right track. Unfortunately, you can use <code>use</code> clause in order to do this. <code>use</code> is checked pre-compile, so you'll get an error before your <code>eval</code> executes.</p> <p>However, there's a clue in the <a href="http://perldoc.perl.org/functions/use.html" rel="nofollow">use</a> perldoc page:</p> <blockquote> <ul> <li><strong>use Module LIST</strong></li> <li><strong>use Module</strong></li> <li><strong>use VERSION</strong><br> <br> Imports some semantics into the current package from the named module, generally by aliasing certain subroutine or variable names into your package. It is <strong><em>exactly equivalent</em></strong> to<br> <br> <strong><code>BEGIN { require Module; Module-&gt;import( LIST ); }</code></strong></li> </ul> </blockquote> <p>There you go! You can use <code>require</code> inside a <a href="http://perldoc.perl.org/perlmod.html#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END" rel="nofollow">BEGIN</a> clause which is executed even before the rest of the file is parsed. You can use your <code>eval</code> there to see if this works or not too. You need to use a <em>package</em> variable as a flag to see whether or not this worked because of the scope issues. A regular lexically scoped variable will disappear when you leave the <code>BEGIN</code> clause.</p> <pre><code>BEGIN { our $FOO_BAR_available = 0; # Must be a package variable eval { require Foo::Bar; Module-&gt;import( qw(...) ); # No need if you don't import any subroutines }; if (not $@ ) { $FOO_BAR_AVAILABLE = 0; } } </code></pre> <p>Then in your program, you'd have:</p> <pre><code>our $FOO_BAR_available; if ( not $FOO_BAR_available ) { # Here be dragons... } else { # Back to your normal code... } </code></pre> <p>The <code>our $FOO_BAR_available</code> is a bit confusing. You're not declaring this variable again, you're merely stating that you want to use this variable without prefixing it with the full package name. The variable was set in the <code>BEGIN</code> clause, and this won't affect the value.</p> <p>You can skip the use of a package variable entirely, if this module was written <em>correctly</em>. Modules are suppose to set a package variable called <code>$VERSION</code>. You can use this variable as your flag:</p> <pre><code>BEGIN { eval { require Foo::Bar; Module-&gt;import( qw(...) ); # No need if you don't import any subroutines }; } </code></pre> <p>Note I not only don't have to declare a package variable, I don't even have to verify if the <code>eval</code> statement worked or not. </p> <p>Then in your program...</p> <pre><code>if ( not $FOO::BAR::VERSION ) { # Here be dragons... } else { # Back to your normal code... } </code></pre> <p>If the module set the <code>$VERSION</code> variable, you know it loaded. Otherwise, you know the module was not loaded.</p> <hr> <h1>Addendum</h1> <blockquote> <p>I want to check the code before deploying it in production, to avoid that any errors occur. The example will fail in production, and I want to catch the error before that, for example when I run my unit tests.</p> </blockquote> <p>Here's my recommendations. It isn't as simple as running a script, but it's much better:</p> <ul> <li>First, define your production environment: What version of Perl does it have? What modules are used? This will help developers know what to expect. I know <code>Foo::Bar</code> is good, but I shouldn't use <code>Far::Bu</code> because production doesn't have that. It's the first step. I'm surprised at the number of places that have no idea what's on their production environment.</li> <li>Use <a href="http://www.vagrantup.com" rel="nofollow">Vagrant</a>. This defines a virtual machine that matches your production environment. Developers can download it to their system, and have on their desktop a copy of the production environment.</li> <li><p>Use <a href="http://jenkins-ci.org" rel="nofollow">Jenkins</a>. Jenkins is a continuous build engine. Yes, you don't compile Perl, but you can still benefit from Jenkins:</p> <ul> <li>Jenkins can run your unit tests for you. Automatic testing with each and every change in the code. You catch your errors early on.</li> <li>Your Jenkins system can match your production machines - Same Perl version, same Perl modules. If it doesn't run on your Jenkins build machine because something's not installed, there's a good chance it won't run on Production.</li> <li>You install via Jenkins. Jenkins can package your release, and you can use that to install known releases. No pulling code from a developer's system and finding out that there's something on the system that's not in your version control system. I don't know how many times I've seen a developer spool something up from their machine for production (thoroughly tested! Trust me!), and then we discover that we don't have that code in our version control system because the developer forgot to check something in.</li> </ul></li> </ul> <p>You don't normally run <code>flake8</code> in a production environment. By then, it's a wee bit late. </p> <p>Perl has a lot of nice tools that perform a similar function:</p> <ul> <li><a href="http://perlbrew.pl" rel="nofollow">Perlbrew</a>: This allows your developers to install a separate Perl program with its own CPAN module library into their development system. They can use this to match the Perl version and the modules required to the production environment. This way, they're playing with the same set of rules.</li> <li><a href="https://metacpan.org/pod/Perl::Critic" rel="nofollow">Perlcritic</a>: This checks your module against coding standard set forth by Damian Conway in his Perl Best Practices.</li> <li><a href="http://perldoc.perl.org/B/Lint.html" rel="nofollow">B::Lint</a>: This is like the old <code>lint</code> program in C and can catch coding issues.</li> </ul> <p>However, this is stuff to do before you're all set to run in Production. Use Vagrant to help developers setup their own private production environment for testing. Use Jenkins to make sure you test in a very production like environment and catch errors as soon as they happen rather than after UAT testing.</p>