Using Parallel::ForkManager in foreach loop
<p>I am just learning Perl as a fourth language.</p> <p>My wish is to use <a href="https://metacpan.org/module/Parallel%3a%3aForkManager" rel="nofollow"><code>Parallel::ForkManager</code></a> to speed up a <code>foreach</code> loop using an array whose members are taken from a text file.</p> <p>Basically I am testing a .txt file of URLs, and wish to make it so that it will test multiple members of the array at once, not one at a time (five at a time in this instance) and without spamming the same URL inadvertently DoSing it.</p> <p>Would something like this do the trick? </p> <pre><code>$limit = new Parallel::ForkManager(5); foreach (@lines) { $limit-&gt;start and next; $lines = $_; ... do processing here ... $limit-&gt;finish; } </code></pre> <p>or would it be the equivalent of running that loop 5 times making a small multithreaded DoS script?</p>
<p>To test, use a safe local process like print or write to avoid spamming the URL's. Here's a working snippet from a program I wrote that uses the fork manager.</p> <pre><code>my $pm=new Parallel::ForkManager(20); foreach $add (@adds){ $pm-&gt;start and next; #if email is invalid move on if (!defined(Email::Valid::Loose-&gt;address($add))){ writeaddr(*BADADDR, $add); #address is bad $pm-&gt;finish; } #if email is valid get domain name $is_valid = Email::Valid::Loose-&gt;address($add); if ($is_valid =~ m/\@(.*)$/) { $host = $1; } $is_valid=""; # perform dsn lookup to check domain @mx=mx($resolver, $host); if (@mx) { writeaddr(*GOODADDR, $add); #address is good }else{ writeaddr(*BADADDR, $add); #address is bad } $pm-&gt;finish; } </code></pre>
<p>It isn't too clear from the documentation, but</p> <ul> <li><p>A call to <code>start</code> will <em>block</em> in the parent process until there are fewer children running than the limit specified. Then it will return the (non-zero) child PID in the parent, and zero in the child</p></li> <li><p>A child process can see all the data in the parent process as it was when the <code>start</code> was called. The data is presumably copy-on-write, as the child may modify it but the changes aren't reflected in any other process's workspace</p></li> <li><p>The <code>$pm-&gt;start and next</code> idiom may seem a little obscure. Essentially it skips the rest of the loop if the <code>start</code> method returns a <em>true</em> value. I prefer something like <code>my $pid = $fm-&gt;start; next if $pid;</code> or the <code>if</code> construct in the code below. Both do the same thing, but I think more legibly</p></li> </ul> <p>I recommend that you experiment with this simpler application, which uses a cache of five child threads to print the numbers from zero to nine.</p> <pre><code>use strict; use warnings; use Parallel::ForkManager; STDOUT-&gt;autoflush; my $fm = Parallel::ForkManager-&gt;new(5); for my $i (0 .. 9) { my $pid = $fm-&gt;start; if ($pid == 0) { print "$i\n"; sleep 2; $fm-&gt;finish; } } </code></pre>