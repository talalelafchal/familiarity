Change formatting on paragraphs, with perl
<p>I have a number of paragraphs that have returns at the end of a line. I do not want returns at the end of lines, I will let the layout program take care of that. I would like to remove the returns, and replace them with spaces. </p> <p>The issue is that I do want returns in between paragraphs. So, if there is more than one return in a row (2, 3, etc) I would like to keep two returns.</p> <p>This would allow for there to be paragraphs, with one blank line between then, but all other formatting for lines would be removed. This would allow the layout program to worry about the line breaks, and not the have the breaks determined by a set number of characters, as they are now. </p> <p>I would like to use Perl to accomplish this change, but am open to other methods. </p> <p>example text:</p> <pre><code>This is a test. This is just a test. This too is a test. This too is just a test. </code></pre> <p>would become:</p> <pre><code>This is a test. This is just a test. This too is a test. This too is just a test. </code></pre> <p>Can this be done easily?</p>
<p>Using a perl one-liner. Replace 2 or more newlines with just 2. Strip all single newlines:</p> <pre><code>perl -0777 -pe 's{(\n{2})\n*|\n}{$1//" "}eg' file.txt &gt; newfile.txt </code></pre> <p><strong>Switches</strong>: </p> <ul> <li><code>-0777</code>: Slurps the entire file</li> <li><code>-p</code>: Creates a <code>while(&lt;&gt;){...; print}</code> loop for each &ldquo;line&rdquo; in your input file. </li> <li><code>-e</code>: Tells <code>perl</code> to execute the code on command line. </li> </ul>
<p>I came up with another solution and also wanted to explain what your regex was matching.</p> <pre><code>Matt@MattPC ~/perl/testing/8 $ cat input.txt This is a test. This is just a test. This too is a test. This too is just a test. another test. test. Matt@MattPC ~/perl/testing/8 $ perl -e '$/ = undef; $_ = &lt;&gt;; s/(?&lt;!\n)\n(?!\n)/ /g; s/\n{2,}/\n\n/g; print' input.txt This is a test. This is just a test. This too is a test. This too is just a test. another test. test. </code></pre> <hr> <p>I basically just wrote a perl program and mashed it into a one-liner. It would normally look like this.</p> <pre><code># First two lines read in the whole file $/ = undef; $_ = &lt;&gt;; # This regex replaces every `\n` by a space # if it is not preceded or followed by a `\n` s/(?&lt;!\n)\n(?!\n)/ /g; # This replaces every two or more \n by two \n s/\n{2,}/\n\n/g; # finally print $_ print; </code></pre> <hr> <pre><code>perl -p -i -e 's/(\w+|\s+)[\r\n]/$1 /g' abc.txt </code></pre> <p>Part of the problem here is what you are matching. <code>(\w+|\s+)</code> matches one of more word characters, which is the same as <code>[a-zA-Z0-9_]</code>, <strong>OR</strong> one or more whitespace characters, which is the same as <code>[\t\n\f\r ]</code>.</p> <p>This wouldn't match your input, since you aren't matching periods, and no line consists of only white space or only characters (even the blank lines would need two whitespace characters to match it, since we have <code>[\r\n]</code> at the end). Plus, neither would match a period.</p>