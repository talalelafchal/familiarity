Perl regex match optional whitespace characters
<p>I'm trying to parse/extract data from an XML file and retrieve necessary data.</p> <p>For example:</p> <pre><code>&lt;about&gt; This is an XML file that I want to extract data from &lt;/about&gt; &lt;message&gt;Hello, this is a message.&lt;/message&gt; &lt;this&gt;Blah&lt;/this&gt; &lt;that&gt;Blahh&lt;/that&gt; &lt;person&gt; &lt;name&gt;Jack&lt;/name&gt; &lt;age&gt;27&lt;/name&gt; &lt;email&gt;jack@gmail.com&lt;/email&gt; &lt;/person&gt; </code></pre> <p>I'm having trouble getting the content within the <code>&lt;about&gt;</code> tags.</p> <p>This is what I have so far:</p> <pre><code>(&lt;\w*&gt;)[\s*]?([\s*]?.*)(&lt;\/\w*&gt;)/m </code></pre> <p>I'm simply trying to extract the tag name and content, which is why I have the parentheses there. i.e. <code>($tag = $1) =~ s/[&lt;&gt;]//</code> to get the tag name, <code>$tagcontent = $2</code> to get the tag's contents. I'm using <code>\s</code> for the white-space characters (<em>space, tab, newline</em>) and the <code>?</code> because it may or may not occur <code>*</code> amount of times.</p> <p>I was testing this through <a href="http://www.regexe.com/" rel="nofollow">http://www.regexe.com/</a>, and no luck with the matching.</p> <p>Any help is appreciated. Thanks in advance!</p>
<p>XML is not a regular language and cannot be accurately parsed using regular expressions. Use an XML parser instead. That is guaranteed to work in all situations, and will not break if the format of the markup changes in the future.</p> <p>However, if you're absolutely sure of the format, you <em>could</em> get away with the following regex:</p> <pre><code>/&lt;(\w+)&gt;\s*(.*?)\s*&lt;\/\1&gt;/s </code></pre> <p>Explanation:</p> <ul> <li><code>/</code> - Starting delimiter</li> <li><code>&lt;(\w+)&gt;</code> - The opening tag</li> <li><code>\s*</code> - Match optional whitespace in between</li> <li><code>(.*?)</code> - Match the contents inside the tag</li> <li><code>\s*</code> - Match optional whitespace in between</li> <li><code>&lt;\/\1&gt;</code> - Match the closing tag. <code>\1</code> here is a backreference which contains what was matched by the first capturing group.</li> <li><code>/</code> - Ending delimiter</li> </ul> <p>Note that the <code>s</code> modifier and <code>m</code> modifier are entirely different, and do different things. See <a href="http://stackoverflow.com/a/24249564/1438393">this answer</a> for more information about what each does.</p> <p><a href="http://regex101.com/r/eO1lM2" rel="nofollow"><strong>Regex101 Demo</strong></a></p>
<p>I advise you to not try using a regular expression for parsing XML, but to instead use an actual XML Parser.</p> <p>The following uses <a href="https://metacpan.org/pod/XML%3a%3aLibXML" rel="nofollow"><code>XML::LibXML</code></a> to display the text in the 'about' node. However, another excellent framework is <a href="https://metacpan.org/pod/XML%3a%3aTwig" rel="nofollow"><code>XML::Twig</code></a>.</p> <pre><code>use strict; use warnings; use XML::LibXML; my $xml = XML::LibXML-&gt;load_xml(IO =&gt; \*DATA); my $about = $xml-&gt;findvalue('//about'); print $about, "\n"; __DATA__ &lt;root&gt; &lt;about&gt; This is an XML file that I want to extract data from &lt;/about&gt; &lt;message&gt;Hello, this is a message.&lt;/message&gt; &lt;this&gt;Blah&lt;/this&gt; &lt;that&gt;Blahh&lt;/that&gt; &lt;person&gt; &lt;name&gt;Jack&lt;/name&gt; &lt;age&gt;27&lt;/age&gt; &lt;email&gt;jack@gmail.com&lt;/email&gt; &lt;/person&gt; &lt;/root&gt; </code></pre> <p>Outputs:</p> <pre><code> This is an XML file that I want to extract data from </code></pre>