Why doesn't this Regex match in Perl?
<p>I have a string that can read something like this (although not always, numbers can vary).</p> <pre><code>Board Length,45,inches,color,board height,8,inches,black,store,wal-mart,Board weight,20,dollars </code></pre> <p>I am trying to match the 45 that follows the Board Length this regex expression.</p> <pre><code>if ($string =~/Board Length,(\d+\.\d+)/){ print $string; } </code></pre> <p>Is the formatting wrong? I thought d+ would match as many numbers as needed, . would match a literal '.', and d+ would match any numbers after the decimal (if there are any).</p>
<p>As you have put it, decimal <code>.</code> and following digits are mandatory. Thus <code>(\.\d+)?</code> to make it optional,</p> <pre><code>if ($string =~/Board Length,(\d+(?:\.\d+)?)/) </code></pre>
<p>You are absolutely right about what that should match. However, without the '?' character, you are specifying that all of those pieces must be present.</p> <pre><code>\d+\.\d+ </code></pre> <p>This means "1 or more numbers, period, 1 or more numbers"</p> <p>1.5, 253333.7, 0.0 would all be matched. However, your example uses 45, which has no "." in it, nor numbers afterward. There are a few solutions to your problem, the most full proof of which was stated above by mpapac. Allow the decimal and following digits to be optional.</p> <pre><code>(\.\d+)? </code></pre> <p>The problem with this as such is that putting a () around it makes it another capture group. You may or may not want this. Putting the ?: inside it means "Use this as a group, but don't capture it." Hence:</p> <pre><code>(?:\.\d+)? </code></pre> <p>The other option is not to do the grouping, and instead make both the decimal itself optional and the digits after the decimal ZERO or more instead of ONE or more. That would look something like this:</p> <pre><code>\d+\.?\d* </code></pre>
<p>You are not printing what you capture. You're printing <code>$_</code> which we don't know what it is.</p> <pre><code>if ($string =~/Board Length,(\d+\.\d+)/){ print $_; } </code></pre> <p>What I think you want is:</p> <pre><code>if ($string =~/Board Length,(\d+\.\d+)/){ print $1; } </code></pre>
<p>You have the following expression:</p> <pre><code>$string =~/Board Length,(\d+\.\d+) / </code></pre> <p>Your string is this:</p> <pre><code>Board Length,45,inches </code></pre> <p>The string <code>Board Length</code> will match the pattern <code>Board Length,</code>. However, the rest of our pattern is matching one or more digits followed by a period follows by one or more digits. This doesn't match the string <code>45</code>. There's no decimal there.</p> <p>The question is what are you trying to match. For example, if the number is surrounded by commas, you could do this:</p> <pre><code>$string =~ /Board Length,([^,]+),/; my $number = $1; </code></pre> <p>The <code>[^,]</code> means <em>Not a comma</em>. You're capturing everything after a comma to the next comma. This will allow you to capture <code>45</code>, <code>45.32</code>, and even <code>4.5e+10</code>. Just anything between the two commas.</p> <p>Note that you use <code>$1</code> for your first capture group and not <code>$_</code>.</p> <p>Another way is to use non-greedy matching:</p> <pre><code>$string =~ /Board Length,(.+?),/; my $number = $1; </code></pre> <p>What happens if what is captured isn't a number? You can test for that using the <code>looks_like_number</code> function from <code>Scalar::Util</code> (which has been included in Perl distributions for a long time).:</p> <pre><code>use Scalar::Util qw(looks_like_number); my $string = "Board Length,Extra long,feet,..."; ... $string =~ /Board Length,(.+?),/; my $number = $1; if ( looks_like_number( $number ) ) { print "$number is a number\n"; } else { print "Nope. $number isn't a number\n"; } </code></pre>