Replacing a class in Perl (&quot;overriding&quot;/&quot;extending&quot; a class with same name)?
<p>I am trying to <a href="http://stackoverflow.com/questions/24718700/iterate-directories-in-perl-getting-introspectable-objects-as-result">Iterate directories in Perl, getting introspectable objects as result</a>, mostly so I can print fields like <code>mtime</code> when I'm using <code>Dumper</code> on the returns from <code>IO::All</code>.</p> <p>I have discovered, that it can be done, if in the module <code>IO::All::File</code> (for me, <code>/usr/local/share/perl/5.10.1/IO/All/File.pm</code>), I add the line <code>field mtimef =&gt; undef;</code>, and then modify its <code>sub file</code> so it runs <code>$self-&gt;mtimef($self-&gt;mtime);</code> (note, this field cannot have the same name (<code>mtime</code>) as the corresponding method/property, as those are dynamically assigned in <code>IO::All</code>). So, in essence, I'm not interested in "overloading", as in having the same name for multiple function signatures - I'd want to "replace" or "override" a class with its extended version (not sure how this is properly called), but under the same name; so all other classes that may use it, get on to using the extended version from that point on. </p> <p>The best approach for me now would be, if I could somehow "replace" the <code>IO::All::File</code> class, from my actual "runnable" Perl script -- if somehow possible, by using the mechanisms for inheritance, so I can just add what is "extra". To show what I mean, here is an example:</p> <pre><code>use warnings; use strict; use Data::Dumper; my @targetDirsToScan = ("./"); use IO::All -utf8 ; # Turn on utf8 for all io # try to "replace" the IO::All::File class { # recursive inheritance! package IO::All::File; use IO::All::File -base; # hacks work if directly in /usr/local/share/perl/5.10.1/IO/All/File.pm field mtimef =&gt; undef; # hack sub file { my $self = shift; bless $self, __PACKAGE__; $self-&gt;name(shift) if @_; $self-&gt;mtimef($self-&gt;mtime); # hack return $self-&gt;_init; } 1; } # main script start my $io = io(@targetDirsToScan); my @contents = $io-&gt;all(0); # Get all contents of dir for my $contentry ( @contents ) { print Dumper \%{*$contentry}; } </code></pre> <p>... which fails with "Recursive inheritance detected in package 'IO::All::Filesys' at /usr/local/share/perl/5.10.1/IO/All/Base.pm line 13."; if you comment out the "recursive inheritance" section, it all works. </p> <p>I'm sort of clear on why this happens with this kind of syntax - however, is there a syntax, or a way, that can be used to "replace" a class with its extended version but of the same name, similar to how I've tried it above? Obviously, I want the same name, so that I wouldn't have to change anything in <code>IO::All</code> (or any other files in the package). Also, I would preferably do this in the "runner" Perl script (so that I can have everything in a single script file, and I don't have to maintain multiple files) - but if the only way possible is to have a separate <code>.pm</code> file, I'd like to know about it as well. </p> <p>So, is there a technique I could use for something like this?</p>
<p>Well, I honestly have no idea what is going on, but I poked around with the code above, and it seems all that is required, is to remove the <code>-base</code> from the <code>use IO::All::File</code> statement; and the code otherwise seems to work as I expect it - that is, the package <em>does</em> get "overriden" - if you change this snippet in the code above:</p> <pre><code># ... { # no more recursive inheritance!? IO::All::File gets overriden with this?! package IO::All::File; use IO::All::File; # -base; # just do not use `-base` here?! # hacks work if directly in /usr/local/share/perl/5.10.1/IO/All/File.pm field mtimef =&gt; undef; # hack sub file { my $self = shift; bless $self, __PACKAGE__; $self-&gt;name(shift) if @_; $self-&gt;mtimef($self-&gt;mtime); # hack print("!! *haxx0rz'd* file() reporting in\n"); return $self-&gt;_init; } 1; } # ... </code></pre> <p>I found this so unbelievable, I even added the <code>print()</code> there to make sure it is the "overriden" function that runs, and sure enough, it is; this is what I get in output:</p> <pre class="lang-none prettyprint-override"><code>... !! *haxx0rz'd* file() reporting in $VAR1 = { '_utf8' =&gt; 1, 'mtimef' =&gt; 1394828707, 'constructor' =&gt; sub { "DUMMY" }, 'is_open' =&gt; 0, 'io_handle' =&gt; undef, 'name' =&gt; './test.blg', '_encoding' =&gt; 'utf8', 'package' =&gt; 'IO::All' }; ... </code></pre> <p>... and sure enough,the field is there, as expected, too...</p> <p>Well - I hope someone eventually puts a more qualified answer here; for the time being, I hope this is as good as a fix to my problems <code>:)</code> ...</p>