Array duplicate removal program in PERL
<p>I am new to programming and i am trying the c logic to implement in perl for the array duplicate removal.</p> <p>But i am not getting required output.Can some please give pointer where did i go wrong.</p> <pre><code>#!/usr/bin/perl -w @x = (2,2,3,1); $n = 3; for ($i=0;$i&lt;$n;$i++) { for ($j=$i+1;$j&lt;$n;$j++) { if ($x[$i]=$x[$j]) { for ($k=$j;$k&lt;$n;$k++) { print " pip"; $x[$k] = $x[$k+1]; print "k = $x[$k] ,j = $x[$j]\n"; $n--; } } else { $j++; } } } print @x; </code></pre>
<p>try using a hash for this:</p> <pre><code>my %h; for my $i (@x) { $h{$i}++ } @x = (keys %h); </code></pre> <p>this puts each value of <code>@x</code> into <code>%h</code> as the key and has the number of occurences of the element as the value in %h. if you just retrieve the keys <code>(keys %h)</code>, you will have the distinct elements of <code>@x</code>, which you can then put back into <code>@x</code>.</p>
<p>Your logic looks horrendous, but I do spot that you have made a rookie mistake, which may explain your program failing:</p> <pre><code>if ($x[$i] = $x[$j]) { </code></pre> <p>Here you are using the assignment operator <code>=</code> instead of the numerical equality operator <code>==</code>. The assignment will, of course, assign the right hand parameter to the left hand parameter, which overwrites your array and corrupts your input.</p> <p>As a side note, the return value of this statement is <code>$x[$j]</code>, which may or may not be a true value, depending on your data. (for numerical data, <code>0</code> and undef will be false, all other true)</p> <p><strong>Edit:</strong></p> <p>It seems that this is not all that is wrong with your program, because it still fails. Trying to debug it does not seem like a good use of time, when deduping is so easily done in Perl, and this is a horrible way of doing it (sorry, but it is). Look at the other answers for how it is done with a hash -- make use of the fact that hash keys are unique.</p> <p>This is how the dedupe function <code>uniq</code> is implemented in <a href="https://metacpan.org/pod/List%3a%3aMoreUtils" rel="nofollow"><code>List::MoreUtils</code></a>:</p> <pre><code>sub uniq (@) { my %seen = (); grep { not $seen{$_}++ } @_; } </code></pre> <p>Quite simple, isn't it? Just return the keys which are <code>not</code> seen before.</p>
<p>it does not want to change the contents when you are referring to an element of an array is good.</p> <pre><code>@x = (2,2,3,1); @hash { @x } = 0; @x = keys %hash; print @x; </code></pre> <hr> <pre><code>#use Array::Uniq from CPAN use Array::Uniq; @x = (2,2,3,1); @x = uniq @x; #or uniq sort @x; print @x; # result:231 </code></pre>