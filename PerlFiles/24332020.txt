split numeric array at specific positions
<p>I am trying to split a numerical array into smaller arrays such that each of the smaller arrays cannot contain any numbers that differ. </p> <p>Example: The array <code>(2,2,2,2,2,9,3,3,3,3)</code> should be split into the three arrays <code>(2,2,2,2,2)</code>, <code>(9)</code> and <code>(3,3,3,3)</code>.</p> <p>Here is what I tried:</p> <pre><code>my @arr = (2,2,2,2,2,9,3,3,3,3); my @result = (); my $last = -1; my @newarr = (); for my $i (0 .. $#arr){ if ( ($i&gt;0 &amp;&amp; $arr[$i] != $last) || $i == $#arr ){ push @result, \@newarr; @newarr = (); } $last = $arr[$i]; push @newarr, $arr[$i]; } </code></pre> <p>Firstly, this code does not give me the desired result. I think my mistake is when I push the reference to <code>@newarr</code> into <code>@result</code>, but then I re-initialize <code>@newarr</code>.</p> <p>Secondly, aren't there more elegant ways to do this? I looked at the functions <code>split</code> and <code>splice</code>, but could not think of a good solution. </p>
<p>Creating an array of arrays grouped by like elements.</p> <p>For a refresher on complex data structures, check out <a href="http://perldoc.perl.org/perldsc.html" rel="nofollow"><code>perldsc</code></a>.</p> <pre><code>use strict; use warnings; my @array = (2,2,2,2,2,9,3,3,3,3); my @grouped; for (@array) { if (! @grouped || $grouped[-1][0] != $_) { push @grouped, []; } push @{$grouped[-1]}, $_; } use Data::Dump; dd @grouped; </code></pre> <p>Outputs:</p> <pre><code>([2, 2, 2, 2, 2], [9], [3, 3, 3, 3]) </code></pre>
<pre><code>use List::Util 'reduce'; my @arr = (2,2,2,2,2,9,3,3,3,3); my $result = reduce { if ( @$a &amp;&amp; $b == $a-&gt;[-1][0] ) { push @{ $a-&gt;[-1] }, $b } else { push @$a, [ $b ] } $a } [], @arr; </code></pre> <p>Simpler but maybe more confusing to read:</p> <pre><code>my $result = reduce { push @{ $a-&gt;[ @$a &amp;&amp; $b == $a-&gt;[-1][0] ? -1 : @$a ] }, $b; $a } [], @arr; </code></pre>
<p>List::MoreUtils has the "<code>part</code>" function:</p> <pre><code>use Data::Dumper; use feature 'state'; use List::MoreUtils 'part'; my @array = ( 2,2,2,2,2, 9, 3,3,3,3 ); my @part = part { state $prev; state $i = -1; $i++ if !defined($prev) || $_ ne $prev; $prev = $_; $i } @array; print Dumper @part; </code></pre> <p>With 'part', the value that the code block returns dictates the top level array index where the current value will be pushed into an anonymous array. <code>$prev</code> starts out undefined, so the first element in the input will trigger <code>$i</code> to increment to <code>0</code>, so all of the '2's will end up in <code>@{$part[0]}</code>. As soon as an element in @array doesn't match $prev, the index will be incremented, and subsequent elements end up in <code>@{$part[1]}</code>. Each time a change is detected, a new grouping starts.</p> <p><strong>Update:</strong></p> <p>If this segment of code might be used more than once, the 'state' variables will persist their values across calls. In such a case, state is more trouble than it's worth, and one should just use lexicals in a subroutine:</p> <pre><code>use Data::Dumper; use List::MoreUtils 'part'; my @array = ( 2,2,2,2,2, 9, 3,3,3,3 ); my @part = partition(@array); print Dumper \@part; sub partition { my( $prev, $i ) = ( undef, -1 ); return part { $i++ if ! defined($prev) || $_ ne $prev; $prev = $_; $i; } @_; } </code></pre>
<pre><code>my @arr = (2,2,2,2,2,9,3,3,3,3); my %h; my @newarr = map { my $ok = !$h{$_}; push @{$h{$_}}, $_; $ok ? $h{$_} : (); } @arr; use Data::Dumper; print Dumper \@newarr; </code></pre> <p>or</p> <pre><code>my @arr = (2,2,2,2,2,9,3,3,3,3); my %h; my @newarr; for my $v (@arr) { if (!$h{$v}) { push @newarr, ($h{$v} = []); } push @{$h{$v}}, $v; } </code></pre> <p>output</p> <pre><code>$VAR1 = [ [ 2, 2, 2, 2, 2 ], [ 9 ], [ 3, 3, 3, 3 ] ]; </code></pre>
<p>This will do what you ask. It works by packing the contents of the data as a set of digits and counts and then unpacks it in the required format. The output data is in <code>@num</code>. I have used <code>Data::Dump</code> only to display the resulting data structure.</p> <pre><code>use strict; use warnings; my @arr = (2,2,2,2,2,9,3,3,3,3); my (%rep, @num); $rep{$_}++ or push @num, $_ for @arr; @num = map [ ($_) x $rep{$_} ], @num; use Data::Dump; dd \@num; </code></pre> <p><strong>output</strong></p> <pre><code>[[2, 2, 2, 2, 2], [9], [3, 3, 3, 3]] </code></pre> <hr> <p><strong>Update</strong></p> <p>The above solution collects all the elements with the same value into one group, even if they came from separate sequences. If you need the output arrays to be split at every change of value then this will do what you need.</p> <pre><code>use strict; use warnings; my @arr = (2,2,2,2,2,9,9,9,2,2,2,9,9,9); my @groups; for (@arr) { push @groups, [ ] unless @groups and $_ == $groups[-1][-1]; push @{ $groups[-1] }, $_; } use Data::Dump; dd \@groups; </code></pre> <p><strong>output</strong></p> <pre><code>[[2, 2, 2, 2, 2], [9, 9, 9], [2, 2, 2], [9, 9, 9]] </code></pre> <hr> <p><strong>Update 2</strong></p> <p>Here's another version in view of your answer to <code>ikegami</code>'s comment, which revealed that a list of values and their associated counts is probably closer to what you need.</p> <pre><code>use strict; use warnings; my @arr = (2,2,2,2,2,9,9,9,2,2,2,9,9,9); my @groups; for (@arr) { if (@groups and $_ == $groups[-1][0]) { $groups[-1][1] += 1; } else { push @groups, [ $_, 1 ]; } } use Data::Dump; dd \@groups; </code></pre> <p><strong>output</strong></p> <pre><code>[[2, 5], [9, 3], [2, 3], [9, 3]] </code></pre>
<p>Mandatory regex answer:</p> <pre><code>my @result = map [ (ord) x length ], grep --$|, join( '', map chr, @arr ) =~ /((.)\2*)/sg; </code></pre> <p>(under <code>no warnings "non_unicode";</code>).</p>
<p>You can create a hash of arrays where by the key of the has will be a number. and for each time you encounter that number you can push it on to the array reference of the hash. thus all numbers will be split into arrays as you expected. you can then just iterate through the hash to print the arrays or access each array by its number.</p> <pre><code>use strict; use Data::Dumper; my @arr = (2,2,2,2,2,9,3,3,3,3); my %hash; push(@{$hash{$_}},$_) foreach (@arr); print Dumper(\%hash); </code></pre> <p>output </p> <pre><code>$VAR1 = { '3' =&gt; [ 3, 3, 3, 3 ], '9' =&gt; [ 9 ], '2' =&gt; [ 2, 2, 2, 2, 2 ] }; </code></pre>