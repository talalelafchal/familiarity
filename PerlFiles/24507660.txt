Perl: subroutine throwing error with $i
<p>Good morning, I'm having trouble using a subroutine - if I put certain code into the subroutine, it throws an error of "use of uninitialised value $i in array element". </p> <p>I have a very long script, so I will only post the bit I believe is relevant.</p> <p>The subroutine I am calling is commented out underneath &amp;exon_positive_strand (saves you scrolling down). When I remove the subroutine and uncomment the code, I get no errors. I can only imagine it is something to do with $i but I don't know what...</p> <p>Any advice would be greatly appreciated. Many thanks, Ellie</p> <pre><code>my ($value, $col, $col2, $l_o_b, $left, $matchedID, $diff_three_prime, $diff_five_prime, $sequence, @three_prime_ss, @five_prime_ss, @reverse_five, @reverse_three); my $i = 0; open (EXONS_five, '&gt;fasta_exons_five_non'); open (EXONS_three, '&gt;fasta_exons_three_non'); foreach my $match(@exonic_matches) { ## works out exon from boundary relative to correct strand direction ## if ($exon_ID[$i] !~ m/unknown/ &amp;&amp; $dupmatches[$i] == 0) { $sequence = ''; $value = $exon_ID[$i]; $col = $exon_left{$value}; $col2 = $exon_right{$value}; @three_prime_ss = split(",", $col); ##splits left column into subcolumns @five_prime_ss = split(",", $col2); ## splits right columnn into subcolumns @reverse_three = reverse(@three_prime_ss); @reverse_five = reverse(@five_prime_ss); shift(@reverse_five); if ($strands{$value} =~ m/\+/) { &amp;exon_positive_strand; # $diff_three_prime = $LBP[$i] - $three_prime_ss[$exons2{$value} - 1]; ## minus numbers denote a difference to the left (i.e. upsteam) # $diff_five_prime = $LBP[$i] - $five_prime_ss[$exons2{$value} - 1]; ## minus numbers denote a difference to the left (i.e. upsteam) # $matchedID = $ID{$LBP[$i]}; # if ($diff_three_prime !~ m/\-/ &amp;&amp; $diff_three_prime &lt;= 3) { # $BP{$LBP[$i]} =~ s/\[[ACTG]\]/$ref[$i]/i; ## putting variant into 50BP seq # $l_o_b = 20; # ##$right_of_boundary = 3; # $l_o_b = $l_o_b + $diff_three_prime; # $left = 51 - $l_o_b; # $sequence = substr($BP{$LBP[$i]}, $left, 23); # } # elsif ($diff_five_prime =~ m/\-/ &amp;&amp; $diff_five_prime &gt;= -3) { # $BP{$LBP[$i]} =~ s/\[[ACTG]\]/$ref[$i]/i; ## putting variant into 50BP seq # $l_o_b = 3; # ##$right_of_boundary = 6; # $l_o_b = $l_o_b + $diff_five_prime; # $left = 51 - $l_o_b; # $sequence = substr( $BP{$LBP[$i]}, $left, 9); } } my $seq_length = length($sequence); if ($seq_length == 9) { print EXONS_five ("&gt;" . "$match_exon{$col_exon_no[$i]}" . "\n", lc($sequence),"\n"); } elsif ($seq_length == 23) { print EXONS_three ("&gt;" . "$match_exon{$col_exon_no[$i]}" . "\n", lc($sequence),"\n"); } $i++; } close (EXONS_five); close (EXONS_three); </code></pre>
<p>You need to pass the <code>$i</code> variable to the subroutine:</p> <pre><code>exon_positive_strand($i); </code></pre> <p>and </p> <pre><code>sub exon_positive_strand { my $i = shift; ... </code></pre>
<p>"Use of uninitialized value in array element" is not an error, it's a warning. <a href="http://p3rl.org/diagnostics" rel="nofollow">Diagnostics</a> can tell you what it means:</p> <blockquote> <p>(W uninitialized) An undefined value was used as if it were already defined. It was interpreted as a "" or a 0, but maybe it was a mistake. To suppress this warning assign a defined value to your variables.</p> <p>To help you figure out what was undefined, perl will try to tell you the name of the variable (if any) that was undefined. In some cases it cannot do this, so it also tells you what operation you used the undefined value in. Note, however, that perl optimizes your program and the operation displayed in the warning may not necessarily appear literally in your program. For example, "that $foo" is usually optimized into "that " . $foo, and the warning will refer to the concatenation (.) operator, even though there is no . in your program.</p> </blockquote>