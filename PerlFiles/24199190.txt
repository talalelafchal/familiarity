Sorting an array of hashes which have alphanumeric values
<p>I am facing an issue with sorting an array of hashes; hashes having alphanumeric values by which I need to sort. </p> <p>Refer to this <a href="http://stackoverflow.com/questions/10395383/sorting-an-array-of-hash-by-multiple-keys-perl" title="Refer to this question">question</a>! My question is an extension of this problem. I tried the solution in the above question but didn't get the required output.</p> <pre><code>$arr_ref = [ { brand =&gt; "A.1", PO =&gt; "1.a", supplier =&gt; "X" }, { brand =&gt; "A.2", PO =&gt; "2.a", supplier =&gt; "X" }, { brand =&gt; "B.1", PO =&gt; "1.b", supplier =&gt; "X" }, { brand =&gt; "B.2", PO =&gt; "2.b", supplier =&gt; "X" }, { brand =&gt; "B.3", PO =&gt; "1.c", supplier =&gt; "Y" }, ] </code></pre> <p>I need to sort by Brand or PO.</p> <pre><code>#sort the array reference and place the array back into the standard_set $arr_ref = [sort by_brand @$arr_ref]; sub by_brand { $a-&gt;{brand} cmp $b-&gt;{brand} } </code></pre> <p>Complexity is the key; can start with numeric or alphabetic character. The Brand or PO can be of different size, as well. The delimiter may be a dot or hypen.</p> <p>Can we solve this depending on the input received in <code>$arr_ref</code>?</p>
<p>You were really close. You just need to remove the <code>[</code> and <code>]</code> brackets and dereference the array you want to assign to <code>@$array_ref = ...</code>.</p> <pre><code>use strict; use warnings; my $arr_ref = [ { brand =&gt; "B.3", PO =&gt; "1.c", supplier =&gt; "Y" }, { brand =&gt; "B.2", PO =&gt; "2.b", supplier =&gt; "X" }, { brand =&gt; "B.1", PO =&gt; "1.b", supplier =&gt; "X" }, { brand =&gt; "A.2", PO =&gt; "2.a", supplier =&gt; "X" }, { brand =&gt; "A.1", PO =&gt; "1.a", supplier =&gt; "X" }, ]; my @sorted = sort { $a-&gt;{brand} cmp $b-&gt;{brand} } @$arr_ref; use Data::Dump; dd @sorted; </code></pre> <p>Output:</p> <pre><code>( { brand =&gt; "A.1", PO =&gt; "1.a", supplier =&gt; "X" }, { brand =&gt; "A.2", PO =&gt; "2.a", supplier =&gt; "X" }, { brand =&gt; "B.1", PO =&gt; "1.b", supplier =&gt; "X" }, { brand =&gt; "B.2", PO =&gt; "2.b", supplier =&gt; "X" }, { brand =&gt; "B.3", PO =&gt; "1.c", supplier =&gt; "Y" }, ) </code></pre>
<p>Sort it using <a href="http://en.wikipedia.org/wiki/Schwartzian_transform" rel="nofollow">Schwartzian transform</a> and correct comparator for each field.</p> <pre><code>use strict; use warnings; use Data::Dumper; my $arr_ref = [ { brand =&gt; "A.1", PO =&gt; "1.a", supplier =&gt; "X" }, { brand =&gt; "A.2", PO =&gt; "2.a", supplier =&gt; "X" }, { brand =&gt; "B.1", PO =&gt; "1.b", supplier =&gt; "X" }, { brand =&gt; "B.2", PO =&gt; "2.b", supplier =&gt; "X" }, { brand =&gt; "B.3", PO =&gt; "1.c", supplier =&gt; "Y" }, ]; my @sorted = map $_-&gt;[0], sort { $a-&gt;[1][0] cmp $b-&gt;[1][0] or $a-&gt;[1][1] &lt;=&gt; $b-&gt;[1][1] or $a-&gt;[1][2] &lt;=&gt; $b-&gt;[1][2] or $a-&gt;[1][3] cmp $b-&gt;[1][3] } map [ $_, [ map split( /[.-]/, $_, 2 ), @$_{qw(brand PO)} ] ], @$arr_ref; print Dumper( \@sorted ); </code></pre> <p>Try use brand <code>"A.10"</code> to spot the difference.</p>
<p>Try this sort method:</p> <pre><code>sub by_brand_or_po { my ($a_ba, $a_bn) = split /\.|-/, $a-&gt;{brand}; my ($b_ba, $b_bn) = split /\.|-/, $b-&gt;{brand}; my ($a_pa, $a_pn) = split /\.|-/, $a-&gt;{PO}; my ($b_pa, $b_pn) = split /\.|-/, $b-&gt;{PO}; return( $a_ba cmp $b_ba or $a_bn &lt;=&gt; $b_bn or $a_pa cmp $b_pa or $a_pn &lt;=&gt; $b_pn ); } </code></pre> <p>It prioritizes the brand alpha over numeric over PO alpha over PO numeric, and will split over a dot or hyphen.</p>
<p>use <a href="https://metacpan.org/pod/Sort%3a%3aKey%3a%3aNatural" rel="nofollow">Sort::Key::Natural</a>!</p> <pre><code>use Sort::Key::Natural qw(natkeysort); my @sorted_by_brand = natkeysort { $_-&gt;{brand} } @data; my @sorted_by_po = natkeysort { $_-&gt;{po} } @data; </code></pre>