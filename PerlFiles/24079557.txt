Merging a list of lists of lists
<p>I have a list of lists, something like this:</p> <pre><code>[ [ 1, 2, 3 ], [ 20, 30, 40, 50 ], [ 11, 15, 17 ], [ 20, 22, 25, 27 ], [ 1, 5, 10 ], [ 1, 100 ] ] </code></pre> <p>I want to merge the inner lists where any element from one list matches any element in another. This also needs to be able to handle multiple overlaps (so in the above example 3 of the lists would be merged into one). So in this case the result would be as follows:</p> <pre><code>[ [ 1, 2, 3, 5, 10, 100 ], # 3 lists have been merged into one [ 11, 15, 17 ], # Untouched due to no overlap [ 20, 22, 25, 30, 40, 50 ], # 2 lists merged ] </code></pre> <p>Is there an obvious algorithm or Perl module to use?</p>
<p>The following is a single pass solution that does a little magic using array references.</p> <p>For <a href="http://www.perlmonks.org/?node_id=898542" rel="nofollow">this algorithm</a> by <a href="http://www.perlmonks.org/?node_id=718055" rel="nofollow">jaredor</a> and other solutions, check out perlmonks: <a href="http://www.perlmonks.org/?node_id=897418" rel="nofollow"><code>how to find combine common elements of an array?</code></a></p> <pre><code>use strict; use warnings; use List::MoreUtils qw(uniq); my @data = map {[split]} &lt;DATA&gt;; my %group = (); for my $array (@data) { my @values = map {@$_} uniq map {$group{$_} || [$_]} @$array; @group{@values} = (\@values) x @values; } @data = uniq values %group; # Resort to make things pretty @$_ = sort {$a &lt;=&gt; $b} @$_ for @data; use Data::Dump; dd @data; __DATA__ 1 2 3 20 30 40 50 11 15 17 20 22 25 27 1 5 10 1 100 </code></pre> <p>Outputs:</p> <pre><code>( [20, 22, 25, 27, 30, 40, 50], [11, 15, 17], [1, 2, 3, 5, 10, 100], ) </code></pre>
<p>Only order of sub-arrays differs,</p> <pre><code>use strict; use warnings; sub merge { my ($arr) = @_; my $i = 0; while ($i &lt; $#$arr) { my $current = $arr-&gt;[$i]; my %h; @h{@$current} = (); my @ovlap = grep { grep exists $h{$_}, @{$arr-&gt;[$_]} } ($i+1) .. $#$arr; my %seen; @$current = sort {$a &lt;=&gt; $b} grep !$seen{$_}++, (@$current, map @$_, @$arr[@ovlap]); @$arr[@ovlap] = (); @$arr = grep defined, @$arr; $i++; } return $arr; } my $arr = [ [ 1, 2, 3 ], [ 20, 30, 40, 50 ], [ 11, 15, 17 ], [ 20, 22, 25, 27 ], [ 1, 5, 10 ], [ 1, 100 ], ]; merge(merge($arr)); use Data::Dumper; print Dumper $arr; </code></pre> <p>output</p> <pre><code>$VAR1 = [ [ 1, 2, 3, 5, 10, 100 ], [ 20, 22, 25, 27, 30, 40, 50 ], [ 11, 15, 17 ] ]; </code></pre>
<p>I used hashes to find the solution. If your lists might contain repeated members, this solution reduces their numbers to 1.</p> <p>%shared represents what number is shared by what lists. Then, while there is a shared number, you merge the lists (i.e. you change the information in %shared). Once there is no shared number, you create the lists back from the hash.</p> <pre><code>#!/usr/bin/perl use warnings; use strict; use Data::Dumper; my @lists = ( [ 1, 5, 10 ], [ 10, 15, 17 ], [ 20, 22, 25, 27 ], [ 20, 30, 40, 50 ], [ 1, 2, 3 ], [ 1, 100 ], ); my %shared; for my $i (0 .. $#lists) { undef $shared{$_}{$i} for @{ $lists[$i] }; } while (my ($num) = grep 1 &lt; keys %{ $shared{$_} }, keys %shared) { my @to_merge = keys %{ $shared{$num} }; my $list = shift @to_merge; for my $merge (@to_merge) { print "Merging list $merge to $list\n"; for my $h (values %shared) { if (exists $h-&gt;{$merge}) { delete $h-&gt;{$merge}; undef $h-&gt;{$list}; } } } } my %left; undef $left{ (keys %{ $shared{$_} })[0] }{$_} for keys %shared; my @result = map [ keys %$_ ], values %left; print Dumper \@result; </code></pre>
<p>My twopence worth. Using simple looping and a cache to store position of each element in results list to save searching each time.</p> <pre><code>#! /usr/bin/perl use warnings; use strict; use Data::Dumper; my $lol = [ [ 1, 2, 3 ], [ 20, 30, 40, 50 ], [ 11, 15, 17 ], [ 20, 22, 25, 27 ], [ 1, 5, 10 ], [ 1, 100 ] ]; my @results = (); my %resultCache; sub elementInResults { my ($element) = $_[0]; # return value for cache, or search if not in cache if (!defined $resultCache{$element} ) { # search for target in destination arrays for (my $destIndex = 0; $destIndex &lt; @results; $destIndex++) { if (grep (/$element/, @{$results[$destIndex]}) &gt; 0 ) { $resultCache{$element} = $destIndex; last; } } } return $resultCache{$element}; } my $srcCount=0; # loop through source arrays for my $srcList (@$lol) { my $destIndex ; # loop through elements of array for (my $srcElementIndex=0; $srcElementIndex &lt; @$srcList; $srcElementIndex++) { $destIndex = elementInResults($srcList-&gt;[$srcElementIndex]); if (defined $destIndex ) { # element exists in an existing result array so merge print "Merging source array $srcCount into result array $destIndex, match on:" . $srcList-&gt;[$srcElementIndex] . "\n"; # remove the duplicate element from src list first splice(@$srcList,$srcElementIndex,1); # then merge into dest list push (@{$results[$destIndex]}, @$srcList); last; } $srcElementIndex++; } # if no elements in list found in existing results add list as new one to results push (@results, $srcList) if (!defined $destIndex ) ; $srcCount++; } map {@$_ = sort ({$a &lt;=&gt; $b} @$_)} @results; print Dumper \@results; </code></pre>