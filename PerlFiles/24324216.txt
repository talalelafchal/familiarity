Manipulating single and multiple word strings
<p>I have an array containing a number of names:</p> <pre><code>Fred Smith Dave Davidson John Andy Wood Robin van Persie foreach my $name ( @arrayOfNames ) { my ($first, $last) = $name =~ /(.*)\s+(.).*/; print "$first$last"; } </code></pre> <p>Using the foreach loop shown above it should print the following:</p> <pre><code>FredS DavidD John AndyW RobinvP </code></pre> <p>However, it does not handle one word names (John) or more than two word names (Robin van Persie) correctly:</p> <p>For one word names (John) I get errors as shown below</p> <pre><code>Use of uninitialized value $first in concatenation... Use of uninitialized value $last in concatenation... </code></pre> <p>And for more than two word names (Robin van Persie) it prints <code>Robin vanP</code> instead of <code>RobinvP</code></p> <p>How should it be changed to cater for these one word and more than two word names? Should one word and more than two word names be moved into a new array and then dealt with later on or can the regex be altered to cater for this?</p>
<p>Using a regular expression:</p> <pre><code>use strict; use warnings; chomp(my @names = &lt;DATA&gt;); my @abbrs = map {s/\s+(.)\S*/$1/gr} @names; use Data::Dump; dd @abbrs; __DATA__ Fred Smith Dave Davidson John Andy Wood Robin van Persie </code></pre> <p>Outputs:</p> <pre><code>("FredS", "DaveD", "John", "AndyW", "RobinvP") </code></pre> <p>Note, if using an older version of perl that doesn't support the <code>/r</code> switch, the following will work just fine:</p> <pre><code>my @abbrs = map {(my $ab = $_) =~ s/\s+(.)\S*/$1/g\; $ab} @names; </code></pre> <p>Also, another possible edge case would be <code>John Paul II</code>. Perhaps that abbreviation should equal <code>JohnPII</code>? If so, the following adjustment would take care of that <code>s/\s+(.[A-Z]*)\S*/$1/gr</code></p>
<p>You can use <a href="http://perldoc.perl.org/functions/split.html" rel="nofollow"><code>split</code></a> instead of a regex to separate the first name from the other names:</p> <pre><code>my ($first, @rest) = split; </code></pre> <p>Then <a href="http://perldoc.perl.org/functions/substr.html" rel="nofollow"><code>substr</code></a> within <a href="http://perldoc.perl.org/functions/map.html" rel="nofollow"><code>map</code></a> to extract the initials:</p> <pre><code>my @initials = map { substr $_, 0, 1 } @rest; </code></pre> <p>Then <a href="http://perldoc.perl.org/functions/join.html" rel="nofollow"><code>join</code></a> them all together:</p> <pre><code>join '', $first, @initials; </code></pre> <p>Putting it all together:</p> <pre><code>for (@arrayOfNames) { my ($first, @rest) = split; print join '', $first, map { substr $_, 0, 1 } @rest; } </code></pre>
<p>I can't think of a way to do this easily with regex, but this works:</p> <pre><code>#!/usr/bin/perl use strict; use warnings; use Data::Dumper; my @names = ('Fred Smith', 'Dave Davidson', 'John', 'Andy Wood', 'Robin van Persie'); my @abbvr = map { my ($n, @n) = split; $n .= substr($_, 0, 1) for @n; $n } @names; print Dumper @abbvr; </code></pre>