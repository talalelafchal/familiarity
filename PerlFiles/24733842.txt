Strict vs non-strict: Which instance of a named variable gets used?
<p>I am trying to find the problem and propose a solution for the following Perl code.</p> <p>A file without <code>strict</code> nor <code>warnings</code> on it has a function that uses a <code>$variable</code> without declaring it. So that variable is global to the file and the changes for that variable in this specific function are used outside of it (since it is global for the file).</p> <p>Due to a recent update, this <code>old_file</code> now <code>requires</code> a modified version of itself (<code>new_file</code>) in which the same function is defined. But this new version has <code>strict</code> and <code>warnings</code>, so the same variable is defined, but this time as 'my' in the new function, and is returned in the end.</p> <p>The tricky thing is that the code in the <code>old_file</code> did not change so it still expects the variable to be changed as its own global variable.</p> <p>Since I don't know Perl well enough to be able to determine which version of this function is used (and since I can't test it, due to IT restrictions) I need an explanation of the behavior, possibly a link to a good paper about that topic.</p> <p><strong>Code:</strong> (I think the problem is in the variable <code>LISTEREPONSE</code> from the function <code>start_handler</code>.)</p> <p>old_file:</p> <pre><code>use XML::Parser; my $parser = new XML::Parser( ErrorContext =&gt; 2 ); $parser-&gt;setHandlers( Start =&gt; \&amp;start_handler, End =&gt; \&amp;end_handler, Char =&gt; \&amp;char_handler ); $parser-&gt;parse(&lt;$remote&gt;); close $remote; ... sub start_handler { my $expat = shift; my $element = shift; print; while (@_) { my $att = shift; my $val = shift; $LISTEREPONSE .= "$att=$val&amp;"; } } </code></pre> <p>new_file:</p> <pre><code>sub start_handler { my $expat = shift; my $element = shift; print; my $LISTEREPONSE; while (@_) { my $att = shift; my $val = shift; $LISTEREPONSE .= "$att=$val&amp;"; } return $LISTEREPONSE; } </code></pre>
<p>In strict mode, if you need $LISTEREPONSE become a global variable in package(file) scope.</p> <p>Just declare (my $LISTEREPONSE;) in the beginning of file (after use).</p> <p>In second case, $LISTEREPONSE is declare in sub, it's lexical scope and only available in sub. </p> <pre><code>my $LISTEREPONSE; # ... sub some_sub { $LISTEREPONSE .= $some_stuff; } </code></pre>