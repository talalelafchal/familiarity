Using a hash data structure from an external text file with perl
<p>I'm a beginner in perl.The below script parses the value stored in the hash and throws an error if the string is not present.</p> <pre><code>#!usr/bin/perl use feature qw/say/; $hash = { 'testing' =&gt; { 'link' =&gt; "http://www.espn.com", 'bandwidth' =&gt; "100", 'r' =&gt; "2", }, }; die "'testing' not found!" unless($hash-&gt;{'testing'}); say $hash-&gt;{'testing'}-&gt;{'link'} // (die "'link' not found!"); say $hash-&gt;{'testing'}-&gt;{'bandwidth'} // (die "'bandwidth not found!"); </code></pre> <p>out put of the above program is </p> <pre><code>http://www.espn.com 100 </code></pre> <p>Now instead of specifying the value in the script i want the hash value to be stored in a txt file say hash.txt . How do i call that text file in the script.</p> <p>The below value is specified in the file hash.txt .I'm not sure how to call this file in my script. Any suggestions?</p> <pre><code>'testing' =&gt; { 'link' =&gt; "http://www.espn.com", 'bandwidth' =&gt; "100", 'r' =&gt; "2", }, </code></pre>
<p>Try something like this, which assumes that the values you want in your hash are stored in a file called <code>in.txt</code> as such:</p> <pre><code>http://www.espn.com 100 2 www.example.com 20 1 www.no_bandwith.com 1 </code></pre> <p>(Note that the 3rd entry is missing a value for bandwidth)</p> <pre><code>use strict; use warnings; open my $in, '&lt;', 'in.text' or die $!; my %data; my $line_count = 0; while (&lt;$in&gt;){ chomp; $line_count++; my @split = split(/\t/); if ($split[0] eq ''){ print "missing link for line $line_count\n"; next; } if ($split[1] eq ''){ print "missing bandwith for line $line_count\n"; next; } $data{$line_count} = [ $split[0], $split[1], $split[2] ]; } for my $line (keys %data){ my ($link, $bwidth, $r) = @{$data{$line}}; print "$link, $bwidth, $r\n"; } </code></pre> <p>output:</p> <pre><code>missing bandwith for line 3 http://www.espn.com, 100, 2 www.example.com, 20, 1 </code></pre>
<p>The core module Storable can be used to serialize data structures painlessly:</p> <pre><code>use Storable; store \%table, 'file'; $hashref = retrieve('file'); </code></pre> <p>Many of Storable's functions throw exceptions (i.e. they <code>die</code>) rather than return <code>undef</code> on failure, so I recommend using the <code>Try::Tiny</code> module if recovery is necessary--it's a lot easier than trying to tackle the headache of properly preserving $@ manually.</p> <p>It's also possible to write to write a plaintext file using <code>Data::Dumper</code>, then read it all in and <code>eval</code> it to recreate the data structure. A bit more complicated, but the resulting storage file is much more human readable than what <code>Storable</code> creates. To read it back in, you can either implement it yourself:</p> <pre><code>use autodie; # For the convenience of this example; # makes all open()s, close()s, etc die # without needing to type `or die "$!\n";' repeatedly my $serialized_hash = do { open my $fh, '&lt;', 'hash.txt'; local $/; # Undefine $/ for this scope... &lt;$fh&gt;; # so &lt;&gt; slurps up the entire file }; </code></pre> <p>or use File::Slurp (also in core, and is quite efficient)</p> <pre><code>use File::Slurp; my $serialized_hash = read_file('hash.txt'); </code></pre> <p>Then <code>eval</code> it</p> <pre><code>my %hash; eval $data; </code></pre> <p>Also if you're checking whether a key exists in a hash rather than if its value is defined, use the <code>exists</code> function, which works in tandem with <code>delete</code>.</p> <p>Sources:</p> <p><code>perldoc Storable</code></p> <p><code>perldoc -f exists</code></p>
<p>You'll want to learn the fundamentals and "in <code>CORE</code>" techniques for doing things like this and to get a good grasp of Perl the language (for storing/retrieving data structures in your situation, <code>Storable</code>is a good choice), so stick with some of the other tried and true responses in this thread. You'll eventually want to look at the various modules for working with JSON, YAML, etc. and other approaches to serializing data. </p> <p>But, just to pique your interest, here's an example of what you can do with a newish <code>perl</code> and a few CPAN modules:</p> <pre><code>#!/usr/bin/env perl use 5.10.0; use DDP; use IO::All; my $testing_hash &lt; io './testing.hash' ; my $hash = { eval $testing_hash } ; p $hash ; say $hash-&gt;{'testing'}{'link'} // (die "'link' not found!"); </code></pre> <p>Output:</p> <pre><code>\ { testing { bandwidth 100, link "http://www.espn.com", r 2 } } http://www.espn.com </code></pre> <p>CPAN modules in <code>use</code> here:</p> <ul> <li><a href="https://metacpan.org/pod/Data%3a%3aPrinter" rel="nofollow"><code>Data::Printer</code></a> for debug printing.</li> <li><a href="https://metacpan.org/pod/IO%3a%3aAll" rel="nofollow"><code>IO::All</code></a> for possibly too simple IO.</li> </ul>