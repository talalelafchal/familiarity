Perl Parsing CSV file with embedded commas
<p>I'm parsing a CSV file with embedded commas, and obviously, using split() has a few limitations due to this.</p> <p>One thing I should note is that the values with embedded commas are surrounded by parentheses, double quotes, or both... </p> <p>for example:</p> <p>(Date, Notional), "Date, Notional", "(Date, Notional)"</p> <p>Also, I'm trying to do this without using any modules for certain reasons I don't want to go into right now...</p> <p>Can anyone help me out with this?</p>
<p>This should do what you need. It works in a very similar way to the code in <a href="https://metacpan.org/module/Text%3a%3aCSV_PP" rel="nofollow"><code>Text::CSV_PP</code></a>, but doesn't allow for escaped characters within the field as you say you have none</p> <pre><code>use strict; use warnings; use 5.010; my $re = qr/(?| "\( ( [^()""]* ) \)" | \( ( [^()]* ) \) | " ( [^"]* ) " | ( [^,]* ) ) , \s* /x; my $line = '(Date, Notional 1), "Date, Notional 2", "(Date, Notional 3)"'; my @fields = "$line," =~ /$re/g; say "&lt;$_&gt;" for @fields; </code></pre> <p><strong>output</strong></p> <pre><code>&lt;Date, Notional 1&gt; &lt;Date, Notional 2&gt; &lt;Date, Notional 3&gt; </code></pre> <hr> <p><strong>Update</strong></p> <p>Here's a version for older Perls (prior to version 10) that don't have the regex branch reset construct. It produces identical output to the above</p> <pre><code>use strict; use warnings; use 5.010; my $re = qr/(?: "\( ( [^()""]* ) \)" | \( ( [^()]* ) \) | " ( [^"]* ) " | ( [^,]* ) ) , \s* /x; my $line = '(Date, Notional 1), "Date, Notional 2", "(Date, Notional 3)"'; my @fields = grep defined, "$line," =~ /$re/g; say "&lt;$_&gt;" for @fields; </code></pre>
<p>I know you already have a working solution with Borodin's answer, but for the record there is also a simple solution with split (see the results at the bottom of the <a href="http://ideone.com/q9Esr9" rel="nofollow">online demo</a>). This situation sounds very similar to <a href="http://stackoverflow.com/q/23589174">regex match a pattern unless...</a>. </p> <pre><code>#!/usr/bin/perl $regex = '(?:\([^\)]*\)|"[^"]*")(*SKIP)(*F)|\s*,\s*'; $subject = '(Date, Notional), "Date, Notional", "(Date, Notional)"'; @splits = split($regex, $subject); print "\n*** Splits ***\n"; foreach(@splits) { print "$_\n"; } </code></pre> <p><strong>How it Works</strong></p> <p>The left side of the alternation <code>|</code> matches complete <code>(parentheses)</code> and <code>(quotes)</code>, then deliberately fails. The right side matches commas, and we know they are the right commas because they were not matched by the expression on the left.</p> <p><strong>Possible Refinements</strong></p> <p>If desired, the parenthess-matching portion could be made recursive to match <code>(nested(parens))</code></p> <p><strong>Reference</strong> </p> <p><a href="http://stackoverflow.com/q/23589174">How to match (or replace) a pattern except in situations s1, s2, s3...</a></p>