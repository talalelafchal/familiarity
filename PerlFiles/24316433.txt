Is there a Python equivalent to the Perl &quot;/x&quot; modifier for regular expressions?
<p>Perl makes it easy to construct <a href="http://programmers.stackexchange.com/a/194999/24321">readable regular expressions</a> using the <code>/x</code> modifier. This modifier allows to write regular expression strings and ignore all whitespaces in these strings. In other words, logical parts of the regular expression can be separated by whitespace or even carriage returns, allowing great readability. In Python, the only way I see of doing this is to construct such regular expression string, remove whitespace from it in an intermediate step, and then use the resulting string for matching. Is there a more elegant way of doing this?</p>
<p>Yes, by setting the <a href="https://docs.python.org/2/library/re.html#re.X"><code>re.X</code> / <code>re.VERBOSE</code> flag</a>:</p> <blockquote> <p>This flag allows you to write regular expressions that look nicer. Whitespace within the pattern is ignored, except when in a character class or preceded by an unescaped backslash, and, when a line contains a <code>'#'</code> neither in a character class or preceded by an unescaped backslash, all characters from the leftmost such <code>'#'</code> through the end of the line are ignored.</p> <p>That means that the two following regular expression objects that match a decimal number are functionally equal:</p> <pre><code>a = re.compile(r"""\d + # the integral part \. # the decimal point \d * # some fractional digits""", re.X) b = re.compile(r"\d+\.\d*") </code></pre> </blockquote> <p>This is pretty much exactly like the <code>/x</code> Perl flag.</p>
<p>To add, inline modifiers can be placed within a regular expression to enforce relevant matching behavior on the given expression. In Python the inline modifiers apply to the entire regular expression, and do not support <strong>inline negate</strong> modifiers such as <code>(?-ismx)</code></p> <pre><code>pattern = re.compile(r''' (?x) \d+ (?# Some numbers) \s+ (?# Whitespace) \d+ (?# More numbers) '''); </code></pre> <p>The way around that would be to import Python's <strong>regex</strong> module in which the inline modifiers apply to the end of the group or pattern, and they can be turned on or off.</p> <pre><code>import regex pattern = regex.compile(r'(?x) \d+ (?-x)[a-z]+(?x) \d+', regex.V1) </code></pre>