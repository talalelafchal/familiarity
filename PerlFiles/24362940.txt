Multiple occurence of string in a line to be grepped
<p>I have two ques.</p> <p>1: if i have a line like this "Fruits: Mango Banana", I want to capture the "Mango Banana" part and assign it to another variable. Currently I am following this,</p> <pre><code>if(/$line == Fruits:\s(\w+)/){ myFav=$1; } </code></pre> <p>but its returning only "Mango" not "Mango Banana". Can anyone suggest how to get full Fruits list delimited by space.</p> <p>2:If I have some string repeated in the same line, I want to capture all the occurances.</p> <p>Eg: if I have a line like "I have Fruit: Mango and the color of the Fruit: Banana is green". I want to capture both Mango and Banana values as well. </p> <pre><code>if(/$line == Fruit:\s(\w+)/){ myFav=$1; } </code></pre> <p>Generally the above code stops searching after the first occurance of the "Fruit:". Can anyone help with the above two? </p> <p>Thanks in advance :)</p>
<p>Use this instead: <code>([\w\s]+)</code></p> <pre><code>if($line =~ /Fruits:\s([\w\s]+)/) { $myFav = $1; } </code></pre> <p>And always:</p> <pre><code>use strict; use warnings; </code></pre>
<pre><code>$line="I have Fruit: Mango and the color of the Fruit: Banana is green"; @found=($line=~m/Fruit: \w+/g); # Make sure to use g operator, finds all matches in $line for each $s (@found) {print "$s\n"; } </code></pre>
<p>1/ The reason why you regex only returns "Mango" is that the \w+ matches "word" characters. That is numbers, letters and the underscore (i.e. the characters that are valid in Perl symbol names). If you want to match the space between two fruit names then you'll need to add a space (or, perhaps better, \s which matches all whitespace) to your regex. You probably want to put both of those atoms in a character class.</p> <pre><code>/Fruit:\s([\w\s]+)/ </code></pre> <p>2/ By default the match operator only matches the first occurrence of the regex in the input string. In order to match all of them, you need to add the <code>/g</code> option to the match operator.</p> <pre><code>/Fruit:\s([\w\s]+)/g </code></pre> <p>Some other notes that you might find useful:</p> <ul> <li>The <a href="http://perldoc.perl.org/perlretut.html" rel="nofollow">Perl regex tutorial</a> is a good way to learn this stuff</li> <li>The <a href="http://perldoc.perl.org/perlre.html" rel="nofollow">Perl regex documentation</a> has all the gory details.</li> <li>The <a href="http://perldoc.perl.org/perlop.html" rel="nofollow">Perl operator documentation</a> explains the match operator.</li> <li>Adding <code>use strict</code> and <code>use warnings</code> to all of your code is a good habit to get into.</li> <li><p>You match a string again a regex using the binding operator (<code>=~</code>) not the assignment operator (<code>=</code>). And the input string and the binding operator go outside the match operator.</p> <p>if($line =~ /Fruits:\s(\w+)/){</p></li> </ul>
<p>One solution would be to rely on the fact that your fruit names are capitalized.</p> <p>However, I'd be tempted to lean toward having two regular expressions, one for Fruits and one for Fruit.</p> <pre><code>use strict; use warnings; while (&lt;DATA&gt;) { chomp; while (/Fruits?: ((?:[A-Z]\w*\s*)+)(?&lt;!\s)/g) { print "Line $. - '$1'\n"; } } __DATA__ Fruits: Mango Banana I have Fruit: Mango and the color of the Fruit: Banana is green </code></pre> <p>Outputs:</p> <pre><code>Line 1 - 'Mango Banana' Line 2 - 'Mango' Line 2 - 'Banana' </code></pre>
<p>In your first post, you're using:</p> <pre><code>if ( /$line == Fruits:\s(\w+)/ ) { </code></pre> <p>First, you should use <code>~=</code> instead of <code>==</code> for regular expressions. Second, you put the slashes around the regular expressions like this:</p> <pre><code>if ( $line ~= /Fruits:\s(\w+)/ ) { </code></pre> <p>Now, the <code>\w+</code> is for a <em>word</em> which includes letters, numbers, underscores and that's it. It doesn't match spaces.</p> <p>You have:</p> <pre><code>Fruits: Mango Banana </code></pre> <p>So, <code>\w+</code> will match <code>Mango</code>, but will stop matching the space after <code>Mango</code>.</p> <p>If you want to match both:</p> <pre><code>if ( $line =~ /^Fruits:\s+(.+)/ ) { </code></pre> <p>Note the <code>.</code> will match any character including a space. The plug sign means match at least one space. An asterisk matches zero or more. Note I also use <code>\s+</code> instead of just <code>\s</code>. This way, if there's more than one space after <code>Fruits</code>, you'll have a match.</p> <p>In your second example, you can do this:</p> <pre><code>my @fruits = $line =~ /Fruits:\s+(\S+)/g </code></pre> <p>The <code>g</code> on the end allows for multiple matches. Otherwise, only the first will be used. The <code>\S</code> represents all non-white space which will included possible dashes. This will put your matches into the array <code>@fruits</code>. Read the <a href="http://perldoc.perl.org/perlretut.html" rel="nofollow">Regular Expression Tutorial</a>. It'll help you understand what's going on a bit better.</p> <p>Always use <code>use strict;</code> and <code>use warnings;</code> in your program. It'll help you catch errors. You will have to declare variables with <code>my</code>, but it's worth it.</p>