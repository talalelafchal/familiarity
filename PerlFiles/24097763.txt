perl's Devel::ebug how to
<p>First I would like to apologize if I misunderstood the whole concept of <a href="http://search.cpan.org/~awwaiid/Devel-ebug-0.56/lib/Devel/ebug.pm" rel="nofollow">Devel::ebug</a> and how it should be used. So I want do some experiment with Devel::ebug perl module. Here I found some example: <a href="http://www.nntp.perl.org/group/perl.beginners/2008/03/msg99151.html" rel="nofollow">What is the perl equivalent of a bash -xv</a> So I took following code and modified it a little bit. According to official documentation <a href="http://search.cpan.org/~awwaiid/Devel-ebug-0.56/lib/Devel/ebug.pm#program" rel="nofollow">Devel::ebug CPAN</a> the program method selects which program to load, so this is only thing that I've changed.</p> <pre><code>#!/usr/bin/perl use strict; use warnings; use Devel::ebug; use Data::Dumper; my $ebug = Devel::ebug-&gt;new; # $ebug-&gt;program(shift); # OLD VALUE: $ebug-&gt;program($ARGV[0]); # NEW VALUE: $ebug-&gt;load; until ($ebug-&gt;finished) { print "+++ file:", $ebug-&gt;filename, " line: ", $ebug-&gt;line, "\n"; my $pad = $ebug-&gt;pad; for my $var (sort keys %$pad) { if (ref $pad-&gt;{$var}) { for my $line (split /\n/, Data::Dumper-&gt;Dump([$pad-&gt;{$var}], [$var])) { print "++ $line\n"; } } else { print "++ $var = $pad-&gt;{$var}\n"; } } for my $line ($ebug-&gt;codelines($ebug-&gt;line-3 .. $ebug-&gt;line-1)) { next unless defined $line; print "+ $line\n"; } print "+&gt; ", $ebug-&gt;codeline, "\n"; for my $line ($ebug-&gt;codelines($ebug-&gt;line+1 .. $ebug-&gt;line+3)) { next unless defined $line; print "+ $line\n"; } $ebug-&gt;step; } </code></pre> <p>Then I saved this file as: stacktrace.pl in the same directory I have also file: debugme.pl from <a href="http://www.nntp.perl.org/group/perl.beginners/2008/03/msg99151.html" rel="nofollow">What is the perl equivalent of a bash -xv</a> page. But instead of output mentioned on <a href="http://www.nntp.perl.org/group/perl.beginners/2008/03/msg99151.html" rel="nofollow">What is the perl equivalent of a bash -xv</a> page I get this:</p> <pre><code>&gt; ./stacktrace.pl debugme.pl ./stacktrace.pl: exec failed: No such file or directory at /home/wakatana/perl5/lib/perl5/Devel/ebug.pm line 41 Could not connect: Connection refused at /home/wakatana/perl5/lib/perl5/Devel/ebug.pm line 71. </code></pre> <p>Some further debugging pointed me to this:</p> <pre><code>Proc::Background::Unix::_new(/home/wakatana/perl5/lib/perl5/Proc/Background/Unix.pm:47): 47: if ($pid = fork()) { DB&lt;7&gt; s Proc::Background::Unix::_new(/home/wakatana/perl5/lib/perl5/Proc/Background/Unix.pm:49): 49: $self-&gt;{_os_obj} = $pid; ######### Forked, but do not know how to create a new TTY. ######### Since two debuggers fight for the same TTY, input is severely entangled. I know how to switch the output to a different window in xterms, OS/2 consoles, and Mac OS X Terminal.app only. For a manual switch, put the name of the created TTY in $DB::fork_TTY, or define a function DB::get_fork_TTY() returning this. On UNIX-like systems one can get the name of a TTY for the given window by typing tty, and disconnect the shell from TTY by sleep 1000000. Proc::Background::Unix::_new(/home/wakatana/perl5/lib/perl5/Proc/Background/Unix.pm:54): 54: exec @_ or croak "$0: exec failed: $!\n"; </code></pre> <p>First I assumed that it was because I run this under the GNU screen and somehow it is unable to create new TTY. But it is not the problem. What I am missing here?</p> <p>PS: Seems the problem occurs when working with Proc::Background::Unix module so above output I obtained using following debugger command:</p> <pre><code>b Proc::Background::Unix::_new c </code></pre> <p>EDIT: Regarding to @Chankey Pathak comment. I issued this commands under terminator. Under xterm the situation is the same:</p> <pre><code>&gt; echo $$ 18548 &gt; ps -elf | grep 18548 0 S wakatana 18548 18546 0 80 0 - 6296 - 16:09 pts/5 00:00:00 bash 0 R wakatana 18990 18548 0 80 0 - 4209 - 16:10 pts/5 00:00:00 ps -elf 0 R wakatana 18991 18548 0 80 0 - 1958 - 16:10 pts/5 00:00:00 grep 18548 &gt; ps -elf | grep 18546 0 S wakatana 18546 18254 0 80 0 - 17220 - 16:09 pts/3 00:00:00 xterm 0 S wakatana 18548 18546 0 80 0 - 6296 - 16:09 pts/5 00:00:00 bash 0 R wakatana 19004 18548 0 80 0 - 1959 - 16:10 pts/5 00:00:00 grep 18546 &gt; perl stacktrace.pl debugme.pl stacktrace.pl: exec failed: No such file or directory at /home/wakatana/perl5/lib/perl5/Devel/ebug.pm line 41 Could not connect: Connection refused at /home/wakatana/perl5/lib/perl5/Devel/ebug.pm line 71. </code></pre> <p>EDIT2: I have cross-posted this also on <a href="http://www.perlmonks.org/?node_id=1089145" rel="nofollow">perlmonks</a></p>
<p>Okay, Devel::ebug works like this: There's a controlling process that listens on sockets (that's the script you pasted above) and does the "user interface" bit of the debugger. Then there's the script you're trying to debug, which the controlling process launches and tells it to load the Devel::ebug debugger and as that script executes it talks to the controlling script via the sockets to work out what do as it's debbuging.</p> <p>I think the problem is because the controlling Deve::ebug is having issues executing your program to debug. Looking around line 41 of Devel::ebug we see:</p> <pre><code>my $backend = $self-&gt;backend || "$Bin/ebug_backend_perl"; my $command = "$backend $program";; my $proc = Proc::Background-&gt;new( {'die_upon_destroy' =&gt; 1}, $command ); </code></pre> <p>It looks like <code>-&gt;backend</code> should contain the path to something that'll execute your script with the right command line flags in order for it to start up the in process debugger configured to talk over sockets to the controlling program you included above.</p> <p>There's the <a href="https://metacpan.org/source/AWWAIID/Devel-ebug-0.56/bin/ebug_backend_perl" rel="nofollow">ebug_backend_perl</a> that was installed with the module that seems to handle this job for you. I think you should <code>$ebug-&gt;backend($path)</code> to be where that is (which if I'm guessing right probably is <code>/home/wakatana/perl5/bin/ebug_backend_perl</code> on your system) before calling <code>$ebug-&gt;load</code></p>