Creating CSV of information extracted from filenames in a given format
<p>I have a little script that lists paths to all files in a directory and all subdirectories and parses each path on the list with regex in Perl.</p> <pre><code>#!/bin/sh find * -type f | while read j; do echo $j | perl -n -e '/\/(\d{2})\/(\d{2})\/(\d+).*-([a-zA-Z]+)(?:_(\d{1}))?/ &amp;&amp; print "\"0\";\"$1$2$3\";\"$4\";\"$5\";$fl\""' &gt;&gt; bss.csv echo | readlink -f -n "$j" &gt;&gt;bss.csv echo \"&gt;&gt;bss.csv done </code></pre> <p>Output:</p> <pre><code>"0";"13957";"4121113";"2";"/home/root/dir1/bss/164146/13/95/7___/000240216___Abc-4121113_2.jpg" </code></pre> <p>I am using the <code>readlink</code> from GNU coreutils: <code>-n</code> suppresses newline at the end, <code>-f</code> performs canonicalization by recursively following symlinks on the path.</p> <p>Problem is, when input string did not pass regex I have only line with file path.</p> <p>How can I add condition to check if regex passed - show path, else - no. I broke my brain with various combinations, but didn't find any that work properly.</p>
<h1>Description of solution</h1> <p>In Perl, use <code>if (/…/) {…} else {…}</code> instead of <code>/…/ &amp;&amp; …</code>. Thus you can execute print if match is successful and some other code otherwise.</p> <p>If this is not the problem and you only want to get rid of the <code>readlink</code> output and closing quote, you can call <code>readlink</code> from Perl using backticks.</p> <h1>Resulting code</h1> <p>I turned everything into a single Perl program, used <code>File::Find</code> instead of <code>find</code> command, assumed <code>$fl</code> at the end of <code>print</code> in Perl is a relict (ignored it) and used <code>Cwd::realpath()</code> to find canonical path of the file instead of <code>readlink -f</code> from GNU coreutils. If you still want to use <code>readlink -f</code>, feel free to change <code>Cwd::realpath($_)</code> to <code>`readlink -f '$_'`</code> (including the backticks!), but then it will not work for filenames containing a single-quote.</p> <p>You should call this script as <code>./script-name starting-directory &gt; bss.csv</code>. If you put it in the directory you are examining, the output would contain it too, along with the <code>bss.csv</code>.</p> <pre><code>#!/usr/bin/perl # Usage: ./$0 [&lt;starting-directory&gt;...] use strict; use warnings; use File::Find; use Cwd; no warnings 'File::Find'; sub handleFile() { return if not -f; if ($File::Find::name =~ /\/(\d{2})\/(\d{2})\/(\d+).*-([a-zA-Z]+)(?:_(\d{1}))?/) { local $, = ';', $\ = "\n"; print map "\"$_\"", 0, $1.$2.$3, $4, $5, Cwd::realpath($_); } else { print STDERR "File $File::Find::name did not match\n"; } } find(\&amp;handleFile, @ARGV ? @ARGV : '.'); </code></pre> <p>For reference I also enclose polished version of the original program. It is calling <code>readlink</code> from Perl as I suggested above and really utilizes the <code>-n</code> option of Perl, avoiding the <code>while read</code> loop.</p> <pre><code>#!/bin/sh find . -type f | perl -n -e 'm{/(\d{2})/(\d{2})/(\d+).*-([a-zA-Z]+)(?:_(\d{1}))?} &amp;&amp; print qq{"0";"$1$2$3";"$4";"$5";"`readlink -f -n '\''$_'\''`"}' &gt; bss.csv </code></pre> <h1>Other remarks to the original code</h1> <ul> <li>The <code>echo |</code> before the <code>readlink</code> does nothing and should be removed. Readlink does not read its stdin.</li> <li>Where does <code>$fl</code> at the end of <code>print</code> in Perl come from? I assume it is a relict.</li> <li>Use of generic quotes like <code>qq{}</code> and thoughtful use of delimiters (e.g. in regex matching and other quote-like operators) can save you from quoting hell. <em>I already used this tip above: <code>/…/</code> → <code>m{…}</code> and <code>"…"</code> → <code>qq{…}</code>. Thx, <a href="http://stackoverflow.com/users/2884483/slade">Slade</a>!</em> See <a href="http://perldoc.perl.org/perlop.html#Quote-and-Quote-like-Operators" rel="nofollow">perlop</a> manpage for more info.</li> </ul>
<p>If I understand you, you want to capture the following parts of the filename:</p> <pre><code>/home/root/dir1/bss/164146/13/95/7___/000240216___Abc-4121113_2.jpg ~~ ~~ ~ ~~~ ~~~~~~~ ~ 1 2 3 4 5 6 </code></pre> <p>But your perl regex doesn't do that. Let's break it apart for better understanding.</p> <pre><code>/\/(\d{2})\/(\d{2})\/(\d+).*-([a-zA-Z]+)(?:_(\d{1}))?/ </code></pre> <p>Sliced into pieces, this would be...</p> <ul> <li><code>\/(\d{2})</code> - a slash then two digits (with the digits captured)</li> <li><code>\/(\d{2})</code> - another slash and two digits</li> <li><code>\/(\d)</code> - one more slash and any number of digits</li> <li><code>.*-</code> - any run of characters until the final hyphen in the input string</li> <li><code>([a-zA-Z]+)</code> - one or more alpha characters</li> <li><code>(?:_(\d{1}))?</code> - nonsensical (I think) construct matching an optional single digit that won't be captured (because it's inside a <code>(?:...)</code>)</li> </ul> <p>If you step through your filename, you'll see that there is nothing here to handle the second last string of digits.</p> <p>I'd do this using simpler tools. Sed, for example:</p> <pre><code>[ghoti@pc ~]$ s="/home/root/dir1/bss/164146/13/95/7___/000240216___Abc-4121113_2.jpg" [ghoti@pc ~]$ echo "$s" | sed -rne 's/.*/"&amp;"/;h;s:.*/([0-9]{2})/([0-9]{2})/([0-9]+)[^[a-zA-Z]]*[^-]+-([0-9]+)(_([0-9]+))?.*:"0";"\1\2\3";"\4";"\6":;G;s/\n/;/;p' "0";"13957";"4121113";"2";"/home/root/dir1/bss/164146/13/95/7___/000240216___Abc-4121113_2.jpg" [ghoti@pc ~]$ </code></pre> <p>I'll break up the sed script for easier reading:</p> <ul> <li><code>s/.*/"&amp;"/;</code> - Put quotes around the filename.</li> <li><code>h;</code> - Store the filename in Sed's "hold" space, for future use...</li> <li><code>s:</code> - Start the big substitution... <ul> <li><code>.*/([0-9]{2})/([0-9]{2})/([0-9]+)[^[a-zA-Z]]*[^-]+-([0-9]+)(_([0-9]+))?.*</code> - This is the pattern we want to match for substitution. Similar to what you did in Perl, obviously, but using ERE instead of PCRE.</li> <li><code>:"0";"\1\2\3";"\4";"\6":;</code> - The replacement pattern, with <code>\n</code> being replaced by the bracketed elements of the RE. Note that <code>\5</code> is skipped in the replace string, as that subexpression is only being used for the match.</li> </ul></li> <li><code>G;</code> - Append the "hold" space to the pattern space</li> <li><code>s/\n/;/;</code> - and remove the newline between them.</li> <li><code>p</code> - Print the result.</li> </ul> <p>Note that this solution, as is, assumes that all input lines match the pattern you're looking for. If that's not the case, then you may get unpredictable output, and should put some pattern matching into the script.</p>