UTF-8 with diamond operator (&lt;&gt;), part II (stdin and regex)
<p>I have seen <a href="http://stackoverflow.com/questions/519309/how-do-i-read-utf-8-with-diamond-operator">How do I read UTF-8 with diamond operator (&lt;&gt;)?</a>, unfortunately nothing in there helps me. Consider this code, <code>test.pl</code>:</p> <pre><code>use 5.010; use warnings; use strict; use utf8; # tell Perl that your script is written in UTF-8? binmode(STDOUT, ":raw"); binmode(STDIN, ":raw"); #~ use open IO =&gt; ':raw'; # nope use open qw(:std :utf8); # nope? use Data::Dumper; my $reValidLine = qr/^[├│└]/; my $line2 = "│   ├── [dr"; my @matches = $line2 =~ $reValidLine; print Dumper(\@matches); while(&lt;&gt;) { binmode ARGV, ':utf8'; my $line = $_; my @imatches = $line =~ $reValidLine; print Dumper(\@imatches); } </code></pre> <p>If I call this from <code>bash</code> command line, I get this:</p> <pre><code>$ echo "│   ├── [dr" | perl test.pl $VAR1 = [ 1 ]; $VAR1 = []; </code></pre> <p>Note that I'm piping (via <code>echo</code>) into perl's stdin, the exact same string which is <code>$line2</code> in the perl code; and the very same regex matches <code>$line2</code> - but does <em>not</em> match the same string when it comes from stdin?</p> <p>Just for confirmation, here is what <code>hexdump</code> and <a href="http://sourceforge.net/p/sdaaubckp/code/HEAD/tree/single-scripts/utfinfo.pl" rel="nofollow">utfinfo.pl</a> report in the very same shell:</p> <pre><code>$ echo "│   ├── [dr" | hexdump -C 00000000 e2 94 82 c2 a0 c2 a0 20 e2 94 9c e2 94 80 e2 94 |....... ........| 00000010 80 20 5b 64 72 0a |. [dr.| 00000016 $ echo "│   ├── [dr" | perl utfinfo.pl Got 11 uchars Char: '│' u: 9474 [0x2502] b: 226,148,130 [0xE2,0x94,0x82] n: BOX DRAWINGS LIGHT VERTICAL [Box Drawing] Char: ' ' u: 160 [0x00A0] b: 194,160 [0xC2,0xA0] n: NO-BREAK SPACE [Latin-1 Supplement] Char: ' ' u: 160 [0x00A0] b: 194,160 [0xC2,0xA0] n: NO-BREAK SPACE [Latin-1 Supplement] Char: ' ' u: 32 [0x0020] b: 32 [0x20] n: SPACE [Basic Latin] Char: '├' u: 9500 [0x251C] b: 226,148,156 [0xE2,0x94,0x9C] n: BOX DRAWINGS LIGHT VERTICAL AND RIGHT [Box Drawing] Char: '─' u: 9472 [0x2500] b: 226,148,128 [0xE2,0x94,0x80] n: BOX DRAWINGS LIGHT HORIZONTAL [Box Drawing] Char: '─' u: 9472 [0x2500] b: 226,148,128 [0xE2,0x94,0x80] n: BOX DRAWINGS LIGHT HORIZONTAL [Box Drawing] Char: ' ' u: 32 [0x0020] b: 32 [0x20] n: SPACE [Basic Latin] Char: '[' u: 91 [0x005B] b: 91 [0x5B] n: LEFT SQUARE BRACKET [Basic Latin] Char: 'd' u: 100 [0x0064] b: 100 [0x64] n: LATIN SMALL LETTER D [Basic Latin] Char: 'r' u: 114 [0x0072] b: 114 [0x72] n: LATIN SMALL LETTER R [Basic Latin] </code></pre> <p>So, both of them confirm the same bytes as for the right utf-8 characters.</p> <p>Then, why doesn't the Perl regex match the string when its piped from stdin, and how do I get it to match? </p>
<p>Well, got it to work with this change:</p> <pre><code>binmode(STDOUT, ":utf8"); binmode(STDIN, ":utf8"); </code></pre> <p>... now I have:</p> <pre><code>$ echo "│   ├── [dr" | perl test.pl $VAR1 = [ 1 ]; $VAR1 = [ 1 ]; </code></pre> <p>... which is what I expected; unfortunately I cannot provide much understanding about reasons behind this <code>:)</code> Still, hope it might help someone... </p>
<p>The problem with doing this inside your <code>while</code> loop:</p> <pre><code>binmode ARGV, ':utf8'; </code></pre> <p>is that it's too late. By the time that <code>binmode</code> has executed, you've already read the first line from the filehandle. (And this particular filehandle only has one line!)</p> <p>Try adding a new line character to the input and you'll see that the <code>binmode</code> does actually work for the subsequent lines.</p> <pre><code>echo "\n│ ├── [dr" | perl test.pl </code></pre> <p>Lifting <code>binmode ARGV, ':utf8'</code> out of the <code>while</code> loop won't work though because at that point the special <code>ARGV</code> filehandle won't have been opened.</p> <p>Personally I'd solve this by reading the handle in <code>raw</code> mode and using the Encode module to decode the UTF-8.</p>