Perl sort genomic positions
<p>I have a list of genomic positions in the format chromosome:start-end</p> <p>for example</p> <pre><code>chr1:100-110 chr1:1000-1100 chr1:200-300 chr10:100-200 chr2:100-200 chrX:100-200 </code></pre> <p>I want to sort this by chromosome number and numerical start position to get this:</p> <pre><code>chr1:100-110 chr1:200-300 chr1:1000-1100 chr2:100-200 chr10:100-200 chrX:100-200 </code></pre> <p>What is a good and efficient way to do this in perl?</p>
<p>You can sort this by providing a custom comparator. It appears that you want a two level value as the sorting key, so your custom comparator would derive the key for a row and then compare that:</p> <pre><code># You want karyotypical sorting on the first element, # so set up this hash with an appropriate normalized value # per available input: my %karyotypical_sort = ( 1 =&gt; 1, ... X =&gt; 100, ); sub row_to_sortable { my $row = shift; $row =~ /chr(.+):(\d+)-/; # assuming match here! Be careful return [$karyotypical_sort{$1}, $2]; } sub sortable_compare { my ($one, $two) = @_; return $one-&gt;[0] &lt;=&gt; $two-&gt;[0] || $one-&gt;[1] &lt;=&gt; $two-&gt;[1]; # If first comparison returns 0 then try the second } @lines = ... print join "\n", sort { sortable_compare(row_to_sortable($a), row_to_sortable($b)) } @lines; </code></pre> <p>Since the calculation would be slightly onerous (string manipulation is not free) and since you are probably dealing with a lot of data (genomes!) it is likely you will notice improved performance if you perform a <a href="https://en.wikipedia.org/wiki/Schwartzian_transform" rel="nofollow">Schwartzian Transform</a>. This is performed by precalculating the sort key for the row and then sorting using that and finally removing the additional data:</p> <pre><code>@st_lines = map { [ row_to_sortable($_), $_ ] } @lines; @sorted_st_lines = sort { sortable_compare($a-&gt;[0], $b-&gt;[0]) } @st_lines; @sorted_lines = map { $_-&gt;[1] } @sorted_st_lines; </code></pre> <p>Or combined:</p> <pre><code>print join "\n", map { $_-&gt;[1] } sort { sortable_compare($a-&gt;[0], $b-&gt;[0]) } map { [ row_to_sortable($_), $_ ] } @lines; </code></pre>
<p>It looks to me like you want to sort in order of the following:</p> <ol> <li>By Chromosome Number</li> <li>Then by the Start Position</li> <li>Then (maybe) by the End Position.</li> </ol> <p>So, perhaps a custom sort like this:</p> <pre><code>use strict; use warnings; print sort { my @a = split /chr|:|-/, $a; my @b = split /chr|:|-/, $b; "$a[1]$b[1]" !~ /\D/ ? $a[1] &lt;=&gt; $b[1] : $a[1] cmp $b[1] or $a[2] &lt;=&gt; $b[2] or $a[3] &lt;=&gt; $b[3] } &lt;DATA&gt;; __DATA__ chr1:100-110 chr1:1000-1100 chr1:200-300 chr10:100-200 chr2:100-200 chrX:100-200 chrY:100-200 chrX:1-100 chr10:100-150 </code></pre> <p>Outputs:</p> <pre><code>chr1:100-110 chr1:200-300 chr1:1000-1100 chr2:100-200 chr10:100-150 chr10:100-200 chrX:1-100 chrX:100-200 chrY:100-200 </code></pre>
<p>You could do something like this the following script, which takes a text file given your above input. The sorting on the chromosome number would need to change a bit because it's not purely lexical or numerical. But i'm sure you could tweak what I have below:</p> <pre><code>use strict; my %chromosomes; while(&lt;&gt;){ if ($_ =~ /^chr(\w+):(\d+)-\d+$/) { my $chr_num = $1; my $chr_start = $2; $chromosomes{$1}{$2} = $_; } } my @chr_nums = sort(keys(%chromosomes)); foreach my $chr_num (@chr_nums) { my @chr_starts = sort { $a &lt;=&gt; $b }(keys(%{$chromosomes{$chr_num}})); foreach my $chr_start (@chr_starts) { print "$chromosomes{$chr_num}{$chr_start}"; } } 1; </code></pre>
<p>There is a similar question asked and answered here:</p> <p><a href="http://stackoverflow.com/questions/11102518/how-to-do-alpha-numeric-sort-perl">How to do alpha numeric sort perl?</a></p> <p>What you are likely looking for is a general numeric sort, like using <code>sort -g</code>.</p>
<p>Just use the module <a href="https://metacpan.org/pod/Sort::Key::Natural" rel="nofollow"><code>Sort::Keys::Natural</code></a>:</p> <pre><code>use strict; use warnings; use Sort::Key::Natural qw(natsort); print natsort &lt;DATA&gt;; __DATA__ chr1:100-110 chr1:1000-1100 chr1:200-300 chr10:100-200 chr2:100-200 chrX:100-200 chrY:100-200 chrX:1-100 chr10:100-150 </code></pre> <p>Outputs:</p> <pre><code>chr1:100-110 chr1:200-300 chr1:1000-1100 chr2:100-200 chr10:100-150 chr10:100-200 chrX:1-100 chrX:100-200 chrY:100-200 </code></pre>