perl overload file name download
<p>I need to be able to propose files to be downloaded but i have to read and print the file in my CGI. I tried to go for :</p> <pre><code>#!/usr/bin/perl -w use strict; push( @INC, $lib_directory ); require 'lib_utils.pl'; dl_file('/tmp/final.pdf'); </code></pre> <p>as main page (dl.pl) and</p> <pre><code>sub dl_file { my ($file) = @_; if ( ! -e $file) { print "file does not exist"; return 0; } my $content = read_file( $file, binmode =&gt; ':utf8' ) ; $file =~ m#(.*)([^/]*)$#; my $directory = $1; my $filename = $2; chdir $directory; my $form = new CGI; print $form-&gt;header( -type =&gt; 'application/octet-stream', -attachment =&gt; $filename, -filename =&gt; $filename, -Content-Disposition =&gt; "attachment; filename=$filename", ); $form-&gt;print($content); return 1; } </code></pre> <p>for the called function. Funny thing is, this code workes just fine if i dont go for a sub and have all the code in dl.pl BUT as soon as i move the code in a sub, the downloaded file is called after the script (ie dl.pl)</p> <p>How would you change it or how would you do ? Thanks in advance for your help</p>
<p>Your line</p> <pre><code>$file =~ m#(.*)([^/]*)$# </code></pre> <p>will leave <code>$1</code> containing the whole of <code>$file</code> and <code>$2</code> empty. You need a slash in there somewhere, probably like this</p> <pre><code>$file =~ m#(.*)/([^/]*)$# </code></pre> <p>It would also make sense to make the directory optional, like so</p> <pre><code>$file =~ m#(?:(.*)/)?([^/]*)$# my $directory = $1; </code></pre> <p>and you would have to write</p> <pre><code>chdir $directory if $directory </code></pre>
<p>This is what's tripping you up:</p> <pre><code>$file =~ m#(.*)([^/]*)$#; </code></pre> <p>Looks like you're trying to split "/tmp/final.pdf" into directory and file. But you don't - that pattern splits you into:</p> <pre><code> print "F:",$filename,"\n"; print "D:",$directory,"\n"; </code></pre> <p>this output:</p> <pre><code>F: D:/tmp/final.pdf </code></pre> <p>This is why you have the problem - you don't have a filename, so it defaults to using the script name. </p> <p>I would suggest instead you want:</p> <pre><code>my ( $directory, $filename ) = ( $file =~ m,(.*/)([\.\w]+)$, ); </code></pre> <p>This gives:</p> <pre><code>F:final.pdf D:/tmp/ </code></pre>
<p>As has been said, you're suffering from the greedy matching of <code>.*</code> which will eat up the entire string:</p> <pre><code>$file =~ m{(.*)([^/]*)$}; </code></pre> <p>There are three easy solutions to this</p> <h3>1. Boundary Conditions</h3> <p>As has been stated, you can add a boundary condition that limits how much <code>.*</code> can match:</p> <pre><code>$file =~ m{(?:(.*)/)?([^/]*)$}; my $dir = $1 // ''; my $filename = $2; </code></pre> <p>Or this somewhat convoluted lookbehind assertion can also enforce a boundary:</p> <pre><code>$file =~ m{(.*)(?&lt;![^/])([^/]*)$}; my $dir = $1; my $filename = $2; </code></pre> <h3>2. Non-greedy matching</h3> <p>However, the simplest regex solution is to use non-greedy matching <code>.*?</code>:</p> <pre><code>$file =~ m{(.*?)([^/]*)$}; my ($dir, $filename) = ($1, $2); </code></pre> <p>Basically, anytime you're about to put <code>.*</code> anywhere, check your assumptions. The majority of the time you'll actually want <code>.*?</code> instead.</p> <h3>3. Module for parsing file paths</h3> <p>The bonus option is just to use a module like <a href="http://perldoc.perl.org/File/Spec.html" rel="nofollow"><code>File::Spec</code></a> parsing file path information</p> <pre><code>use File::Spec; my ($vol, $dirs, $filename) = File::Spec-&gt;splitpath( $file ); </code></pre>