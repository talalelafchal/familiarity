Regular expression one liner that knows if a substitute variable is filled
<p>I'm trying to figure out if there's a way to detect and if a match variable (inside a regular expression) is filled, so that it can be used inside the one liner. If the variable is filled, I want to prepend or postpend text that I wouldn't otherwise:</p> <p>In Bash the syntax for if a variable exists is:</p> <pre><code>$ FOO="asdf" $ echo ${FOO:+'hello'$FOO} helloasdf </code></pre> <p>So if I write a regular expression search and replace:</p> <pre><code>$ echo "Foo big Bar" | sed -e 's/Foo(.*?)(Bar)/Hello${1}$2/' </code></pre> <p>and</p> <pre><code>$ echo "FooBar" | sed -e 's/Foo(.*?)(Bar)/Hello${1}$2/' </code></pre> <p>I want the first to return something like: "Hello big world" and the second to return something like "Helloworld". Note: ${1} is a some sort of check... I don't know what it looks like (hence the question). if $1 is empty, I want it to say one thing, if it's not empty, I want it to say another.</p> <p>Let's try a better example. The names are:</p> <pre><code>"document.05.name.txt" "document.06.txt" </code></pre> <p>I'm feeding them into the same regular expression:</p> <pre><code>$ echo $name | sed -e 's/document.([0-9]{2}).(.*?).txt/doc $1${2:+ - $2}.txt/s' </code></pre> <p>Again note the syntax at the end is inaccurate, because that's what I'm trying to find. I want document 05 to be named: "doc 05 - name.txt" and document 06 to be named: "doc 06.txt" Notice the lack of a dash.</p> <p>Is this something that perl regular expressions can do?</p> <p>I'm looking for a one liner so I can feed this into rename. But I'm also curious.</p>
<p>You can use this <code>perl</code> regex with <code>/e</code> modifier:</p> <pre><code>p='Foo big Bar' perl -pe 's/Foo(.*)Bar/my $s=$1; $s =~ s~^\s+|\s+$~~g; $s =~ s~(.+)~ $1 pretty ~; "Hello${s}world"/e' &lt;&lt;&lt; "$p" Hello big pretty world p='Foo Bar' perl -pe 's/Foo(.*)Bar/my $s=$1; $s =~ s~^\s+|\s+$~~g; $s =~ s~(.+)~ $1 pretty ~; "Hello${s}world"/e' &lt;&lt;&lt; "$p" Helloworld </code></pre>
<pre><code>rename 's/document\.(\d\d)\.?(\w+)?(.txt)/"docs $1".($2 &amp;&amp; " - $2").$3/e' document.*.txt </code></pre>
<ol> <li><p><code>sed</code> does not implement non-greedy repeats. <code>.*?</code> means "any number of characters followed by a literal <kbd>?</kbd>" (unless you specified extended regex format, in which case it just means "any number of characters", exactly like <code>.*</code>9</p></li> <li><p>In <code>sed</code> replacements, the syntax for "substitute capture N" is <code>\N</code> (single digit only, so a maximum of 9 captures are allowed). <code>$1</code> and <code>${2}</code> are both considered just literal replacements.</p></li> <li><p>Unless you specify <code>-r</code> (for Gnu sed; it's <code>-E</code> on BSD seds), you need to use Basic Regular Expressions, in which captures are surrounded by <code>\(</code> and <code>\)</code> instead of <code>(</code> and <code>)</code>. (Also with the <code>+</code> operator and explicit repeats; eg., <code>[0-9]\{2\}</code>.)</p></li> <li><p><code>.</code> always means "any character". If you want to match a <kbd>.</kbd>, use <code>\.</code></p></li> </ol> <p>Now, if you want to only match a non-empty sequence, you could use <code>.\+</code> (or just <code>.+</code> with <code>-r</code>), which lets you do a replacement only if the match was non-empty. But aiui, you want to do two different matches, one on empty and the other on non-empty. So you need to provide two possible substitution commands:</p> <pre><code>sed -r -e 's/document\.([0-9]{2})\.(.+)\.txt/document \1 - \2.txt/' \ -e t \ -e 's/document\.([0-9]{2})\.txt/document \1.txt/' </code></pre> <p>The <code>t</code> command skips to the next cycle if the preceding <code>s</code> command successfully replaced something.</p> <p>Note: I wrote that out with 3 <code>-e</code> options so that it wouldn't cause right-scroll, but in practice I'd just use a single <code>sed</code> command argument with the three <code>sed</code> commands separated with semicolons.</p>
<pre><code>cat file|perl -pe 's/document\.([0-9]{2})\.((name\.)?txt)/"doc $1". ($3 ? " - $2":".$2")/e' </code></pre> <p>output</p> <pre><code>doc 05 - name.txt doc 06.txt </code></pre>