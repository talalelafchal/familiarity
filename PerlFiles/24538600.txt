How do you override substitution operations?
<p>I'm playing around with Perl and creating a <em>string object</em>. I know that this is <em>a very bad idea</em> to do in the real world. I'm doing it purely for fun. </p> <p>I'm using <a href="http://perldoc.perl.org/overload.html" rel="nofollow">overload</a> to overload standard Perl <em>string</em> operators with the standard operators you would find in most other languages.</p> <pre><code>use strict; use warnings; use feature qw(say); my $obj_string1 = Object::String-&gt;new("foo"); my $obj_string2 = Object::String-&gt;new("bar"); my $reg_string1 = "foobar"; my $reg_string2 = "barfu"; # Object::String "stringifies" correctly inside quotes say "$obj_string1 $obj_string2"; # Use "+" for concatenations say $obj_string1 + $obj_string2; # Works say $obj_string1 + $reg_string1 + $reg_string2 # Works say $reg_string1 + $obj_string1 # Still works! say $reg_string1 + $obj_string1 + $reg_string2; # Still works! say $reg_string1 + $reg_string2 + $obj_string1; # Does't work, of course. # Overload math booleans with their string boolean equivalents my $forty = Object::String(40); my $one_hundred = "100"; if ( $forty &gt; $one_hundred ) { # Valid say "$forty is bigger than $one_hundred (in strings!)"; } if ( $one_hundred &lt; $forty ) { # Also Valid say "$one_hundred is less than $forty (In strings!)"; } # Some standard "string" methods say $forty-&gt;length # Prints 5 say $forty-&gt;reverse; # Prints "ytrof" say $forty; # Prints "ytrof" </code></pre> <p>Now comes the hard part:</p> <pre><code>my $string = Object::String("I am the best programmer around!"); say $string; # Prints "I am the best programmer around" say $string-&gt;get_value; # Prints "I am the best programmer around" with get_value Method # But, it's time to speak the truth... $string =~ s/best programer/biggest liar/; say $string; # Prints "I am the biggest liar around" say $string-&gt;get_value; # Whoops, no get_value method on scalar strings </code></pre> <p>As you can see, when I do my substitution, it works correctly, but returns a regular scalar string instead of an Object::String.</p> <p>I am trying to figure out how to override the substitution operation. I've looked in the Perldoc, and I've gone through various Perl books (Advance Perl Programming, Intermediate Perl Programming, Perl Cookbook, etc.), but haven't found a way to override the substitution operation, so it returns an <code>Object::String</code>.</p> <p>How do I override the substitution operation?</p>
<p>Unfortunately Perl's overload support isn't very universal in the area of strings. There's many operations that overloading isn't party to; and <code>s///</code> is one of them.</p> <p>I have started a module to fix this; <a href="https://metacpan.org/pod/overload%3a%3asubstr" rel="nofollow"><code>overload::substr</code></a> but as yet it's incomplete. It allows you to overload the <code>substr()</code> function for your object, but so far it doesn't yet have power to apply to <code>m//</code> or <code>s///</code>.</p> <p>You might however, be able to use lvalue (or 4-argument) <code>substr()</code> on your objects as a way to cheat this; if the objects at least stringify into regular strings that can be matched upon, the substitution can be done using the <code>substr()</code>-rewrite trick.</p> <p>Turn</p> <pre><code>$string =~ s/pattern/replacement/; </code></pre> <p>into</p> <pre><code>$string =~ m/pattern/ and substr($string, $-[0], $+[0]-$-[0]) = "replacement"; </code></pre> <p>and then you'll have some code which will respect a <code>substr()</code> overload on the <code>$string</code> object, if you use my module above.</p> <p>At some point of course it would be nice if <code>overload::substr</code> can perform that itself; I just haven't got around to writing it yet.</p>