Linux :search for specific columns with particular string and print on screen
<p>Its kind of daily record, sample below, though value format will not change but position of field/column of record keep changing which is creating a problem while using <code>awk,sed,grep</code>. </p> <p>Filename.txt - with millions of record</p> <pre><code>abcd D20140624 Useragent username userid abcd D20140625 Useragent username1 userid1 D20140626 Useragent username2 userid2 </code></pre> <p>result should be: </p> <pre><code>D20140624 username userid D20140625 username1 userid1 D20140626 username2 userid2 </code></pre> <p>IF i use <code>cat Filename.txt|awk -f ' ' '{print $2,$4,$5}'</code> - invalid result</p> <p>Similarly <code>sed</code> gives invalid result.</p> <p>Can anyone help me with this. </p>
<p><code>-f</code> is the argument to tell awk to read its script from a file so when you say "invalid result" I assume you're getting an error message like <code>can't open source file ' '</code>.</p> <p>I THINK You probably were trying to use <code>-F</code> but then <code>' '</code> is the default FS value so there's no need to set it explicitly.</p> <p>Once you've got past that issue, to get the output you want from that input file is just:</p> <pre><code>$ awk '{print $(NF-3), $(NF-1), $NF}' file D20140624 username userid D20140625 username1 userid1 D20140626 username2 userid2 </code></pre>
<p>You can do like this with <code>awk</code></p> <pre><code>awk '!/^D20[0-9][0-9]/ {$1="";sub(/^ /,"")}1' D20140624 Useragent username userid D20140625 Useragent username1 userid1 D20140626 Useragent username2 userid2 </code></pre> <p>If first field dos not start with a year, remove it and remove extra space.</p>
<p>use this:</p> <pre><code>awk '{ if(NF==5) print $2,$4,$5; else print $1,$3,$4; }' </code></pre>
<pre><code>awk '{for(i=1;i&lt;=NF;i++)if($i~/^D[0-9]{8}$/){n=i;break}} {print $n,$(NF-1),$NF}' file </code></pre> <p>gives:</p> <pre><code>D20140624 username userid D20140625 username1 userid1 D20140626 username2 userid2 </code></pre> <p>it searches for the the first column that matching <code>D....</code> no matter where it is, print it and the last two column. you didn't specify the rule in detail, so I came with this.</p>
<p>You can also use sed command </p> <pre><code>sed -r 's/.*(D[0-9]+) \w+ (.*)/\1 \2/g' file_name </code></pre>
<p>Through GNU sed,</p> <pre><code>$ sed -r 's/^.*(D\S*).*(usern\S*).*(useri\S*).*/\1 \2 \3/g' file D20140624 username userid D20140625 username1 userid1 D20140626 username2 userid2 </code></pre>
<p>Using a perl one-liner, using indexes from the end of the fields:</p> <pre><code>perl -lane 'print "@F[-4,-2,-1]"' file </code></pre> <p>Or with more explicit logic:</p> <pre><code>perl -lane 'print @F == 5 ? "@F[1,3,4]" : "@F[0,2,3]"' file </code></pre> <h3>Explanation:</h3> <p><strong>Switches</strong>: </p> <ul> <li><code>-l</code>: Enable line ending processing, specifies line terminator</li> <li><code>-a</code>: Splits the line on space and loads them in an array <code>@F</code></li> <li><code>-n</code>: Creates a <code>while(&lt;&gt;){..}</code> loop for each &ldquo;line&rdquo; in your input file. </li> <li><code>-e</code>: Tells <code>perl</code> to execute the code on command line. </li> </ul>