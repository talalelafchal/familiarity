Perl grepping similar words
<p>I have below output in some variable in my perl script-the out output is actually coming from some executable which I am storing in variable $retval in this case- example below</p> <pre><code>my $retval=`imp_vol -u 110.5 -s 110.9 -p 0.005 -t 0.041 -c 1` Black Scholes NVol = 1.19711 Black Scholes NDelta = 0.0494522 Black Scholes NGamma = 0.42176 Black Scholes NTheta = -0.302207 Black Scholes NVega = 0.0207006 Black Scholes Vol = 0.0108141 Black Scholes Delta = 0.049565 Black Scholes Gamma = 0.42329 Black Scholes Theta = -0.302212 Black Scholes Vega = 2.29159 </code></pre> <p>Here imp_vol is my executable with different parameters..and it prints different BLack Scholes values.Now My purpose is to get all the Black Scholes Values-Below is what I am using currently using in perl script-</p> <pre><code>if($retval=~/\s*Black\s+Scholes\s+Vol\s*\=\s*(.*)/i){ $vol=$1; } if($retval=~/\s*Black\s+Scholes\s+Delta\s*\=\s*(.*)/i){ $delta=$1; } if($retval=~/\s*Black\s+Scholes\s+Gamma\s*\=\s*(.*)/i){ $gamma=$1; } if($retval=~/\s*Black\s+Scholes\s+Theta\s*\=\s*(.*)/i){ $theta=$1; } if($retval=~/\s*Black\s+Scholes\s+Vega\s*\=\s*(.*)/i){ $vega=$1; } if($retval=~/\s*Black\s+Scholes\s+NVol\s*\=\s*(.*)/i){ $nvol=$1; } if($retval=~/\s*Black\s+Scholes\s+NDelta\s*\=\s*(.*)/i){ $ndelta=$1; } if($retval=~/\s*Black\s+Scholes\s+NGamma\s*\=\s*(.*)/i){ $ngamma=$1; } if($retval=~/\s*Black\s+Scholes\s+NTheta\s*\=\s*(.*)/i){ $ntheta=$1; } if($retval=~/\s*Black\s+Scholes\s+NVega\s*\=\s*(.*)/i){ $nvega=$1; } </code></pre> <p>Any help will be applauded</p>
<p>You can instead collect them in a hash:</p> <pre><code>use strict; use warnings; my $retval = &lt;&lt;HERE; Black Scholes NVol = 1.19711 Black Scholes NDelta = 0.0494522 Black Scholes NGamma = 0.42176 Black Scholes NTheta = -0.302207 Black Scholes NVega = 0.0207006 Black Scholes Vol = 0.0108141 Black Scholes Delta = 0.049565 Black Scholes Gamma = 0.42329 Black Scholes Theta = -0.302212 Black Scholes Vega = 2.29159 HERE my %h; while ($retval =~ /Black\s+Scholes\s+(\S*)\s*\=\s*(\S*)/ig) { $h{lc $1} = $2; } for my $k (keys %h) { print "$k, $h{$k}\n"; } </code></pre> <p><em>Produces:</em></p> <pre><code>ntheta, -0.302207 nvega, 0.0207006 ndelta, 0.0494522 vol, 0.0108141 theta, -0.302212 ngamma, 0.42176 nvol, 1.19711 vega, 2.29159 delta, 0.049565 gamma, 0.42329 </code></pre>
<p>First of all you should put the text returned by the backticks <code>imp_val ...</code> into an <em>array</em> instead of a scalar. That will split it into lines and make it much easier to handle.</p> <p>Then you can process it into a <em>hash</em> using just <code>map</code> with a regular expression. It looks like this. Note that I have used <code>Data::Dump</code> and <code>dd</code> only to demonstrate the resulting hash structure: you would not need it in your own code</p> <pre><code>use strict; use warnings; use Data::Dump; my @retval = `imp_vol -u 110.5 -s 110.9 -p 0.005 -t 0.041 -c 1`; my %scholes = map { /(\w+)\s*=\s*(-?[\d.]+)/ } @retval; dd \%scholes; </code></pre> <p><strong>output</strong> given the data you show in your question</p> <pre><code>{ Delta =&gt; 0.049565, Gamma =&gt; 0.42329, NDelta =&gt; 0.0494522, NGamma =&gt; 0.42176, NTheta =&gt; -0.302207, NVega =&gt; 0.0207006, NVol =&gt; 1.19711, Theta =&gt; -0.302212, Vega =&gt; 2.29159, Vol =&gt; 0.0108141, } </code></pre> <hr> <p><strong>Update</strong></p> <p>From your other comments it looks like you want a subroutine to return a specific sequence of values. I suggest that this code would be best:</p> <pre><code>use strict; use warnings; use Data::Dump; sub scholes { my @retval=`imp_vol -u 110.5 -s 110.9 -p 0.005 -t 0.041 -c 1`; my %scholes = map { /(\w+)\s*=\s*(-?[\d.]+)/ } @retval; return @scholes{qw/ Vol Delta Gamma Theta Vega NVol NDelta NGamma NTheta NVega /}; } dd [ scholes ]; </code></pre> <p><strong>output</strong></p> <pre><code>[ 0.0108141, 0.049565, 0.42329, -0.302212, 2.29159, 1.19711, -0.302207, 0.0207006, 0.0494522, 0.42176, ] </code></pre>