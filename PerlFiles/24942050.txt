Running scripts from Perl CGI programs with root permissions
<p>I have a Perl CGI that is supposed to allow a user to select some files from a filesystem, and then send them via Rsync to a remote server. All of the HTML is generated by the Perl script, and I am using query strings and temp files to give the illusion of a stateful transaction. The Rsync part is a separate shell script that is called with the filename as an argument (the script also sends emails and a bunch of other stuff which is why I haven't just moved it into the Perl script). I wanted to use sudo without a password, and I setup sudoers to allow the apache user to run the script without a password and disabled requiretty, but I still get errors in the log about no tty. I tried then using su -c scriptname, but that is failing as well.</p> <p><strong>TD;DR</strong> Is it awful practice to use a Perl CGI script to call a Bash script via sudo, and how are you handling privilege escalation for Perl CGI scripts? Perl 5.10 on Linux 2.6 Kernel.</p> <p>Relevant Code: (LFILE is a file containing the indexes for the array of all files in the filesystem)</p> <pre><code>elsif ( $ENV{QUERY_STRING} =~ 'yes' ) { my @CMDLINE = qw(/bin/su -c /bin/scriptname.sh); print $q-&gt;start_html; open('TFILE', '&lt;', "/tmp/LFILE"); print'&lt;ul&gt;'; foreach(&lt;TFILE&gt;) { $FILES[$_] =~ s/\/.*\///g; print "Running command @CMDLINE $FILES[$_]"; print $q-&gt;h1("Sending File: $FILES[$_]") ; `@CMDLINE $FILES[$_]` or print $q-&gt;h1("Problem: $?); </code></pre>
<p>However you end up doing this, you have to be careful. You want to minimise the chance of a <a href="https://en.wikipedia.org/wiki/Privilege_escalation" rel="nofollow">privilege escalation</a> attack. Bearing that in mindâ€¦.</p> <p><code>sudo</code> is not the only way that a user (or process) can execute code with increased privileges. For this sort of application, I would make use of a program with the <a href="https://en.wikipedia.org/wiki/Setuid" rel="nofollow">setuid bit</a> set.</p> <ol> <li><p>Write a program which can be run by an appropriately-privileged user (root, in this case, although see the warning below) to carry out the actions which <em>require</em> that privilege. (This may be the script you already have, and refer to in the question.) Make this program as simple as possible, and spend some time making sure it is well-written and appropriately secure.</p></li> <li><p>Set the "setuid bit" on the program by doing something like:</p> <pre><code>chmod a+x,u+s transfer_file </code></pre> <p>This means that anyone can execute the program, but that it runs with the privileges of the <em>owner</em> of the program, not just the <em>user</em> of the program.</p></li> <li><p>Call the (privileged) transfer program from the existing (non-privileged) CGI script.</p></li> </ol> <p>Now, in order to keep required privileges as low as possible, I would <em>strongly</em> avoid carrying out the transfer as root. Instead, create a separate user who has the necessary privileges to do the file transfer, but no more, and make this user the owner of the setuid program. This way, even if the program is open to being exploited, the exploiter can use this user's privileges, not root's.</p> <p>There are some important "gotchas" in setting up something like this. If you have trouble, ask again on this site.</p>