Substituting letters in an array
<pre><code>#!/usr/bin/env perl use warnings; use strict; my $input = "test"; my @arr = ('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'); my @cip = ('%', '@', '!', '^', '*', '_', '+', '&amp;', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', 'A', 'B', 'D', '$', '(', ')', '/', '|'); &lt;do something here&gt; print $res; </code></pre> <p>The output should be according to the arrays: <code>B*AB</code></p> <p>The only problem is I don't know how to get there, I tried using s// from regex but that doesn't seem to be working.</p>
<p>You can do it like this:</p> <pre><code>#!/usr/bin/env perl use warnings; use strict; my $input = "test"; my @arr = ('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'); my @cip = ('%', '@', '!', '^', '*', '_', '+', '&amp;', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', 'A', 'B', 'D', '$', '(', ')', '/', '|'); # Loop through each index in the first array for my $index (0..$#arr) { # search for the element at that index in the first array my $search = $arr[$index]; # Replace it with the corresponding element in the next array my $replace =$cip[$index]; # Search and replace, /i for ignore case and /g for replacing all instances $input =~ s/$search/$replace/gi; } my $res = $input; print $res; </code></pre> <p>output:</p> <pre><code>Matt@MattPC ~/perl/testing/9 $ perl test.pl B*AB </code></pre>
<pre><code>#!/usr/bin/perl use strict; use warnings; use 5.010; my $input = "test"; my @arr = ('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'); my @cip = ('%', '@', '!', '^', '*', '_', '+', '&amp;', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', 'A', 'B', 'D', '$', '(', ')', '/', '|'); my %translate; @translate{@arr} = @cip; $input =~ s/(\w)/$translate{uc $1}/eg; say $input; </code></pre>
<p>Use a hash:</p> <pre><code>use strict; use warnings; my $input = "test"; my @keys = qw{A B C D E F G H I J K L M N O P Q R S T U V W X Y Z}; my @vals = qw{% @ ! ^ * _ + &amp; 2 3 4 5 6 7 8 9 0 1 A B D $ ( ) / |}; my %hash; @hash{@keys} = @vals; my $output = join '', map {$hash{uc $_} // warn "not found $_"} split '', $input; print $output; </code></pre> <p>Outputs:</p> <pre><code>B*AB </code></pre>
<p>You can replace char by char using hash look up table, where <code>@arr</code> elements are keys, and <code>@cip</code> are values. <code>"\U$1"</code> does upper case on captured string.</p> <pre><code>use warnings; use strict; my $input = "test"; my @arr = ('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'); my @cip = ('%', '@', '!', '^', '*', '_', '+', '&amp;', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', 'A', 'B', 'D', '$', '(', ')', '/', '|'); my %h; @h{@arr} = @cip; (my $res = $input) =~ s/(.)/ $h{"\U$1"} /ge; print $res; </code></pre> <p>output</p> <pre><code>B*AB </code></pre>
<p>Just for good measure, an answer using the transliteration operator (<code>tr//</code>).</p> <pre><code>my @arr = qw(A B C D E F G H I J K L M N O P Q R S T U V W X Y Z); my @cip = qw(% @ ! ^ * _ + &amp; 2 3 4 5 6 7 8 9 0 1 A B D $ ( ) / |); my $arr = join "", @arr; my $cip = join "", @cip; my $res; eval "(\$res = uc \$input) =~ tr/\Q$arr\E/\Q$cip\E/"; print "test =&gt; $res\n"; # B*AB </code></pre> <p>Unfortunately using variables in a <code>tr//</code> requires using eval. If the list is always going to be the same you could do something like <code>tr/A-Z/\%\@.../</code> instead and avoid the eval.</p>
<p>A slightly different transliteration example that is delimiter safe:</p> <pre><code>#!/usr/bin/perl use warnings; use strict; my $input = "test"; my @arr = qw(A B C D E F G H I J K L M N O P Q R S T U V W X Y Z); my @cip = qw(% @ ! ^ * _ + &amp; 2 3 4 5 6 7 8 9 0 1 A B D $ ( ) / |); my $plaintext = join '', @arr; my $ciphertext = join '', @cip; $_ = uc $input; eval(sprintf("tr/%s/%s/", map { quotemeta($_) . "" } ($plaintext, $ciphertext))); my $res = $_; print "$res\n"; </code></pre>