Perl scp a remote directory and show the progress
<p>I am very new to perl scripting. With my below code, i am trying to loop this system call command to print (====) until the remote scp is done. But it turns out the loop does not get executed until the scp is complete. Any help will be appreciated.</p> <pre><code>$server = "myserver.com" $download_from = "/var/tmp"; $download_to = "/tmp" chomp ($scp_user = &lt;STDIN&gt;); $rc = system ("scp -r ${scp_user}\@${server}:{download_from} ${download_to} &gt;&gt; $logfile 2&gt;&amp;1"); my count = 0; while (( $rc == 0) &amp;&amp; ( $count &lt; 120 )) { print "=" ; sleep 5; $count = $count = 1; $rc = system ("scp -r ${scp_user}\@${server}:{download_from} ${download_to} &gt;&gt; $logfile 2&gt;&amp;1"); } </code></pre>
<p>What you're doing here is calling scp (in a subshell that gets started by the system call) when that finishes you check the exit code and if it's zero (which typically indicates success) you call it again.</p> <p>BTW the line <code>$count = $count = 1;</code> is not incrementing as I assume you intended, it's just setting it to 1. You probably meant to write <code>$count++;</code></p> <p>I assume that you want to print out an equals sign every 5 seconds until the command completes. To do this you would need to run the command in parallel and check when it has finished.</p> <p>I guess that your code never stops and just prints out equals signs every 5 seconds or so until you get bored and kill it</p>
<p>One solution is to use threads to copy the file while your program prints the progress.</p> <p>Here is an example...</p> <pre><code>use Config; use threads; $Config{useithreads} or die('Recompile perl with threads to run this program'); $| = -1; # non buffered output. my $thread = threads-&gt;create(\&amp;copy_file); # Spawn the thread. while (threads-&gt;list(threads::runing)) { # While it is running. print "="; # show the progress. sleep 1; # sleep to give it a chance to run. } $thread-&gt;join(); # Cleanup the thread. # Function to do the file copy. sub copy_file { system 'scp /tmp/junk.junk localhost:/tmp/junk.bunk &gt;/dev/null 2&gt;&amp;1'; } </code></pre> <p>Here is another solution which uses fork instead of threads... .. and handles the password. (although I really do recommend using public keys)</p> <pre><code>#!/usr/bin/perl use strict; use warnings; use Net::SCP::Expect; use Term::ReadKey; use POSIX ":sys_wait_h"; my $user; my $pw; print "Enter Username: "; chomp($user = &lt;STDIN&gt;); ReadMode('noecho'); print "Enter Password: "; chomp($pw = &lt;STDIN&gt;); ReadMode('restore'); my $scpe = Net::SCP::Expect-&gt;new; $scpe-&gt;login($user, $pw); $| = -1; my $pid = fork; if ($pid) { print "parent\n"; } elsif ($pid == 0) { $scpe-&gt;scp('/tmp/junk','localhost:/tmp/junk2'); exit 0; } else { die "Couldnt fork\n"; } my $child; do { $child = waitpid(-1, WNOHANG); sleep 1; print "-"; } while $child &gt;= 0; print "\nFile has been copied.\n"; </code></pre>