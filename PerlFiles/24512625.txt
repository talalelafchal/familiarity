Enumerate all modules in a .pm file, and get an reference of them all
<p>I'm trying to avoid <code>Module::Pluggable</code> and make thing easier.</p> <p>Here's what I do, I have a set of modules stored in <code>modules/</code>, all packages defined inside share the same method names:</p> <pre><code># in XX.pm package MyClass::XX; sub new {} sub method_1 {} sub method_2 {} # in YY.pm package MyClass::YY; sub new {} sub method_1 {} sub method_2 {} </code></pre> <p>(But note that there might be more than one module defined in a single .pm file)</p> <p>Now I want to get all objects blessed to these modules, e.g <code>[ XX-&gt;new, YY-&gt;new]</code></p> <p>Is that possible? </p>
<p>You should be able to loop through this <code>modules/</code> directory you say you have, and gather a list of files in it. (Use <code>opendir</code> or better yet, <a href="https://metacpan.org/pod/Path%3a%3aTiny" rel="nofollow">Path::Tiny</a> to gather the list of files.) Then:</p> <pre><code>my @classes = map { (my $class = $_) =~ s{/}{::}g; $class =~ s{\.pm\z}{}; $class; } @files; </code></pre> <p>In the above I'm assuming a fairly standard filename-to-classname mapping. Feel free to tweak it if it doesn't fit your situation.</p> <p>Once you have a list of classes, you can get back a list of objects pretty easily:</p> <pre><code>my @objects = map $_-&gt;new, @classes; </code></pre> <p>Personally I'd use <a href="https://metacpan.org/pod/Module%3a%3aPluggable" rel="nofollow">Module::Pluggable</a> though. Don't be afraid of the deprecation warnings. The module is not deprecated. What the warnings mean is that the copy of Module::Pluggable that comes bundled with the Perl interpreter is being phased out. Instead you should install a copy from the CPAN.</p>