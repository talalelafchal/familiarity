Codegolf regex match
<p>In the codegold i found this answer: <a href="http://codegolf.stackexchange.com/a/34345/29143">http://codegolf.stackexchange.com/a/34345/29143</a> , where is this perl one liner:</p> <pre><code>perl -e '(q x x x 10) =~ /(?{ print "hello\n" })(?!)/;' </code></pre> <p>After the -MO=Deparse got:</p> <pre><code>' ' =~ /(?{ print "hello\n" })(?!)/; ^^^^^^^^^^^^ 10 spaces </code></pre> <p>The explanation told than the <code>(?!)</code> never match, so the regex tries match each character. OK, but <strong>why it prints 11 times</strong> hello and not 10 times?</p>
<p>It's because when you have a string of n characters there are n+1 positions in the string where the pattern is tested.</p> <p>example with <code>"abc"</code>:</p> <pre><code> a b c ^ ^ ^ ^ | | | | | | | +--- end of the string | | +----- position of c | +------- position of b +--------- position of a </code></pre> <p>The position of the end of the string can be a little counter-intuitive, but this position exists. To illustrate this fact, consider the pattern <code>/c$/</code> that will succeed with the example string. <em>(think of the position in the string when the end anchor is tested)</em>. Or this other one <code>/(?&lt;=c)/</code> that succeeds in the last position.</p>
<p>Take a look at the following:</p> <pre><code>$x = "abc"; $x =~ s/.{0}/x/; print("$x\n"); # xabc $x = "abc"; $x =~ s/.{1}/x/; print("$x\n"); # xbc $x = "abc"; $x =~ s/.{2}/x/; print("$x\n"); # xc $x = "abc"; $x =~ s/.{3}/x/; print("$x\n"); # x </code></pre> <p>Nothing surprising. You can match anywhere between 0 and 3 of the three characters, and place an <code>x</code> at the position where you left off. That's four positions for three characters.</p> <hr> <p>Also consider <code>'abc' =~ /^abc\z/</code>.</p> <ul> <li>Starting at position <code>0</code>, <code>^</code> matches zero chars.</li> <li>Starting at position <code>0</code>, <code>a</code> matches one char.</li> <li>Starting at position <code>1</code>, <code>b</code> matches one char.</li> <li>Starting at position <code>2</code>, <code>c</code> matches one char.</li> <li>Starting at position <code>3</code>, <code>\z</code> matches zero char.</li> </ul> <p>Again, that's a total of four positions needed for a three character string.</p> <p>Only zero-width assertions can match at the last position, but there are plenty of those (<code>^</code>, <code>\z</code>, <code>\b</code>, <code>(?=...)</code>, <code>(?!...)</code>, <code>(?&lt;=...)</code>, <code>(?:...)?</code>, etc).</p> <hr> <p>You can think of the positions as the edges of the characters, if that helps.</p> <pre><code>|a|b|c| 0 1 2 3 </code></pre>
<p>Regular expressions start matching based off positions, which can includes both before each character but also after the last character.</p> <p>The following zero width regular expression will match before each of the 5 characters of the string, but also after the last one, thus demonstrated why you got 11 prints instead of just 10.</p> <pre><code>use strict; use warnings; my $string = 'ABCDE'; # Zero width Regular expression $string =~ s//x/g; print $string; </code></pre> <p>Outputs:</p> <pre><code>xAxBxCxDxEx ^ ^ ^ ^ ^ ^ 1 2 3 4 5 6 </code></pre>