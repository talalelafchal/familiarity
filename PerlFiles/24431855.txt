Perl - extract series of numbers with offsets from array
<p>I am trying to search for series of numbers within an array of integers. For instance, if the array consists of the numbers <code>1,2,3,10,12,14</code>, it could be summarized to </p> <p>1 to 3 with offset 1, </p> <p>10 to 14 with offset 2 </p> <p>Below my code, where I loop over the array from the second element, track the offset between consecutive array elements and create a new 'series' if the offset changes:</p> <pre><code>use strict; use warnings; my @numbers = (1,2,3,10,12,14); #array to extract series from my $last_diff; my $start = $numbers[0]; my $end; my @all_series; #array will hold all information on series for my $i (1..($#numbers+1)){ my $diff; if ($i &lt;($#numbers+1)){ $diff = $numbers[$i] - $numbers[$i-1]; } if (!$diff || ( $last_diff &amp;&amp; ($last_diff != $diff)) ) { $end = $numbers[$i-1]; my $series = { 'start'=&gt; $start, 'end' =&gt; $end, 'offset'=&gt; $start == $end ? 1 : $last_diff, }; push @all_series, $series; $start = $numbers[$i]; } $last_diff = $diff; } use Data::Dumper; print Dumper(@all_series); </code></pre> <p>Output looks as follows:</p> <pre><code>$VAR1 = { 'offset' =&gt; 1, 'end' =&gt; 3, 'start' =&gt; 1 }; $VAR2 = { 'offset' =&gt; 1, 'end' =&gt; 10, 'start' =&gt; 10 }; $VAR3 = { 'offset' =&gt; 2, 'end' =&gt; 14, 'start' =&gt; 12 }; </code></pre> <p>This is not the desired result, since the last two series could be summarised into one (10 to 14, offset 2 instead of two series).</p> <p>The flaw in the algorithm is independent from perl, however, maybe someone could give me a hint on how to approach this best, maybe there exist some perl-specific tricks for this.</p> <p>In my application, all integers in the array are in ascending order and duplicate numbers do not exist.</p> <p><strong>EDIT</strong> If single numbers occur that cannot be assignet to a serious, they should be a series of length one. </p> <p>The more numbers can be summarized to series, the better (I want to minimize the number of series!)</p>
<p>The problem is in the ternary operator. If you used plain</p> <pre><code>offset =&gt; $last_diff, </code></pre> <p>you'd notice that there is </p> <pre><code>$VAR2 = { 'offset' =&gt; 7, 'end' =&gt; 10, 'start' =&gt; 10 </code></pre> <p>Which is correct in a way. To avoid it, you can <code>undef $diff</code> after pushing to @series. It would produce the expected output for your case, but would still treat <code>1 2 3 7 10 12 14</code> as three sequences, starting at 1, 7 and 12. What you need is to make a longer sentence greedy somehow, now.</p> <p>I experimented with the following, but you should test more:</p> <pre><code>#!/usr/bin/perl use warnings; use strict; use Data::Dumper; my @numbers = (1, 2, 3, 10, 12, 14); my $last_diff; my $start = $numbers[0]; my @all_series; for my $i (1 .. $#numbers + 1) { my $diff; if ($i &lt; $#numbers + 1) { $diff = $numbers[$i] - $numbers[ $i - 1 ]; } # Merge with the last number from the previous series if needed: if (!$last_diff # Just starting a new series. and $i &gt; 2 # Far enough to have preceding numbers. and $diff and $diff == $numbers[ $i - 1 ] - $numbers[ $i - 2 ] ) { $all_series[-1]{end} = $numbers[ $i - 3 ]; $all_series[-1]{offset} = 0 if $all_series[-1]{start} == $all_series[-1]{end}; $start = $numbers[ $i - 2 ]; } if (! $diff or ( $last_diff &amp;&amp; ($last_diff != $diff)) ) { push @all_series, { start =&gt; $start, end =&gt; $numbers[ $i - 1 ], offset =&gt; $last_diff, }; $start = $numbers[$i]; undef $diff; } $last_diff = $diff; } print Dumper(@all_series); </code></pre>
<p>This is most easily solved if done in three separate steps</p> <ul> <li>Determine difference between each number.</li> <li>Determine sequences of differences.</li> <li>Finally determine the ranges.</li> </ul> <p>Each of these steps is done in order to more easily debug whether each step is correct. Additionally, for certain values like <code>1,7,8,9</code>, it is necessary to look three numbers ahead to determine if <code>7</code> should be cuddled with <code>1</code> or not. Therefore it helps to have already calculated all information in advance to more easily determine and specify the rules that are needed in the final loop to build the ranges.</p> <p>To make the output easier to read, I'm displaying solitary numbers as just a <code>start</code> value. Additionally, I added a <code>count</code> to the range hashes. These changes are easily adjusted later.</p> <p>For additional testing data, I added a sequence with a solitary 1 followed by a sequence of 3 numbers, and I also added a Fibonacci sequence for the challenge.</p> <pre><code>use strict; use warnings; use Data::Dump; while (&lt;DATA&gt;) { chomp; my @nums = split ','; my @diffs = map {$nums[$_+1] - $nums[$_]} (0..$#nums-1); my @seq; for (@diffs) { if (@seq &amp;&amp; $seq[-1]{diff} == $_) { $seq[-1]{count}++; } else { push @seq, {diff =&gt; $_, count =&gt; 1}; } } my @ranges; for (my $i = 0; $i &lt; @nums; $i++) { my $seq = shift @seq; # Solitary Number if (!$seq || ($seq-&gt;{count} == 1 &amp;&amp; @seq &amp;&amp; $seq[0]{count} &gt; 1)) { push @ranges, {start =&gt; $nums[$i]}; # Confirmed Range } else { push @ranges, { start =&gt; $nums[$i], end =&gt; $nums[$i + $seq-&gt;{count}], count =&gt; $seq-&gt;{count} + 1, # Can be commented out offset =&gt; $seq-&gt;{diff}, }; $i += $seq-&gt;{count}; shift @seq if @seq &amp;&amp; !--$seq[0]{count}; } } dd @nums; dd @ranges; print "\n"; } __DATA__ 1,2,3,10,12,14 1,2,3,5,7 1,7,8,9 1,2,3,7,8,11,13,15,22,100,150,200 2,3,5,8,13,21,34,55,89 </code></pre> <p>Outputs:</p> <pre><code>(1, 2, 3, 10, 12, 14) ( { count =&gt; 3, end =&gt; 3, offset =&gt; 1, start =&gt; 1 }, { count =&gt; 3, end =&gt; 14, offset =&gt; 2, start =&gt; 10 }, ) (1, 2, 3, 5, 7) ( { count =&gt; 3, end =&gt; 3, offset =&gt; 1, start =&gt; 1 }, { count =&gt; 2, end =&gt; 7, offset =&gt; 2, start =&gt; 5 }, ) (1, 7, 8, 9) ( { start =&gt; 1 }, { count =&gt; 3, end =&gt; 9, offset =&gt; 1, start =&gt; 7 }, ) (1, 2, 3, 7, 8, 11, 13, 15, 22, 100, 150, 200) ( { count =&gt; 3, end =&gt; 3, offset =&gt; 1, start =&gt; 1 }, { count =&gt; 2, end =&gt; 8, offset =&gt; 1, start =&gt; 7 }, { count =&gt; 3, end =&gt; 15, offset =&gt; 2, start =&gt; 11 }, { start =&gt; 22 }, { count =&gt; 3, end =&gt; 200, offset =&gt; 50, start =&gt; 100 }, ) (2, 3, 5, 8, 13, 21, 34, 55, 89) ( { count =&gt; 2, end =&gt; 3, offset =&gt; 1, start =&gt; 2 }, { count =&gt; 2, end =&gt; 8, offset =&gt; 3, start =&gt; 5 }, { count =&gt; 2, end =&gt; 21, offset =&gt; 8, start =&gt; 13 }, { count =&gt; 2, end =&gt; 55, offset =&gt; 21, start =&gt; 34 }, { start =&gt; 89 }, ) </code></pre>