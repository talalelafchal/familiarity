Search&amp;Replace into multiple files with the name of the containing folder
<p>I have multiple folders with names :</p> <pre><code>1_1,1_2,...,2_1,..., </code></pre> <p>each of these folders contains the same file with the name <code>file.sh</code>. The file has the following form :</p> <blockquote> <p><em>job_name=NAME</em></p> <p><em>Partition</em> = <em>Long</em></p> </blockquote> <p>I want to use a search&amp;replace command in the terminal (Linux) for all my folders, like for example the following </p> <pre><code>find . -type f -name "file.sh" -print |xargs sed -i 's/job_name/REPLACED_TEXT/g' </code></pre> <p>and in the position of the <em>REPLACED_TEXT</em> I want the name of the folder. For example, inside folder <code>1_1</code>, there will be the <code>file.sh</code> file with the modified form:</p> <blockquote> <p><em>job_name=1_1</em></p> <p><em>Partition</em> = <em>Long</em></p> </blockquote> <p>I haven't found a solution for that yet. </p>
<p>You didn't specify how many subdirectories you might have to traverse, e.g. </p> <pre><code>./1_1/file.sh ./1_2/file.sh ./a/b/c/1_1/file.sh </code></pre> <p>So for this I'll just assume one subdirectory like so: </p> <pre><code>./1_1/file.sh ./1_2/file.sh </code></pre> <p>Something like the below should be able to get you started, not tested, just writing it off the top of my head. It's bash scripted but you can turn it into one big long command. Make sure to back up your directory first in case the script has unpredictable results.</p> <pre><code>for i in `find . -type f -print "file.sh"`; do subdir=`echo $i | awk -F\/ '{print $2}'` sed -e s/job_name=NAME/jobname=$subdir/ $i &gt; $i.bak mv $i.bak $i done </code></pre>
<p>You can try this line to print all the <code>sed</code> commands you want to execute:</p> <pre><code>find . -type f -name 'file.sh' | \ sed 's=\(.*\)/\([^/]*\)=sed -i "s/NAME/\1/" \"&amp;\"=' </code></pre> <p>For each file we found, it extracts the name of its directory and creates a <code>sed</code> command able to replace <code>NAME</code> with it.<br> Output should be something like:</p> <pre><code> sed -i "s/NAME/1_1/" "1_1/file.sh" sed -i "s/NAME/1_2/" "1_2/file.sh" </code></pre> <p>Then, if it looks good to you, you can repeat with the <code>e</code> command for <code>sed</code>, which will make the outer <code>sed</code> execute its result (i.e. inner <code>sed</code> command), like this:</p> <pre><code>find . -type f -name 'file.sh' | \ sed 's=\(.*\)/\([^/]*\)=sed -i "s/NAME/\1/" \"&amp;\"=e' # 'e' command added here -------------------------^ </code></pre>