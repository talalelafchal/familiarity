How to execute lambda within a &quot;closure scope&quot;?
<p>How this can work?</p> <pre><code> use strict; use warnings; sub base { my $constant = "abcd"; my ($driver_cr) = (@_); &amp;$driver_cr; } base(sub {print $constant}); </code></pre> <p>In other words how $driver_cr can have an access to $constant without:</p> <ol> <li>passing $constant as an arg to driver <code>&amp;$driver_cr($constant)</code></li> <li>changing scope of $constant to global <code>our $constant = "abcd";</code></li> <li><p>making a common block and moving $constant from base:</p> <pre><code>use strict; use warnings; { my $constant = "abcd"; sub base { my ($driver_cr) = (@_); &amp;$driver_cr; } base(sub {print $constant}); } </code></pre></li> </ol>
<p>That's what function arguments are for.</p> <pre><code>use strict; use warnings; sub base { my $constant = "abcd"; my ($driver_cr) = (@_); $driver_cr-&gt;($constant); } base(sub { my $constant = shift; print $constant; }); </code></pre> <p>But if you're really opposed to passing arguments, then:</p> <pre><code>use strict; use warnings; use Acme::Lexical::Thief; sub base { my $constant = "abcd"; my ($driver_cr) = (@_); &amp;$driver_cr; } base(sub { steal $constant; print $constant; }); </code></pre>