Using optional arguments from command line within the system function in perl
<p>I am generalizing a pre-existing perl script... i.e. making it work on numerous instances simultaneously. Basically it is a parameter scan feature of a modelling script. The scan does a single parameter and I want it to do them all. The pre-existing script (called scan_var.pl from bionetgen if your interested) has a bunch of arguments - some of them optional. </p> <p>The following is successful in implementing the parameter scan with the default settings </p> <pre><code>#execute the parameter scan with each variable individually foreach $var_name (@var_names){ my $param = shift @var_names; system ("perl", $scan_var_location, $model, $param, $min_value, $max_value, $NPTS); } </code></pre> <p>But now I want to use the <code>GetOpt::Long</code> module to parse in the optional arguments. My code so far is: </p> <pre><code># some default parameters my $log = 0; my $t_end = 20; my $n_steps = 1; my $steady_state = 0; my $method = "\"ode\""; my $verbose = 0; my $prefix; my $options = GetOptions ( 'verbose' =&gt; \$verbose, #boolean 'log' =&gt; \$log, #boolean 'n_steps:i' =&gt; \$n_steps, #integer 'steady_state' =&gt; \$steady_state, #boolean 'method:s' =&gt; \$method, #string 't_end:i' =&gt; \$t_end, #integer 'prefix:s' =&gt; \$prefix string ); #execute the parameter scan with each variable individually foreach $var_name (@var_names){ #iterates through a list stored in $var_names(not shown for concise-ness) my $param = shift @var_names; system ("perl", $scan_var_location, #required value, directory $options, #optional command line arguments - corresponds to the list above $model, #required command line value (directory) $param, #list iterated over $min_value, #requierd integer $max_value, #required integer $NPTS #required integer ); } </code></pre> <p>This however is somehow incorrect. Does anybody have any suggestions for corrections?</p> <p>Cheers</p>
<p>One problem is that you probably don't want to use the <strong>return value</strong> of <code>GetOptions</code> in your <code>system</code> call. <code>$options</code> has the return value:</p> <blockquote> <p>GetOptions returns true to indicate success. It returns false when the function detected one or more errors during option parsing.</p> </blockquote>
<p><a href="https://metacpan.org/pod/Getopt%3a%3aLong#Storing-options-values-in-a-hash" rel="nofollow"><code>GetOptions()</code></a> supports the storage of values in a hash. This allows you to reduce variable clutter:</p> <pre><code>use Getopt::Long; my %options; GetOptions( \%options, 'verbose', 'log', 'n_steps:i', 'steady_state', 'method:s', 't_end:i', 'prefix:s', ); my $stringified_options = join ' ', map "-$_ $options{$_}", keys %options; foreach my $var_name ( @var_name ) { system ("perl", $scan_var_location, $stringified_options, $model, $param, $min_value, $max_value, $NPTS ); } </code></pre>
<p>The following is a tighter version of your code:</p> <pre><code>GetOptions ( 'verbose' =&gt; \(my $verbose = 0), #boolean 'log' =&gt; \(my $log = 0), #boolean 'n_steps:i' =&gt; \(my $n_steps = 1), #integer 'steady_state' =&gt; \(my $steady_state = 0), #boolean 'method:s' =&gt; \(my $method = q{"ode"}), #string 't_end:i' =&gt; \(my $t_end = 20), #integer 'prefix:s' =&gt; \my $prefix, #string ); #execute the parameter scan with each variable individually #iterates through a list stored in $var_names(not shown for concise-ness) foreach $var_name (@var_names) { system("perl", $scan_var_location, #required value, directory $model, #required command line value (directory) $var_name, #list iterated over $min_value, #requierd integer $max_value, #required integer $NPTS, #required integer ); } </code></pre>