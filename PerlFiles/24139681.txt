How does this negative lookbehind work?
<p>This code snippet is from the book Mastering Regular Expressions. I am having trouble understanding the last part with negative lookbehind (The comment <code># Not allowed to end with [.,?!]</code> ). How will that expression drop <code>[?!,.]</code> from <code>http://www.google.com/foo!</code> or <code>http://www.google.com/bar\!</code> ?</p> <pre class="lang-none prettyprint-override"><code># Turn HTTP URLs into links . . . $text =~ s{ \b # Capture the URL to $1 . . . ( http:// [-a-z0-9]+(\.[-a-z0-9]+)*\.(com|edu|info) \b # hostname ( / [-a-z0-9_:\@&amp;?=+,.!/~*'%\$]* # Optional path (?&lt;![.,?!]) # Path not allowed to end with [.,?!] )? ) }{&lt;a href="$1"&gt;$1&lt;/a&gt;}gix; print $text; # Finally, display the HTML-ized text. </code></pre>
<p>It will not. It's in the part of the expression were the optional path is being matched, and since there is no path in <code>http://www.google.com</code>, it will have no effect.</p>
<p>The idea is, when <code>[-a-z0-9_:@&amp;?=+,.!/~*%\$]+</code> has consumed all it can, it hands control over to the lookbehind. If the lookbehind sees one of those sentence-punctuation characters, it reports failure and hands control back to the <code>[-a-z0-9_:\@&amp;?=+,.!/~*%\$]+</code> part. It backs off one position, "giving back" the last character it had consumed, then hands off to the lookbehind again. </p> <p>In the case of <code>www.google.com/foo!</code>, the lookbehind will now be looking at the <code>o</code>, so it reports success and the overall match succeeds. </p> <p>However, when you try to match <code>www.google.com/bar\!</code> the lookbehind never gets a chance to look at the bang (<code>!</code>). <code>[-a-z0-9_:\@&amp;?=+,.!/~*%\$]+</code> doesn't match backslashes because they aren't legal in URLs. It stops after consuming the <code>r</code>, and this time the lookbehind succeeds without having to backtrack.</p> <p><strong>EDIT:</strong> In response to a question in the comments: yes, you can use something like this:</p> <pre class="lang-none prettyprint-override"><code>\b(https?|ftp|file)://[-A-Z0-9+&amp;@#/%?=~_|$!:,.;]*[A-Z0-9+&amp;@#/%=~_|$] </code></pre> <p>Where the lookbehind regex consumes the invalid characters and barfs them back up, this one doesn't consume them in the first place. But it's not always possible to do it that way. For example, what if the thing you want to exclude is a whole word rather than a single character? That can get real ugly, real fast. I mean, look at all those characters you have to type in, just for this bone-basic matching task.</p>