Perl: difficulty understanding how to access list of list passed by reference?
<p>This is a perl function I wrote for a genetic/evolution algorithm for comparing data from various texts documents. I'm trying to get the reproduction part down:</p> <p>My function calls <code>get_2d_agree_groups</code> which returns a "list of list" by reference which I then need to further access, modify, remove or add to the inner lists as needed. <code>combine_arrays</code> and <code>split_array</code> take 1d lists and operate on them. I can't figure out how to properly access these inner lists to pass to the functions. Specifically when I try to append to inner lists with <code>combine_arrays</code> it adds a reference to a list as opposed to the individual elements as desired.</p> <pre><code>sub assemble_groups { #(parent1, parent2, new group size) my $holder = 0; my $parent1 = shift; my $parent2 = shift; my $num_groups = shift; my $blocks = get_2d_agree_groups(\@{${$parent1}{'groups'}},\@{${$parent2}{'groups'}}); my @disagree_block = pop @{$blocks}; my $agree_size = @{$blocks}; while($agree_size &lt; $num_groups) { my $index = getrand(0,($agree_size-1)); my $size = @{${$blocks}[$index]}; my $split_index = getrand(0,($size-1)); my $new_array = split_array(\@{${$blocks}[$index]},$split_index); push @{$blocks}, $new_array; $agree_size++; } while($agree_size &gt; $num_groups) { my $join1 = getrand(0,($agree_size-1)); my $join2 = getrand(0,($agree_size-1)); while($join1==$join2) { $join2 = getrand(0,($agree_size-1)); } my @hold = ${$blocks}[$join2]; my $test = join('',@hold); splice @{$blocks}, $join2, 1; combine_arrays(\@{${$blocks}[$join1]},\@hold); #right here $agree_size--; } my $i=0; my $disagree_size = @disagree_block; while (($i&lt;$agree_size) &amp;&amp; $disagree_size) { getnewgroup(\@{${$blocks}[$i]},\@disagree_block); $disagree_size = @disagree_block; $i++; } if($disagree_size) { combine_arrays(\@{${$blocks}[$i-1]},\@disagree_block); #right here } return $blocks; } </code></pre> <p>relevant functions:</p> <pre><code>sub combine_arrays { #(1d array 1, 1d array) my $group1 = shift; my $group2 = shift; my $group2_size = @{$group2}; my $next = 0; for(my $i=0;$i&lt;$group2_size;$i++) { $next = @{$group2}[$i]; push @{$group1}, $next; } } sub split_array { #(array, index) my $old_array = shift; my $at = shift; my @new_array; my $old_size = @{$old_array}; for(my $i=$at;$i&lt;$old_size;$i++) { push @new_array, ${$old_array}[$at]; splice @{$old_array}, $at, 1; } return \@new_array; } </code></pre>
<p>You do not need a combine_array function. That's what <a href="http://perldoc.perl.org/functions/push.html" rel="nofollow"><code>push</code></a> is for.</p> <p>The two calls to that function can be changed from</p> <pre><code>combine_arrays(\@{${$blocks}[$join1]},\@hold); #right here ... combine_arrays(\@{${$blocks}[$i-1]},\@disagree_block); #right here </code></pre> <p>To just a call to <code>push</code>:</p> <pre><code>push @{$blocks-&gt;[$join1]}, @hold; ... push @{$blocks-&gt;[$i-1]}, @disagree_block; </code></pre>
<pre><code>my @hold = ${$blocks}[$join2]; </code></pre> <p>is unreadable version of</p> <pre><code>my @hold = $blocks-&gt;[$join2]; </code></pre> <p>so you might want to dereference the array,</p> <pre><code>my @hold = @{ $blocks-&gt;[$join2] }; </code></pre> <p><em>Side notes</em>: </p> <ul> <li>enable <code>strict</code> and <code>warnings</code> if you didn't already.</li> <li><code>\@{${$blocks}[$join1]}</code> is taking reference to dereferenced array which is equal back to <code>${$blocks}[$join1]</code> (or <code>$blocks-&gt;[$join1]</code>)</li> </ul>