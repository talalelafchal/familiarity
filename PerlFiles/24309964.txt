Issue with XML::Bare perl
<p>I'm using <a href="http://search.cpan.org/~codechild/XML-Bare-0.53/Bare.pm" rel="nofollow">XML::Bare</a> module in perl.</p> <p>My xml is something like:</p> <pre><code>&lt;xml&gt; &lt;element num="1"&gt; &lt;num&gt;10&lt;/num&gt; &lt;/element&gt; &lt;element num="2"&gt; &lt;num&gt;20&lt;/num&gt; &lt;/element&gt; &lt;/xml&gt; </code></pre> <p>I want to extract out value contained in child <code>&lt;num&gt;</code> tag. i.e. I want <code>10 and 20</code> as output. But when I get value using <code>$xml-&gt;{element}-&gt;[$i]-&gt;{num}-&gt;{value}</code> it returns <code>1 adn 2</code> i.e it returns with value of <code>num</code> attribute instead of child node. Can anyone please help me how to handle cases when attribute and child name are same.</p> <p>Thanks</p>
<p>It looks like a bug in <code>XML::Bare</code>. I don't see the <code>&lt;num&gt;</code> element in <code>Dumper</code> output:</p> <pre><code>use warnings; use strict; use XML::Bare; my $xml = q( &lt;xml&gt; &lt;element num="1"&gt; &lt;num&gt;10&lt;/num&gt; &lt;/element&gt; &lt;element num="2"&gt; &lt;num&gt;20&lt;/num&gt; &lt;/element&gt; &lt;/xml&gt; ); my $ob = new XML::Bare( text =&gt; $xml ); my $root = $ob-&gt;parse(); use Data::Dumper; $Data::Dumper::Sortkeys=1; print Dumper($root); __END__ $VAR1 = { '_i' =&gt; 0, '_pos' =&gt; 0, '_z' =&gt; 0, 'value' =&gt; ' ', 'xml' =&gt; { '_i' =&gt; 438404290, '_pos' =&gt; 1, '_z' =&gt; 130, 'element' =&gt; [ { '_i' =&gt; 438404300, '_pos' =&gt; 2, '_z' =&gt; 64, 'num' =&gt; { '_att' =&gt; 1, 'value' =&gt; '1' }, 'value' =&gt; ' ' }, { '_i' =&gt; 438404359, '_pos' =&gt; 4, '_z' =&gt; 123, 'num' =&gt; { '_att' =&gt; 1, 'value' =&gt; '2' }, 'value' =&gt; ' ' } ], 'value' =&gt; ' ' } }; </code></pre> <p><a href="https://rt.cpan.org/Public/Dist/Display.html?Name=XML-Bare" rel="nofollow">You could submit a bug report</a>.</p> <p>Here is a solution with <code>XML::Twig</code>:</p> <pre><code>use warnings; use strict; use XML::Twig; my $xml = q( &lt;xml&gt; &lt;element num="1"&gt; &lt;num&gt;10&lt;/num&gt; &lt;/element&gt; &lt;element num="2"&gt; &lt;num&gt;20&lt;/num&gt; &lt;/element&gt; &lt;/xml&gt; ); my $twig= XML::Twig-&gt;new(twig_handlers =&gt; { element =&gt; \&amp;elem }); $twig-&gt;parse($xml); sub elem { my( $twig, $ele)= @_; my $att = $ele-&gt;att('num'); my $num = $ele-&gt;first_child('num')-&gt;text(); print "$att $num\n"; } __END__ 1 10 2 20 </code></pre>
<p>If <a href="https://metacpan.org/pod/XML%3a%3aBare" rel="nofollow"><code>XML::Bare</code></a> or <a href="https://metacpan.org/pod/XML%3a%3aSimple" rel="nofollow"><code>XML::Simple</code></a> are used, they should be limited to only the most basic XML reading. Given that your data has an attribute and child node that share a name fails that limitation.</p> <p>In truth though, unless there is a specific reason to not, one should just stick with the more modern XML Parsers such as <a href="https://metacpan.org/pod/XML%3a%3aTwig" rel="nofollow"><code>XML::Twig</code></a> and <a href="https://metacpan.org/pod/XML%3a%3aLibXML" rel="nofollow"><code>XML::LibXML</code></a> and the full power of XPath support.</p> <p>The following parses your XML using both of these two modules:</p> <pre><code>use strict; use warnings; use XML::LibXML; use XML::Twig; my $data = do {local $/; &lt;DATA&gt;}; print "XML::LibXML\n"; my $xml = XML::LibXML-&gt;load_xml(string =&gt; $data); for my $node ($xml-&gt;findnodes('//element/num')) { print $node-&gt;textContent(), "\n"; } print "XML::Twig\n"; my $t = XML::Twig-&gt;new( twig_handlers =&gt; { '//element/num' =&gt; sub { print $_-&gt;text(), "\n" }, }, ); $t-&gt;parse( $data ); __DATA__ &lt;xml&gt; &lt;element num="1"&gt; &lt;num&gt;10&lt;/num&gt; &lt;/element&gt; &lt;element num="2"&gt; &lt;num&gt;20&lt;/num&gt; &lt;/element&gt; &lt;/xml&gt; </code></pre> <p>Outputs:</p> <pre><code>XML::LibXML 10 20 XML::Twig 10 20 </code></pre>