Perl rounding error again
<p>The example to show the problem:</p> <ul> <li>having a number 105;</li> <li>divide with 1000 (result 0.105)</li> <li>rouded to 2 decimal places should be: 0.11</li> </ul> <p>Now, several scripts - based on answers to another questions:</p> <p>This is mostly recommented and mostly upvoted solution is using <code>printf</code>.</p> <pre><code>use 5.014; use warnings; my $i = 105; printf "%.2f\n", $i/1000; #prints 0.10 </code></pre> <p>but prints a wrong result. In the comment to <a href="http://stackoverflow.com/a/1838885">http://stackoverflow.com/a/1838885</a> @Sinan Unur says (6 times upvoted comment): </p> <blockquote> <p>Use sprintf("%.3f", $value) for mathematical purposes too.</p> </blockquote> <p>but, it didn't works "sometimes"... like above.</p> <p>The another recommented solution <code>Math::BigFloat</code>:</p> <pre><code>use 5.014; use warnings; use Math::BigFloat; my $i = 105; Math::BigFloat-&gt;precision(-2); my $r = Math::BigFloat-&gt;new($i/1000); say "$r"; #0.10 ;( </code></pre> <p>Wrong result too. Another recommened one <code>bignum</code>:</p> <pre><code>use 5.014; use warnings; use bignum ( p =&gt; -2 ); my $i = 105; my $r = $i/1000; say "$r"; #0.10 ;( </code></pre> <p>wrong again. ;(</p> <p>Now the working ones:</p> <pre><code>use 5.014; use warnings; use Math::Round; my $i = 105; say nearest(0.01, $i/1000); #GREAT prints 0.11 :) </code></pre> <p>good result <code>0.11</code>, however a comment here <a href="http://stackoverflow.com/a/571740">http://stackoverflow.com/a/571740</a> complains about it.</p> <p>and finally another recommendation "by my own" function:</p> <pre><code>use 5.014; use warnings; my $i = 105; my $f = $i/1000; say myround($f,2); # 0.11 sub myround { my($float, $prec) = @_; my $f = $float * (10**$prec); my $r = int($f + $f/abs($f*2)); return $r/(10**$prec); } </code></pre> <p>prints <code>0.11</code> too, but can't prove it's correctness.</p> <p>For the reference I was read:</p> <ul> <li><a href="http://stackoverflow.com/q/178539">How do you round a floating point number in Perl?</a></li> <li><a href="http://stackoverflow.com/q/571329">In Perl, how can I limit the number of places after the decimal point but have no trailing zeroes?</a></li> <li><p><a href="http://stackoverflow.com/q/1838808">How do I set the floating point precision in Perl?</a></p></li> <li><p>and many-many others...</p></li> <li><p>and finally this too: <a href="http://www.exploringbinary.com/inconsistent-rounding-of-printed-floating-point-numbers/">http://www.exploringbinary.com/inconsistent-rounding-of-printed-floating-point-numbers/</a> what gives a an <strong>really good</strong> overall view to the problem.</p></li> </ul> <p>I understand than it is common problem to all languages, but please, after all above reading - I still have this question:</p> <p>What is the <strong>error-proof</strong> way in perl to round a floating point number to N decimal places - with mathematically correct way, e.g. what will round results like <code>105/1000</code> correctly to N decimal places without "surprises"...</p>
<p>Your custom function should mostly work as expected. Here's how it works and how you can verify it's correct:</p> <pre><code>sub myround { my($float, $prec) = @_; # Prevent div-by-zero later on if ($float == 0) { return 0; } # Moves the decimal $prec places to the right # Example: $float = 1.234, $prec = 2 # $f = $float * 10^2; # $f = $float * 100; # $f = 123.4; my $f = $float * (10**$prec); # Round 0.5 away from zero using $f/abs($f*2) # if $f is positive, "$f/abs($f*2)" becomes 0.5 # if $f is negative, "$f/abs($f*2)" becomes -0.5 # if $f is zero, we have a problem (hence the earlier if statement) # In our example: # $f = 123.4 + (123.4 / (123.4 * 2)); # $f = 123.4 + (0.5); # $f = 123.9; # Then we truncate to integer: # $r = int(123.9); # $f = 123; my $r = int($f + $f/abs($f*2)); # Lastly, we shift the deciaml back to where it should be: # $r / 10^2 # $r / 100 # 123 / 100 # return 1.23; return $r/(10**$prec); } </code></pre> <p>However, the following it will throw an error for <code>$float = 0</code>, so there's an additional <code>if</code> statement at the beginning.</p> <p>The nice thing about the above function is that it's possible to round to <em>negative</em> decimal places, allowing you round to the left of the decimal. For example, <code>myround(123, -2)</code> will give <code>100</code>.</p>
<p>In the old Integer math days of programming, we use to <em>pretend</em> to use decimal places:</p> <pre><code>N = 345 DISPLAY N # Displays 345 DISPLAY (1.2) N # Displays 3.45 </code></pre> <p>We learned a valuable trick when attempting to round sales taxes correctly:</p> <pre><code>my $amount = 1.344; my $amount_rounded = sprintf "%.2f", $amount + .005; my $amount2 = 1.345; my $amount_rounded2 = sprintf "%.2f", $amount2 + .005; say "$amount_rounted $amount_rounded2"; # prints 1.34 and 1.35 </code></pre> <p>By adding in 1/2 of the precision, I display the rounding correctly. When the number is 1.344, adding .005 made it 1.349, and chopping off the last digit displays dip lays 1.344. When I do the same thing with 1.345, adding in .005 makes it 1.350 and removing the last digit displays it as 1.35.</p> <p>You could do this with a subroutine that will return the <em>rounded</em> amount.</p> <hr> <h2>Interesting...</h2> <p>There is a <a href="http://perldoc.perl.org/perlfaq4.html#Does-Perl-have-a-round%28%29-function%3f-What-about-ceil%28%29-and-floor%28%29%3f-Trig-functions%3f">PerlFAQ</a> on this subject. It recommends simply using <code>printf</code> to get the correct results:</p> <pre><code>use strict; use warnings; use feature qw(say); my $number = .105; say "$number"; printf "%.2f\n", $number; # Prints .10 which is incorrect printf "%.2f\n", 3.1459; # Prins 3.15 which is correct </code></pre> <p>For <em>Pi</em>, this works, but not for <code>.105</code>. However:</p> <pre><code>use strict; use warnings; use feature qw(say); my $number = .1051; say "$number"; printf "%.2f\n", $number; # Prints .11 which is correct printf "%.2f\n", 3.1459; # Prints 3.15 which is correct </code></pre> <p>This looks like an issue with the way Perl stores .105 internally. Probably something like <code>.10499999999</code> which would be correctly rounded downwards. I also noticed that Perl warns me about using <code>round</code> and <code>rounding</code> as possible future reserved words.</p>
<p>You're expecting a specific behaviour when the number is exactly <code>0.105</code>, but floating point errors mean you can't expect a number to be exactly what you think it is.</p> <p>105/1000 is a periodic number in binary just like 1/3 is periodic in decimal.</p> <pre><code>105/1000 ____________________ = 0.00011010111000010100011 (bin) ~ 0.00011010111000010100011110101110000101000111101011100001 (bin) = 0.10499999999999999611421941381195210851728916168212890625 </code></pre> <p>0.1049999... is less than 0.105, so it rounds to 0.10.</p> <p>But even if you had 0.105 exactly, that would still round to 0.10 since <code>sprintf</code> rounds half to even. A better test is 155/1000</p> <pre><code>155/1000 ____________________ = 0.00100111101011100001010 (bin) ~ 0.0010011110101110000101000111101011100001010001111010111 (bin) = 0.1549999999999999988897769753748434595763683319091796875 </code></pre> <p>0.155 should round to 0.16, but it rounds to 0.15 due to floating point error.</p> <pre><code>$ perl -E'$_ = 155; say sprintf("%.2f", $_/1000);' 0.15 $ perl -E'$_ = 155; say sprintf("%.0f", $_/10)/100;' 0.16 </code></pre> <p>The second one works because 5/10 isn't periodic, and therein lies the solution. As Sinan Unur said, you can correct the error by using <code>sprintf</code>. But you have to round to an integer if you don't want to lose your work.</p> <pre><code>$ perl -E' $_ = 155/1000; $_ *= 1000; # Move decimal point past significant. $_ = sprintf("%.0f", $_); # Fix floating-point error. $_ /= 10; # 5/10 is not periodic $_ = sprintf("%.0f", $_); # Do our rounding. $_ /= 100; # Restore decimal point. say; ' 0.16 </code></pre> <p>That will fix the rounding error, allowing <code>sprintf</code> to properly round half to even.</p> <pre><code>0.105 =&gt; 0.10 0.115 =&gt; 0.12 0.125 =&gt; 0.12 0.135 =&gt; 0.14 0.145 =&gt; 0.14 0.155 =&gt; 0.16 0.165 =&gt; 0.16 </code></pre> <p>If you want to round half up instead, you'll need to using something other than <code>sprintf</code> to do the final rounding. Or you could add <code>s/5\z/6/;</code> before the division by 10.</p> <hr> <p>But that's complicated.</p> <p>The first sentence of the answer is key. You're expecting a specific behaviour when the number is exactly <code>0.105</code>, but floating point errors mean you can't expect a number to be exactly what you think it is. The solution is to introduce a tolerance. That's what rounding using <code>sprintf</code> does, but it's a blunt tool.</p> <pre><code>use strict; use warnings; use feature qw( say ); use POSIX qw( ceil floor ); sub round_half_up { my ($num, $places, $tol) = @_; my $mul = 1; $mul *= 10 for 1..$places; my $sign = $num &gt;= 0 ? +1 : -1; my $scaled = $num * $sign * $mul; my $frac = $scaled - int($scaled); if ($sign &gt;= 0) { if ($frac &lt; 0.5-$tol) { return floor($scaled) / $mul; } else { return ceil($scaled) / $mul; } } else { if ($frac &lt; 0.5+$tol) { return -floor($scaled) / $mul; } else { return -ceil($scaled) / $mul; } } } </code></pre> <p>&#x20;</p> <pre><code>say sprintf '%5.2f', round_half_up( 0.10510000, 2, 0.00001); # 0.11 say sprintf '%5.2f', round_half_up( 0.10500001, 2, 0.00001); # 0.11 Within tol say sprintf '%5.2f', round_half_up( 0.10500000, 2, 0.00001); # 0.11 Within tol say sprintf '%5.2f', round_half_up( 0.10499999, 2, 0.00001); # 0.11 Within tol say sprintf '%5.2f', round_half_up( 0.10410000, 2, 0.00001); # 0.10 say sprintf '%5.2f', round_half_up(-0.10410000, 2, 0.00001); # -0.10 say sprintf '%5.2f', round_half_up(-0.10499999, 2, 0.00001); # -0.10 Within tol say sprintf '%5.2f', round_half_up(-0.10500000, 2, 0.00001); # -0.10 Within tol say sprintf '%5.2f', round_half_up(-0.10500001, 2, 0.00001); # -0.10 Within tol say sprintf '%5.2f', round_half_up(-0.10510000, 2, 0.00001); # -0.11 </code></pre> <p>There's probably existing solutions that work along the same lines.</p>
<p>I'd add <a href="http://perldoc.perl.org/bignum.html" rel="nofollow"><code>use bignum</code></a> to your original code example.</p> <pre><code>use 5.014; use warnings; use bignum; my $i = 105; # Parsed as Math::BigInt my $r = $i / 1000; # Overloaded division produces Math::BigFloat say $r-&gt;ffround(-2, +inf); # Avoid using printf and the resulting downgrade to common float. </code></pre> <p>This solves the error you made in your <code>use Math::BigFloat</code> example by parsing your numbers into objects imediately and not waiting for you to pass the results of a round off error into <code>Math::BigFloat-&gt;new</code></p>