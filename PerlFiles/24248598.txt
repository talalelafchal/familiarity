Perl Function that validates input using if statements
<p>I want to create a Perl function as follows:</p> <pre><code>$iError = _validate( "$cVariable", "c" ); </code></pre> <p><code>$cVariable</code> – the input that I want to validate against a pre-defined standard</p> <pre><code>"c" – the type of data that is expected c = character a = alphanumeric i = integer x = decimal number d = date, two default formats are YY_MM_DD and YYYY_MM_DD f = file/dir name e = characters that are valid in an email address (email address must have \@ instead of just @) </code></pre> <p>Return values:</p> <pre><code>Success = 0 Failed = -1 </code></pre> <p>This is what I have so far but there's definitely some formatting errors that I can't catch since I am completely new to Perl, can anyone point out where I am going wrong?</p> <pre><code>$iError=_validate($cVariable, c) if ($c == c) { if ($cVariable =~ ^.+$) { $iError=0 } else { $iError=-1 } # end if elsif ($c == a) { if ($cVariable =~ ^([a-z])|([0-9])+$) { %iError=0 } else {$iError=-1} # end if } elsif ($c == i) { if ($cVariable =~ ^[-+]?\d+$) { $iError=0 } else {$iError = -1} # end if } elsif ($c == x) { if ($cVariable =~ ^[0-9]+[.][0-9]+$) { $iError=0 } else {$iError=-1} # end if } elsif ($c == d) { if ($cVariable =~ ^\d{2}_{1}\d{2}_{1}\d{2}$) { $iError=0 } elsif ($cVariable =~ ^\d{4}_{1}\d{2}_{1}\d{2}$) { $iError=0 } else {$iError=-1} # end if } elsif($c == f) { if ($cVariable =~ ^.+$) { $iError=0 } else {$iError=-1} # end if } else($c == e) { if ($cVariable =~ ^\S{0,50}\\@\S{0,20}[.]\S{1,10}$) { $iError=0 } else {$iError=0} # end if } # end outer if return($iError); </code></pre>
<p>Your code is broken and incomplete enough that I'm reluctant to wade through all the error messages just to get it to compile, as you would still have a flawed solution in the end.</p> <p>Syntax, just about anyone can learn. But the more important problem is that each of the things you're trying to validate (with the exception of a character) are not as trivial as you might expect. Given the complexities involved in validating an email address, or a date, well-proven code as provided by trusted CPAN modules is the way to go. You really don't want to waste a lot of time fleshing out the details of a date validator, for example. </p> <p>Here's how I might get started on it. The following code provides exactly the behavior you've described (with the exception of file/dir, since I don't know what you want there). But it does so in a way that is probably more correct than simple regex matching alone:</p> <pre><code>#!/usr/bin/env perl use strict; use warnings; use Scalar::Util 'looks_like_number'; use Date::Calc 'check_date'; use Email::Valid; use constant VALIDATORS =&gt; { 'c' =&gt; \&amp;char, # Validate a single character. 'a' =&gt; \&amp;alnum, # Validate string is alphanumeric only. 'i' =&gt; \&amp;intgr, # Validate input is an integer. 'x' =&gt; \&amp;dec, # Validate input is a number. 'd' =&gt; \&amp;date, # Validate input is a date in YYYY_MM_DD or YY_MM_DD 'f' =&gt; \&amp;fdn, # Who knows?! Something to do with file validation. 'e' =&gt; \&amp;eml, # Validate input is a legal email address. }; sub validate { my( $input, $mode ) = @_; die "No mode provided." unless defined $mode; die "Invalid mode: $mode." unless exists VALIDATORS-&gt;{$mode}; return -1 if not defined $input; return VALIDATORS-&gt;{$mode}-&gt;($input) ? 0 : -1; } sub char { my $c = shift; return 1 == length $c; } sub alnum { my $an = shift; return $an =~ /\A\p{Alnum}+\z/; } sub intgr { my $n = shift; return looks_like_number($n) &amp;&amp; $n == int($n); } sub dec { return looks_like_number(shift); } sub date { my $date = shift; my( $y, $m, $d ); if( ( $y, $m, $d ) = $date =~ m/\A(\d{2}|\d{4})_(\d{2})_(\d{2})\z/ ) { return check_date( $y, $m, $d ); } else { return 0; } } sub fdn { # I have no idea what you want to do in validating a filename or directory. # Is this a matter of "legal characters" for a given OS? # Or is it a matter of "This file / path exists"? } sub eml { return Email::Valid-&gt;address(shift) } # ___________________________ use Test::More; { local $@; eval{ validate('a') }; like ( $@, qr/^No mode provided/, 'Die if no mode provided.' ); } { local $@; eval{ validate('a','invalid') }; like( $@, qr/^Invalid mode/, 'Die on invalid mode.' ); } # 0 = success, -1 = failure. ok( 0 == validate( 'a','c' ), 'Char accepted.' ); ok( -1 == validate( 'ab', 'c' ), 'More than one char rejected.' ); ok( -1 == validate( '', 'c' ), 'Empty string rejected.' ); ok( -1 == validate( undef, 'c' ), 'undefined value rejected.' ); # 0 = success, non-zero = failure (-1). ok( !validate( 'aA10', 'a' ), 'Alnum accepted.' ); ok( validate( '.$', 'a' ), 'Non-alnum rejected.' ); ok( validate( undef,'a' ), 'undefined value rejected for alnum.' ); ok( !validate( '10', 'i' ), 'Positive integer.' ); ok( !validate( -5, 'i' ), 'Negative integer.' ); ok( validate( -0.5, 'i' ), 'Reject non-integer.' ); ok( validate( 'a', 'i' ), 'Reject non-numeric as int.' ); ok( !validate( '10', 'x' ), 'Positive integer as decimal number.' ); ok( !validate( '10.5', 'x' ), 'Positive floating point as decimal number.' ); ok( validate( '17f', 'x' ), 'Decimal rejects hex string.' ); ok( validate( '12.3.5', 'x' ), 'Malformed decimal rejected.' ); ok( !validate( '1600_12_15', 'd' ), 'Four digit year date accepted.' ); ok( !validate( '14_06_05', 'd' ), 'Two digit year date accepted.' ); ok( validate( '15000_12_15', 'd' ), 'Y10k bug ;)' ); ok( validate( '2000_02_30', 'd' ), 'Impossible date rejected.' ); ok( !validate( 'someone@example.com', 'e' ), 'Good email address accepted.' ); ok( validate( 'a"b(c)d,e:f;g&lt;h&gt;i[j\k]l@example.com', 'e' ), 'Bad email rejected.' ); ok( validate( 'a@b@example.com', 'e' ), 'Bad email rejected.' ); done_testing(); </code></pre> <p>I don't particularly care for the "0 == success, -1 == failure" mode, but it's not unheard of, and is simple to achieve.</p> <p>There are modules on CPAN that would probably do a better job of validating integers and numbers, and you're welcome to search them out and drop them into place. My tests for those categories are quick and dirty, and should be effective in most cases.</p> <p>For more detailed info on numeric validation, have a look at <a href="http://perldoc.perl.org/perlfaq4.html#How-do-I-determine-whether-a-scalar-is-a-number/whole/integer/float?" rel="nofollow">perlfaq4</a>.</p> <p>I didn't attempt to validate a filename or directory, as I'm not sure what you're after in that regard. The File::Util module could be useful in verifying that a filename is legal for a given operating system. As for paths, I'm not sure if you want to know if the characters are legal, or if the path exists. You'll have to work on that yourself.</p> <p>None of this is the sort of thing that someone new to Perl should be taking on oneself when a deadline looms. There's a lot of learning involved in something that on the face looks quite simple.</p>
<p>One way to develop a solution, while learning Perl, would be to take the <a href="http://en.wikipedia.org/wiki/Test-driven_development" rel="nofollow">Test Driven Development</a> [TDD] approach, in which you start out writing one or more tests and then develop the code to enable the tests to pass.</p> <p>For the problem you state, you could start with a file of tests (call it 'validate.t' and put it in a directory named 't'):</p> <pre><code>#!/usr/bin/env perl -I. use Test::More ; BEGIN { require_ok( "ValidateStarter.pl" ) ; } my $cVariable = 'abc' ; my $iError = validate( $cVariable, 'c' ) ; is( $iError, 0, "correctly validated a character string ($cVariable)" ) ; $cVariable = 'def456' ; $iError = validate( $cVariable, 'c' ) ; is( $iError, -1, "correctly validated a non-character string ($cVariable)" ) ; $cVariable = 'def456' ; $iError = validate( $cVariable, 'a' ) ; is( $iError, 0, "correctly validated an alphanumeric string ($cVariable)" ) ; $cVariable = '123' ; $iError = validate( $cVariable, 'a' ) ; is( $iError, -1, "correctly validated a non-alphanumeric string ($cVariable)" ) ; $cVariable = '1' ; $iError = validate( $cVariable, 'i' ) ; is( $iError, 0, "correctly validated an integer ($cVariable)" ) ; $cVariable = 'z' ; $iError = validate( $cVariable, 'i' ) ; is( $iError, -1, "correctly validated a non-integer ($cVariable)" ) ; $cVariable = '123.456' ; $iError = validate( $cVariable, 'x' ) ; is( $iError, 0, "correctly validated a decimal number ($cVariable)" ) ; $cVariable = '-0.1234567' ; $iError = validate( $cVariable, 'x' ) ; is( $iError, 0, "correctly validated a decimal number ($cVariable)" ) ; $cVariable = '1234567' ; $iError = validate( $cVariable, 'x' ) ; is( $iError, 0, "correctly validated a decimal number ($cVariable)" ) ; $cVariable = '0xDEADBEEF' ; $iError = validate( $cVariable, 'x' ) ; is( $iError, -1, "correctly validated a non-decimal number ($cVariable)" ) ; done_testing ; </code></pre> <p>Next, in the directory 'above' t/, create a file called ValidateStarter.pl:</p> <pre><code>#!/usr/bin/env perl use strict ; use warnings ; use Regexp::Common qw( number ) ; sub validate { my ( $cVar, $c ) = @_ ; if ( 'c' eq $c ) { if ( $cVar =~ /^[[:alpha:]]+$/ ) { return 0 ; } } elsif ( 'a' eq $c ) { if ( $cVar =~ /^[[:alpha:]][[:alnum:]]+$/ ) { return 0 ; } } elsif ( 'i' eq $c ) { if ( $cVar =~ /^$RE{num}{int}$/ ) { return 0 ; } } elsif ( 'x' eq $c ) { if ( $cVar =~ /^$RE{num}{decimal}$/ ) { return 0 ; } } elsif ( 'a' eq $c ) { if ( $cVar =~ /^\A\p{Alnum}+\z$/ ) { return 0 ; } } return -1 ; } 1 ; </code></pre> <p>Execute the tests by changing to the directory containing ValidateStarter.pl and the t/ directory and typing (Note: '$' would be your console prompt -- don't type it):</p> <pre><code>$ perl t/validate.t </code></pre> <p>If you can figure out how to make 'validate.t' an executable file (hint: use 'chmod' on Linux), then you could just type:</p> <pre><code>$ t/validate.t </code></pre> <p>On Linux, you'd see:</p> <pre><code>$ t/validate.t ok 1 - require 'ValidateStarter.pl'; ok 2 - correctly validated a character string (abc) ok 3 - correctly validated a non-character string (def456) ok 4 - correctly validated an alphanumeric string (def456) ok 5 - correctly validated a non-alphanumeric string (123) ok 6 - correctly validated an integer (1) ok 7 - correctly validated a non-integer (z) ok 8 - correctly validated a decimal number (123.456) ok 9 - correctly validated a decimal number (-0.1234567) ok 10 - correctly validated a decimal number (1234567) ok 11 - correctly validated a non-decimal number (0xDEADBEEF) 1..11 </code></pre> <p>'ok' on a line of output means a test passed, while 'not ok' would mean it failed.</p> <p>Starting with these lines of working code, I would suggest further steps along these lines:</p> <ol> <li>Read <a href="http://search.cpan.org/dist/Test-Simple/lib/Test/Tutorial.pod" rel="nofollow">Test::Tutorial</a> for more on how to write tests in Perl.</li> <li>Read <a href="http://search.cpan.org/dist/Regexp-Common/lib/Regexp/Common/number.pm" rel="nofollow">Regexp::Common::number</a> to see about using some good regular expression utilities.</li> <li><a href="http://modernperlbooks.com/books/modern_perl_2014/" rel="nofollow">Browse the online text of 'Modern Perl'</a> by chromatic to read more about Perl itself.</li> <li>Study and tinker with the example code until you understand how it works.</li> <li>Add more test cases applying to the sample code.</li> <li>Add a test case applying to another of the line items in your problem spec. and follow-up with the code to enable the test to pass.</li> <li>Debug &amp; add more test cases until you're done.</li> </ol> <p>Judging by the very specific nature of your question, it seems likely that it's based on an assignment with a specific deadline, so you may believe you don't have time to write automated tests; but TDD is a good way to make progress incrementally as you learn what you need to know to develop the solution.</p> <p>Keep in mind that you will know that whatever parts you're able to finish by the deadline are working as proven by the tests that you've written.</p>
<p>When you do RegEx ("=~"), you need to surround the expression with "/". So your first RegEx if statement should look like:</p> <p><code>if ($cVariable =~ /^.+$/) {</code></p>