Reforming abnormal conditions to normal ones in Perl
<p>I have a weird file that lists some conditions in an abnormal way. Some of the abnormalities that I'm stuck with are the following forms:</p> <p><code>bluh &lt; blah &lt; blip</code>, <code>bluh &lt;= blah &lt; blih</code>, <code>bluh &lt; blah &lt;= blih</code> and <code>bluh &lt;= blah &lt;= blih</code> (and same forms for <code>&gt;</code> and <code>&gt;=</code>). </p> <p>(The abnormalities are not limited to this, but I'll try to handle the rest myself.) For now, assume that I am given with a $COND including multiple abnormalities (listed above). I want to reform all of the abnormalities to normal (perl looking) form.</p> <p>For instance, I have:</p> <p><code>100 &lt; r &lt;= expression &amp;&amp; 10 &gt;= d &gt; 1.3 &amp;&amp; s &gt;= 3</code></p> <p>and want to reform it to</p> <p><code>100 &lt; r &amp;&amp; r &lt;= expression &amp;&amp; 10 &gt;= d &amp;&amp; d &gt; 1.3 &amp;&amp; s &gt;=3</code></p> <p><strong>NOTE:</strong></p> <p>If it's too hard -which it shouldn't be- share your solution only for one abnormal condition. For example:</p> <p><code>10 &gt;= d &gt; 1.3</code> to <code>10 &gt;= d &amp;&amp; d &gt; 1.3</code></p>
<p>Need more examples to do this well, but based on the single example in your question, I think this will work:</p> <pre><code>open my $ABNORM, "&lt;file.txt" or die $!; my @lines = &lt;$ABNORM&gt;; close $ABNORM or die $!; foreach(@lines) { s/([&gt;=&lt;!]{1,2})\s*(\w+)\s*([&gt;=&lt;!]{1,2})/$1 $2 &amp;&amp; $2 $3/g; print $_, "\n"; } </code></pre>
<p>A relatively simple regex solution:</p> <pre><code>use strict; use warnings; my $expr_re = qr{(?:[\w\s.]+?)}; my $op_re = qr{(?:[&lt;&gt;=]+)}; while (&lt;DATA&gt;) { chomp; s/$expr_re$op_re\K\s*(?=($expr_re)\s*$op_re)/ $1 &amp;&amp; /g; print $_, "\n"; } __DATA__ foo &lt; bar &lt; baz foo &lt;= bar &lt; baz foo &lt; bar &lt;= baz foo &lt;= bar &lt;= baz foo &lt;= bar &lt;= baz &lt;= bazinga 100 &lt; r &lt;= expression &amp;&amp; 10 &gt;= d &gt; 1.3 &amp;&amp; s &gt;= 3 </code></pre> <p>Outputs:</p> <pre><code>foo &lt; bar &amp;&amp; bar &lt; baz foo &lt;= bar &amp;&amp; bar &lt; baz foo &lt; bar &amp;&amp; bar &lt;= baz foo &lt;= bar &amp;&amp; bar &lt;= baz foo &lt;= bar &amp;&amp; bar &lt;= baz &amp;&amp; baz &lt;= bazinga 100 &lt; r &amp;&amp; r &lt;= expression &amp;&amp; 10 &gt;= d &amp;&amp; d &gt; 1.3 &amp;&amp; s &gt;= 3 </code></pre> <p>There are two known flaws with this logic</p> <ol> <li><code>A || B &lt; C &lt; D</code> is not the same thing as <code>A || B &lt; C &amp;&amp; C &lt; D</code>. Namely, there needs to be parenthesis around the expanded expression to maintain proper order of operations. <code>A || (B &lt; C &amp;&amp; C &lt; D)</code></li> <li>I don't attempt to distinguish between lower precedence operators: <code>and</code>, <code>or</code>, <code>xor</code>. </li> </ol> <p>There are probably other flaws, but this can be a proof of concept at least.</p>