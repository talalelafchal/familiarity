Can you extend pack() to handle custom, variable length fields?
<p>The <a href="https://en.bitcoin.it/wiki/Protocol_specification#Variable_length_integer" rel="nofollow">Bitcoin protocol</a>, in order to save space, encodes their integers using what they call variable length integers or varints. The first byte of the varint encodes its length and its interpretation:</p> <pre><code>FirstByte Value &lt; 0xfd treat the byte itself as an 8 bit integer 0xfd next 2 bytes form a 16 bit integer 0xfe next 4 bytes form a 32 bit integer 0xff next 8 bytes form a 64 bit integer </code></pre> <p>(All ints are little endian and unsigned). I wrote the following function to unpack varints:</p> <pre><code>my $varint = "\xfd\x00\xff"; # \x00\xff in little endian == 65280 say unpack_varint($varint); # print 65280 sub unpack_varint{ my $v = shift; my $first_byte = unpack "C", $v; say $first_byte; if ($first_byte &lt; 253) { # \xfd == 253 return $first_byte; } elsif ($first_byte == 253){ return unpack "S&lt;", substr $v, 1, 2; } elsif ($first_byte == 254){ return unpack "L&lt;", substr $v, 1, 4; } elsif ($first_byte == 255){ return unpack "Q&lt;", substr $v, 1, 8; } else{ die "error"; } } </code></pre> <p>This works... but its very inelegant b/c if I have a long bytestring with embedded varints, I would have to read up to the beginning of the varint, pass the remainder to the function above, find out how long the encoded varint was, etc. etc. Is there a better way to write this? In particular, can I somehow extend <code>pack()</code> to support this kind of structure?</p>
<p>You can create a set of <code>shift_$type</code> functions that read and delete some value at the beginning of the given string, so your code becomes something as the following:</p> <pre><code>my $buffer = ...; my $val1 = shift_varint($buffer); my $val2 = shift_string($buffer); my $val3 = shift_uint32($buffer); ... </code></pre> <p>You can also add a multirecord "shifter":</p> <pre><code>my ($val1, $val2, $val3) = shift_multi($buffer, qw(varint string uint32)); </code></pre> <p>If you need more speed you could also write a compiler which can convert a set of types into an unpacker sub.</p>