how to check if the number of records in a db occurs more than x times
<p>I have a MySQL Table that holds records in the following scheme:</p> <pre><code>hostname | appname | timestamp | message </code></pre> <p>I am using a perl script to query the database to get all records for the last minute. This script is activated every 60 seconds.</p> <p>The Perl script gathers all records where timestamp is larger then current timestamp - 60 seconds. I can then check if I have more than, lets say 5, records which makes me do some other stuff in the script.</p> <p>What I want to achieve is to have a sort of "window" in my script, to be able to see if there is an overlapping between those every 60s script activation to ensure that there may be also more than 5 records.</p> <p>I give an example:</p> <p>The script is executed at 08:42:00 which gathers all records from 08:41:00 to starttime:</p> <pre><code>foo.net spbx 16-06-2014 08:41:51 foo.net spbx 16-06-2014 08:41:55 foo.net spbx 16-06-2014 08:41:57 foo.net spbx 16-06-2014 08:42:59 </code></pre> <p>So its 4 records - nothing to do.</p> <p>Script executed at 08:43:00 gathering from 08:42:00 to starttime:</p> <pre><code>foo.net spbx 16-06-2014 08:42:01 foo.net spbx 16-06-2014 08:42:02 foo.net spbx 16-06-2014 08:42:03 foo.net spbx 16-06-2014 08:42:04 </code></pre> <p>Still no error. But if you look precisely having a "dynamic interval" of 60 seconds you have more than 5 events occuring in a 60s interval that is not seen by this simple approach.</p> <p>I thought about gathering always the last 120 seconds and then check from the oldest entry upwards in a 60s window if there are more than 5 events. But I am wondering if there is any nicer approach to this "problem"?</p> <p>Thinking further if this dynamic approach finds more than 5 events then it needs to delete those entries in order to not gather them in the next execution (or just flag them in db whatever)</p> <p>The current code section is following:</p> <pre><code>my $dbConnect = DBI-&gt;connect("DBI:mysql:database=$dbName;host=$dbHost","$dbUser","$dbPass", { RaiseError =&gt; 1, AutoCommit =&gt; 0}) or die "ERROR - Can't connect to MySQL-Database: ".$DBI::errstr."\n"; debug("Connect to database successfull"); my $dbQuery = $dbConnect-&gt;prepare("SELECT message,timestamp FROM $dbTable WHERE hostname='$hostname' AND appname='$appname' AND timestamp &gt; ?"); my $date = Time::Piece-&gt;strptime(localtime-&gt;epoch-$threshold[1],"%s"); # adding the timezone offset - workaround for FAP-CENTREON $date += $date-&gt;localtime-&gt;tzoffset; my $starttime = $date-&gt;strftime("%Y-%m-%d %H:%M:%S"); debug("query: SELECT message,timestamp FROM $dbTable WHERE hostname=$hostname AND appname=$appname AND timestamp &gt; ".$starttime); $dbQuery-&gt;execute($starttime); my $amount = $dbQuery-&gt;rows; $alarmMessage = "$amount errors in ".$threshold[1]."s!\n"; if($amount &lt; $threshold[0]) { $alarmMessage = "$amount errors in ".$threshold[1]."s - this is OK! \n"; $exitCode = 0; } else { while(my @resultrows = $dbQuery-&gt;fetchrow_array) { $alarmMessage = $alarmMessage.$resultrows[1]." ".$resultrows[0]."\n"; } $exitCode = 2; } $dbQuery-&gt;finish(); $dbConnect-&gt;disconnect(); print "$alarmMessage \n"; </code></pre>
<p>A comment on scaling, if you don't mind.</p> <p>Performance on an SQL-only solution, joining the actively-being-written-to table against itself, is not going to scale well. If you really do expect to have on the order of 1 row per second you'll be fine. When you get to 100 rows per second it's going to hurt.</p> <p>In that case you'll probably want to have a periodic task summarizing short chunks of your table into a secondary table, then scan the secondary table for interesting events. If your secondary table has one row for each 10-second chunk, you can SUM those COUNTs in roughly constant time, no matter how many events are in the original table.</p> <p>If you find a SUM over a minute's worth of chunks that exceeds your threshold, then, depending on whether it really matters to you whether n events are seen in 59 vs. 61 seconds, or whether you just need a rough estimate, you can then perform a more-specific SELECT on the original table that gets you a precise answer.</p> <p>I wrote about this a few years ago, here:</p> <p><a href="http://beta.slashdot.org/journal/93006" rel="nofollow">http://beta.slashdot.org/journal/93006</a></p>
<p>You can do the first part with a single query:</p> <pre><code>SELECT a.timestamp, COUNT(*) ct FROM $dbTable AS a JOIN $dbTable AS b ON b.timestamp BETWEEN a.timestamp AND DATE_ADD(a.timestamp, INTERVAL 1 MINUTE) WHERE a.timestamp &gt; DATE_SUB(NOW(), INTERVAL 2 MINUTE) GROUP BY a.timestamp HAVING ct &gt; 5 </code></pre> <p>To find the messages that should be deleted or marked as having been noticed as excess, you can join this subquery to the table and select all the messages that are within 1 minute after the timestamp.</p>