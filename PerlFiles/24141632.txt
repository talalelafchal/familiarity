separating a string which does not has a delimiter in it
<p>Can we separate a string using index values, so that my input which comprises of combined characters can be separated and the final output would be a string which is readable.</p> <pre><code>Input = 20140610182213 Expecting Output = 2014-06-10 18:22:13 </code></pre>
<p>Just use <a href="http://perldoc.perl.org/Time/Piece.html" rel="nofollow"><code>Time::Piece</code></a></p> <pre><code>use strict; use warnings; use Time::Piece; my $string = "20140610182213"; my $date = Time::Piece-&gt;strptime($string, "%Y%m%d%H%M%S"); print $date-&gt;strftime("%Y-%m-%d %H:%M:%S"), "\n"; </code></pre> <p>Outputs:</p> <pre><code>2014-06-10 18:22:13 </code></pre>
<p>You might like <code>unpack</code> for this:</p> <pre><code>my ( $year, $mon, $mday, $hour, $min, $sec ) = unpack "A4 A2 A2 A2 A2 A2", "20140610182213"; say "$year-$mon-$mday $hour:$min:$sec"; </code></pre>
<p>If you want the values assigned to variables (e.g. $y, $m,$d etc.) for use later:</p> <pre><code>perl -E '($y,$m,$d,$H,$M,$S)="20140610182213"=~/(....)(..)(..)(..)(..)(..)/;say "$y-$m-$d $H:$M:$S"' </code></pre>
<p>I think this is tidiest using a global pattrn match with <code>sprintf</code>:</p> <pre><code>my $dt = sprintf '%s%s-%s-%s %s:%s:%s', '20140610182213' =~ /../g; print $dt; </code></pre> <p><strong>output</strong></p> <pre><code>2014-06-10 18:22:13 </code></pre>
<p>Let's get all <a href="http://modernperlbooks.com" rel="nofollow">modern</a> on you:</p> <pre><code>use strict; use warnings; use feature qw(say); my $input = "20140610182213"; $input =~ /(?&lt;year&gt;\d{4}) (?&lt;month&gt;\d{2}) (?&lt;day&gt;\d{2}) (?&lt;hour&gt;\d{2}) (?&lt;minute&gt;\d{2}) (?&lt;second&gt;\d{2})/x; say "$+{year}-$+{month}-$+{day} $+{hour}:$+{minute}:$+{second}"; </code></pre> <p>I'm using <em>named back references</em> here. In Perl since the very early beginning, you always had numeric <em>back references</em> which I could set by using parentheses:</p> <pre><code>$input =~ /(\d{4})(\d{2})(\d{2})/; my $year = $1; my $month = $2; my $day = $3; </code></pre> <p>Each parentheses grouping was a back reference. This was taken directly from <code>sed</code>.</p> <p>In Perl 5.10, named back references can now be used. They're in the format of <code>(?&lt;name&gt;regex)</code> where <code>name</code> is the name of the back reference and <code>regex</code> is the regular expression. To refer to them, you use <code>$+{name}</code> where <code>name</code> is your back reference name.</p> <p>The big advantage is that you now have actual names for your back references, and you don't have to worry what <code>$2</code> means:</p> <pre><code>$input =~ /(?&lt;year&gt;\d{4})(?&lt;month&gt;\d{2})(?&lt;day&gt;\d{2})/; my $year = $+{year}; my $month = $+{month}; my $day = $+{day}; </code></pre> <p>Now, we use the <code>x</code> flag in regular expressions. This allows us to have multiple line regular expressions:</p> <pre><code>$input =~ /(?&lt;year&gt;\d{4}) (?&lt;month&gt;\d{2}) (?&lt;day&gt;\d{2})/x; #The /x flag my $year = $+{year}; my $month = $+{month}; my $day = $+{day}; </code></pre> <p>If you're not familiar with the syntax, it can be a bit hard on the eyes at first. However, one of the nice things about this is that it documents what's going on, and makes maintenance easer. Once your eyes <em>adjust to the light</em>, it is easy to see what is going on and find errors.</p> <hr> <p>Another possibility is to use <a href="http://perldoc.perl.org/Time/Piece.html" rel="nofollow">Time::Piece</a> to convert that date time to something that Perl can directly manipulate:</p> <pre><code>use strict; use warnings; use feature qw(say); use Time::Piece; my $input = "20140610182213"; my $date_object = Time::Piece-&gt;strptime($input, "%Y%m%d%H%M%S"); printf "%04d-%02d-%02d %02d:%02d:%02d\n", $date_object-&gt;year, $date_object-&gt;mon, $date_object-&gt;mday, $date_object-&gt;hour, $date_object-&gt;minute, $date_object-&gt;second; </code></pre> <p>Again, what's going on is well documented. You can see what the input string is, and you can easily refer to each part of the string, and even change the formatting. What if you want the name of the month? Use <code>$date_object-&gt;month</code>.</p> <p>For simple parsing and never using this again, the first way is probably the best. However, by using <code>Time::Piece</code>, you can now check to see how days there are between two dates (for example, how old is your date/time stamp?).</p>
<p>I usually use a substitution for similar tasks:</p> <pre><code>my $input = '20140610182213'; $input =~ s/(....)(..)(..)(..)(..)(..)/$1-$2-$3 $4:$5:$6/; print $input; </code></pre> <p>Another possibility is to use <code>substr</code>:</p> <pre><code>my $input = '20140610182213'; my @delims = ('-', '-', ' ', ':', ':'); substr $input, $_, 0, pop @delims for 12, 10, 8, 6, 4; print $input; </code></pre>