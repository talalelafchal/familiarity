Perl Class Inheritance
<p>I just wrote three perl objects that do relatively similar things, but with slightly different data. I realized after finishing the project that a lot of methods can be consolidated into a base class to reduce this duplication, so now I am in the process of moving the code around and I am running into some problems, one thing to keep in mind is that I am using 5.8.8, so some of the latest things don't work. Upgrading to a newer version is not an option for me at this time. </p> <p>I have a method that is invoked form the base class that is supposed to invoke another method also in the base class, but work on the the data in the actual object, they look like this:</p> <pre><code>sub check_cache{ my ($self, @data) = @_; #do stuff to check cache, return 0 if cache is not hit, otherwise return value } sub update_cache { my ($self, @data) = @_; if ($self-&gt;check_cache(@data) == 0 ) { #Check to see if value is already in cache, if not update it } } </code></pre> <p>The update_cache method is invoked from the actual object as $self->SUPER::update_cache(@data)</p> <p>The update_cache methods gets called fine, however it can't find the check_cache method. check_cache method seems to work fine if called from outside the base class. Can you guys give me a hand here? </p> <p>I've tried to invoke it in a number of different ways, but I keep getting something along the lines of </p> <pre><code>"Can't locate object method "check_cache" via package "ACTUAL OBJECT=hash(0x1231231)" (perhaps you forgot to load ACTUAL OBJECT=hash(0x1231231))? at line number. </code></pre> <p>line number points at update_cache's invokation of check cache in base class. </p> <p>What is the proper way for me to invoke this? </p> <p>EDIT: I got my code working, but I am not sure why I ran into this problem. Maybe someone can help me understand this a bit better. Here is some code that you can run that will demonstrate the problem, I ran this on perl 5.18.2 and I still ran into the same issue.</p> <p>All in all, it was just sloppy copying and pasting on my part, but it looks like the $self variable gets overwritten with some other data in here. I was able to troubleshoot it by placing Dumping statements throughout the culprit function to see if the object was still there, narrowed it down to this.</p> <p>Thanks in advance</p> <p>parentclass.pm:</p> <pre><code>package parentclass; use Data::Dumper; sub _print1{ my $self = shift; print($self-&gt;{class}); $self-&gt;_print2(); } sub _print2{ $self = shift; my @arr = [1,2,3]; my @b = $self-&gt;uniq(@arr); #&lt;---This line is the culprit if enabled the class tring won't print print("\n\nSecondPrint\n\n"); print($self-&gt;{class}); } sub uniq { my %seen = (); #&lt;---I wasn't pulling self or returning it here my @r = (); foreach my $a (@_) { $a = lc($a); unless ($seen{$a}) { push @r, $a; $seen{$a} = 1; } } return @r; } 1; </code></pre> <p>class.pm:</p> <pre><code>package class; use Data::Dumper; use parent parentclass; sub new { my $class = shift; my $self = {}; $self-&gt;{class} = "Class Value"; bless $self, $class; return $self; } sub _class_print{ my $self = shift; $self-&gt;_print1; } 1; </code></pre> <p>run.pl:</p> <pre><code>use class; my $class = class-&gt;new(); $class-&gt;_class_print(); </code></pre> <hr> <p>I got my code working, but I am not sure why I ran into this problem. Maybe someone can help me understand this a bit better. Here is some code that you can run that will demonstrate the problem, I ran this on perl 5.18.2 and I still ran into the same issue.</p> <p>All in all, it was just sloppy copying and pasting on my part, but it looks like the $self variable gets overwritten with some other data in here. I was able to troubleshoot it by placing Dumping statements throughout the culprit function to see if the object was still there, narrowed it down to this. </p> <p>Thanks in advance</p> <p>parentclass.pm:</p> <pre><code>package parentclass; use Data::Dumper; sub _print1{ my $self = shift; print($self-&gt;{class}); $self-&gt;_print2(); } sub _print2{ $self = shift; my @arr = [1,2,3]; my @b = $self-&gt;uniq(@arr); #&lt;---This line is the culprit if enabled the class tring won't print print("\n\nSecondPrint\n\n"); print($self-&gt;{class}); } sub uniq { my %seen = (); #&lt;---I wasn't pulling self or returning it at the end my @r = (); foreach my $a (@_) { $a = lc($a); unless ($seen{$a}) { push @r, $a; $seen{$a} = 1; } } return @r; } 1; </code></pre> <p>class.pm:</p> <pre><code>package class; use Data::Dumper; use parent parentclass; sub new { my $class = shift; my $self = {}; $self-&gt;{class} = "Class Value"; bless $self, $class; return $self; } sub _class_print{ my $self = shift; $self-&gt;_print1; } 1; </code></pre> <p>invoker.pl use class;</p> <pre><code>my $class = class-&gt;new(); $class-&gt;_class_print(); </code></pre>
<p>Always use <code>use strict; use warning;</code>!!!</p> <hr> <pre><code>use parent parentclass </code></pre> <p>should be</p> <pre><code>use parent 'parentclass'; </code></pre> <p>Found by strict. No harm done.</p> <hr> <p>Also,</p> <pre><code>sub _print2 { $self = shift; ... } </code></pre> <p>should be</p> <pre><code>sub _print2 { my $self = shift; ... } </code></pre> <p>No harm done, but mostly by luck. Caught by strict.</p> <hr> <p>Then you get</p> <pre><code>Can't use string ("class=hash(0x4a9334)") as a HASH ref while "strict refs" in use at parentclass.pm line 18. </code></pre> <p>That comes from the line </p> <pre><code>$self-&gt;{class} </code></pre> <p>It means <code>$self</code> is the <em>string</em> <code>class=hash(0x4a9334)</code>. Somehow, <code>$self</code> got stringified and converted the lowercase.</p> <p>It's due to a combination of two bugs.</p> <ol> <li><p>You call <code>uniq</code> as a method, but it's not a method.</p></li> <li><p><code>uniq</code> modifies <code>@_</code>, which means it's modifying the arguments passed to it.</p></li> </ol> <p>Don't forget that <code>foreach</code> doesn't copy the value into the loop variable; it aliases the loop variable to the value.</p> <p>When you modify <code>$a</code>, you modify <code>$_[0]</code>. When you modify <code>$self</code> (<code>uniq</code>'s first arg).</p> <p>Fix:</p> <pre><code>sub _print2{ ... my @b = uniq(@arr); ... } sub uniq { my %seen; return grep !$seen{lc($_)}++, @_; } </code></pre> <p>or</p> <pre><code>use List::MoreUtils qw( uniq ); sub _print2{ ... my @b = uniq(@arr); ... } </code></pre> <hr> <p>After that, there's yet another bug.</p> <pre><code>my @arr = [1,2,3]; # Assign a single scalar that's a reference to an array. </code></pre> <p>should be</p> <pre><code>my @arr = (1,2,3); # Assign three scalar that are numbers. </code></pre>