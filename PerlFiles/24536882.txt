Serving Image with Perl prints wrong Content-Length (Gives net::ERR_CONTENT_LENGTH_MISMATCH in Chrome)
<p>Activeperl 5.16 + Windows environment.</p> <p>Windows machine:</p> <p>Summary of my perl5 (revision 5 version 16 subversion 3) configuration:</p> <p>Linux machine:</p> <p>Summary of my perl5 (revision 5 version 14 subversion 2) configuration:</p> <p>Doesn't occur on Linux based at all with the same code.</p> <p>Here's my code that fetches a weather gif image, and does some magic (serving from cached directory for failover support in case internet dies or remote server does a radar update in the middle of a fetch, going offline)</p> <pre><code>sub get_map { my $whichImage = $_[0]; my $ua = LWP::UserAgent-&gt;new; my $cache_file = $GLOB{'cache_mapA'}; # tempdata file path my $cache_file_age = 100000; # this is used to determine if we have to get fresh data from the ems site will hold the tempdata file age in seconds my $data = ''; # initializing empty data variable to enable later check for empty variable my $cache_time = $GLOB{'cache_timeMap'}; # Max age of the temdata file in seconds my $useCached = 0; my $url = $GLOB{'mapAurl'}; if( $whichImage eq "B" ) { $cache_file = $GLOB{'cache_mapB'}; $url = $GLOB{'mapBurl'}; } if ( -s $cache_file ) # test existence of the tempdata file - if it has a size it exists { my $mtime = ( stat $cache_file )[9]; # get the Unix time of the last change (in seconds) my $current_time = time; # get the current Unix time (in seconds) $cache_file_age = $current_time - $mtime; # get the age of the tempdata fileim seconds! } if( $cache_file_age &gt; $cache_time ) # check if we have to query the ems server { my $response = $ua-&gt;get($url); if ($response-&gt;is_success) # checking if we were able to get the website { $data = $response-&gt;decoded_content( charset =&gt; 'none' ); open my $filehandle , '&gt;' , $cache_file or die 'Horribly'; binmode $filehandle; print $filehandle $data; close $filehandle; } } my $file = $cache_file; my $length = -s $file; print "Content-type: image/gif\n"; print "Content-length: $length \n\n"; binmode STDOUT; open (FH,'&lt;', $file) || die "Could not open $file: $!"; my $buffer = ""; while (read(FH, $buffer, 10240)) { print $buffer; } close(FH); } </code></pre> <p>cache_mapA points to tmp/map.A.gif and cache</p> <p>Going to <a href="http://mywebserver.com/whatever.cgi?type=mapA" rel="nofollow">http://mywebserver.com/whatever.cgi?type=mapA</a> gives a corrupted gif file that shows net::ERR_CONTENT_LENGTH_MISMATCH in Google Chrome's debugger.</p> <p>Going to <a href="http://mywebserver.com/tmp/map.A.gif" rel="nofollow">http://mywebserver.com/tmp/map.A.gif</a> works fine in a browser.</p> <p>Tried switching server software on my test box, Apache and LightTPD both show this behavior. </p> <p>I'm out of ideas since this works perfectly fine on non Windows based machine. </p> <p>It's possible there is an issue with this section but it looks fine to me:</p> <pre><code>print "Content-type: image/gif\n"; print "Content-length: $length \n\n"; binmode STDOUT; open (FH,'&lt;', $file) || die "Could not open $file: $!"; my $buffer = ""; while (read(FH, $buffer, 10240)) { print $buffer; } close(FH); </code></pre> <p>Help! </p>
<p>You did <code>binmode STDOUT</code> but not <code>binmode FH</code>. Windows Perl opens files with <code>:crlf</code> enabled by default; Unix Perl does not.</p> <p>The more modern technique would be <code>open (FH,'&lt;:raw', $file)</code> instead of using a separate call to <code>binmode</code>.</p> <p>If the image displays in other browsers, then the corruption for that particular image is probably minor enough that it doesn't prevent decoding.</p>