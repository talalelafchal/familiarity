Printing in unexpected order
<p>I expected the following to print in the order of the elements of <code>@Data</code>, but it's printing in the order of the elements of <code>@Queries</code>. Am I missing something? I also tried declaring the items to be printed after <code>foreach(@data){...</code> and then printing inside that loop, but still wrong order. </p> <p><code>$datafile</code> is a file with the following:</p> <pre><code>GR29929,JAMES^BOB GR21122,HANK^REN </code></pre> <p><code>$queryfile</code> is a file with the following:</p> <pre><code>(3123123212):# FD [GR21122] line 2 line 3 line 4 (12): # FD [HANK^REN] line 6 line 7 line 8 (13): # FD [Y] ------------------------------- -------------------------------- (3123123212):# FD [GR29929] line 2 line 3 line 4 (12): # FD [JAMES^BOB] line 6 line 7 line 8 (13): # FD [Z] </code></pre> <p>The output file is:</p> <pre><code>GR21122,HANK^WREN,Y GR29929,JAMES^BOB,Z </code></pre> <p>When I want:</p> <pre><code>GR29929,JAMES^BOB,Z GR21122,HANK^WREN,Y </code></pre> <p>Code is:</p> <pre><code>open(DA, "&lt;$datafile"); open(QR, "&lt;$queryfile"); my @Data = &lt;DA&gt;; my @Queries = &lt;QR&gt;; foreach (@Data) { my ( $acce, $namee ) = split( ',', $_ ); chomp $acce; chomp $namee; print "'$acce' and '$namee'\n"; for my $i ( 0 .. $#Queries ) { my $Qacce = $Queries[$i]; my $Qname = $Queries[ $i + 4 ]; my $Gen = $Queries[ $i + 8 ]; if ( $Qacce =~ m/$acce/ and $Qname =~ m/$namee/ ) { my ($acc) = $Qacce =~ /\[(.+?)\]/; my ($gen) = $Gen =~ /\[(.+?)\]/; $gen =~ s/\s+$//; my ($name) = $Qname =~ /\[(.+?)\]/; print GL "$i,$acc,$gen,$name\n"; } } } </code></pre>
<p>The basic shell of your program prints what you ask for, but there is a lot missing. The refactoring below should do what you want.</p> <p>You had a problem with the values of your <code>$i</code> index variable, so that the first time around the loop you were accessing <code>@data</code> elements <code>[0, 4, 8]</code>, the second time <code>[1, 5, 9]</code> etc. It looks like the second loop execution should use elements <code>[11, 15, 19]</code> and so on. Please correct me if I'm wrong.</p> <p>In addition you were using regular expressions to compare the keys in the two files, and you were finding nothing because the name values contain caret <code>^</code> characters which are special within regexes. Escaping the strings using <code>\Q...\E</code> fixed this.</p> <p>Note that a better solution would use hashes to match keys across the two files, but without details on your file format - particularly <code>queryfile</code> - I have had to follow your own algorithm.</p> <pre><code>use strict; use warnings; use autodie; my ($data_file, $query_file) = qw/ datafile.txt queryfile.txt /; my @queries = do { open my $query_fh, '&lt;', $query_file; &lt;$query_fh&gt;; }; chomp @queries; open my $data_fh, '&lt;', $data_file; while (&lt;$data_fh&gt;) { chomp; my ($acce, $namee) = split /,/; for (my $i = 0; $i &lt; @queries; $i += 11) { my ($qacce, $qname, $qgen) = @queries[$i, $i+4, $i+8]; if ( $qacce =~ /\Q$acce\E/ and $qname =~ /\Q$namee\E/ ) { my ($acc, $name, $gen) = map / \[ ( [^\[\]]+ ) \] /x, ($qacce, $qname, $qgen); $gen =~ s/\s+\z//; print "$acc,$name,$gen\n"; } } } </code></pre> <p><strong>output</strong></p> <pre><code>GR29929,JAMES^BOB,Z GR21122,HANK^REN,Y </code></pre>