Finding the GCD of two numbers quickly
<p>Are there any ways to make this program faster? I am thinking about some faster tools for user input etc.</p> <p>Here is my code:</p> <pre><code>sub partia { my ( $u, $v ) = @_; if ( $u == $v ) { return $u } if ( $u == 0 ) { return $v } if ( $v == 0 ) { return $u } if ( ~$u &amp; 1 ) { if ( $v &amp; 1 ) { return partia( $u &gt;&gt; 1, $v ); } else { return partia( $u &gt;&gt; 1, $v &gt;&gt; 1 ) &lt;&lt; 1; } } if ( ~$v &amp; 1 ) { return partia( $u, $v &gt;&gt; 1 ); } if ( $u &gt; $v ) { return partia( ( $u - $v ) &gt;&gt; 1, $v ); } return partia( ( $v - $u ) &gt;&gt; 1, $u ); } sub calosc { $t = &lt;&gt;; while ($t) { @tab = split( /\s+/, &lt;&gt; ); print( partia( $tab[0], $tab[1] ), "\n" ); $t--; } } calosc(); </code></pre> <p>How does program works :<br/> Generally it returns greatest common divisor for 2 numbers inputed by user. It's mostly Stein's algorithm.<br/> <br/> <strong>INPUT</strong> :<br/> First line: <br/> How many pairs user wants to check.[enter] <br/> Second line: <br/> first number [space] second number[enter] <br/> <br/> <strong>OUTPUT</strong>: <br/> GCD[enter] <br/> In Python I would use things like : <br/></p> <pre><code>from sys import stdin t=int(stdin.readline()) </code></pre> <p>instead of <br /></p> <pre><code>t=input() </code></pre> <p>Is there any way to do it?</p>
<p>Unless I've completely forgotten what I'm doing (no promises) - this algorithm looks like it keeps dividing it's terms by 2 in each recurse, which means your algorithm is O(log-base2-N). Unless you can find a constant-time algorithm, you've probably got the best one at the moment. </p> <p>Now @ikegami has mentioned micro-optimizations...if you want to make those, I suggest that you check out <a href="http://search.cpan.org/~timb/Devel-NYTProf-5.06/lib/Devel/NYTProf.pm" rel="nofollow">Devel::NYTProf</a> for an awesome Perl profiler that should be able to tell you where you're spending time in your algorithm, so you can target your microoptimisations.</p>
<h3>Your solution &mdash; Recursive Stein's Algorithm</h3> <p>It appears that you're simply trying to get the <a href="http://en.wikipedia.org/wiki/Greatest_common_divisor" rel="nofollow">GCD</a> of two numbers, and wanting to do so quickly.</p> <p>You're apparently using the recursive version of the <a href="http://en.wikipedia.org/wiki/Binary_GCD_algorithm" rel="nofollow">Binary GCD Algorithm</a>. Typically speaking, it is much better to use an iterative algorithm for both speed and scalability. However, I would assert that it is almost certainly worth it to try the much simpler <a href="http://en.wikipedia.org/wiki/Euclidean_algorithm" rel="nofollow">Euclidean algorithm</a> first.</p> <h3>Alternatives &mdash; Iterative Stein's Algorithm and Basic Euclidean Algorithm</h3> <p>I've adapted your script to take 3 number pairs from the <code>__DATA__</code> block as input. The first pair are just two small numbers, then I have two numbers from the <a href="http://en.wikipedia.org/wiki/Fibonacci_number" rel="nofollow">Fibonacci Sequence</a>, and finally two larger numbers including some shared powers of two.</p> <p>I then coded two new subroutines. One of them uses the Iterative Stein's Algorithm (the method your using), and the other is just a simple Euclidean Algorithm. <a href="http://perldoc.perl.org/Benchmark.html" rel="nofollow">Benchmarking</a> your <code>partia</code> subroutine versus my two subroutine for 1 million iterations report that the iterative is 50% faster, and that Euclid is <strong>3 times faster</strong>.</p> <pre><code>use strict; use warnings; use Benchmark; #use Math::Prime::Util::GMP qw(gcd); # Original solution # - Stein's Algorithm (recursive) sub partia { my ( $u, $v ) = @_; if ( $u == $v ) { return $u } if ( $u == 0 ) { return $v } if ( $v == 0 ) { return $u } if ( ~$u &amp; 1 ) { if ( $v &amp; 1 ) { return partia( $u &gt;&gt; 1, $v ); } else { return partia( $u &gt;&gt; 1, $v &gt;&gt; 1 ) &lt;&lt; 1; } } if ( ~$v &amp; 1 ) { return partia( $u, $v &gt;&gt; 1 ); } if ( $u &gt; $v ) { return partia( ( $u - $v ) &gt;&gt; 1, $v ); } return partia( ( $v - $u ) &gt;&gt; 1, $u ); } # Using Euclidian Algorithm sub euclid { my ( $quotient, $divisor ) = @_; return $divisor if $quotient == 0; return $quotient if $divisor == 0; while () { my $remainder = $quotient % $divisor; return $divisor if $remainder == 0; $quotient = $divisor; $divisor = $remainder; } } # Stein's Algorithm (Iterative) sub stein { my ($u, $v) = @_; # GCD(0,v) == v; GCD(u,0) == u, GCD(0,0) == 0 return $v if $u == 0; return $u if $v == 0; # Remove all powers of 2 shared by U and V my $twos = 0; while ((($u | $v) &amp; 1) == 0) { $u &gt;&gt;= 1; $v &gt;&gt;= 1; ++$twos; } # Remove Extra powers of 2 from U. From here on, U is always odd. $u &gt;&gt;= 1 while ($u &amp; 1) == 0; do { # Remove all factors of 2 in V -- they are not common # Note: V is not zero, so while will terminate $v &gt;&gt;= 1 while ($v &amp; 1) == 0; # Now U and V are both odd. Swap if necessary so U &lt;= V, # then set V = V - U (which is even). For bignums, the # swapping is just pointer movement, and the subtraction # can be done in-place. ($u, $v) = ($v, $u) if $u &gt; $v; $v -= $u; } while ($v != 0); return $u &lt;&lt; $twos; } # Process 3 pairs of numbers my @nums; while (&lt;DATA&gt;) { my ($num1, $num2) = split; # print "Numbers = $num1, $num2\n"; # print ' partia = ', partia($num1, $num2), "\n"; # print ' euclid = ', euclid($num1, $num2), "\n"; # print ' stein = ', stein($num1, $num2), "\n"; # print ' gcd = ', gcd($num1, $num2), "\n\n"; push @nums, [$num1, $num2]; } # Benchmark! timethese(1_000_000, { 'Partia' =&gt; sub { partia(@$_) for @nums }, 'Euclid' =&gt; sub { euclid(@$_) for @nums }, 'Stein' =&gt; sub { stein(@$_) for @nums }, # 'GCD' =&gt; sub { gcd(@$_) for @nums }, }); __DATA__ 20 25 # GCD of 5 89 144 # GCD of Fibonacci numbers = 1 4789084 957196 # GCD of 388 = 97 * 2 * 2 </code></pre> <p>Outputs:</p> <pre><code>Benchmark: timing 1000000 iterations of Euclid, Partia, Stein... Euclid: 9 wallclock secs ( 8.31 usr + 0.00 sys = 8.31 CPU) @ 120279.05/s (n=1000000) Partia: 26 wallclock secs (26.00 usr + 0.00 sys = 26.00 CPU) @ 38454.14/s (n=1000000) Stein: 18 wallclock secs (17.36 usr + 0.01 sys = 17.38 CPU) @ 57544.02/s (n=1000000) </code></pre> <h3>Module Solution &mdash; Math::Prime::Util::GMP qw(gcd)</h3> <p>The fastest solutions are likely to be C implementations of these algorithms though. I therefore recommend finding already coded versions like that provided by <a href="https://metacpan.org/pod/Math::Prime::Util::GMP" rel="nofollow"><code>Math::Prime::Util::GMP</code></a>.</p> <p>Running benchmarks including this new function shows that it is twice again as fast as the basic Euclidean algorithm that I programmed:</p> <pre><code>Benchmark: timing 1000000 iterations of Euclid, GCD, Partia, Stein... Euclid: 8 wallclock secs ( 8.32 usr + 0.00 sys = 8.32 CPU) @ 120264.58/s (n=1000000) GCD: 3 wallclock secs ( 3.93 usr + 0.00 sys = 3.93 CPU) @ 254388.20/s (n=1000000) Partia: 26 wallclock secs (25.94 usr + 0.00 sys = 25.94 CPU) @ 38546.04/s (n=1000000) Stein: 18 wallclock secs (17.55 usr + 0.00 sys = 17.55 CPU) @ 56976.81/s (n=1000000) </code></pre>