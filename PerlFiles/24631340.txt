Decoding UTF-16 with CRLF line endings from a line-based iterator
<p>So, I have an iterator object that returns lines, which are later decoded as the iterator doesn't know about encodings. All fine, right up until I tried to add UTF-16 support.</p> <p>Here's roughly my code:</p> <pre><code>use Encode qw(decode); my @lines; my $buffer = ''; while($buffer .= $iter-&gt;next){ push @lines, decode("UTF-16LE", $buffer, Encode::FB_QUIET); } </code></pre> <p>The data is little-endian UTF-16 with CRLF line-endings. Here's the first line pumped through <code>od -a</code>:</p> <pre><code>0000000 ff fe e nul m nul a nul i nul l nul ht nul l nul 0000020 a nul n nul g nul u nul a nul g nul e nul ht nul 0000040 e nul x nul a nul m nul p nul l nul e nul _ nul 0000060 t nul e nul x nul t nul cr nul nl nul </code></pre> <p>The problem that I've got is that I end up with the line endings split. The first line ends in a CR, and the second begins in an LF, and so on.</p> <p>Any idea what's going on here and how to get around it?</p> <p>Edit:</p> <p>On closer inspection, what's happening is the line-based iterator is returning everything up to and including the LF, but (importantly) NOT the null byte after it. <code>decode()</code> is set up to only read the characters it can from the buffer, so leaves the lone LF in the buffer for next time. The next iteration comes around and adds everything up to the next LF, which includes the null. So you end up with a CR at the end of one line and a LF at the beginning of the next.</p> <p>I'm not really sure what to do about that, apart from have another buffer on top that reads only complete lines from <code>decode()</code>s output..</p> <p>Any suggestions?</p>
<p>This is what happens when you try to read UTF-16 with code that expects ASCII. With ASCII-compatible encodings like ISO 8859-1 and UTF-8 you can read them with code expecting plain ASCII (as long as it's 8-bit clean) and then decode them later. That just doesn't work with UTF-16. UTF-16LE is worse, because the LF is represented as <code>0A00</code>, but similar problems can crop up with big-endian also.</p> <p>What happens when your file contains <a href="http://www.fileformat.info/info/unicode/char/010a/index.htm" rel="nofollow">U+010A</a>? Or <a href="http://www.fileformat.info/info/unicode/char/020a/index.htm" rel="nofollow">U+020A</a>? Or <a href="http://www.fileformat.info/info/unicode/char/0a01/index.htm" rel="nofollow">U+0A01</a>? Or ...</p> <p>You're going to have to teach your iterators about encodings, or insert a layer below the iterator to do decoding, or write an iterator that reads "lines" from another iterator and assembles them into properly decoded actual lines.</p>
<p>It looks like you're using <a href="https://metacpan.org/module/Iterator%3a%3aFile" rel="nofollow"><code>Iterator::File</code></a>? I suggest you abandon it precisely because of problems like this as it doesn't offer anything beyond the standard <code>while (&lt;&gt;) { ... }</code> interface.</p> <p>Open your file with</p> <pre><code>open my $fh, '&lt;:encoding(UTF-16LE)', 'myfile.txt' or die $!; </code></pre> <p>and then read it with</p> <pre><code>my @lines; while (my $buffer = &lt;$fh&gt;) { push @lines, $buffer; } </code></pre> <p>or just</p> <pre><code>my @lines = &lt;$fh&gt;; </code></pre> <p>But have you considered processing the file line-by-line? It is rare that you need all of the data in memory at once.</p>