Why are Perl's canonical &quot;true&quot; and &quot;false&quot; values PVNV internally?
<p>Perl has a canonical "true" and "false" value which it uses for cases of Boolean negation with <code>!</code> or <code>not</code>.</p> <pre><code>#!/usr/bin/env perl use strict; use warnings; use Data::Dumper; print Dumper !1; # outputs $VAR1 = ''; print Dumper !!1; # outputs $VAR1 = 1; </code></pre> <p>All good so far.</p> <p>But, when I look at the values with <a href="https://metacpan.org/pod/Devel%3a%3aPeek" rel="nofollow"><code>Devel::Peek</code></a> it is clear that they are not equivalent to literal <code>''</code> and <code>1</code>, they are both SV PVNV values.</p> <pre><code>$ perl -MDevel::Peek -E 'Dump ""; Dump !1;' 2&gt;&amp;1 | grep '^SV' SV = PV(0x15e5140) at 0x1603298 SV = PVNV(0x15e3010) at 0x7814b0 $ perl -MDevel::Peek -E 'Dump 1; Dump !!1;' 2&gt;&amp;1 | grep '^SV' SV = IV(0xfce228) at 0xfce238 SV = PVNV(0xfae030) at 0x7819f0 </code></pre> <p>I have tested this with Perl 5.16.3 and Perl 5.20.0.</p> <p>Isn't a PVNV much larger than a simple IV? Is this a case of Perl trading memory for speed?</p>
<p>I believe the answer here is that yes, a PVNV is larger, but Perl only keeps one copy of the true value and one copy of the false value in memory, so it's not like you're going to run out of memory having lots of Boolean values in your script.</p> <p>I'm getting that from the reference count (<code>REFCNT</code>) from this <code>Devel::Peek</code> output:</p> <pre><code>$ perl -MDevel::Peek -E 'Dump !1; Dump !!1;' 2&gt;&amp;1 | grep REFCNT REFCNT = 2147483646 REFCNT = 2147483644 </code></pre>
<p>Not just boolean negation; these values are returned by many builtins.</p> <p>There is really no issue of memory, since there is only one instance of each of them.</p> <p>The false value in particular <em>must</em> be a PVNV since its string value <code>''</code> and its numeric value <code>0</code> are not derivable from each other (at least without triggering a warning).</p>