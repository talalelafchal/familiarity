Point in triangle - SPOJ task
<p>I am trying to learn Perl by answering some problems from the Polish SPOJ (Sphere Online Judge) site. This is regarding the <a href="http://pl.spoj.com/problems/T_PINTR/" rel="nofollow"><em>541: Points Within Triangles</em></a> problem. I will do my best to translate.</p> <p>I have to find whether a point p=(x,y) is within a triangle defined by its three vertices.</p> <p>The triangle's coordinates are: p1=(x1; y1), p2=(x2;y2), p3=(x3; y3). Each of x1,y2,x3 etc. is an integer in the range of (1... 1000).</p> <p>Each line of input is 8 integers:</p> <pre><code>x1 y1 x2 y2 x3 y3 x y ..... 0 0 0 0 0 0 0 0 </code></pre> <p>If all eight values are zero then the program should terminate.</p> <p>Each line of input should generate a line of output containing single letter:</p> <ul> <li><strong>I</strong>, if the point is inside the triangle <br/></li> <li><strong>O</strong>, if the point is outside the triangle <br/></li> <li><strong>E</strong>, if the point is on the triangle <br/></li> </ul> <p>This is my code: </p> <pre><code>use warnings; use strict; our ($a, @t, $q); our ($x1, $x2, $x3, $y1, $y2, $y3, $px, $py); our ($det); our ($deta, $detb, $detc); $a = 0; sub licz { ($t[0][0],$t[0][1],$t[1][0],$t[1][1],$t[2][0],$t[2][1])=@_; my $ret = ( $t[0][0]*$t[1][1]+ $t[1][0]*$t[2][1]+ $t[2][0]*$t[0][1]- $t[2][0]*$t[1][1]- $t[0][0]*$t[2][1]- $t[1][0]*$t[0][1] ); return ($ret); } sub czek { $deta = licz($x1, $y1, $x2, $y2, $px, $py); $detb = licz($x2, $y2, $x3, $y3, $px, $py); $detc = licz($x3, $y3, $x1, $y1, $px, $py); if ($deta == 0 or $detb == 0 or $detc == 0) { return 1; } else { return 0 } } sub kier { if ($det &gt; 0) { return 1; } else { return 0; } } while () { my @tab = split(/\s+/, &lt;&gt;); if ( $tab[0] and $tab[1] and $tab[2] and $tab[3] and $tab[4] and $tab[5] and $tab[6] and $tab[7] ) { $x1 = $tab[0]; $y1 = $tab[1]; $x2 = $tab[2]; $y2 = $tab[3]; $x3 = $tab[4]; $y3 = $tab[5]; $px = $tab[6]; $py = $tab[7]; $det = licz($x1, $y1, $x2, $y2, $x3, $y3); if (czek()) { print("E\n"); } else { if (kier()) { if ($deta &gt; 0 and $detb &gt; 0 and $detc &gt; 0) { print("I\n"); } else { print("O\n") } } else { if ($deta &lt; 0 and $detb &lt; 0 and $detc &lt; 0) { print("I\n") } else { print("O\n"); } } } } else { last } } </code></pre> <p>I do not understand why I do not get AC (WA) all the time. All the inputs I have tested have good answers, so I think it's a problem with some spaces or something like that. If anyone can help me, please do.</p>
<p>Using <a href="http://mathforum.org/library/drmath/view/54505.html" rel="nofollow">Point Inside or Outside Triangle?</a> as a guide, the following uses the vector cross product to determine if a point inside, outside, or on the edge of a triangle:</p> <pre><code>#!/usr/bin/perl use strict; use warnings; while (&lt;DATA&gt;) { last if !/[1-9]/; #print; my ($x1, $y1, $x2, $y2, $x3, $y3, $x, $y) = split; my @cps = ( ($x1 - $x2) * ($y1 - $y) - ($x1 - $x) * ($y1 - $y2), ($x2 - $x3) * ($y2 - $y) - ($x2 - $x) * ($y2 - $y3), ($x3 - $x1) * ($y3 - $y) - ($x3 - $x) * ($y3 - $y1), ); # Both Negative and Positive Cross Products means is outside if (grep {$_ &gt; 0} @cps and grep {$_ &lt; 0} @cps) { print " Outside\n"; # A Zero Cross Product means is on an edge as long as the sign of all other CP's match } elsif (my $zeros = grep {$_ == 0} @cps) { print $zeros == 1 ? " Edge\n" : " Vertice\n"; # Same Sign for all CP's means is Inside. } else { print " Inside\n"; } __DATA__ 630 421 326 242 561 432 478 332 378 212 380 550 840 735 379 381 591 916 765 191 487 490 678 554 975 75 324 166 343 28 650 120 0 0 0 0 0 0 0 0 </code></pre> <p>Outputs:</p> <pre><code> Inside Edge Outside Inside </code></pre>
<h3>Working algorithm in other answer</h3> <p>I've already demonstrated a working algorithm for this problem in my <a href="http://stackoverflow.com/a/24600967/1733163">earlier answer</a>. However, you're also inquiring as to why your code was not accepted as an answer.</p> <h3>An example of where your logic fails</h3> <p>One example of where your code fails for the following data:</p> <pre><code>1 1 4 1 4 4 5 5 </code></pre> <p>The point <code>(5,5)</code> will be incorrectly reported as on an edge instead of outside the below triangle:</p> <p><img src="https://i.stack.imgur.com/JhseV.png" alt="Triangle (1,1);(4,1);(4,4) Point (5,5)"></p> <p>Basically, any point that is along the vector created by an edge is reported as actually on the edge. Therefore, the following points will also be reported as on an edge: <code>(500, 500)</code>, <code>(4, -9000)</code>, <code>(0,0)</code>, etc.</p> <p>To show you were your logic is failing it is necessary to clean up your code.</p> <h3>Coding style fixes</h3> <p>Kudos to you for including <a href="http://perldoc.perl.org/strict.html" rel="nofollow noreferrer"><code>use strict;</code></a> and <a href="http://perldoc.perl.org/warnings.html" rel="nofollow noreferrer"><code>use warnings;</code></a>. That is the first step to becoming a good programmer in perl.</p> <p>However, one next step is to never use global variables for anything but constants. <strong>Always pass parameters to your subroutines and return values.</strong> It is of course possible to code in other ways, but keeping each subroutine as an isolated thought or idea helps with readability and maintainability. </p> <p>Applying this one single coding style reduces your program to the following:</p> <pre><code>use warnings; use strict; sub licz { my ($x1, $y1, $x2, $y2, $x3, $y3) = @_; return ($x1*$y2 - $x2*$y1) + ($x2*$y3 - $x3*$y2) + ($x3*$y1 - $x1*$y3); } while (&lt;DATA&gt;) { my @tab = split(/\s+/, $_); last if grep {!$_} @tab[0..7]; my ($x1, $y1, $x2, $y2, $x3, $y3, $px, $py) = @tab; my $det = licz($x1, $y1, $x2, $y2, $x3, $y3); my $deta = licz($x1, $y1, $x2, $y2, $px, $py); my $detb = licz($x2, $y2, $x3, $y3, $px, $py); my $detc = licz($x3, $y3, $x1, $y1, $px, $py); if ($deta == 0 || $detb == 0 || $detc == 0) { print("E\n"); } elsif ($det &gt; 0) { if ($deta &gt; 0 and $detb &gt; 0 and $detc &gt; 0) { print("I\n"); } else { print("O\n") } } else { if ($deta &lt; 0 and $detb &lt; 0 and $detc &lt; 0) { print("I\n") } else { print("O\n"); } } } __DATA__ 630 421 326 242 561 432 478 332 378 212 380 550 840 735 379 381 591 916 765 191 487 490 678 554 975 75 324 166 343 28 650 120 1 1 4 1 4 4 500 500 1 1 1 4 4 4 5 5 0 0 0 0 0 0 0 0 </code></pre> <h3>The Flaw in your logic</h3> <p>Now, as you can see, your program looks very similar to mine in its reduced form. In fact, we're using the same formula. Yours is just the reduced form of the vector cross products, where I start with the point subtraction. The values in your program of <code>($deta, $detb, $detc)</code> are equivalent to <code>($cps[0], $cps[1], $cps[2])</code> in mine. </p> <p>These values tell us whether or not a point is to the right, left, or along an edge. They do this by the sign of the value. You also calculate the clockwise or counter clockwise nature of the triangle using <code>$det</code>. However, you do not need this information.</p> <p>Basically, if we go around the 3 edges of a triangle, and a point is to the right of each edge, then the point must be INSIDE the triangle. Similarly, if we go around the 3 edges, and a point is to the left of each edge, then we can also conclude that the point must be inside the triangle and that we must have traversed the triangle counter clockwise. In the end, the sign of each of the cross products doesn't matter, only whether the signs all match or not.</p> <ul> <li>Sign of cross products all match &rArr; Point is inside the triangle</li> <li>Both positive and negative signs &rArr; Point is outside the triangle</li> </ul> <p>Now, if the sign of a cross product is Zero, we know that the point is <strong>along an edge</strong>, but that's not enough information to determine if the point is actually <strong>on the edge</strong>. There are five different cases. I'll start with the obvious ones:</p> <ol> <li>If two cross products are Zero &rArr; Point matches a vertice of the triangle</li> <li>If the non-zero cross products are both positive &rArr; Point is on an edge</li> <li>If the non-zero cross products are both negative &rArr; Point is on an edge</li> <li>If there is both a negative and positive cross product &rArr; Point is along edge but outside.</li> </ol> <p>Now, hopefully this reveals the flaw in your logic. Basically, you check to see if a cross product is zero, but you don't check the sign of the other cross products. In fact, one can and should just check to see if a point is outside before bothering to check if it is along an edge, like demonstrated in my solution.</p> <p>I've now laid out exactly what you need to do to fix your code, but I leave the final edits to you.</p>