Reading in an array and multiple scalars at one with @_ with Perl
<p>I am trying to pass some arguments into a sub routine </p> <pre><code>sub mean { my (@values, $chan1, $chan2, $chan3, $chan4) = @_; print $chan1, $chan2, $chan3, $chan4; my $ave_value = sum($values[$chan1],$values[$chan2],$values[$chan3],$values[$chan4])/@values; } </code></pre> <p>with a call of </p> <pre><code> push (@avg_value , mean(@datachunk,$subchannel[0],$subchannel[1],$subchannel[2],$subchannel[3])); </code></pre> <p>I am getting error uninitialized value in an array element. I am assuming it because of the way I Am trying read in values. Is this the proper approach?</p>
<p>Your array assignment is eating up all the parameters.</p> <p>For example, in the following, <code>$foo</code> and <code>$bar</code> will always be undefined, and <code>@array</code> will contain 4 elements:</p> <pre><code>my (@array, $foo, $bar) = (1,2,3,4); </code></pre> <p>Here are two potential solutions:</p> <p>1) Put scalars first, and then your array:</p> <pre><code>sub mean { my ($chan1, $chan2, $chan3, $chan4, @values) = @_; print $chan1, $chan2, $chan3, $chan4; my $ave_value = sum(@values[$chan1, $chan2, $chan3, $chan4])/@values; } # Calling method: mean($subchannel[0], $subchannel[1], $subchannel[2], $subchannel[3], @datachunk) </code></pre> <p>2) Alternatively, you can pass the array by reference:</p> <pre><code>sub mean { my ($arrayref, $chan1, $chan2, $chan3, $chan4) = @_; print $chan1, $chan2, $chan3, $chan4; my $ave_value = sum(@{$arrayref}[$chan1, $chan2, $chan3, $chan4]) / @$arrayref; } # Calling method: mean(\@datachunk, $subchannel[0], $subchannel[1], $subchannel[2], $subchannel[3]) </code></pre> <p>However, the tightest solution is to restyle your code. All you want is the average of a list. Therefore, just pass a list directly instead of the array with index values.</p> <pre><code>sub mean { return @_ ? sum(@_) / @_ : die "Mean of 0 numbers is undefined"; } # Calling method: mean(@datachunk[@subchannel[0..3]]) </code></pre>
<p>The problem is that Perl isn't as clever as Ruby, so when you gather the parameters to <code>mean</code> with the assignment</p> <pre><code>my (@values, $chan1, $chan2, $chan3, $chan4) = @_; </code></pre> <p>you assign the <em>whole</em> of <code>@_</code> to <code>@values</code> leaving <code>$chan1</code>, <code>$chan2</code> etc. set to <code>undef</code></p> <p>In general, and especially if you are combining array parameters with scalars, you should pass arrays by <em>reference</em>. So your subroutine could be</p> <pre><code>sub mean { my ($values, $chan1, $chan2, $chan3, $chan4) = @_; print "$chan1, $chan2, $chan3, $chan4\n"; my $avg = sum( $values-&gt;[$chan1], $values-&gt;[$chan2], $values-&gt;[$chan3], $values-&gt;[$chan4] ) / @values; } </code></pre> <p>and you would call it as</p> <pre><code>push(@avg_value, mean( \@datachunk, $subchannel[0], $subchannel[1], $subchannel[2], $subchannel[3] )); </code></pre> <p>However, your <code>mean</code> subroutine would be much more generally useful if you passed just the list of values. For instance, if you had <code>mean</code> defined as</p> <pre><code>sub mean { sum(@_) / @_ } </code></pre> <p>then you could call it using an array slice, like this</p> <pre><code>push(@avg_value, mean(@datachunk[@subchannel[0..3]])); </code></pre> <p>or, if that is too much for you then split out the slices</p> <pre><code>my @chunk_indices = @subchannel[0..3]; my @values = @datachunk[@chunk_indices]; push @avg_value, mean(@values)); </code></pre> <p>I hope this helps</p>