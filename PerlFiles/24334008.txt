Why declare Perl variable with &quot;my&quot; at file scope?
<p>I'm learning Perl and trying to understand variable scope. I understand that <code>my $name = 'Bob';</code> will declare a local variable <em>inside a sub</em>, but why would you use the <code>my</code> keyword at the global scope? Is it just a good habit so you can safely move the code into a sub?</p> <p>I see lots of example scripts that do this, and I wonder why. Even with <code>use strict</code>, it doesn't complain when I remove the <code>my</code>. I've tried comparing behaviour with and without it, and I can't see any difference.</p> <p>Here's <a href="http://perlmaven.com/simple-database-access-using-perl-dbi-and-sql" rel="nofollow">one example</a> that does this:</p> <pre><code>#!/usr/bin/perl use strict; use warnings; use DBI; my $dbfile = "sample.db"; my $dsn = "dbi:SQLite:dbname=$dbfile"; my $user = ""; my $password = ""; my $dbh = DBI-&gt;connect($dsn, $user, $password, { PrintError =&gt; 0, RaiseError =&gt; 1, AutoCommit =&gt; 1, FetchHashKeyName =&gt; 'NAME_lc', }); # ... $dbh-&gt;disconnect; </code></pre> <h2>Update</h2> <p>It seems I was unlucky when I tested this behaviour. Here's the script I tested with:</p> <pre><code>use strict; my $a = 5; $b = 6; sub print_stuff() { print $a, $b, "\n"; # prints 56 $a = 55; $b = 66; } print_stuff(); print $a, $b, "\n"; # prints 5566 </code></pre> <p>As I learned from some of the answers here, <code>$a</code> and <code>$b</code> are special variables that are already declared, so the compiler doesn't complain. If I change the <code>$b</code> to <code>$c</code> in that script, then it complains.</p> <p>As for why to use <code>my $foo</code> at the global scope, it seems like the <em>file</em> scope may not actually be the <em>global</em> scope.</p>
<p>A few points: </p> <ul> <li><p><code>strict</code> demands that all variables be declared with a <code>my</code> (or <code>state</code>) or installed into the package--declared with an <code>our</code> statement or a <code>use vars</code> pragma (archaic), or inserted into the symbol table at compile time.</p></li> <li><p>They are <em>that file's</em> variables. They remain of no concern and no use to any module required during the use of that file. </p></li> <li><p>They can be used across packages (although that's a less good reason.)</p></li> <li><p>Lexical variables don't have any of the magic that the only alternative does. You can't "push" and "pop" a lexical variable as you change scope, as you can with any package variable. No magic means faster and plainer handling. </p></li> <li><p>Laziness. It's just easier to declare a <code>my</code> with no brackets as opposed to concentrating its scope by specific bracketing. </p> <pre><code>{ my $visible_in_this_scope_only; ... sub bananas { ... my $bananas = $visible_in_this_scope_only + 3; ... } } # End $visible_in_this_scope_only </code></pre></li> </ul> <p>(Note on the syntax: in my code, I never use a bare brace. It will always tell you, either before (standard loops) or after what the scope is for, even if it would have been "obvious".</p>
<p>It's just good practice. As a personal rule, I try to keep variables in the smallest scope possible. If a line of code can't see a variable, then it can't mess with it in unexpected ways.</p> <p>I'm surprised that you found that the script worked under <code>use strict</code> without the <code>my</code>, though. That's generally not allowed:</p> <pre><code>$ perl -E 'use strict; $db = "foo"; say $db' Global symbol "$db" requires explicit package name at -e line 1. Global symbol "$db" requires explicit package name at -e line 1. Execution of -e aborted due to compilation errors. $ perl -E 'use strict; my $db = "foo"; say $db' foo </code></pre> <p>Variables <code>$a</code> and <code>$b</code> are exempt:</p> <pre><code>$ perl -E 'use strict; $b = "foo"; say $b' foo </code></pre> <p>But I don't know how you would make the code you posted work with strict and a missing <code>my</code>.</p>
<p>A <code>sub</code> controls/limits the scope of variables between the braces <code>{}</code> that define its operations. Of course many variables exist outside of a particular function and using lexical <code>my</code> for "global" variables can give you more control over how "dynamic" their behavior is inside your application. The <code>Private Variables via my()</code> section of <code>perlodoc</code><a href="http://perldoc.perl.org/perlsub.html#Private-Variables-via-my%28%29" rel="nofollow"><code>perlsub</code></a> discusses reasons for doing this pretty thoroughly.</p> <p>I'm going to quote myself from <a href="http://stackoverflow.com/a/23222857/2019415">elsewhere</a> which is not the best thing to do on SO but here goes:</p> <blockquote> <p>The classic <strong>perlmonks</strong> node - <a href="http://www.perlmonks.org/?node_id=66677" rel="nofollow">Variable Scoping in Perl: the basics</a> - is a frequently consulted reference :-)</p> </blockquote> <p>As I noted in a comment, Bruce Gray's talk at YAPC::NA 2012 - <a href="https://www.youtube.com/watch?v=SA4mUs3Ro98" rel="nofollow">The why of my()</a> is a good story about how a pretty expert perl programmer wrapped his head around perl and namespaces.</p> <p>I've heard people explain <code>my</code> as Perl's equivalent to Javascript's <code>var</code> - it's practically necessary but, Perl being <code>perl</code>, things will work without it if you insist or take pains to make it do that. </p> <p>ps: Actually with Javascript, I guess functions <strong>are</strong> used to control "scope" in a way that is analagous to your description of using <code>my</code> in <code>sub</code>'s.</p>
<p>The addition of <code>my</code> was about the best thing that ever happened to Perl and the problem it solved was typos. </p> <p>Say you have a variable <code>$variable</code>. You do some assignments and comparisons on this variable.</p> <pre><code>$variable = 5; # intervening assignments and calculations... if ( $varable + 20 &gt; 25 ) # don't use magic numbers in real code { # do one thing } else { # do something else } </code></pre> <p>Do you see the subtle bug in the above code that happens if you don't <code>use strict;</code> and require variables be declared with <code>my</code>? The <code># do one thing</code> case will <em>never</em> happen. I encountered this several times in production code I had to maintain.</p>