Efficient semantic triples with Perl, without external db server
<p>I have several semantic triples. Some examples: </p> <pre><code>Porky,species,pig // Porky's species is "pig" Bob,sister,May // Bob's sister is May May,brother,Sam // May's borther is Sam Sam,wife,Jane // Sam's wife is Jane ... and so on ... </code></pre> <p>I store each triple in 6 different hashes. Example: </p> <pre><code>$ijk{Porky}{species}{pig} = 1; $ikj{Porky}{pig}{species} = 1; $jik{species}{Porky}{pig} = 1; $jki{species}{pig}{Porky} = 1; $kij{pig}{Porky}{species} = 1; $kji{pig}{species}{Porky} = 1; </code></pre> <p>This lets me efficiently ask questions like: </p> <ul> <li><p>What species is Porky (<code>keys %{$ijk{Porky}{species}}</code>) </p></li> <li><p>List all pigs (<code>keys %{$jki{species}{pig}}</code>) </p></li> <li><p>What information do I have on Porky? (<code>keys %{$ijk{Porky}}</code>) </p></li> <li><p>List all species (<code>keys %{$jik{species}}</code>) </p></li> </ul> <p>and so on. Note that none of the examples above go through a list one element at a time. They all take me "instantly" to my answer. In other words, each answer is a hash value. Of course, the answer itself may be a list, but I don't traverse any lists to get to that answer.</p> <p>However, defining 6 separate hashes seems really inefficient. Is there an easier way to do this <em>without using an external database engine</em> (for this question, SQLite3 counts as an external database engine)? </p> <p>Or have I just replicated a small subset of SQL into Perl?</p> <p>EDIT: I guess what I'm trying to say: I love associative arrays, but they seem to be the wrong data structure for this job. What's the right data structure here, and what Perl module implements it?</p>
<p>"Efficient" is not really the right word here since you're worried about improving speed <em>in exchange for</em> memory, which is generally how it works.</p> <p>Only real alternative is to store the triplets as distinct values, and then just have three "indexes" into them:</p> <pre><code>$row = [ "Porky", "species", "pig" ]; push @{$subject_index{Porky}}, $row; push @{$relation_index{species}}, $row; push @{$target_index{pig}}, $row; </code></pre> <p>To do something like "list all pigs", you'd have to find the intersection of <code>$relation_index{species}</code> and <code>$target_index{pig}</code>. Which you can do manually, or with your favorite set implementation.</p> <p>Then wrap it all up in a nice object interface, and you've basically implemented <code>INNER JOIN</code>. :)</p>
<p>A single hash of hash should be sufficient:</p> <pre><code>use strict; use warnings; use List::MoreUtils qw(uniq); use Data::Dump qw(dump); my %data; while (&lt;DATA&gt;) { chomp; my ($name, $type, $value) = split ','; $data{$name}{$type} = $value; } # What species is Porky? print "Porky's species is: $data{Porky}{species}\n"; # List all pigs print "All pigs: " . join(',', grep {defined $data{$_}{species} &amp;&amp; $data{$_}{species} eq 'pig'} keys %data) . "\n"; # What information do I have on Porky? print "Info on Porky: " . dump($data{Porky}) . "\n"; # List all species print "All species: " . join(',', uniq grep defined, map $_-&gt;{species}, values %data) . "\n"; __DATA__ Porky,species,pig Bob,sister,May May,brother,Sam Sam,wife,Jane </code></pre> <p>Outputs:</p> <pre class="lang-none prettyprint-override"><code>Porky's species is: pig All pigs: Porky Info on Porky: { species =&gt; "pig" } All species: pig </code></pre>
<p>Have you looked at using <a href="https://metacpan.org/release/RDF-Trine" rel="nofollow">RDF::Trine</a>? It has DBI-backed stores, but it also has in-memory stores, and can parse/serialize in RDF/XML, Turtle, N-Triples, etc if you need persistence.</p> <p>Example:</p> <pre><code>use strict; use warnings; use RDF::Trine qw(statement literal); my $ns = RDF::Trine::Namespace-&gt;new("http://example.com/"); my $data = RDF::Trine::Model-&gt;new; $data-&gt;add_statement(statement $ns-&gt;Peppa, $ns-&gt;species, $ns-&gt;Pig); $data-&gt;add_statement(statement $ns-&gt;Peppa, $ns-&gt;name, literal 'Peppa'); $data-&gt;add_statement(statement $ns-&gt;George, $ns-&gt;species, $ns-&gt;Pig); $data-&gt;add_statement(statement $ns-&gt;George, $ns-&gt;name, literal 'George'); $data-&gt;add_statement(statement $ns-&gt;Suzy, $ns-&gt;species, $ns-&gt;Sheep); $data-&gt;add_statement(statement $ns-&gt;Suzy, $ns-&gt;name, literal 'Suzy'); print "Here are the pigs...\n"; for my $pig ($data-&gt;subjects($ns-&gt;species, $ns-&gt;Pig)) { my ($name) = $data-&gt;objects($pig, $ns-&gt;name); print $name-&gt;literal_value, "\n"; } print "Let's dump all the data...\n"; my $ser = RDF::Trine::Serializer::Turtle-&gt;new; print $ser-&gt;serialize_model_to_string($data), "\n"; </code></pre> <p>RDF::Trine is quite a big framework, so has a bit of a compile-time penalty. At run-time it's relatively fast though.</p> <p>RDF::Trine can be combined with RDF::Query if you wish to query your data using SPARQL.</p> <pre><code>use RDF::Query; my $q = RDF::Query-&gt;new(' PREFIX : &lt;http://example.com/&gt; SELECT ?name WHERE { ?thing :species :Pig ; :name ?name . } '); my $r = $q-&gt;execute($data); print "Here are the pigs...\n"; while (my $row = $r-&gt;next) { print $row-&gt;{name}-&gt;literal_value, "\n"; } </code></pre> <p>RDF::Query supports both SPARQL 1.0 and SPARQL 1.1. RDF::Trine and RDF::Query are both written by Gregory Williams who was a member of the SPARQL 1.1 Working Group. RDF::Query was one of the first implementations to achieve 100% on the SPARQL 1.1 Query test suite. (It may have even been the first?)</p>
<blockquote> <p><em>Or have I just replicated a small subset of SQL into Perl?</em></p> </blockquote> <p>It's pretty easy to start using actual SQL, using an SQLite in memory database.</p> <pre><code>#!/usr/bin/perl use warnings; use strict; use DBI; my $dbh = DBI-&gt;connect("dbi:SQLite::memory:", "", "", { sqlite_use_immediate_transaction =&gt; 0, RaiseError =&gt; 1, }); $dbh-&gt;do("CREATE TABLE triple(subject,predicate,object)"); $dbh-&gt;do("CREATE INDEX 'triple(subject)' ON triple(subject)"); $dbh-&gt;do("CREATE INDEX 'triple(predicate)' ON triple(predicate)"); $dbh-&gt;do("CREATE INDEX 'triple(object)' ON triple(object)"); for ([qw&lt;Porky species pig&gt;], [qw&lt;Porky color pink&gt;], [qw&lt;Sylvester species cat&gt;]) { $dbh-&gt;do("INSERT INTO triple(subject,predicate,object) VALUES (?, ?, ?)", {}, @$_); } use JSON; print to_json( $dbh-&gt;selectall_arrayref('SELECT * from triple WHERE predicate="species"', {Slice =&gt; {}}) ); </code></pre> <p>Gives:</p> <pre><code> [{"object":"pig","predicate":"species","subject":"Porky"}, {"object":"cat","predicate":"species","subject":"Sylvester"}] </code></pre> <p>You can then query and index the data in a familiar manner. Very scalable as well.</p>
<p>I think you are mixing categories and values, such as name=Porky, and species=pig. </p> <p>Given your example, I'd go with something like this:</p> <pre><code> my %hash; $hash{name}{Porky}{species}{pig} = 1; $hash{species}{pig}{name}{Porky} = 1; $hash{name}{Bob}{sister}{May} = 1; $hash{sister}{May}{name}{Bob} = 1; $hash{name}{May}{brother}{Sam} = 1; $hash{brother}{Sam}{name}{May} = 1; $hash{name}{Sam}{wife}{Jane} = 1; $hash{wife}{Jane}{name}{Sam} = 1; </code></pre> <p>Yes, this has some apparent redundancy, since we can easily distinguish most names from other values. But the 3rd-level hash key is also a top level hash key, which can be used to get more information on some element.</p>