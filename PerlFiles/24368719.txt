Odd string parsing with double colons in Perl
<p>I've stumbled upon something odd with Perl string parsing. Here's an example:</p> <pre><code>$word = "hello"; $test1 = "colon:values::$word:test"; $test2 = "colon:values::$word::test"; // test1 prints: "colon:values::hello:test" // test2 prints: "colon:values::" </code></pre> <p>So if Perl sees a double colon after a variable in a string, it will (I assume) think you're trying to use a package name. I guess it's trying to load "Hello::test" and not finding anything - hence the early termination of the string.</p> <p>Is this normal? I find it pretty counter-intuitive. I was able to work around it by escaping the first colon like so:</p> <pre><code>$works = "colon:values::$word\::test"; </code></pre> <p>Is this a bug or am I completely missing something obvious?</p>
<p>Perl uses namespaces for variable names, and Perl when Perl sees <code>::</code> or a <code>'</code>, it assumes what's before is a package (i.e. namespace) name. It is similar to this <em>error</em>:</p> <pre><code>use strict; use warnings; # You're using these? Aren't you? my $foo = "bar" print "The magic word is $foo_for_you\n"; </code></pre> <p>Since the underscore is a valid character for variable names, Perl assumes that you want the variable <code>$foo_for_you</code> and not <code>$foo</code> with <code>_for_you</code> appended to the value. So, would you consider this a <em>bug</em> or a <em>feature</em>? Is it any difference from this:</p> <pre><code>print "The magic word is $foobar\n"; # Whoops! my variable is $foo. </code></pre> <p>The way to get around this is to make it absolutely clear that <code>$foo</code> is your variable:</p> <pre><code>print "The magic word is " . $foo . "_for_you\n"; printf "The magic word is %s_for_you\n", $foo; print "The magic word is ${foo}_for_you\n"; </code></pre> <p>The same issue if you had <code>$foo::for::you</code> (or <code>$foo'for'you</code>) In this case, Perl is looking for a variable called <code>$you</code> in the namespace <code>foo::for</code>. As you can imagine, you can use similar solutions:</p> <pre><code>print "The magic word is " . $foo . "::for::you\n"; printf "The magic word is %d::for::you\n", $foo; print "The magic word is ${foo}::for::you\n"; </code></pre> <p>Namespaces are used to help keep variables in Perl modules from modifying variables in your program. Imagine calling a function in a Perl package, and suddenly discovering that a variable you were using in your program was changed.</p> <p>Take a look at <a href="http://perldoc.perl.org/File/Find.html" rel="nofollow">File::Find</a> and you can see variables with the package namespace attached to them (<code>$File::Find::name</code> and <code>$File::Find::dir</code> are two examples).</p>
<p>The reason this is happening is because it's trying to look up <code>$word::test</code> as a variable name. As you've correctly deduced, the package separator <code>::</code> is part of the name, but it's not going to follow the value of <code>$word</code> because it's not being used as a symbolic reference here (that requires more syntax).</p> <p>Oesor's solution will solve your problem - the general way to fix this kind of issue is to use <code>${identifier}</code> syntax. Basically use it any time you're interpolating a variable into a string and you need to follow it with something that's a valid identifier character or related symbol (i.e. <code>::</code>).</p>
<p>While that works, a more widespread way to handle the case is to disambiguate the name of your variable with braces:</p> <pre><code>perl -E "my $word = 'red'; say qq|colon::values::${word}::test|" colon::values::red::test </code></pre> <p>This is documented in <a href="http://perldoc.perl.org/perldata.html#Scalar-value-constructors" rel="nofollow">perldata</a>:</p> <blockquote> <p>As in some shells, you can enclose the variable name in braces to disambiguate it from following alphanumerics (and underscores). You must also do this when interpolating a variable into a string to separate the variable name from a following double-colon or an apostrophe, since these would be otherwise treated as a package separator:</p> <pre><code>$who = "Larry"; print PASSWD "${who}::0:0:Superuser:/:/bin/perl\n"; print "We use ${who}speak when ${who}'s here.\n"; </code></pre> <p>Without the braces, Perl would have looked for a <code>$whospeak</code>, a <code>$who::0</code>, and a <code>$who's</code> variable. The last two would be the <code>$0</code> and the <code>$s</code> variables in the (presumably) non-existent package <code>who</code>.</p> </blockquote>