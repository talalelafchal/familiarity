Extracting multiple subsections of a file in Perl
<p>I have the following script and want turn some parts of it to Perl script. The parts that I'm interested in are very similar to perl and easy to convert (FYI: <code>COND</code> and <code>FORMULA</code> mean <code>if</code> and <code>return</code> in Perl, respectively). However, I'm struggling to extract these sections properly.</p> <pre><code>... #OTHER STUFFS K K1 { ... #MORE OTHER STUFFS LOL { COND { d &lt; 0.01 } FORMULA { -0.2 + 3.3*sqrt(d) } COND { d &gt;= 0.01 } FORMULA { -0.2 + 3.3*sqrt(d+0.4) } } ... #MORE OTHER STUFFS } ... #OTHER STUFFS K K2 { ... #MORE OTHER STUFFS LOL { COND { d &lt; 0.03 } FORMULA { -2.2 + 1.3*sqrt(d) } COND { d &gt;= 0.03 } FORMULA { -2.2 + 1.3*sqrt(d+0.8) } } ... #MORE OTHER STUFFS } ... #OTHER STUFFS K K3 { ... #MORE OTHER STUFFS LOL { COND { d &lt; 0.02 } FORMULA { -4.3 + 0.3*sqrt(d) } COND { d &gt;= 0.02 } FORMULA { -4.3 + 0.3*sqrt(d+0.3) } } ... #MORE OTHER STUFFS } ... #OTHER STUFF </code></pre> <p>I've tried the following perl-liner, </p> <pre><code>perl -ne 'print $1 if /K\sK2\s\{/ .. /\}/ and /LOL\s\{/ .. /\}/ and /COND*(.*)/' filename </code></pre> <p>to extract, for instance, <code>{ d &lt; 0.03 }</code> from</p> <pre><code>K K2 { ... #MORE OTHER STUFFS LOL { COND { d &lt; 0.03 } FORMULA { -2.2 + 1.3*sqrt(d) } COND { d &gt;= 0.03 } FORMULA { -2.2 + 1.3*sqrt(d+0.8) } } ... #MORE OTHER STUFFS } </code></pre> <p>But</p> <ol> <li>It failed and I don't know how to fix it </li> <li>How I can fix it in a way to be able to catch the second <code>COND</code> statement in the same section (i.e. <code>COND { w &gt;= 0.03 }</code>). In other word, how I can skip the first, second,... occurrence of a string.</li> </ol> <p>PS If I can get this extraction part done, I know how to convert it to Perl-looking code</p>
<p>Parse the conditions, and translate them into anonymous subroutines that can be eval'd and then assigned to a hash.</p> <p>You will want to test the below thoroughly before using, as I don't know your full data set.</p> <pre><code>use strict; use warnings; our %formula_per_k; INIT { # List all functions that you want to allow in formulas. All other words will be interpretted as variables. my @FORMULA_FUNCS = qw(sqrt exp log); # Load the data via a file. my $data = do {local $/; &lt;DATA&gt;}; # Parse K blocks while ($data =~ m{ ^K \s+ (\w+) \s* \{ ( (?: [^{}]+ | \{(?2)\} )* ) # Matched braces only. \} }mgx) { my ($name, $params) = ($1, $2); # Parse LOL block next if $params !~ m{ LOL \s* \{ ( (?: [^{}]+ | \{(?1)\} )*? ) # Matched braces only. \} }mx; my $lol = $1; # Start building anonymous subroutine my $conditions = ''; # Parse Conditions and Formulas while ($lol =~ m{ COND \s* \{ (.*?) \} \s* FORMULA \s* \{ (.*?) \} }gx) { my ($cond, $formula) = ($1, $2); # Remove Excess spacing and translate variable into perl scalar. for ($cond, $formula) { s/^\s+|\s+$//g; s{([a-zA-Z]+)}{ my $var = $1; $var = "\$hashref-&gt;{$var}" if ! grep {$var eq $_} @FORMULA_FUNCS; $var }eg; } $conditions .= "return $formula if $cond; "; } my $code = "sub {my \$hashref = shift; ${conditions} return; }"; my $sub = eval $code; if ($@) { die "Invalid formulas in $name: $@"; } $formula_per_k{$name} = $sub; } } sub formula_per_k { my ($k, $vars) = @_; die "Unrecognized K value '$k'" if ! exists $formula_per_k{$k}; return $formula_per_k{$k}($vars); } print "'K1', {d =&gt; .1} = " . formula_per_k('K1', {d =&gt; .1}) . "\n"; print "'K1', {d =&gt; .05} = " . formula_per_k('K1', {d =&gt; .05}) . "\n"; print "'K3', {d =&gt; .02} = " . formula_per_k('K3', {d =&gt; .02}) . "\n"; print "'K3', {d =&gt; .021} = " . formula_per_k('K3', {d =&gt; .021}) . "\n"; __DATA__ ... #OTHER STUFFS K K1 { LOL { COND { d &lt; 0.01 } FORMULA { -0.2 + 3.3*sqrt(d) } COND { d &gt;= 0.01 } FORMULA { -0.2 + 3.3*sqrt(d+0.4) } } } ... #OTHER STUFFS K K2 { LOL { COND { d &lt; 0.03 } FORMULA { -2.2 + 1.3*sqrt(d) } COND { d &gt;= 0.03 } FORMULA { -2.2 + 1.3*sqrt(d+0.8) } } } ... #OTHER STUFFS K K3 { LOL { COND { d &lt; 0.02 } FORMULA { -4.3 + 0.3*sqrt(d) } COND { d &gt;= 0.02 } FORMULA { -4.3 + 0.3*sqrt(d+0.3) } } } ... #OTHER STUFF </code></pre> <p>Outputs:</p> <pre><code>'K1', {d =&gt; .1} = 2.13345237791561 'K1', {d =&gt; .05} = 2.01370729772479 'K3', {d =&gt; .02} = -4.13029437251523 'K3', {d =&gt; .021} = -4.13002941430942 </code></pre>
<p>First at all, sorry for the one-liner, but I use a readable way.</p> <p>To extract the information you want (in general):</p> <pre><code>my $data = &lt;&lt;EOD; ... #OTHER STUFFS K K1 { LOL { COND { d &lt; 0.01 } FORMULA { -0.2 + 3.3*sqrt(d) } COND { d &gt;= 0.01 } FORMULA { -0.2 + 3.3*sqrt(d+0.4) } } } ... #OTHER STUFFS K K2 { LOL { COND { d &lt; 0.03 } FORMULA { -2.2 + 1.3*sqrt(d) } COND { d &gt;= 0.03 } FORMULA { -2.2 + 1.3*sqrt(d+0.8) } } } ... #OTHER STUFFS K K3 { LOL { COND { d &lt; 0.02 } FORMULA { -4.3 + 0.3*sqrt(d) } COND { d &gt;= 0.02 } FORMULA { -4.3 + 0.3*sqrt(d+0.3) } } } EOD while( $data =~ /COND \s* { \s* (?&lt;cond&gt; [^}]*? ) \s* } \s* FORMULA \s* { \s* (?&lt;formula&gt; [^}]*? ) \s* } /xg ) { print "Condition: $+{cond}\nFormula: $+{formula}\n"; } </code></pre> <p>for a particular item, you can use:</p> <pre><code>if ($data =~ /K2 \s* { \s* LOL \s* { \s* COND \s* { \s* (?&lt;cond&gt; [^}]*? ) \s* } \s* FORMULA \s* { \s* (?&lt;formula&gt; [^}]*? ) \s* } /x) { print "Condition: $+{cond}\nFormula: $+{formula}\n"; } </code></pre> <p>Note: I have build the patterns to automatically trim spaces that wraps "condition" and "formula", but if you want to preserve these spaces you can change <code>\s* (?&lt;cond&gt; [^}]*? ) \s*</code> to <code>(?&lt;cond&gt; [^}]* )</code> <em>(the same for "formula")</em>. Note that this change makes your pattern more performant.</p> <hr> <p>If the item you contains several "LOL" parts, you can use the <a href="http://www.regular-expressions.info/continue.html" rel="nofollow"><code>\G</code> feature</a> in a global research to obtain all the items:</p> <pre><code>my $data = &lt;&lt;EOD; K K2 { LOL { COND { d &lt; 0.02 } FORMULA { -2.1 + 1.2*sqrt(d) } COND { d &gt;= 0.02 } FORMULA { -2.1 + 1.2*sqrt(d+0.7) } } LOL2 { COND { d &lt; 0.03 } FORMULA { -2.2 + 1.3*sqrt(d) } COND { d &gt;= 0.03 } FORMULA { -2.2 + 1.3*sqrt(d+0.8) } } LOL3 { COND { d &lt; 0.04 } FORMULA { -2.3 + 1.4*sqrt(d) } COND { d &gt;= 0.04 } FORMULA { -2.3 + 1.4*sqrt(d+0.9) } } } EOD while($data =~ /(?:K2 \s* { | \G(?!\A) )\s* (?:LOL\d* \s* { \s* )? COND \s* { \s* (?&lt;cond&gt; [^}]*? ) \s* } \s* FORMULA \s* { \s* (?&lt;formula&gt; [^}]*? ) \s* } (?: \s* } )? /x) { print "Condition: $+{cond}\nFormula: $+{formula}\n"; } </code></pre> <p>Note: obviously, you must replace <code>LOL\d*</code> with a subpattern that matches all possible names.</p>