Flush INET Socket response data with BLOCKING enabled
<p>I am making a program that interfaces with Teamspeak, and I have an issue where the responses received will not match the commands sent. I run the program multiple times and each time, I will get different results when they should be the same, due to responses being out of sync.</p> <pre><code>my $buf = ''; use IO::Socket; my $sock = new IO::Socket::INET ( PeerAddr =&gt; 'localhost' ,PeerPort =&gt; '10011' ,Proto =&gt; 'tcp' ,Autoflush =&gt; 1 ,Blocking =&gt; 1 ,Timeout =&gt; 10 ); sub ExecuteCommand{ print $sock $_[0]."\n";$sock-&gt;sysread($buf,1024*10); return $buf; }; ExecuteCommand("login ${username} ${password}"); ExecuteCommand("use sid=1"); ExecuteCommand("clientupdate client_nickname=Idle\\sTimer"); my $client_list = ExecuteCommand("clientlist"); </code></pre> <p>Each command is executed properly, however the server likes to return extra lines, so a single sysread will not be enough and I will have to execute another. The size of responses are at most 512, so they aren't being cut off. If I try to run the sysread multiple times in an attempt to flush it, when there is nothing to read it will just make the program hang.</p> <p>The end of the executions are followed with "error id=0 msg=ok"</p> <p>How would I be able to read all the data that comes out, even if it's multiple lines? Or just be able to flush it all out so I can move onto the next command without having to worry about old data?</p>
<p>So you want to read until you find a line starting with <code>error</code>. In addition to doing that, the following buffers anything extra read since it's part of the next response.</p> <pre><code>sub read_response { my ($conn) = @_; my $fh = $conn-&gt;{fh}; our $buf; local *buf = \($conn-&gt;{buf}); # alias our $eof; local *eof = \($conn-&gt;{eof}); # alias $buf = '' if !defined($buf); return undef if $eof; while (1) { if ($buf =~ s/\A(.*?^error[^\n]*\n)//ms) { return $1; } my $rv = sysread($fh, $buf, 64*1024, length($buf)); if (!$rv) { if (defined($rv)) { $eof = 1; return undef; } else { die "Can't read response: $!\n"; } } } } </code></pre> <p>&#x20;</p> <pre><code>my $conn = { fh =&gt; $sock }; ... send command ... my $response = read_response($conn); ... ... send command ... my $response = read_response($conn); ... </code></pre>
<p>I changed my <code>ExecuteCommand</code> subroutine to include a check for "error code=[0-9]{1,}", which is what is always at the end of a response for Teamspeak 3 servers.</p> <pre><code>sub ExecuteCommand{ print $sock $_[0]."\n"; my $response = ""; while (1){ $sock-&gt;sysread($buf,1024*10); last if($buf =~ /error id=([0-9]{1,})/); $response .= $buf; }; return $response; }; </code></pre>