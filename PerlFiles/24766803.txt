Inquiry about Perl Regexes
<p>This question is related to one I asked yesterday. I'm new to Perl and am still getting the hang of things*. In the code, I am trying to replace right single quotation marks with apostrophes. However, I do not want to replace the right single quotation on singly quoted words. An example being: </p> <pre><code>He said the movie was 'magnificent.' </code></pre> <p>Here's the code I'm currently working with:</p> <pre><code>#!/usr/bin/perl use strict; use warnings; # Subroutine prototype sub problem_character(); my $previousPosition=0; my $currentPosition=0; #Locates problematic apostrophes and replaces them with properly encoded apostrophes sub problem_character(){ while($_[0]=~m/\x{2019}/g){ $currentPosition=pos($_[0]); pos($_[0])=$previousPosition; unless(....){ $_[0]=~s/\x{2019}/\x{0027}/g; } $previousPosition=$currentPosition; } } </code></pre> <p>First off, I'm not sure what I would put in the unless check. I want to be able to check if the matched right single quote is part of a singly quoted word. Also, in the Perl documentation, it was the pos function the offset where the last <code>m//q</code> search left off. Does the replacement search also fall under this category? Finally, is there a simpler way of writing this type of code? Thanks. </p> <p>*Does anyone know of a good book I could pick up that explains Peril in detail? I found the online resources to be quite confusing.</p>
<p>You posted you have the following:</p> <pre><code>He said the movie was 'magnificent.' </code></pre> <p>But you said you were trying to replace <code>’</code> which aren't present in that string. Do you actually have the following?</p> <pre><code>He said the movie was ‘magnificent.’ </code></pre> <p>If so, the simple solution would be to replace all <code>’</code> that aren't matched by a preceding <code>‘</code>. It's a bit tricky to implement, though.</p> <pre><code>s{ \G (?: [^\x{2018}\x{2019}]++ | \x{2018} [^\x{2018}\x{2019}]*+ \x{2019}?+ )*+ \K \x{2019} }{'}xg; </code></pre> <hr> <p>Simpler (but a little less efficient) implementation:</p> <pre><code>$_ = reverse($_); s/\x{2019}(?![^\x{2018}\x{2019}]*\x{2018})/'/g; $_ = reverse($_); </code></pre> <hr> <p>By the way, you can actually use the characters <code>‘</code> and <code>’</code> in the regex pattern if you want. Just make sure to encode your file using UTF-8 and tell Perl you did that using <code>use utf8;</code></p> <pre><code>use utf8; # Source code is encoded using UTF-8. $_ = reverse($_); s/’(?![^‘’]*‘)/'/g; $_ = reverse($_); </code></pre>