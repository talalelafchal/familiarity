Getting &quot;Use of uninitialized value within array in join or string&quot; error in spite of creating new variable using 'my' in each iteration
<p>I have two set of files (say set 1 and set 2). I have to read corresponding files from both sets and output corresponding file (with a modified name). </p> <p>Code looks like this:</p> <pre><code>my @files = &lt;path/to/directory/containing/both/set/of/files/*&gt;; foreach my $file (@files) { # pick a file from directory my $str; my $lines; my @arr; my @ans; # need new version of these for every file open(FH, $file) or die "Can't open file $!" ; # open file from set1 and copy everything to single string $lines = do { local $/; &lt;FH&gt; }; open(MYFILE, "&gt;tagged$basename.xml"); # open flle to be written into # basename extracted correctly, open corresponding file from set2 open(FILE, "&lt;outtrain$basename"); while (&lt;FILE&gt;) { # code modifying $lines and output stored in @ans, works perfectly for single file my $k = 0; my $num = 0; # no.(yr/vol/pg etc.) to be searched and tagged in xml file # find tag and num (see outtrain file, 1st no. is tag if (/(\d)\sdummy\,(\d*\.*\d*)\,(\d*\.*\d*)/) { $num = $3 * 1000; $tag = $1; } # important variables: @ans would store final (tagged) output array, @flag helps in # shifting charaters to right so that tags can be inserted (shifted version of @arr is # @ans, and after all shiftings have been done, @ans would store final tagged array. # @index is the position around which tags are to be inserted, $check ensures only 1st # matching of $num in @lines is considered my $check = 0; $flag = 0; for ($k = $index + $flag ; $k &lt;= $#arr ; $k++) { $ans[$k + $flag] = $arr[$k]; if (($arr[$k] eq $num) &amp;&amp; ($check eq 0)) { $flag = 2; $index = $k; $check = 1; } } # after arrays is shifted, time to insert the tags around ($index+1) in @ans if ($tag eq 4) { $ans[$index] = '&lt;Volume&gt;'; $ans[$index + 1] = $num; $ans[$index + 2] = '&lt;/Volume&gt;'; } if ($tag eq 1) { $ans[$index] = '&lt;Year&gt;'; $ans[$index + 1] = $num; $ans[$index + 2] = '&lt;/Year&gt;'; } if ($tag eq 2) { $ans[$index] = '&lt;StartPg&gt;'; $ans[$index + 1] = $num; $ans[$index + 2] = '&lt;/StartPg&gt;'; } if ($tag eq 3) { $ans[$index] = '&lt;EndPg&gt;'; $ans[$index + 1] = $num; $ans[$index + 2] = '&lt;/EndPg&gt;'; } #@arr=(); @arr = @ans; #print "\n@arr"; } $str = join(" ", @ans); # (line 56) # $str to be printed to outputfile print MYFILE "$str"; # print to file $lines = (); # clear $lines, though I think it's useless close(MYFILE); close(FILE); close(FH); } </code></pre> <p>It works perfectly for single file, but when I try to iterate, I get the error</p> <pre><code>Use of uninitialized value within @ans in join or string at tagger.pl line 56, &lt;FILE&gt; line 97. </code></pre> <p>I also tried making all these variables global, but then I started getting same output (output from 1st file being read) in every file.</p>
<p>With such limited information, the best way I can help you is to show how your <code>while</code> loop could be coded.</p> <p>Note these points</p> <ul> <li><p>There is the bare minimum of comments. If your code needs a lot of comments to make it comprehensible then you should write it more intelligibly and choose better identifiers</p></li> <li><p>It uses <code>autodie</code> so that you don't have to code explicit tests for the status of each <code>open</code> call (which you do for only one of the three <code>open</code>s in any case</p></li> <li><p>It uses <em>lexical file handles</em> and the <em>three-parameter form</em> of <code>open</code>, which is current best practice</p></li> <li><p>All variables are declared as <em>late</em> as possible; usually at the point they are defined</p></li> <li><p>I have rewritten the regex pattern to what I think you mean, and used the <code>/x</code> modifier so that I could space it out to make it more readable. In your original code <em>everything</em> was optional in the second and third captures</p></li> <li><p>It skips a line from the <em>outtrain</em> file altogether if it doesn't match the regex. Your code simply avoids assigning <code>$num</code> and <code>$tag</code> in case of a mismatch, but continues to use their values regardless</p></li> <li><p>There is a global array that defines the correspondency between numbers and tag names, avoiding the need for multiple <code>if</code> statements</p></li> <li><p><code>@arr</code> is modified <em>in place</em>, by using double-quote interpolation to wrap it in the appropriate start and end tags</p></li> </ul> <p>You don't show how <code>@arr</code> is populated so I have left its declaration commented. You also don't show any data so I have had to make several guesses, but you should get more mileage with this code than what you started with.</p> <p>It <em>does</em> compile as it stands, but you will have to weave it into the rest of your existing code. But I haven't been able to test it in the absence of useable data</p> <pre><code>use strict; use warnings; use autodie; use File::Basename 'basename'; my @tags = qw/ none Year StartPg EndPg Volume /; my @files = &lt;path/to/directory/containing/both/set/of/files/*&gt;; for my $file (@files) { my $basename = basename $file; my @arr = (); # How does this get filled? my $lines = do { # What is this for? Perhaps @arr = split /\n/, $lines? open my $fh, '&lt;', $file; local $/; &lt;$fh&gt;; }; open my $tagged_fh, '&gt;', "tagged$basename.xml"; open my $outtrain_fh, '&lt;', "outtrain$basename"; while (&lt;$outtrain_fh&gt;) { next unless / (\d) \s+ dummy , (\d+(?:\.\d*)?) , (\d+(?:\.\d*)?) /x; my $num = $3 * 1000; my $tag = $tags[$1]; for my $item (@arr) { $item = qq{&lt;$tag&gt;$item&lt;/$tag&gt;} if $item == $num; } } print $tagged_fh @arr; } </code></pre>