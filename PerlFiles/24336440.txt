Bash Command In Perl Script
<p>How can I get the following Bash command to execute correctly in a Perl Script?</p> <pre><code>su - oracle -c "echo \"select database_role from v\\\$database;\" | sqlplus -s / as sysdba"; </code></pre> <p>When placed in a bash script, the command executes correctly. But when in a perl script using the following:</p> <pre><code>my @roleQuery = `su - oracle -c "echo \"select database_role from v\\\$database;\" | sqlplus -s / as sysdba"`; </code></pre> <p>Returns:</p> <pre><code>sh: | sqlplus -s / as sysdba: not found Oracle Corporation SunOS 5.10 Generic Patch January 2005 You have mail. select </code></pre> <p>I am executing both the bash and perl script as the same user.</p> <p>Bash Output (Which is my desired return)</p> <pre><code>Oracle Corporation SunOS 5.10 Generic Patch January 2005 You have mail. DATABASE_ROLE ---------------- PRIMARY </code></pre>
<p><code>qx</code> (backticks) follows the same rules as <code>qq</code> (double-quotes). Escape the <code>\</code> and <code>$</code> characters. (And <code>@</code> if you had any.)</p> <pre><code>su - oracle -c "echo \"select database_role from v\\\$database;\" | sqlplus -s / as sysdba"; </code></pre> <p>is executed by</p> <pre><code>`su - oracle -c "echo \\"select database_role from v\\\\\\\$database;\\" | sqlplus -s / as sysdba";` </code></pre>
<h3>Double Quoted Strings - Lots of escaping required</h3> <p>The backtick operator <code>`STRING`</code> is synonymous with <a href="http://perldoc.perl.org/functions/qx.html" rel="nofollow"><code>qx/STRING/</code></a> and behaves like a double quoted string that interpolates variables. Therefore one must escape the following characters for them to be treated as literals: <code>$</code>, <code>@</code>, <code>\</code>, and whatever character(s) is used as the delimiter.</p> <pre><code>my @roleQuery = `su - oracle -c "echo \\"select database_role from v\\\\\\\$database;\\" | sqlplus -s / as sysdba";` </code></pre> <h3>Single Quoted Strings - Less escaping</h3> <p>There is one trick documented in <a href="http://perldoc.perl.org/perlop.html#Quote-Like-Operators" rel="nofollow"><code>perlop Quote-Like Operators</code></a> though:</p> <blockquote> <p>Using single-quote as a delimiter protects the command from Perl's double-quote interpolation, passing it on to the shell instead:</p> <pre><code> $perl_info = qx(ps $$); # that's Perl's $$ $shell_info = qx'ps $$'; # that's the new shell's $$ </code></pre> </blockquote> <p>Of course, single quoted strings still need single quotes to be escaped and any multiple backslash or backslash at the end of the string. This reduces your escaping to just the three backslashes in a row:</p> <pre><code>my @roleQuery = qx'su - oracle -c "echo \"select database_role from v\\\\\\$database;\" | sqlplus -s / as sysdba"'; </code></pre> <h3>Single Quoted Heredoc - No escaping</h3> <p>To avoid the need to escape, you can assign your command to a variable using a single quoted heredoc. This adds a step, but this can be helpful when one already has two different levels of escaping potentially. Also, you can remove the chomp if the additional newline doesn't matter.</p> <pre><code>chomp(my $rolecmd = &lt;&lt;'END_COMMAND'); su - oracle -c "echo \"select database_role from v\\\$database;\" | sqlplus -s / as sysdba" END_COMMAND my @roleQuery = `$rolecmd`; </code></pre>