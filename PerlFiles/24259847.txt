Is there a better way of writing this code to avoid redundancy?
<p>I have a segment of code in a program, which accepts GNU style input from a pipe (which is a list of file names). If STDIN does not contain data, I need to accept input from a predetermined text file containing file names.</p> <p>I find myself needing to write redundant code. Is it possible to simplify this bit of code to avoid redundancy? </p> <pre><code>sub downloadlinkgen { my $fh; print "Printing links\n"; if ($getfilelist==1) { open $fh, '&lt;', "fuzzyfile" or die $!; while (&lt;$fh&gt;) { chomp ($_); (my $fname,my $path, my $suffix) = fileparse($_); my ($name, $ext) = $fname =~ /(.*)\.(.*)/; my $newfile=$path.$name.".$ext"; $newfile =~ s/\s/%20/g; $newfile =~ s/\/root/http:\/\/myip/; print $newfile."\n"; } } else { while (&lt;&gt;) { chomp ($_); (my $fname,my $path, my $suffix) = fileparse($_); my ($name, $ext) = $fname =~ /(.*)\.(.*)/; my $newfile=$path.$name.".$ext"; $newfile =~ s/\s/%20/g; $newfile =~ s/\/root/http:\/\/myip/; print $newfile."\n"; } } } </code></pre>
<pre><code>sub downloadlinkgen { # default file handle my $fh = \*ARGV; print "Printing links\n"; if ($getfilelist==1) { open $fh, '&lt;', "fuzzyfile" or die $!; } while (&lt;$fh&gt;) { chomp ($_); (my $fname,my $path, my $suffix) = fileparse($_); my ($name, $ext) = $fname =~ /(.*)\.(.*)/; my $newfile=$path.$name.".$ext"; $newfile =~ s/\s/%20/g; $newfile =~ s/\/root/http:\/\/myip/; print $newfile."\n"; } } </code></pre> <p>From <code>perldoc -f readline</code></p> <blockquote> <p>Reads from the filehandle whose typeglob is contained in EXPR (or from *ARGV if EXPR is not provided)</p> </blockquote> <p>so <code>\*ARGV</code> is reference to file handle used when reading from <code>&lt;&gt;</code>, and you can use <code>$fh</code> in both cases.</p>
<p>Yes, just make the default ARGV filehandle open the file:</p> <pre><code>sub downloadlinkgen { @ARGV = 'fuzzyfile' if $getfilelist == 1; print "Printing links\n"; while (&lt;&gt;) { chomp ($_); (my $fname,my $path, my $suffix) = fileparse($_); my ($name, $ext) = $fname =~ /(.*)\.(.*)/; my $newfile=$path.$name.".$ext"; $newfile =~ s/\s/%20/g; $newfile =~ s/\/root/http:\/\/myip/; print $newfile."\n"; } } </code></pre>
<p>Even if you don't know about <code>ARGV</code>, you could do something simple like this:</p> <pre><code>sub downloadlinkgen { my $fh; print "Printing links\n"; if ($getfilelist==1) { open $fh, '&lt;', "fuzzyfile" or die $!; while (&lt;$fh&gt;) { process_line($_); } } else { while (&lt;&gt;) { process_line($_); } } } sub process_line { my $line = shift; chomp ($line); (my $fname,my $path, my $suffix) = fileparse($line); my ($name, $ext) = $fname =~ /(.*)\.(.*)/; my $newfile=$path.$name.".$ext"; $newfile =~ s/\s/%20/g; $newfile =~ s/\/root/http:\/\/myip/; print $newfile."\n"; } </code></pre>