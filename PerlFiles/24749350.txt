Adding accessors to Class::XSAccessor via predefined hash?
<p>Consider the following example:</p> <pre><code>use 5.010; use Data::Dumper; { package MyTestPck; use Data::Dumper; use Tie::IxHash; sub ordered_hash { # http://stackoverflow.com/a/3001400/277826 tie my %hash =&gt; 'Tie::IxHash'; %hash = @_; \%hash } my $fields = ordered_hash( (map { $_ =&gt; $_ } (qw( varA varB varC ))) ); print Dumper($fields); use Class::XSAccessor accessors =&gt; { %{$fields} }; sub new { my $class = shift; my @set_arr = @_; # the rest my $ic = 0; my $self = {}; bless $self, $class; for my $k (keys %{$fields}) { my $fld = $fields-&gt;{$k}; my $val = $set_arr[$ic]; print("k $k fld $fld ic/val $ic $val\n"); $self-&gt;$fld($val); $ic++; } return $self; } 1; } my $pcktestobj = MyTestPck-&gt;new((10, 20, 30)); print Dumper($pcktestobj); </code></pre> <p>If I run it as is; the code fails with:</p> <pre class="lang-none prettyprint-override"><code>$ perl /tmp/test.pl $VAR1 = { 'varA' =&gt; 'varA', 'varB' =&gt; 'varB', 'varC' =&gt; 'varC' }; k varA fld varA ic/val 0 10 Can't locate object method "varA" via package "MyTestPck" at /tmp/test.pl line 34. </code></pre> <p>However, if you replace the middle part of the code with:</p> <pre><code>... use Class::XSAccessor accessors =&gt; ordered_hash( (map { $_ =&gt; $_ } (qw( varA varB varC ))) ); ... </code></pre> <p>... then the output is as expected:</p> <pre class="lang-none prettyprint-override"><code>$ perl /tmp/test.pl $VAR1 = { 'varA' =&gt; 'varA', 'varB' =&gt; 'varB', 'varC' =&gt; 'varC' }; k varA fld varA ic/val 0 10 k varB fld varB ic/val 1 20 k varC fld varC ic/val 2 30 $VAR1 = bless( { 'varC' =&gt; 30, 'varB' =&gt; 20, 'varA' =&gt; 10 }, 'MyTestPck' ); </code></pre> <p>So, apparently, I cannot set accessors via predefined hash, as in <code>use Class::XSAccessor accessors =&gt; { %{$fields} };</code> - I apparently must specify the accessors hash inline.</p> <p>But why is this? Is there anything in the <a href="https://metacpan.org/source/SMUELLER/Class-XSAccessor-1.19/README" rel="nofollow">Class::XSAccessor docs</a> that should have alerted me to this behavior? Is there a way I could use predefined fields (as I intended in the first example) with <code>Class::XSAccessor</code>?</p>
<p><code>use</code> statements are executed at <strong>compile time</strong>, but your hash doesn't get populated until <strong>run time</strong>. Look at this example:</p> <pre><code>my $x = {}; # this statement is executed **SECOND** use strict; # this statement is executed **FIRST** </code></pre> <p>So you couldn't usefully employ the <code>$x</code> variable in the <code>use</code> statement above. <code>$x</code> would not have been defined yet.</p> <p>Luckily, <code>use</code> statements can easily be broken down into a <code>require</code> followed by an <code>import</code>. Each of those happen at run time. So try replacing this:</p> <pre><code>use Class::XSAccessor accessors =&gt; { %{$fields} }; </code></pre> <p>With this:</p> <pre><code>require Class::XSAccessor; Class::XSAccessor-&gt;import( accessors =&gt; $fields ); </code></pre> <hr> <p>An alternative would be to force <code>$fields</code> to be populated at compile time. This should work, but is less pretty:</p> <pre><code>my $fields; BEGIN { $fields = ordered_hash( (map { $_ =&gt; $_ } (qw( varA varB varC ))) ); print Dumper($fields); }; use Class::XSAccessor accessors =&gt; { %{$fields} }; </code></pre>