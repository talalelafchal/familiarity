Perl: prototype in anonymous subroutine
<p>I am currently learning about Perls system of typeglobs and namespaces. So I wrote a module that takes two arguments the value and the name of a constant and exports the constant to the caller. The $package variable is equal to caller[2].</p> <pre><code>*{"$package::$name"} = sub () { return $value; }; </code></pre> <p>This code above does the job of exporting a anonymous subroutine into the callers symboltable. Because my goal is to build my own constant-implementation the subroutine has a empty prototype which means its a read-only subroutine.</p> <p>But this is my problem: the prototype does not work. So</p> <pre><code>print &amp;TestConst; #works well print TestConst(); #works well print TestConst; #Name "main::TestConst" used only once: possible typo at testscript.pl line 7. </code></pre> <p>Is there something wrong in my thoughts? Is there another way of doing it?</p>
<p>You can define all the symbols you want during runtime, but prototypes will only affect code compiled afterwards since prototypes affect how calls to the sub are parsed and compiled. For example:</p> <pre><code>use strict; use warnings; package Foo; BEGIN { *Foo::bar = sub () { 42 }; } *Foo::baz = sub () { 43 }; my $bar = bar; my $baz = baz; print "bar = [$bar], baz = [$baz]\n"; </code></pre> <p>If we run this, it dies with:</p> <blockquote> <p>Bareword "baz" not allowed while "strict subs" in use at tprot.pl line 13.</p> </blockquote> <p>That's a <em>compile</em>-time error caused by <code>strict</code>: the compiler saw the symbol <code>baz</code> and didn't know what it was, because the typeglob <code>*Foo::baz</code> does not get altered until runtime. But <code>bar</code> worked fine because it was defined in a <code>BEGIN</code> block, which executes immediately during compilation.</p> <p>IOW, because barewords are ambiguous, Perl needs to know at compile-time whether it's a sub or something else. So you can install these during <code>import</code> (which executes in an implicit <code>BEGIN</code> block) but not at runtime.</p> <p>Additionally, prototypes affect compilation semantics; a constant subroutine (like those made by <code>constant.pm</code>) gets optimized away. Other prototypes cause the parser to change its behavior (e.g. subs which can take code blocks.) The compiler has to know about all this stuff before calls to the sub are actually encountered in the code, so they can be parsed correctly. The code runs after everything is already parsed.</p> <p>Calling a sub with explicit parens or with an ampersand does not have this restriction because Perl is smart enough at runtime to know that these are subroutine calls, and to look them up dynamically in the symbol table.</p>