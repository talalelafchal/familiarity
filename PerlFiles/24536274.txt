non-capturing in substitution regex
<p>I have a line that reads like this.</p> <pre><code>NAME: ^?^?^, DOB: ^?^?^?^?, SN: ^?^? </code></pre> <p>For reasons beyond my control, non-printing characters are showing up in the file. For this, I just need to match and remove ONLY the ones appear after NAME, DOB, and SN.</p> <p>So I am testing out the code with NAME, and this is my regex</p> <pre><code>$_ =~ s/(?:NAME: )[^[:print:]]//g) </code></pre> <p>The expected output is:</p> <pre><code>NAME: , </code></pre> <p>However, I am getting:</p> <pre><code>^?^?^, </code></pre> <p>With name stripped instead? Does non-capturing not work in substitution?</p>
<p>Non-capturing groups are for when you want to avoid the overhead involved in capturing, or when you want to keep unnecessary things out of your capture groups while still being able to group them. To keep something in a substitution you could do</p> <pre><code>$_ =~ s/(NAME:)\P{print}+/$1/g; </code></pre> <p>which will capture Name: and substitute it back in, or use the \K (keep) metacharacter:</p> <pre><code>$_ =~ s/NAME:\K\P{print}+//g; </code></pre> <p>which prevents s/// from substituting anything left of it in the pattern.</p> <p>Side note: s/// operates on $_ unless a variable is specified with =~, so $_ =~ s/// is redundant (but some might argue it conveys intent).</p>