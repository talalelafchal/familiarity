Perl module or code for finding overlapping region of two strings
<p>I have two strings.</p> <p>They are not substrings of each other but there is a overlapping region between them.</p> <pre><code>my $str1 = "AAAAAAAAAABBBBBBBBCC"; my $str2 = "BBBBBBBBCCZZZZZZZZZZ"; </code></pre> <p>I want to find this overlapping region.</p> <pre><code> "AAAAAAAAAABBBBBBBBCC" "BBBBBBBBCCZZZZZZZZZZ" Overlap is "BBBBBBBBCC" </code></pre> <p>I searched CPAN and google extensively.</p> <p>There are many modules about "<em>Edit Distance</em>" Method such as <a href="https://metacpan.org/pod/Algorithm%3a%3aDiff" rel="nofollow"><code>Algorithm::Diff</code></a>, <a href="https://metacpan.org/pod/Text%3a%3aLevenshtein" rel="nofollow"><code>Text::Levenshtein</code></a> or <a href="https://metacpan.org/pod/Text%3a%3aOverlapFinder" rel="nofollow"><code>Text::OverlapFinder</code></a> and <a href="https://metacpan.org/pod/String%3a%3aSimilarity" rel="nofollow"><code>String::Similarity</code></a>. But, they are not what I am looking for.</p> <p>String should not be <em>gaped</em> (Insert or Delete any character) or <em>substituted</em>. It's similar to sequence alignment in bioinformatics but without gap "open" and "extension" permission unless in both extremes.</p> <p>I was wondering if anyone found a solution or a work around yet.</p>
<p>Check <a href="https://metacpan.org/pod/String%3a%3aLCSS_XS" rel="nofollow"><code>String::LCSS_XS</code></a> module,</p> <pre><code>use String::LCSS_XS 'lcss'; my ($s1,$s2) = qw( AAAAAAAAAABBBBBBBBBB BBBBBBBBBBCCCCCCCCCC ); my $longest = lcss ($s1, $s2); print "$longest\n"; </code></pre> <p>output</p> <pre><code>BBBBBBBBBB </code></pre>
<p>Because you're searching for the bounded overlap, this is a simple enough problem that brute force is the way to go. Equalize the string lengths, and then just chop off characters until you find a match.</p> <p>There are some potential avenues to make this more efficient, but only explore those IF this becomes too slow.</p> <pre><code>use strict; use warnings; sub overlap { my ($str1, $str2) = @_; # Equalize Lengths if (length $str1 &lt; length $str2) { $str2 = substr $str2, 0, length($str1); } elsif (length $str1 &gt; length $str2) { $str1 = substr $str1, length($str1) - length($str2); } # Reduce until match found while ($str1 ne $str2) { substr $str1, 0, 1, ''; chop $str2; } return $str1; } while (&lt;DATA&gt;) { print "Overlap is " . overlap(split), "\n"; } __DATA__ AAAAAAAAAABBBBBBBBBB BBBBBBBBBBCCCCCCCCCC aln.trp.leu.tre leu.tre.met.ile aaaaaaaaaaaaaaaaaaaZ aaaaaaaaaaaaaaa </code></pre> <p>Outputs:</p> <pre><code>Overlap is BBBBBBBBBB Overlap is leu.tre Overlap is </code></pre>