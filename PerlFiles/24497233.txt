Loop over one dimension of a multi-dimensional array in Perl using for each
<p><strong>* UPDATED*</strong> for typos</p> <p>Another PERL question.... I am trying to loop through a 2D array. I am positive about the size of one dimension but unsure on the second. The code snippet:</p> <pre><code>foreach my $value (@surfaces[1]) { my $sum = 0; my $smallest = 9999; my $limit_surface = 0; for (my $i = 0; $i &lt; 3; $i++) { $sum += $surfaces[$i][$counter]; if ($surfaces[$i][$counter] &lt;= $smallest) { $smallest = $surfaces[$i][$counter]; $limit_surface = $subchannel_number[$i]; } } $counter++; push(@avg_value,$sum/@rodsurface_number); push(@limiting_schan,$limit_surface); push(@limiting_value,$smallest); } </code></pre> <p>I am compiled but $value variable is failing to initialize. </p>
<p>I've set up some dummy variables and changed a few things around. This compiles and produces the results I show below. </p> <p>This might not answer your question, but should allow you to copy and paste the code, run it yourself, edit the input and see how the output compares to what you want.</p> <pre><code>use warnings; use strict; use Data::Dumper; $Data::Dumper::Sortkeys = 1; my @surfaces = ( ['1','2','3'], ['10','20','30'], ['100','200','400'], ); my @subchannel_number = ( ['1','2','3'], ['10','20','30'], ['100','200','400'], ); my @rodsurface_number = (1 .. 10); my $counter = 0; my (@avg_value, @limiting_schan, @limiting_value); foreach my $value ($surfaces[1]){ my $sum = 0; my $smallest = 9999; my $limit_surface = 0; for (my $i = 0; $i &lt; 3; $i++) { $sum += $surfaces[$i][$counter]; if ($surfaces[$i][$counter] &lt;= $smallest){ $smallest = $surfaces[$i][$counter]; $limit_surface = $subchannel_number[$i]; } } $counter++; push(@avg_value,$sum/@rodsurface_number); push(@limiting_schan,$limit_surface); push(@limiting_value,$smallest); } print Dumper (\@avg_value, \@limiting_schan, \@limiting_value); </code></pre> <hr> <pre><code>$VAR1 = [ '11.1' ]; $VAR2 = [ [ '1', '2', '3' ] ]; $VAR3 = [ 1 ]; </code></pre>
<p>You do not describe your data structure, nor explain exactly what you want to do with it. This limits the advice that we can give to just the general variety. </p> <p>If you're trying to iterate over an array of arrays, I would advise you to do it based off of element instead of index.</p> <p>For example, below I have a 4 by 5 matrix of integers. I would like to find the average of these values. One way to do this is to simply iterate over each row and then column, and add up the values:</p> <pre><code>use strict; use warnings; my @AoA = ( [11, 12, 13, 14, 15], [21, 22, 23, 24, 25], [31, 32, 33, 34, 35], [41, 42, 43, 44, 45], ); my $sum = 0; my $count = 0; for my $row (@AoA) { for my $element (@$row) { # &lt;-- dereference the array ref $sum += $element; $count++; } } print "Average of Matrix is " . ($sum / $count) . "\n"; </code></pre> <p>Outputs:</p> <pre><code>Average of Matrix is 28 </code></pre> <p>For more information on complex data structures, check out: <a href="http://perldoc.perl.org/perldsc.html" rel="nofollow"><code>Perl Data Structures Cookbook</code></a></p>
<p>Repeat after me:</p> <p><strong>Perl does not have multidimensional arrays</strong><br> <strong>Perl does not have multidimensional arrays</strong><br> <strong>Perl does not have multidimensional arrays</strong></p> <p>What Perl does have is have are <em>arrays</em> that contain <em>references</em> pointing to other arrays. You can <em>emulate</em> multidimensional arrays in Perl, but they are not true multidimensional arrays. For example:</p> <pre><code>my @array; $array[0] = [ 1, 2, 3, 4, 5 ]; $array[1] = [ 1, 2, 3 ]; $array[2] = [ 1, 2 ]; </code></pre> <p>I can talk about <code>$array[0][1]</code>, and <code>$array[2][1]</code>, but while <code>$array[0][3]</code> exists, <code>$array[2][3]</code> doesn't exist.</p> <p>If you don't understand references, read the <a href="http://perldoc.perl.org/perlreftut.html" rel="nofollow">tutorial on references</a>. </p> <p>What you need to do is go through your array and then find out the size of each subarray and go through each of those. There's no guarantee that</p> <ol> <li>The reference contained in your primary array actually points to another array:</li> <li>That your sub-array contains only scalar data. </li> </ol> <p>You can use the <code>$#</code> operator to find the size of your array. For example <code>$#array</code> is the number of items in your array. You an use <code>( 0..$#array )</code> to go through each item of your array, and this way, you have the index to play around with.</p> <pre><code>use strict; use warnings; my @array; $array[0] = [ 1, 2, 3, 4, 5 ]; $array[1] = [ 1, 2, 3 ]; $array[2] = [ 1, 2, ]; # # Here's my loop for the primary array. # for my $row ( 0..$#array ) { printf "Row %3d: ", $row ; # # My assumption is that this is another array that contains nothing # but scalar data... # my @columns = @{ $array[$row] }; # Dereferencing my array reference for my $column ( @columns ) { printf "%3d ", $column; } print "\n"; } </code></pre> <p>Note I did <code>my @columns = @{ $array[$row] };</code> to convert my <em>reference</em> back into an array. This is an extra step. I could have simply done the dereferencing in my <code>for</code> loop and saved a step. </p> <p>This prints out:</p> <pre><code>Row 0: 1 2 3 4 5 Row 1: 1 2 3 Row 2: 1 2 </code></pre> <p>I could put some safety checks in here. For example, I might want to verify the size of each row, and if one row doesn't match the other, complain:</p> <pre><code>my $row_size = $array[0]; for my $row ( 1..$#array ) { my @columns = @{ $array[$row] }; if ( $#columns ne $array_size ) { die qq(This is not a 2D array. Not all rows are equal); } } </code></pre>