Having trouble initializing dictonary values in a Python script ported from Perl
<p>I am trying to convert a Perl script to Python. Here is the Perl code:</p> <pre><code>my %ScenarioTenorValues; my @tenor_list =(12,24,36,48,60,84,120,180,240,300,360); my $scen; my $tenor; for($scen = 1; $scen &lt; 20; $scen += 1) { print "scen entered $scen \n"; foreach $tenor (@tenor_list) { print "tenor entered $tenor \n"; $ScenarioTenorValues{$scen}{$tenor} = 0; print Dumper(\%ScenarioTenorValues); } } </code></pre> <p>And the output looks like this:</p> <pre><code>tenor: 240 $VAR1 = '11'; $VAR2 = { '240' =&gt; 0, '84' =&gt; 0, '120' =&gt; 0, '36' =&gt; 0, '12' =&gt; 0, '48' =&gt; 0, '360' =&gt; 0, '60' =&gt; 0, '180' =&gt; 0, '24' =&gt; 0, '300' =&gt; 0 }; </code></pre> <p>I tried to convert it to Python as follows:</p> <pre><code>scenarioTenorValues = {} tenor_list =[12,24,36,48,60,84,120,180,240,300,360] scenario = None tenor = None for scenario in range(1,20): print "scenario: ",scenario for tenor in tenor_list: print "tenor entered: ",tenor, "\n" scenarioTenorValues[scenario] = { tenor : 0 } print (scenarioTenorValues), "\n" </code></pre> <p>However, the output from the Python script doesn't match the output from the Perl script:</p> <pre><code>{1: {360: 0}, 2: {360: 0}, 3: {360: 0}, 4: {360: 0}, 5: {360: 0}, 6: {360: 0}, 7: {360: 0}, 8: {360: 0}, 9: {360: 0}, 10: {360: 0}, 11: {360: 0}, 12: {360: 0}, 13: {360: 0}, 14: {360: 0}, 15: {360: 0}, 16: {360: 0}, 17: {360: 0}, 18: {360: 0}, 19: {36: 0}} </code></pre> <p>Why doesn't the output from the two scripts match?</p>
<p>In the pythong version, you are wiping out the previous 'tenor' value in the scenario every time you assign the new tenor. I think you want something like:</p> <pre><code>scenarioTenorValues[scenario, tenor] = 0 </code></pre>
<p>Your perl code is a little strange. Are the print statements just for debugging to help tell you where you are? Why print the data structure at every iteration? You might code that a little more concisely with a map.</p> <p>Anyway, for a dict of a dict, the setdefault method of dicts is handy for such a case:</p> <pre><code>#!/usr/bin/python import pprint scenarioTenorValues = {} tenor_list = [12,24,36,48,60,84,120,180,240,300,360] scenario = None tenor = None for scenario in range(1,20): print "scen: %d" % scenario for tenor in tenor_list: print "tenor: %d" % tenor scenarioTenorValues.setdefault(scenario,{})[tenor] = 0 pprint.pprint(scenarioTenorValues) </code></pre> <p>Here's a snippet of the perl result using <code>Data::Dump</code>:</p> <pre><code>scen entered 2 tenor entered 12 { 1 =&gt; { 12 =&gt; 0, 24 =&gt; 0, 28 =&gt; 0, 36 =&gt; 0, 60 =&gt; 0, 84 =&gt; 0, 120 =&gt; 0, 180 =&gt; 0, 240 =&gt; 0, 300 =&gt; 0, 360 =&gt; 0 }, 2 =&gt; { 12 =&gt; 0 }, } </code></pre> <p>Here's the python version using <code>pprint</code>:</p> <pre><code>scen: 2 tenor: 12 {1: {12: 0, 24: 0, 36: 0, 48: 0, 60: 0, 84: 0, 120: 0, 180: 0, 240: 0, 300: 0, 360: 0}, 2: {12: 0}} </code></pre>