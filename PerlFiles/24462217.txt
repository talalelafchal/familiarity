Perl script writing output twice; second time in reverse order
<p>I'm trying to figure out why a script is writing output twice. The first time in proper order, the second time in reverse order. It should only be writing it once.</p> <pre><code>#!/usr/bin/perl use warnings; use strict; use Fcntl ':mode'; use File::Find; no warnings 'File::Find'; no warnings 'uninitialized'; my $dir = "/var/log/tivoli/"; my $mtab = "/etc/mtab"; my $permFile = "world_writable_files.txt"; my $tmpFile = "world_writable_files.tmp"; my $exclude = "/usr/local/etc/world_writable_excludes.txt"; my $mask = S_IWUSR | S_IWGRP | S_IWOTH; my (%excludes, %devNums); my $errHeader; # Compile a list of mountpoints that need to be scanned my @mounts; open MT, "&lt;${mtab}" or die "Cannot open ${mtab}, $!"; # We only want the local mountpoints while (&lt;MT&gt;) { if ($_ =~ /ext[34]/) { chomp; my @line = split; push(@mounts, $line[1]); my @stats = stat($line[1]); $devNums{$stats[0]} = undef; } } close MT; # Build a hash from /usr/local/etc/world_writables_excludes.txt if ((! -e $exclude) || (-z $exclude)) { $errHeader = &lt;&lt;HEADER; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !! !! !! /usr/local/etc/world_writable_excludes.txt is !! !! is missing or empty. This report includes !! !! every world-writable file including those which !! !! are expected and should be excluded. !! !! !! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! HEADER } else { open XCLD, "&lt;${exclude}" or die "Cannot open ${exclude}, $!\n"; while (&lt;XCLD&gt;) { chomp; $excludes{$_} = 1; } } sub wanted { my @dirStats = stat($File::Find::name); # Is it excluded from the report... return if exists $excludes{$File::Find::name}; # ...is the Tivoli installation directory or a special directory... if ($File::Find::name =~ m{^/sys|^/proc|^/dev|^/opt/IBM/ITM}) { $File::Find::prune = 1; return; } # ...a regular file, ... return unless -f; # ...local, ... return unless (exists $devNums{$dirStats[0]}); # ...and world writable? return unless ($dirStats[2] &amp; $mask) == $mask; # If so, add the file to the list of world writable files print(WWFILE "$File::Find::name\n"); } # Create the output file path if it doesn't already exist. mkdir($dir or die "Cannot execute mkdir on ${dir}, $!") unless (-d $dir); # Create our filehandle for writing our findings open WWFILE, "&gt;${dir}${tmpFile}" or die "Cannot open ${dir}${tmpFile}, $!"; print(WWFILE "${errHeader}") if ($errHeader); find(\&amp;wanted, @mounts); close WWFILE; # If no world-writable files have been found ${tmpFile} should be zero-size; # Delete it so Tivoli won't alert if (-z "${dir}${tmpFile}") { unlink "${dir}${tmpFile}"; } else { rename("${dir}${tmpFile}","${dir}${permFile}") or die "Cannot rename file ${dir}${tmpFile}, $!"; } </code></pre> <p>Example output:</p> <pre><code># cat world_writable_files.txt /var/opt/ds_agent/am/diagnostic_1.log /home/User1/report.pl.20130220 /home/User1/report.pl.20130220 /var/opt/ds_agent/am/diagnostic_1.log </code></pre> <p>Each file is being written only once in the script so I am wondering if the filesystem is being scanned twice. Once in each direction. I don't see where that would be happening, but I don't know.</p> <p>Excludes file:</p> <pre><code># cat /usr/local/etc/world_writable_excludes.txt /var/opt/ds_agent/diagnostic.log /var/opt/ds_agent/am/diagnostic.log </code></pre> <p>Any thoughts on this conundrum?</p>
<p>It's because <code>@mounts</code> has <code>/</code> in addition to <code>/home</code> and <code>/var</code>. So you're asking it to scan everything at and below <code>/</code> (including <code>/home</code> and <code>/var</code>), then to scan everything at and below <code>/home</code>, then to scan everything at and below <code>/var</code>.</p> <p>It's better to identify the places you want to avoid.</p> <pre><code>while (&lt;MT&gt;) { my @fields = split; if ($field[2] !~ /^ext[34]\z/) { ++$excludes{ $fields[1] }; } } find(\&amp;wanted, '/'); sub wanted { if ($excludes{$File::Find::name}) { $File::Find::prune = 1; return; } my @dirStats = stat($File::Find::name); return if !-f; return if $dirStats[2] &amp; S_IWOTH; print(WWFILE "$File::Find::name\n"); } </code></pre> <p>You won't need <code>if ($File::Find::name =~ m{^/sys|^/proc|^/dev|^/opt/IBM/ITM})</code> anymore because they're not ext3 or ext4. Except maybe for <code>/opt/IBM/ITM</code> (since I don't know what that is). If you did have some files or directories you wanted to skip, add them to <code>%excludes</code> rather than making a relatively expensive regex match.</p> <pre><code>++$excludes{$_} for qw( /foo /bar /opt/IBM/ITM ); </code></pre>