Reading file, matching strings and formatting the output in Perl
<p>spent to long on this and it is now hurting my head. I have simplified the data file but basically I have grep'd some values out of 5 different files and now want to graph them into excel. So the format in excel for a line graph needs to correct.</p> <p>Current file looks like</p> <pre><code>Report-20140521.csv: Sun, 20 Report-20140530.csv: Sun, 23 Report-20140606.csv: Sun, 24 Report-20140613.csv: Sun, 25 Report-20140621.csv: Sun, 21 Report-20140521.csv: Mon, 22 Report-20140530.csv: Mon, 23 Report-20140606.csv: Mon, 24 Report-20140613.csv: Mon, 24 Report-20140621.csv: Mon, 21 Report-20140521.csv: Tues, 22 Report-20140530.csv: Tues, 23 Report-20140606.csv: Tues, 20 Report-20140613.csv: Tues, 21 Report-20140621.csv: Tues, 21 </code></pre> <p>I would like to flatten this all out and have five lines with the values in each like :-</p> <pre><code> Sun Mon Tue wed .. Report-20140521.csv: 20 22 22 Report-20140530.csv: 23 23 23 Report-20140606.csv: 24 24 20 Report-20140613.csv: 25 24 21 Report-20140621.csv: 21 21 21 </code></pre> <p>Have looked at using arrays and arrays of arrays but either way the data seems to be rigged and can't get it to flatten out using the 5 different lines. On top of this I need to keep the file name as this will be striped out into a date format later in excel.</p>
<p>You could use a hash of arrays to store your data in, and then print out values matching your column names (i.e. day):</p> <pre><code>use warnings; use strict; open my $in, '&lt;', 'in.txt'; my (%data, @record, @day, @n); while (&lt;$in&gt;){ chomp; my @split = split(/\s/); push @record, $split[0]; $split[1] =~ s/,//g; push @day, $split[1]; push @n, $split[2]; } push @{$data{$record[$_]} }, [ $day[$_], $n[$_] ] for 0 .. $#record; my @days = qw(Sun Mon Tues Wed Thu Fri Sat); print "$_ " foreach (@days); print "\n"; for my $report (sort keys %data){ print "$report\t"; for my $val (@{$data{$report}}){ my ($day, $n) = @$val; foreach(@days){ print "$n\t" if $day eq $_; } print "\n"; } } </code></pre> <p>Output:</p> <pre><code>Sun Mon Tues Wed Thu Fri Sat Report-20140521.csv: 20 22 22 Report-20140530.csv: 23 23 23 Report-20140606.csv: 24 24 20 Report-20140613.csv: 25 24 21 Report-20140621.csv: 21 21 21 </code></pre>
<p>I think a hash of hashes would work well for this, since your Day of Week values are discrete and bounded. Some variant of this might work:</p> <pre><code>use strict; my %matrix; open IN, 'yourfile.txt' or die $!; while (&lt;IN&gt;) { chomp; my ($report, $val) = split /,/; my ($file, $dow) = split /: /, $report; $matrix{$file}{$dow} = $val; } close IN; my @dow = qw(Sun Mon Tues Wed Thu Fri Sat); foreach my $file (sort keys %matrix) { print $file, "\t"; my $report_ref = $matrix{$file}; foreach my $dow (@dow) { print $$report_ref{$dow}, "\t"; } print "\n"; } </code></pre> <p>Sample output:</p> <pre><code>Report-20140521.csv 20 22 22 Report-20140530.csv 23 23 23 Report-20140606.csv 24 24 20 Report-20140613.csv 25 24 21 Report-20140621.csv 21 21 21 </code></pre>
<p>This solution does as you ask. It uses a hash <code>%headers</code> to convert the date names into column numbers as the data is read in, and produces a hash that is keyed by the CSV file name. The values of the hash are arrays of value pairs, each pair consisting of a column number and a value for that column</p> <p>Once the data has been digested into the hash, it is scanned in sorted order of file name. An array <code>@info</code> is initialised to seven empty fields, and the column/value pairs in the hash are used to overwrite those columns that are provided</p> <p>The maximum length of the file names is determined and used first in printing the <code>@headers</code> array of day names, and then the <code>@info</code> array for each hash entry</p> <p>I hope this helps</p> <pre><code>use strict; use warnings; use List::Util 'max'; my $filename = 'current.txt'; open my $fh, '&lt;', $filename or die qq{Unable to open "$filename" for input: $!}; my @headers = qw/ Sun Mon Tue Wed Thu Fri Sat /; my %headers = map { $headers[$_] =&gt; $_ } 0 .. $#headers; my %file_data; while (&lt;$fh&gt;) { next unless my @fields = /(\S[^:]+:)\s+(\w{3})\w*, (\d+)/; my $file = shift @fields; $fields[0] = $headers{ucfirst lc $fields[0]}; push @{ $file_data{$file} }, \@fields; } my $width = max map length, keys %file_data; my $format = "%*s%3s %3s %3s %3s %3s %3s %3s\n"; printf $format, $width, '', @headers; for my $file (sort keys %file_data) { my $days = $file_data{$file}; my @info = ('') x 7; for my $day (@$days) { my ($index, $val) = @$day; $info[$index] = $val; } printf $format, $width, $file, @info; } </code></pre> <p><strong>output</strong></p> <pre><code> Sun Mon Tue Wed Thu Fri Sat Report-20140521.csv: 20 22 22 Report-20140530.csv: 23 23 23 Report-20140606.csv: 24 24 20 Report-20140613.csv: 25 24 21 Report-20140621.csv: 21 21 21 </code></pre>