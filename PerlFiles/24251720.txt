Perl: struct-like storage of data
<p>I have an existing perl script which I have to modify. For this, I need some struct-like container for my data. I do not have any 'outside' modules, nor do I possess the capability to obtain them, and my perl is 5.8.8. I've written a package containing one var and two arrays for my needs, however I cannot get it to work and I am not sure why. Here it is:</p> <pre><code>{ package TestData; sub new { my $class = shift; my $self = { _id =&gt; shift, _genUsers =&gt; [], _testSymbols =&gt; [], }; return bless ($self, $class); } sub setId { my ($self, $id) = @_; $self-&gt;{_id} = $id if defined($id); } sub addGenUser { my ($self, $user) = @_; push @{$self-&gt;{_genUsers}}, $user; } sub addTestSymbol { my ($self, $sym) = @_; push @{$self-&gt;{_testSymbols}}, $sym; } sub getId { my $self = @_; return $self-&gt;{_id}; } sub getGenUserList { my $self = @_; return @{$self-&gt;{_genUsers}}; } sub getTestSymbolList { my $self = @_; return @{$self-&gt;{_testSymbols}}; } } use strict; use POSIX; my $id = "test"; my @a; push @a, "this"; my @b; push @b, "that"; my $obj = new TestData($id, @a, @b); print "DEBUG: " . $obj-&gt;getId() . "\n"; </code></pre> <p>Last line always throws "use of uninitialized value". What's going on?</p> <p>Also would it be possible to do something like this:</p> <pre><code>my @c; push @c, $obj; foreach(@c){ print "DEBUG2: " . $_-&gt;getId() . "\n"; } </code></pre> <p>Thank you.</p> <p>EDIT: Thank you everyone for your replies. This is what the fully working end result looked like:</p> <pre><code>{ use strict; use POSIX; package TestData; sub new { my $class = shift; my $self = { _alpha =&gt; shift, _beta =&gt; shift, _gamma =&gt; shift, _delta =&gt; shift, _theta =&gt; shift }; return bless ($self, $class); } sub getAlpha { my $self = shift; return $self-&gt;{_alpha}; } sub getBeta { my $self = shift; return $self-&gt;{_beta}; } sub getGamma { my $self = shift; return $self-&gt;{_gamma}; } sub getDelta { my $self = shift; return $self-&gt;{_delta}; } sub getTheta { my $self = shift; return $self-&gt;{_theta}; } } </code></pre>
<p>Rather than roll your own, you might want to check out <code>Class::Struct</code>, which has been part of Perl's core since 5.4.</p>
<p>The bug is in the line(s) that read:</p> <pre><code>my $self = @_; </code></pre> <p>This is a scalar assignment, and so assigns the <em>length</em> on <code>@_</code> to <code>$self</code>. Trying to use the length as a hash reference then gives the "use of uninitialized value" warning you see, and returns <code>undef</code>.</p> <p>By the way, in addition to enabling warnings, you should get into the habit of starting all your scripts and modules with <code>use strict;</code>. If you'd done that, it would've caught this bug, and you would've received a runtime error saying something like:</p> <pre class="lang-none prettyprint-override"><code>Can't use string ("1") as a HASH ref while "strict refs" in use at foo.pl line 36. </code></pre> <p>Anyway, to fix your code, you should replace the line above with either:</p> <pre><code>my ($self) = @_; </code></pre> <p>or:</p> <pre><code>my $self = shift; </code></pre> <p>or even:</p> <pre><code>my $self = $_[0]; </code></pre> <p>With <code>my ($self) = @_</code> the parentheses turn it into a list assignment; with <code>my $self = shift</code> it's still a scalar assignment, but <a href="http://perldoc.perl.org/functions/shift.html" rel="nofollow"><code>shift</code></a> (which, inside a <code>sub</code>, is shorthand for <code>shift @_</code>) pulls the first scalar out of <code>@_</code>.</p> <p>The choice of which style to prefer basically comes down to personal taste and consistency; if you're used to pulling all your method args out of <code>@_</code> with a single assignment like:</p> <pre><code>my ($self, $foo, $bar, $baz) = @_; </code></pre> <p>then, for methods that take no arguments other than <code>$self</code>, a single-element list assignment seems more consistent. On the other hand, if you prefer to pick your args out of <code>@_</code> one at a time, as in:</p> <pre><code>my $self = shift; my $foo = shift; my $bar = shift; my $baz = shift; </code></pre> <p>the you obviously should follow that pattern for single-arg methods too.</p>
<p>Change</p> <blockquote> <p>my $self = @_;</p> </blockquote> <p>to </p> <blockquote> <p>my $self = shift;</p> </blockquote> <p>in your methods that only expect one argument and especifically the called one (i.e.):</p> <pre><code> sub getId { my $self = shift; return $self-&gt;{_id}; } </code></pre> <p>You can also wrap the $self around parentheses to change context and do the same thing as commented</p> <p>Output:</p> <pre><code>DEBUG: test </code></pre>