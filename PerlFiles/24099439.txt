IO::Socket::INET &quot;send: Cannot determine peer address&quot;
<p>I have this Perl code snippet:</p> <pre><code>my $serverSocket = new IO::Socket::INET( LocalPort =&gt; 53, Proto =&gt; 'udp', ReuseAddr =&gt; 1, ) or Error("Could't open server socket."); print "Server started.\n"; my $clientQuery; while (1) { $serverSocket-&gt;recv($clientQuery, 1024, 0); my $clientQueryParsed = IncomingDNSPacket::parseDNSPacket($clientQuery); my @questions = @{ $clientQueryParsed-&gt;{questions} }; my @answers = map {getAnswer($_, $forwarder)} @questions; my $errorCode = @answers == 0 ? 3 : ''; my $clientResponseParsed = { errorCode =&gt; $errorCode, id =&gt; $clientQueryParsed-&gt;{id}, questions =&gt; \@questions, answerRRs =&gt; \@answers, additionalRRs =&gt; [], authorityRRs =&gt; [], }; my $clientResponse = OutgoingDNSPacket::makeAnswer(%$clientResponseParsed); $serverSocket-&gt;send($clientResponse, 0); } </code></pre> <p>Sometimes <code>$serverSocket-&gt;send($clientResponse, 0);</code> returns this error: <code>send: Cannot determine peer address</code>. I tried to google it and found that this situation can be if socket was closed by remote host. But this is not TCP, this is UDP. Why do I get this error?</p> <p><strong>EDIT:</strong> Here's code of <code>getAnswer</code>:</p> <pre><code>sub getAnswer { my $question = shift; my $forwarder = shift; my @answer; @answer = $cache -&gt; get($question); if (@answer == 0) { my $forwarderPacket = getAnswerFromForwarder($question); $cache -&gt; add ($forwarderPacket); @answer = $cache -&gt; get($question); } return @answer; } sub getAnswerFromForwarder { my $question = shift; my $forwQuery = OutgoingDNSPacket::makeQuestion(id =&gt; 0, questions =&gt; [$question]); my $forwSock = new IO::Socket::INET ( PeerAddr =&gt; $forwarder, PeerPort =&gt; 53, Proto =&gt; 'udp' ) or Error("Couldn't create forwarder socket"); $forwSock -&gt; send($forwQuery, 0); my $select = new IO::Select; $select -&gt; add ($forwSock); my @socks = $select -&gt; can_read(2); if (@socks &gt; 0) { my $forwAnswer; $forwSock -&gt; recv($forwAnswer, 1024, 0); my $forwUnpacked = IncomingDNSPacket::parseDNSPacket($forwAnswer); return $forwUnpacked; } else { return { errorCode =&gt; 3, questions =&gt; [], answerRRs =&gt; [], authorityRRs =&gt; [], additionalRRs =&gt; [] }; } } </code></pre> <p><code>$forwSock</code>'s <code>send</code> can be unsuccessful. And if it is unsuccessful, I can't send anything from <code>$serverSocket</code>. Why?</p>
<p><strong>Short Answer</strong></p> <p>Your problem is that you are not handling <code>$udpSocket-&gt;recv(...)</code> errors, and this is confounding your later <code>send</code>.</p> <p>Most likely the <code>recv</code> fails with ECONNREFUSED. You want to ignore this error and try again, and do the same for the <code>send</code> call, too.</p> <p><strong>Longer Answer</strong></p> <p>To clarify, your call to <code>send</code> does not <em>return</em> the error "Cannot determine peer address" â€” it <a href="http://perldoc.perl.org/Carp.html" rel="nofollow"><code>croak</code></a>s with that message.</p> <p>IO::Socket remembers the remote peer address after a successful call to <code>$io_socket-&gt;recv()</code>. This peer is the implicit destination for the next call to <code>$io_socket-&gt;send()</code>. An <em>unsuccessful</em> <code>recv</code>, however, leaves no peer address available, and the following <code>send</code> simply <code>croak</code>s for want of a destination.</p> <p>(Your code doesn't choke because the <code>recv</code> buffer, <code>$clientQuery</code>, is unmodified after a failed <code>recv</code>. You are processing the previously <code>recv</code>d packet again.)</p> <p>Now, <em>because this is UDP</em>, the underlying error probably pertains to a previous failed <code>send</code>. Most likely you sent a datagram, an ICMP "dest unreach" came back sometime later, and the subsequent <code>send</code>/<code>recv</code> call on the socket reports this as ECONNREFUSED.</p> <p><strong>Pseudocoded Answer</strong></p> <pre><code>use Errno; # for %! #use caution; this is untested and not thoroughly thought through while (1) { my $ok = $udpSocket-&gt;recv($buf, $len, 0); if (! $ok) { redo if $!{ECONNREFUSED}; # Error from a previous UDP send die "recv: $!\n"; } ... do { $ok = $udpSocket-&gt;send($buf, 0); } while (! $ok and $!{ECONNREFUSED}); } </code></pre>