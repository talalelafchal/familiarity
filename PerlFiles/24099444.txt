Case statement in perl: not able to enter proper case
<pre><code>#!/usr/bin/perl -w use warnings; use diagnostics; use Switch; open FH, "&lt;$ARGV[0]" or die "$!"; sub commandType{ print "comm entered for $_"; switch($_){ case("add") {print "this is add\n"} case("sub") {print "this is sub\n"} case("neg") {print "this is neg\n"} case("eq") {print "this is eq\n"} case("gt") {print "this is gt\n"} case("lt") {print "this is lt\n"} case("and") {print "this is and\n"} case("or") {print "this is or\n"} case("not") {print "this is not\n"} } } while(&lt;FH&gt;){ next if /^\s*\/\//; next if /^\s*$/; my $line = "$_"; $line =~ s/\s+$//; print "$line\n"; commandType($line); } </code></pre> <p>Here is my code which takes the input from the following file supplied to it through the command line:</p> <pre><code>// Pushes and adds two constants. push constant 7 push constant 8 add </code></pre> <p>For each line of the file above the perl code will run the subroutine <code>commandType</code> to check if it is among the given cases inside the subroutine and prints if it is. But even though the add command is present in the file above the code still does not print it. I am getting the following output:</p> <pre><code>push constant 7 comm entered for push constant 7 push constant 8 comm entered for push constant 8 add comm entered for add` </code></pre> <p>Why is case "add" not printing anything? </p>
<h3>EXPLANATION</h3> <p>The problem is that <code>$_</code> doesn't automatically refer to the first argument passed to a <code>sub</code>, currently you are reading the same <code>$_</code> as the one in your <em>while-loop</em>.</p> <p>The value of <code>$_</code> when inside <em>commandType</em> is the line read, still having the potential new-line attached to it, and since <code>"add\n"</code> isn't equal to <code>"add"</code>, your <em>case</em> isn't entered.</p> <hr> <h3>SOLUTION</h3> <p>It would be preferred to change the contents of <code>sub commandType</code> to the below:</p> <pre><code>sub commandType{ my $cmd = shift; # retrieve first argument print "comm entered for $cmd"; switch($cmd) { ... } } </code></pre>
<p>It isn't safe to use <code>$_</code> as you would a normal variable. It has global scope and many built-in Perl operators act on it, so it is likely to be modified without any obvious reason.</p> <p>In any case, the parameters passed to a subroutine are presented in <code>@_</code>, not in <code>$_</code> and it is random chance that it seems to contain the right value in this case.</p> <p>Rewrite your <code>commandType</code> subroutine like this and it should start behaving more sensibly</p> <pre><code>sub commandType { my ($cmd) = @_; print "comm entered for $cmd"; switch ($cmd) { case 'add' { print "this is add\n" } case 'sub' { print "this is sub\n" } case 'neg' { print "this is neg\n" } case 'eq' { print "this is eq\n" } case 'gt' { print "this is gt\n" } case 'lt' { print "this is lt\n" } case 'and' { print "this is and\n" } case 'or' { print "this is or\n" } case 'not' { print "this is not\n" } } } </code></pre> <p>You must also <em>always</em> add <code>use strict</code> at the top of <em>every</em> program, especially if you are asking for help with it. It will quickly report trivial errors that you may otherwise spend valuable time tracking down.</p> <p>The <code>Switch</code> module is also unsafe, and the built-in language construct <code>given</code>/<code>when</code> that has been available since version 10 has been marked as experimental because of a number of arcane shortcomings. You are much better off using a list of <code>if</code> statements as described in the <a href="http://perldoc.perl.org/perlsyn.html#Basic-BLOCKs" rel="nofollow">"Basic BLOCKs" section of perlsyn</a>.</p>
<p>Starting from Perl 5.10.1 (well, 5.10.0, but it didn't work right), you can say <code>use feature "switch";</code> to enable an experimental switch feature. Under the "switch" feature, Perl gains the <strong>experimental</strong> keywords <code>given</code> , <code>when</code> , <code>default</code> , <code>continue</code>, and <code>break</code>. </p> <pre><code> #!/usr/bin/perl use strict; use warnings; use feature "switch"; while(my $line=&lt;DATA&gt;){ given ($line) { when (/push/) { print 'found push' } when (/add/) { print 'found add' } } } __DATA__ push constant 7 push constant 8 add </code></pre> <p><a href="http://ideone.com/8ndRGK" rel="nofollow"><strong>Demo</strong></a></p> <p>Also see: <a href="http://stackoverflow.com/questions/16927024/perl-5-20-and-the-fate-of-smart-matching-and-given-when">Perl 5.20 and the fate of smart matching and given-when?</a></p>