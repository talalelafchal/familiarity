How to refer to matched part in regex
<p>I am using the following code to search for a substring and print it out with a few characters before and after it. Somehow Perl takes issue with me using <code>$1</code> and complains about </p> <blockquote> <p>Use of uninitialized value <code>$1</code> in concatenation (.) or string.</p> </blockquote> <p>I cannot figure out why...can you?</p> <pre><code>use List::Util qw[min max]; my $word = "test"; my $lines = "this is just a test to find something out"; my $context = 3; while ($lines =~ m/\b$word\b/g ) { # as long as pattern is found... print "$word\ "; print "$1"; print substr ($lines, max(pos($lines)-length($1)-$context, 0), length($1)+$context); # check: am I possibly violating any boundaries here } </code></pre>
<p>When you use <code>$1</code>, you are asking the code to use the first captured group from the regex and since your regex doesn't have any, well, that variable won't exist.</p> <p>You can either refer to the whole match with <code>$&amp;</code> or you add a capture group to your regex and keep using <code>$1</code>.</p> <p>i.e. Either:</p> <pre><code>use List::Util qw[min max]; my $word = "test"; my $lines = "this is just a test to find something out"; my $context = 3; while ($lines =~ m/\b$word\b/g ) { # as long as pattern is found... print "$word\ "; print "$&amp;"; print substr ($lines, max(pos($lines)-length($&amp;)-$context, 0), length($&amp;)+$context); # check: am I possibly violating any boundaries here } </code></pre> <p>Or</p> <pre><code>use List::Util qw[min max]; my $word = "test"; my $lines = "this is just a test to find something out"; my $context = 3; while ($lines =~ m/(\b$word\b)/g ) { # as long as pattern is found... print "$word\ "; print "$1"; print substr ($lines, max(pos($lines)-length($1)-$context, 0), length($1)+$context); # check: am I possibly violating any boundaries here } </code></pre> <p>Note: It doesn't matter whether you use <code>(\b$word\b)</code> or <code>(\b$word)\b</code> or <code>\b($word\b)</code> or <code>\b($word)\b</code> here because <code>\b</code> is a 'string' of 0 length.</p>
<p>When you want to address a matched part in regex, put it in parenthes. Than you'll be able to address this mathced part via <code>$1</code> variable (for first pair of parenthes), <code>$2</code> (for the second pair) and so on.</p>
<p>The values <code>$1</code>, <code>$2</code> and so on hold the strings found by capture groups. When a match is performed all of these variables are set to undef. The code in the question does not have any capture groups and hence <code>$1</code> is never given a value, it is undefined.</p> <p>Running the code below shows the effect. Initially <code>$1</code>, <code>$2</code> and <code>$3</code> are not defined. The first match sets <code>$1</code> and <code>$2</code> but not <code>$3</code>. The second match sets only <code>$1</code> but not that <code>$2</code> is cleared to be undefined. The third match has no capture groups and all three are undefined.</p> <pre><code>use strict; use warnings; sub show { printf "\$1: %s\n", (defined $1 ? $1 : "-undef-"); printf "\$2: %s\n", (defined $2 ? $2 : "-undef-"); printf "\$3: %s\n", (defined $3 ? $3 : "-undef-"); print "\n"; } my $text = "abcdefghij"; show(); $text =~ m/ab(cd)ef(gh)ij/; # First match show(); $text =~ m/ab(cd)efghij/; # Second match show(); $text =~ m/abcdefghij/; # Third match show(); </code></pre>
<p><code>$1</code> will have no value unless you are actually capturing something.</p> <p>You can adjust your boundary collection method to using lookahead and lookbehinds. </p> <pre><code>use strict; use warnings; my $lines = "this is just a test to find something out"; my $word = "test"; my $extra = 10; while ($lines =~ m/(?:(?&lt;=(.{$extra}))|(.{0,$extra}))\b(\Q$word\E)\b(?=(.{0,$extra}))/gs ) { my $pre = $1 // $2; my $word = $3; my $post = $4; print "'...$pre&lt;$word&gt;$post...'\n"; } </code></pre> <p>Outputs:</p> <pre><code>'...is just a &lt;test&gt; to find s...' </code></pre>
<p>You have to capture <code>$word</code> into regex group <code>$1</code> by using parentheses,</p> <pre><code>while ($lines =~ m/\b($word)\b/g) </code></pre>