Run Function On N Elements of Array at a Time
<p>Let's say I have an array <code>my @arr</code> which is of hypothetical length 240 (but this length is variable). How could I go about running a function on each N elements of that array at a time?</p> <p>For example, if <code>N = 100</code>, the function would first run on <code>@arr[0..99]</code>, then <code>@arr[100..199]</code>, and finally <code>@arr[200..239]</code>.</p> <p>My idea was to have some sort of loop which creates a temporary array of length N by joining N elements together, but these seems overly complicated.</p>
<pre><code>while (@arr) { f(splice(@arr, 0, 100)); } </code></pre> <p>Non-destructive version:</p> <pre><code>use List::Util qw( min ); for (my $i=0; $i&lt;@a; $i+=100) { f(@arr[$i .. min($i+99, $#arr)]); } </code></pre> <p>You could also avoid destroying the original array cheaply by creating an array of aliases:</p> <pre><code>my $shadow = sub { \@_ }-&gt;(@arr); while (@$shadow) { f(splice(@$shadow, 0, 100)); } </code></pre>
<p>You can use <a href="http://perldoc.perl.org/functions/splice.html" rel="nofollow"><code>splice</code></a>:</p> <pre><code>sub apply_f_to_n_elements { my ($f, $n, @elements) = @_; my @results; while ( @elements ) { my @batch = splice(@elements, 0, $n) push @results, $f-&gt;(@batch); } return @results; } </code></pre> <p>Usage:</p> <pre><code>apply_f_to_n_elements(\&amp;f, 100, @arr); </code></pre> <p>or</p> <pre><code>my @results = apply_f_to_n_elements(\&amp;f, 100, @arr); </code></pre> <hr> <p>The following is optimized to avoid making two copies of every input (while still remaining non-destructive), and optimized to avoid collecting the results of the callback if they're going to be discarded anyway:</p> <pre><code>sub apply_f_to_n_elements { my $f = shift; my $n = shift; if (wantarray) { my @results; while (@_) { push @results, $f-&gt;(splice(@_, 0, $n)); } return @results; } else { while (@_) { $f-&gt;(splice(@_, 0, $n)); } } } </code></pre>
<p>Using <a href="http://perldoc.perl.org/List/Util.html" rel="nofollow"><code>List::Util qw(min)</code></a> works well.</p> <p>However, if you want a more semantic solution, you can use <a href="https://metacpan.org/pod/List%3a%3aMoreUtils" rel="nofollow"><code>List::MoreUtils qw(natatime)</code></a>.</p> <pre><code>use List::MoreUtils qw(natatime); my $iter = natatime 100, @arr; while (my @vals = $iter-&gt;()) { f(@vals); } </code></pre>