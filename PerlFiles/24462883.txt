Match the nth longest possible string in Perl
<p>The pattern matching quantifiers of a Perl regular expression are "greedy" (they match the longest possible string). To force the match to be "ungreedy", a ? can be appended to the pattern quantifier (*, +).</p> <p>Here is an example:</p> <pre><code>#!/usr/bin/perl $string="111s11111s"; #-- greedy match $string =~ /^(.*)s/; print "$1\n"; # prints 111s11111 #-- ungreedy match $string =~ /^(.*?)s/; print "$1\n"; # prints 111 </code></pre> <p>But how one can find the second, third and .. possible string match in Perl? Make a simple example of yours --if need a better one.</p>
<p>Utilize a <a href="http://perldoc.perl.org/perlretut.html#Conditional-expressions" rel="nofollow">conditional expression</a>, a <a href="http://perldoc.perl.org/perlretut.html#A-bit-of-magic%3a-executing-Perl-code-in-a-regular-expression" rel="nofollow">code expression</a>, and <a href="http://perldoc.perl.org/perlretut.html#Backtracking-control-verbs" rel="nofollow">backtracking control verbs</a>.</p> <pre><code>my $skips = 1; $string =~ /^(.*)s(?(?{$skips-- &gt; 0})(*FAIL))/; </code></pre> <p>The above will use greedy matching, but will cause the largest match to intentionally fail. If you wanted the 3rd largest, you could just set the number of skips to 2. </p> <p>Demonstrated below:</p> <pre><code>#!/usr/bin/perl use strict; use warnings; my $string = "111s11111s11111s"; $string =~ /^(.*)s/; print "Greedy match - $1\n"; $string =~ /^(.*?)s/; print "Ungreedy match - $1\n"; my $skips = 1; $string =~ /^(.*)s(?(?{$skips-- &gt; 0})(*FAIL))/; print "2nd Greedy match - $1\n"; </code></pre> <p>Outputs:</p> <pre class="lang-none prettyprint-override"><code>Greedy match - 111s11111s11111 Ungreedy match - 111 2nd Greedy match - 111s11111 </code></pre> <p>When using such advanced features, it is important to have a full understanding of regular expressions to predict the results. This particular case works because the regex is fixed on one end with <code>^</code>. That means that we know that each subsequent match is also one shorter than the previous. However, if both ends could shift, we could not necessarily predict order.</p> <p>If that were the case, then you find them all, and then you sort them:</p> <pre><code>use strict; use warnings; my $string = "111s11111s"; my @seqs; $string =~ /^(.*)s(?{push @seqs, $1})(*FAIL)/; my @sorted = sort {length $b &lt;=&gt; length $a} @seqs; use Data::Dump; dd @sorted; </code></pre> <p>Outputs:</p> <pre class="lang-none prettyprint-override"><code>("111s11111s11111", "111s11111", 111) </code></pre> <h3>Note for Perl versions prior to <code>v5.18</code></h3> <p>Perl <code>v5.18</code> introduced a change, <a href="http://search.cpan.org/dist/perl-5.18.0/pod/perldelta.pod#/%28?%7B%7D%29/_and_/%28??%7B%7D%29/_have_been_heavily_reworked" rel="nofollow"><code>/(?{})/</code> and <code>/(??{})</code>/ have been heavily reworked</a>, that enabled the scope of lexical variables to work properly in code expressions as utilized above. Before then, the above code would result in the following errors, as demonstrated in <a href="http://ideone.com/8mIHAQ" rel="nofollow">this subroutine version run under v5.16.2</a>:</p> <pre class="lang-none prettyprint-override"><code>Variable "$skips" will not stay shared at (re_eval 1) line 1. Variable "@seqs" will not stay shared at (re_eval 2) line 1. </code></pre> <p>The fix for older implementations of RE code expressions is to declare the variables with <a href="http://perldoc.perl.org/functions/our.html" rel="nofollow"><code>our</code></a>, and for further good coding practices, to <a href="http://perldoc.perl.org/functions/local.html" rel="nofollow"><code>localize</code></a> them when initialized. This is demonstrated in this <a href="http://ideone.com/7pZDDi" rel="nofollow">modified subroutine version run under v5.16.2</a>, or as put below:</p> <pre><code>local our @seqs; $string =~ /^(.*)s(?{push @seqs, $1})(*FAIL)/; </code></pre>
<p>Start by getting all possible matches.</p> <pre><code>my $string = "111s1111s11111s"; local our @matches; $string =~ /^(.*)s(?{ push @matches, $1 })(?!)/; </code></pre> <p>This finds</p> <pre><code>111s1111s11111 111s1111 111 </code></pre> <p>Then, it's just a matter of finding out which one is the second longuest and filtering out the others.</p> <pre><code>use List::MoreUtils qw( uniq ); my $target_length = ( sort { $b &lt;=&gt; $a } uniq map length, @matches )[1]; @matches = uniq grep { length($_) == $target_length } @matches if $target_length; </code></pre>