Why does Perl access to cross-platform packed structs not work with SWIG?
<p>Working from:</p> <ul> <li><a href="http://stackoverflow.com/questions/17889678">Is ignoring __attribute__((packed)) always safe in SWIG interfaces?</a> </li> <li><a href="http://stackoverflow.com/questions/1537964">Visual C++ equivalent of GCC&#39;s __attribute__ ((__packed__))</a></li> </ul> <p>My <code>.i</code> does:</p> <pre><code>#define __attribute__(x) </code></pre> <p>then uses %include to include my cross-platform definition of PACK():</p> <pre><code>#if defined(SWIG) #define PACK(...) VA_ARGS #elif defined(_MSC_VER) #define PACK(__Decl__) __pragma(pack(push, 1)) __Decl__ __pragma(pack(pop)) #else // GCC #define PACK(__Decl__) __Decl__ __attribute__ ((packed)) #endif </code></pre> <p>Then I have code like:</p> <pre><code>PACK( typedef struct { uint8_t something; uint32_t more; } ) aName; </code></pre> <p>With earlier versions of the <code>PACK()</code> macro, I got syntax error from SWIG on the <code>typedef</code> line. Now I get past that but when compiling the SWIG-generated <code>.c</code> file, I have get and set functions that complain <code>aName</code> doesn't exist. The messages are like (edited):</p> <pre><code>libudr_perl_swig.c: In function '_wrap_aName_set': libudr_perl_swig.c:2367:20: error: expected identifier or '(' before '=' token libudr_perl_swig.c: In function '_wrap_aName_get': libudr_perl_swig.c:2377:3: error: expected expression before 'aName' </code></pre> <p>SWIG sort of seems to know about my struct -- it creates access functions -- but the doesn't expose them enough that the access functions can find it.</p> <p>Before I started to make this cross-platform -- when it was still Linux-only with <code>__attribute__ ((packed))</code> -- it worked in SWIG. And it still works in Linux. So there appears to be something about SWIG's interpretation of <code>PACK()</code> that is flawed. </p> <p>The old way generated a lot of per-field code like:</p> <pre><code>XS(_wrap_aName_something_set) { { aName *arg1 = (aName *) 0 ; ... </code></pre> <p>the new way generates a little per-struct code like:</p> <pre><code>SWIGCLASS_STATIC int _wrap_aName_set(pTHX_ SV* sv, MAGIC * SWIGUNUSEDPARM(mg)) { MAGIC_PPERL { </code></pre> <p>Why should my <code>PACK()</code> (which should be a no-op in SWIG) do that?</p>
<p>Googling "cpp standard variadic macros" leads to <a href="http://en.wikipedia.org/wiki/Variadic_macro" rel="nofollow">http://en.wikipedia.org/wiki/Variadic_macro</a> which notes the expansion of <code>...</code> is <code>__VA_ARGS__</code>, not <code>VA_ARGS</code> (as I had found somewhere). When I change my macro definition to be:</p> <pre><code>#if defined(SWIG) #define PACK(...) __VA_ARGS__ #elif defined(_MSC_VER) #define PACK(__Decl__) __pragma(pack(push, 1)) __Decl__ __pragma(pack(pop)) #else // GCC #define PACK(__Decl__) __Decl__ __attribute__ ((packed)) #endif </code></pre> <p>it works.</p>