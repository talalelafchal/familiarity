Initialize a set of hash keys using slicing in Perl
<p>I am trying to initialize a hash using slicing:</p> <pre><code>use warnings; use strict; use Data::Dump qw(dump); my %h; my $a=['a','b']; @h{@$a}=(1)x@$a; dump(%h); </code></pre> <p>This works fine, but if I try to do a sub hash, for example <code>%h{test}</code></p> <pre><code>@h{test}{@$a}=(1)x@$a; </code></pre> <p>I get error:</p> <pre><code>Scalar value @h{test} better written as $h{test} at ./p.pl line 14. syntax error at ./p.pl line 14, near "}{" Execution of ./p.pl aborted due to compilation errors. </code></pre>
<p>You should use <code>@{ $h{test} }{ @$a }=(1)x@$a;</code> since hash contains hash reference, not hash.</p> <pre><code>use warnings; use strict; use Data::Dumper; my %h; my $a=['a','b']; @{ $h{test} }{ @$a }=(1)x@$a; print Dumper(\%h); </code></pre> <p>Output is:</p> <pre><code>$VAR1 = { 'test' =&gt; { 'a' =&gt; 1, 'b' =&gt; 1 } }; </code></pre> <p>See also: <a href="http://stackoverflow.com/questions/8131541/perl-hash-ref-accessing-array-of-keys">Perl: Hash ref accessing array of keys</a></p>
<p>The compiler sees the '@' and thinks to itself 'array', then sees the '{' and says 'wait, what? that's a hash index indicator. Game over man.' So turn the @ into a $.</p>