Perl $1 giving uninitialized value error
<p>I am trying to extract a part of a string and put it into a new variable. The string I am looking at is:</p> <pre><code>maker-scaffold_26653|ref0016423-snap-gene-0.1 </code></pre> <p>(inside a <code>$gene_name</code> variable)</p> <p>and the thing I want to match is:</p> <pre><code>scaffold_26653|ref0016423 </code></pre> <p>I'm using the following piece of code:</p> <pre><code>my $gene_name; my $scaffold_name; if ($gene_name =~ m/scaffold_[0-9]+\|ref[0-9]+/) { $scaffold_name = $1; print "$scaffold_name\n"; } </code></pre> <p>I'm getting the following error when trying to execute:</p> <pre><code>Use of uninitialized value $scaffold_name in concatenation (.) or string </code></pre> <p>I know that the pattern is right, because if I use <code>$'</code> instead of <code>$1</code> I get </p> <pre><code>-snap-gene-0.1 </code></pre> <p>I'm at a bit of a loss: why will <code>$1</code> not work here? </p>
<p>If you want to use a value from the matching you have to make <code>()</code> arround the character in regex</p>
<p>To expand on Jens' answer, () in a regex signifies an anonymous capture group. The content matched in a capture group is stored in $1-9+ from left to right, so for example,</p> <pre><code>/(..):(..):(..)/ </code></pre> <p>on an HH:MM:SS time string will store hours, minutes, and seconds in $1, $2, $3 respectively. Naturally this begins to become unwieldy and is not self-documenting, so you can assign the results to a list instead:</p> <pre><code>my ($hours, $mins, $secs) = $time =~ m/(..):(..):(..)/; </code></pre> <p>So your example could bypass the use of $ variables by doing direct assignment:</p> <pre><code>my ($scaffold_name) = $gene_name =~ m/(scaffold_[0-9]+[|]ref[0-9]+)/; # $scaffold_name now contains 'scaffold_26653|ref0016423' </code></pre> <p>You can even get rid of the ugly =~ binding by using for as a topicalizer:</p> <pre><code>my $scaffold_name; for ($gene_name) { ($scaffold_name) = m/(scaffold_\d+[|]ref\d+)/; print $scaffold_name; } </code></pre> <p>If things start to get more complex, I prefer to use named capture groups (introduced in Perl v5.10.0):</p> <pre><code>$gene_name =~ m{ (?&lt;scaffold_name&gt; # ?&lt;name&gt; creates a named capture group scaffold_\d+? # 'scaffold' and its trailing digits [|] # Literal pipe symbol ref\d+ # 'ref' and its trailing digits ) }xms; # The x flag lets us write more readable regexes print $+{scaffold_name}, "\n"; </code></pre> <p>The results of named capture groups are stored in the magic hash %+. Access is done just like any other hash lookup, with the capture groups as the keys. %+ is locally scoped in the same way the $ are, so it can be used as a drop-in replacement for them in most situations.</p> <p>It's overkill for this particular example, but as regexes start to get larger and more complicated, this saves you the trouble of either having to scroll all the way back up and count anonymous capture groups from left to right to find which of those darn $ variables is holding the capture you wanted, or scan across a long list assignment to find where to add a new variable to hold a capture that got inserted in the middle. </p> <p>My personal rule of thumb is to assign the results of anonymous captured to descriptively named lexically scoped variables for 3 or less captures, then switch to using named captures, comments, and indentation in regexes when more are necessary.</p>