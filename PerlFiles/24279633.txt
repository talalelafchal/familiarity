Regex for openfootball
<p>Exists string</p> <pre><code>(1) Thu Jun/12 17:00 Brazil 3-1 (1-1) Croatia @ Arena de São Paulo, São Paulo (UTC-3) </code></pre> <p>I use regex:</p> <pre><code>/^\((\d+)\)\s(.*?)\s{2,}(.+?)\ (\d+)-(\d+)\ \(.*?\)\ (.+?)\s{2,}.*UTC-(\d+)/ </code></pre> <p>How to modify regex, that passing also matches without first time result:</p> <pre><code>(1) Thu Jun/12 17:00 Brazil 3-1 Croatia @ Arena de São Paulo, São Paulo (UTC-3) </code></pre> <p>?</p> <p>Upd:</p> <pre><code>$1=1 $2=Thu Jun/12 17:00 $3=Brazil $4=3 $5=1 $6=Croatia $7=3 </code></pre>
<p>Just make the first time result optional:</p> <pre><code>/^\((\d+)\)\s(.*?)\s{2,}(.+?) (\d+)-(\d+) (?:\(.*?\) )?(.+?)\s{2,}.*UTC-(\d+)/ # ^^^________^^ </code></pre>
<p>A set of progressive matches would probably turn out more legible / maintainable, but at least by adding the /x modifier we can allow for insignificant whitespace, which permits formatting of the regex to make it easier to read and understand.</p> <p>Here's one way to do it:</p> <pre><code>my @targets = ( q{(1) Thu Jun/12 17:00 Brazil 3-1 (1-1) Croatia @ Arena de São Paulo, São Paulo (UTC-3)}, q{(1) Thu Jun/12 17:00 Brazil 3-1 Croatia @ Arena de São Paulo, São Paulo (UTC-3)} ); foreach my $target ( @targets ) { print "($1)($2)($3)($4)($5)($6)($7)\n" if $target =~ m/ ^\(([^)]+)\)\s+ # 1 (\w{3}\s\w{3}\/\d{1,2}\s\d{2}:\d{2})\s+ # Date and Time (\D+?)\s+ # Team A (\d+)-(\d+)\s+ # Score A - B (?:\([^)]+\)\s+)? # Optional (.+?)\s+@ # Team B .+\(UTC-(\d+)\)$ # TZ /x; } </code></pre> <p>This produces the following output:</p> <pre><code>(1)(Thu Jun/12 17:00)(Brazil)(3)(1)(Croatia)(3) (1)(Thu Jun/12 17:00)(Brazil)(3)(1)(Croatia)(3) </code></pre>