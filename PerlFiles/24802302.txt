Perl Out of memory but there is plenty of available memory
<p>I am running a perl script that crashes with an Out of Memory error. The script is running under Ubuntu Linux on a machine with 128 Gb of memory. At the time of submission most of the memory is available, however the script dies as its used memory exceeds a value slightly above 8Gb. The machine (and the OS) are 64 bits.</p> <p>I have been searching the net for limits on memory allocation in perl, but all I found is that the only limitation is the machine memory, and in this case there is plenty of that even without considering the swap partition.</p> <p>This is the second time I encounter this problem. The first time I was using a different script and the same thing occurred. Does anyone have an explanation? The only possibility I see is that perl has some limitation on memory allocation but all the results of my searches on the net seem to contradict this possibility.</p> <p>Thanks in advance</p> <p><strong>EDIT 1</strong>: The operating system is Fedora Linux, not Ubuntu Linux. Sorry I made confusion.</p> <p><strong>EDIT 2</strong>: Here is the portion of code that leads to the error:</p> <pre><code>open( $psFullInput, "&lt;", "fullPsIn.dat" ); $counter = &lt;$psFullInput&gt;; # First element is counter of spectra while ($line = &lt;$psFullInput&gt;) { @elems = split(" ",$line); $xx = shift(@elems); $yy = shift(@elems); $freq = shift(@elems); $psStored[$xx][$yy] = []; push( @{$psStored[$xx][$yy]}, @elems ); } close( $psFullInput ); </code></pre> <p>The previous script was doing something similar, except that the array elements were not read from a file but where the result of some calculation.</p> <p><strong>EDIT 3</strong>: result of perl -V:</p> <pre><code> Summary of my perl5 (revision 5 version 16 subversion 3) configuration: Platform: osname=linux, osvers=3.10.9-200.fc19.x86_64, archname=x86_64-linux-thread-multi uname='linux buildvm-01.phx2.fedoraproject.org 3.10.9-200.fc19.x86_64 #1 smp wed aug 21 19:27:58 utc 2013 x86_64 x86_64 x86_64 gnulinux ' config_args='-des -Doptimize=-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector --param=ssp-buffer-size=4 -grecord-gcc-switches -m64 -mtune=generic -Dccdlflags=-Wl,--enable-new-dtags -Dlddlflags=-shared -O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector --param=ssp-buffer-size=4 -grecord-gcc-switches -m64 -mtune=generic -Wl,-z,relro -DDEBUGGING=-g -Dversion=5.16.3 -Dmyhostname=localhost -Dperladmin=root@localhost -Dcc=gcc -Dcf_by=Red Hat, Inc. -Dprefix=/usr -Dvendorprefix=/usr -Dsiteprefix=/usr/local -Dsitelib=/usr/local/share/perl5 -Dsitearch=/usr/local/lib64/perl5 -Dprivlib=/usr/share/perl5 -Dvendorlib=/usr/share/perl5/vendor_perl -Darchlib=/usr/lib64/perl5 -Dvendorarch=/usr/lib64/perl5/vendor_perl -Darchname=x86_64-linux-thread-multi -Dlibpth=/usr/local/lib64 /lib64 /usr/lib64 -Duseshrplib -Dusethreads -Duseithreads -Dusedtrace=/usr/bin/dtrace -Duselargefiles -Dd_semctl_semun -Di_db -Ui_ndbm -Di_gdbm -Di_shadow -Di_syslog -Dman3ext=3pm -Duseperlio -Dinstallusrbinperl=n -Ubincompat5005 -Uversiononly -Dpager=/usr/bin/less -isr -Dd_gethostent_r_proto -Ud_endhostent_r_proto -Ud_sethostent_r_proto -Ud_endprotoent_r_proto -Ud_setprotoent_r_proto -Ud_endservent_r_proto -Ud_setservent_r_proto -Dscriptdir=/usr/bin -Dusesitecustomize' hint=recommended, useposix=true, d_sigaction=define useithreads=define, usemultiplicity=define useperlio=define, d_sfio=undef, uselargefiles=define, usesocks=undef use64bitint=define, use64bitall=define, uselongdouble=undef usemymalloc=n, bincompat5005=undef Compiler: cc='gcc', ccflags ='-D_REENTRANT -D_GNU_SOURCE -fno-strict-aliasing -pipe -fstack-protector -I/usr/local/include -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64', optimize='-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector --param=ssp-buffer-size=4 -grecord-gcc-switches -m64 -mtune=generic', cppflags='-D_REENTRANT -D_GNU_SOURCE -fno-strict-aliasing -pipe -fstack-protector -I/usr/local/include' ccversion='', gccversion='4.8.2 20131017 (Red Hat 4.8.2-1)', gccosandvers='' intsize=4, longsize=8, ptrsize=8, doublesize=8, byteorder=12345678 d_longlong=define, longlongsize=8, d_longdbl=define, longdblsize=16 ivtype='long', ivsize=8, nvtype='double', nvsize=8, Off_t='off_t', lseeksize=8 alignbytes=8, prototype=define Linker and Libraries: ld='gcc', ldflags =' -fstack-protector' libpth=/usr/local/lib64 /lib64 /usr/lib64 libs=-lresolv -lnsl -lgdbm -ldb -ldl -lm -lcrypt -lutil -lpthread -lc -lgdbm_compat perllibs=-lresolv -lnsl -ldl -lm -lcrypt -lutil -lpthread -lc libc=, so=so, useshrplib=true, libperl=libperl.so gnulibc_version='2.17' Dynamic Linking: dlsrc=dl_dlopen.xs, dlext=so, d_dlsymun=undef, ccdlflags='-Wl,--enable-new-dtags -Wl,-rpath,/usr/lib64/perl5/CORE' cccdlflags='-fPIC', lddlflags='-shared -O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector --param=ssp-buffer-size=4 -grecord-gcc-switches -m64 -mtune=generic -Wl,-z,relro ' Characteristics of this binary (from libperl): Compile-time options: HAS_TIMES MULTIPLICITY PERLIO_LAYERS PERL_DONT_CREATE_GVSV PERL_IMPLICIT_CONTEXT PERL_MALLOC_WRAP PERL_PRESERVE_IVUV USE_64_BIT_ALL USE_64_BIT_INT USE_ITHREADS USE_LARGE_FILES USE_LOCALE USE_LOCALE_COLLATE USE_LOCALE_CTYPE USE_LOCALE_NUMERIC USE_PERLIO USE_PERL_ATOF USE_REENTRANT_API USE_SITECUSTOMIZE Built under linux Compiled at Nov 11 2013 12:36:47 %ENV: PERL5LIB="/home/parisia/lib/perl5/lib64/perl5" @INC: /home/parisia/lib/perl5/lib64/perl5 /usr/local/lib64/perl5 /usr/local/share/perl5 /usr/lib64/perl5/vendor_perl /usr/share/perl5/vendor_perl /usr/lib64/perl5 /usr/share/perl5 . </code></pre> <p><strong>EDIT 4</strong>: Here is a short code that reproduces the problem. As you can see, I am just filling up memory.</p> <pre><code>use strict; use warnings; my ($xx,$yy); # Coordinate variables my (@elems); # Array of elements to be stored on each matrix position # Generate an array of 3000 floating point values. # The list will be added to each array element. In the true script # of course, each element has a list of completely different values. # Here I use the same list of values for simplicity. for ($xx = 1; $xx &lt; 3000; $xx++) { push( @elems, 1+$xx/10000 ); } # Fill in each matrix element with the generated array my @psStored; for ($xx = 0; $xx &lt; 300; $xx++) { print "Row [$xx]\n"; for ($yy = 0; $yy &lt; 300; $yy++) { push( @{$psStored[$xx][$yy]}, @elems ); } } </code></pre> <p>And this is the result of "free" just before the crash (there are some parallel processes running on the machine):</p> <pre><code>[parisia@gloria01 ~]$ free total used free shared buffers cached Mem: 132015788 46395504 85620284 0 217192 16979772 -/+ buffers/cache: 29198540 102817248 Swap: 268435452 0 268435452 </code></pre> <p><strong>UPDATE 1</strong></p> <p>I investigated further. As suggested I used Devel::Size and checked the size of $psStored. The last lines of the output (printing the size at the end of each cycle in $yy) are:</p> <pre><code>Row [226] 8772773032 Row [227] 8811419600 Row [228] Out of memory! </code></pre> <p>The size of the process when the script gives the error is: VIRT: 8943960, RES: 8.406g</p> <p>However, I tried the following script that allocates a string of a given size (in gigabytes) as specified on the command line:</p> <pre><code>use strict; use warnings; my $size = $ARGV[0]; print "$size GB "; $size = int($size * 1000000000); print "($size bytes)...\n"; my $var = "x" x $size; print "Allocated\n"; </code></pre> <p>This script has no problem with large allocations. For instance, I can request 30 GB, and I have the following output from "top" before the script finishes: VIRT: 56.004g, RES: 0.054t</p> <p>Hence, there is something that is interfering with allocation when dealing with arrays, but I do not understand what is going on. I also tried with hashes, but I get the same limitation at around 8-9GB.</p>
<p>I suspect that the values of <code>$xx</code> and <code>$yy</code> are fairly large and sparse (i.e. there are big gaps between them). That would mean Perl has to create array elements for all the intervening values even though there is no data in them.</p> <p>The design of the data structure depends mainly on what you want to do with it after it is built, and how you need to access it. The most space-saving way is to use a hash, so that if you have</p> <pre><code>$xx = 1024 $yy = 2048 </code></pre> <p>then instead of storing the frequency in <code>$ps_stored[1024][2048]</code> (which creates <code>$ps_stored[0]</code> through to <code>$ps_stored[1023]</code>, and <code>$ps_stored[1024][0]</code> through to <code>$ps_stored[1024][2047]</code> and leaves them empty) you could store it in <em>hash</em> <code>$ps_stored{'1024,2048'}</code> which wastes no space at all.</p> <p>Since you don't say anything about how you will be using this data I can't tell whether it will be workable like this, but here is some code to replace yours that builds the hash that way.</p> <pre><code>use strict; use warnings; use autodie; my %ps_stored; open my $ps_full_input, '&lt;', 'fullPsIn.dat'; my $counter = &lt;$ps_full_input&gt;; # First element is counter of spectra while (&lt;$ps_full_input&gt;) { my @elems = split; my ($xx, $yy, $freq) = @elems; push @{ $ps_stored{"$xx,$yy"} }, \@elems; } close $ps_full_input; </code></pre> <p>Note the following</p> <ul> <li><p>You must <em>always</em> check that an <code>open</code> call succeeded. Ignoring a failed <code>open</code> will make your program generate nonsense for no apparent reason. You can either write an explicit</p> <pre><code>open my $ps_full_input, '&lt;', 'fullPsIn.dat' or die $!; </code></pre> <p>or you can <code>use autodie</code> at the top of your program, which is useful if there are more than a couple of <code>open</code> calls in your code</p></li> <li><p>You must <em>always</em> <code>use strict</code> and <code>use warnings</code> at the top of every Perl program, and declare all your variables as close as possible to their first point of use with <code>my</code>. Because your code is a sample it isn't clear whether you have <code>strict</code> and <code>warnings</code> in place, but there are no declarations at all so something is wrong</p></li> <li><p>People who are used to using Perl will thank you for using only lower-case letters, digits and underscores in local identifiers. Upper-case letters are reserved for package and module names like <code>Data::Dumper</code></p></li> <li><p>There is no need to preset a scalar value to a reference to an empty array before you <code>push</code> onto it. An array will be <em>autovivified</em> the first time you use <code>push</code> as long as the scalar is still <code>undef</code>. For instance</p> <pre><code>my $aref; push @{ $aref }, 1, 2, 3; </code></pre> <p>has the same effect as</p> <pre><code>my $aref; $aref = []; push @{ $aref }, 1, 2, 3; </code></pre></li> <li><p>I have pushed a <em>reference</em> to the <code>@elems</code> array onto the <code>ps_stored</code> list. I can't tell whether particular values of <code>$xx</code> and <code>$yy</code> can occur more than once, but if they do then your way will just push all the different <code>@elems</code> sets into a single list, which could be awkward to split back into individual sets. If you push a reference instead then they remain separate</p></li> </ul> <p>I hope this helps</p>
<p>OP, can you duplicate the problem with a very short test script? Maybe you can post the test script and I'll run it on my machine. Perhaps a module you didn't write is going wonky. </p> <hr> <p>Try this code with a hash. </p> <pre><code>use strict; use warnings; my ($xx,$yy); # Coordinate variables my (@elems); # Array of elements to be stored on each matrix position # Generate an array of 3000 floating point values. # The list will be added to each array element. In the true script # of course, each element has a list of completely different values. # Here I use the same list of values for simplicity. for ($xx = 1; $xx &lt; 3000; $xx++) { push( @elems, 1+$xx/10000 ); } # Fill in each matrix element with the generated array my %psStored; my $s; $s=join('=',@elems); for ($xx = 0; $xx &lt; 300; $xx++) { print "Row [$xx]\n"; for ($yy = 0; $yy &lt; 300; $yy++) { $psStored{$xx,$yy} = $s; # Here I join all elements and store them as a string. #push( @{$psStored[$xx][$yy]}, @elems ); } } </code></pre>