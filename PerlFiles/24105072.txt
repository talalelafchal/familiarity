perl eval without block
<p>I am learning perl eval. I understand how to use eval BLOCK, but I have came across the code below. What is the code below doing?</p> <pre><code>while(&lt;&gt;) { eval; warn $@ if $@; } </code></pre>
<p>Perl's <code>eval()</code> builtin can take either a BLOCK or an EXPR. If it is given an EXPR that EXPR will be evaluated as a string which contains Perl code to be executed.</p> <p>For example:</p> <pre><code>#!/usr/bin/env perl use strict; use warnings; use feature 'say'; eval { say "Hello, Block World!"; }; eval 'say "Hello, String World!";'; </code></pre> <p>This code executes both <code>say()</code>s as you would expect.</p> <pre><code>$ ./evals.pl Hello, Block World! Hello, String World! </code></pre> <p>In general the string version of <code>eval()</code> is considered dangerous, especially if you allow interpolation into that string based on variables that are coming from outside your control. For exmaple:</p> <pre><code>#!/usr/bin/env perl use strict; use warnings; use feature 'say'; my $name = $ARGV[0] // 'World'; eval "say 'Hello, $name';"; </code></pre> <p>This code is safe if called as so:</p> <pre><code>$ ./evals.pl Kaoru Hello, Alex $ ./evals.pl Hello, World </code></pre> <p>But would be very dangerous if the user called it as:</p> <pre><code>$ ./evals.pl "Kaoru'; system 'rm -rf /" </code></pre> <p>On the other hand, in string <code>eval()</code>'s favour, it can be very useful as the opposite of <code>Data::Dumper::Dumper()</code> for turning dumped Perl code back into Perl-internal data structures. For example:</p> <pre><code>#!/usr/bin/env perl use strict; use warnings; use feature 'say'; use Data::Dumper; my $hashref = { a =&gt; 1, b =&gt; 2, c =&gt; 3 }; print Dumper $hashref; my $VAR1; my $hashref_copy = eval Dumper $hashref; say $hashref_copy-&gt;{b}; </code></pre> <p>Which, as you would expect, outputs:</p> <pre><code>$ ./evals.pl $VAR1 = { 'c' =&gt; 3, 'b' =&gt; 2, 'a' =&gt; 1 }; 2 </code></pre> <p>See <code>perldoc -f eval</code> or <a href="http://perldoc.perl.org/functions/eval.html" rel="nofollow">http://perldoc.perl.org/functions/eval.html</a> for more details.</p> <p>As of Perl 5.16.3, there is also an <code>evalbytes()</code> which treats the string as a byte string rather than a character string. See <code>perldoc -f perlunicode</code> or <a href="http://perldoc.perl.org/perlunicode.html" rel="nofollow">http://perldoc.perl.org/perlunicode.html</a> for more details on the difference between character strings and byte strings.</p> <p>The code which you asked about explicitly:</p> <pre><code>while(&lt;&gt;) { eval; warn $@ if $@; } </code></pre> <p>Is reading in each line of either <code>STDIN</code> or the files specified in @ARGV, and evaluating each line of input as a line of Perl code. If that Perl code fails to compile, or throws an exception via <code>die()</code>, the error is warned to <code>STDERR</code>. <code>perldoc -f eval</code> has the full details of how and why <code>eval()</code> might set <code>$@</code>.</p> <p>As an example of the code being called:</p> <pre><code>$ echo 'print "foo\\n";' | ./evals.pl foo $ echo 'print 1 + 1, "\\n";' | ./evals.pl 2 $ echo 'dfsdfsdaf' | ./evals.pl Bareword "dfsdfsdaf" not allowed while "strict subs" in use at (eval 1) line 1, &lt;&gt; line 1. $ echo 'die "dead";' | ./evals.pl dead at (eval 1) line 1, &lt;&gt; line 1. </code></pre>
<pre><code>while(&lt;&gt;) { </code></pre> <p>This reads input, and places it in the variable <code>$_</code>. The input used by <code>&lt;&gt;</code> is first <code>@ARGV</code> (if you called your script with arguments), then STDIN (standard input).</p> <p>Information on the diamond operator <a href="https://www.cs.cf.ac.uk/Dave/PERL/node68.html" rel="nofollow">here</a>.</p> <pre><code>eval; </code></pre> <p>This evaluates the line that was read, since not specifying what to evaluate looks at <code>$_</code>.</p> <pre><code>warn $@ if $@; </code></pre> <p>This line will display the warnings that appear in <code>$@</code>, if there are any.</p>