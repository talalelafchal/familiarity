Perl how to properly handle System Commands (including Timeout with Kill &amp; capture of RC/STDERR/STDOUT)
<p>From a Perl script I want to execute various system commands and process the output in my script.</p> <p>The script will be run automatically, so I want to make sure that no commands are hanging etc.</p> <p>I'm open to any kind of feedback.</p> <p>My requirements for the command execution:</p> <ul> <li>Timeout -> If command runs longer than XX Seconds, it should kill its process(es)</li> <li>If command returns information, it should not have to wait for end of timeout</li> <li>I want to capture the exit status, STDERR, STDOUT in the script.</li> </ul> <p>Here is an example I worked out from an other stackoverflow question: <a href="http://stackoverflow.com/questions/9397937/kill-a-hung-child-process">Kill a hung child process</a></p> <p>What's not working for me at the moment:</p> <ul> <li>cannot capture exit status of executed command</li> <li>cannot capture STDERR of executed command</li> </ul> <p>Code:</p> <pre><code>my $cmd = "sleep 15"; # other tests i use -&gt; "echo bla" and "alkjdsf" my $TIMEOUT = 10; my $pid = open my $proc, '-|', "$cmd"; if (fork() == 0) { my $poor_mans_alarm = "sleep 1,kill 0,$pid ||exit for 1..$TIMEOUT;kill 9,$pid"; # run poor man's alarm in a background process exec($^X, '-e', "$poor_mans_alarm"); } my $process_output = ""; while (&lt;$proc&gt;) { $process_output .= $_; } </code></pre> <p>If you either have a trick for this code or recommend a completely different solution, let me know.</p> <p>Thanks and cheers</p> <hr> <hr> <p><strong>Addition:</strong></p> <p><strong>Got a working Example with IPC::Open3, But for future reader please Check out IPC::Run which has a Timeout Functionality included, as mentioned by James Green.</strong></p> <p>Working example with IPC::Open3:</p> <pre><code>my $pid = open3(\*WRITE, \*READ,\*ERROR,"$command"); if (fork() == 0) { my $poor_mans_alarm = "sleep 1,kill 0,$pid ||exit for 1..10;kill 9,$pid"; # run poor man's alarm in a background process exec($^X, '-e', "$poor_mans_alarm"); } # get all the STDOUT and STDERR from the Child. while (&lt;READ&gt;) { $output .= $_; } while (&lt;ERROR&gt;) { $output .= $_; } waitpid($pid, 0); if ($?) { $rc = $? &gt;&gt; 8; if ($rc != 1){ print "Some error $?\n"; } } </code></pre>
<p>It looks like <code>IPC::Run</code> provides pretty much everything you're after, including timeouts and capture of both STDOUT and STDERR. Docs are at <a href="https://metacpan.org/pod/IPC%3a%3aRun" rel="nofollow">https://metacpan.org/pod/IPC::Run</a> including some usage examples.</p>