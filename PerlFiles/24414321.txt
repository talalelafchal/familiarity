Automatically modifying text files
<p>Here is my problem: I have a directory containing a bunch of sample code from the Oracle Instant Client. Each of them demonstrates a simple database operation. My objective is to change all of their connection sequences.</p> <p>There are two ways they connect. Either they do</p> <pre><code>EXEC SQL CONNECT :username IDENTIFIED BY :password; </code></pre> <p>or they do</p> <pre><code>EXEC SQL CONNECT :uid; </code></pre> <p>In the first case, earlier in the program we define variables </p> <pre><code>char *username = "scott"; char *password = "tiger"; </code></pre> <p>Whenever I encounter a program using this sequence, I first want to change the password and then I want to add a line below the two above to get the following</p> <pre><code>char *username = "scott"; char *password = "newPassword"; char *sqlHost = "hostid"; </code></pre> <p>Then I will need to change the connection sequence above (we are in case 1) to</p> <pre><code>EXEC SQL CONNECT :username IDENTIFIED BY :password USING :sqlHost; </code></pre> <p>If we are in case two, then earlier in the program we define the variable</p> <pre><code>char *uid = "scott/tiger"; </code></pre> <p>This case is easier to handle: all I need to do is change the definition to</p> <pre><code>char *uid = "scott/newPassword/hostid"; </code></pre> <p>and I can leave the connection sequence untouched.</p> <p>I'm not asking for someone to write this whole thing for me, just to give me some pointers. I have been reading some Perl documentation to get ideas, but I am not sure how to dynamically change the file cursor so I can insert a line directly after a matched pattern. I am also not totally sure how I can have a single script differentiate between the two cases (then again, maybe I won't have to, assuming I can write my patterns to only ever match on one or the other.)</p> <p>Another way I could solve this is to change all of them to connect using the second type of sequence. In this case I suppose I could just insert a new line declaring a <code>uid</code> as I want and then modifying the connection sequence to always take the form of the second type. I would also want to remove the previous variable declarations of <code>username</code> and <code>password</code>.</p> <p>Thanks SO.</p>
<p>For files that fit into memory:</p> <ol> <li>'slurp' the file into an array</li> <li>loop through the lines of the array <ul> <li>check each line for a match to $usernameRe, saving the line number if there's a match</li> <li>check each line for a match to $prefixRe <ul> <li>if the line matches to $caseOnePrefixRe, note the line number &amp; flag it as Case 1</li> <li>else flag it as Case 2</li> <li>terminate the loop</li> </ul></li> </ul></li> <li>use the saved array indexes to update the (existing) lines as required</li> <li>loop through the array to write the lines to output <ul> <li>adding the appropriate extra line, if needed, based on the saved array index</li> </ul></li> </ol> <p>For files which won't fit into memory, you'll have to make 2 passes through each file, processing a line at a time.</p> <p>Simple regular expressions are sufficient in this case:</p> <pre><code>use strict ; use warnings ; use Test::More ; my $usernameStr = 'char *username = "scott"' ; my $usernameRe = qr/char\s\*username\s=/ ; like( $usernameStr, $usernameRe, "username RE works" ) ; my $caseOneStr = 'EXEC SQL CONNECT :username IDENTIFIED BY :password;' ; my $caseTwoStr = 'EXEC SQL CONNECT :uid;' ; my $prefixRe = qr/EXEC\sSQL\sCONNECT\s/ ; like( $caseOneStr, $prefixRe, "Prefix RE works for Case 1" ) ; like( $caseTwoStr, $prefixRe, "Prefix RE works for Case 2" ) ; my $caseOnePrefixRe = qr/EXEC\sSQL\sCONNECT\s:[[:alnum:]]+\sIDENTIFIED\sBY/ ; like ( $caseOneStr, $caseOnePrefixRe, "Case 1 prefix RE works for Case 1" ) ; unlike ( $caseTwoStr, $caseOnePrefixRe, "Case 1 prefix RE rejects Case 2" ) ; </code></pre> <p>If the files can be held in memory, then do something like this to read a file into an array of lines:</p> <pre><code>my $filename = 'foo' ; open my $fh, "&lt;", $filename ; my @lines = &lt;$fh&gt; ; close $fh ; </code></pre> <p>Use an indexed 'for' to loop through the array of lines:</p> <pre><code>for ( my $i = 0; $i &lt; scalar( @lines ); $i++ ) { # scan &amp;/or update $lines[$i] in this iteration } </code></pre> <p>For more on 'slurping' files, see <a href="http://search.cpan.org/dist/File-Slurp/extras/slurp_article.pod" rel="nofollow" title="get it from CPAN">Perl Slurp Ease</a>.</p> <p>For more on 'like()' and 'unlike()', see <a href="http://p3rl.org/Test%3a%3aMore" rel="nofollow">Test::More</a>.</p>