Perl: undef value in %hash -- why?
<p>Good afternoon. I am writing some keys and values into a %hash, but I keep getting an undef value that I can't seem to explain.</p> <pre><code>my @maxent_unchanged = &lt;FILE1&gt;; close FILE1; chomp (@maxent_unchanged); my @NM; my @max_score_unchanged; foreach my $line(@maxent_unchanged) { if ($line =~ m/[a-z]/i) { push (@NM, $line); } else { push (@max_score_unchanged, $line); } } my %max_unchanged; my $i = 0; foreach my $lines(@maxent_unchanged) { $max_unchanged{$NM[$i]} = $max_score_unchanged[$i]; ##maxent score for unchanged seq $i++; } </code></pre> <p>To put into context, @maxent_unchanged alternates between @NM and @max_score_unchanged like this:</p> <pre><code>$VAR1 = 'TTAAGGCAGCCCACCCGCAGGCT &gt; 1 110740688 110740688 C T GCCTGGGCGGGGAGGGCTGTCACAGTGCCGGCAGCAGCCCTTAAGGCAGC[C]CACCCGCAGGCTGCCGAGCGCTACCTGTATTTCCCCAACTGGGCCATGGC splicing splicing SLC6A17:NM_001010898:exon12:c.1816-10C&gt;T'; $VAR2 = '0.77'; $VAR3 = 'TTCTATCCTTTGTTTTACAGGAA &gt; 1 111857154 111857154 T C TTAAATGGAGGGAGTCCTGACTTTTGAAGTTTATCTGTTTCTATCCTTTG[T]TTTACAGGAACAGCCAGCTGAAAACTCTCCTGGCCATTGGAGGCTGGAAC splicing splicing CHIA:NM_201653:exon5:c.258-8T&gt;C'; $VAR4 = '10.99'; </code></pre> <p>Therefore it (@maxent_unchanged) has twice the number of lines of @NM and @max_score_unchanged. I have checked this and it holds true.</p> <p>If I data dump @NM and @max_score_unchanged I get the same number of variables, but when I put these into a %hash, I get an extra key-value pair as shown by data dumping the hash.</p> <pre><code>$VAR1 = ''; $VAR2 = undef; $VAR3 = 'TTTTATTAATTCCTTTGTAGAAC &gt; 6 144835040 144835040 T C TATCATCTTAAATATTTCATATGGTTATGTAAGCATTTTATTAATTCCTT[T]GTAGAACCATCAGAACCAGCTAGAAATATTTGATGGGAACGTGGCTCACA splicing splicing UTRN:NM_007124:exon35:c.4945-5T&gt;C'; $VAR4 = '8.22'; $VAR5 = 'TCTTTTTTGGACATGTACAGAGC &gt; 10 97127462 97127462 C A AGGAGTCTCTGAAGAAATTTCCGGAGTAGGGCTGATGGCTGAGCTCTGTA[C]ATGTCCAAAAAAGAAAAAAAAGAAGAAAAAAATAATGTAGATGATTTATT splicing splicing SORBS1:NM_001034957:exon13:c.1024-6G&gt;T,NM_001034955:exon21:c.1972-6G&gt;T,NM_001034956:exon18:c.1459-6G&gt;T,NM_006434:exon13:c.1024-6G&gt;T,NM_015385:exon17:c.1420-6G&gt;T,NM_001034954:exon21:c.1906-6G&gt;T,NM_024991:exon17:c.1147-6G&gt;T'; $VAR6 = '4.43'; </code></pre> <p>My keys are unique, so I know that is not the issue. Any ideas why?</p> <p>Second, as I want to remove the empty hash key and value, how can I do this?</p> <p>Many thanks for your patience and help in advance, E</p>
<p>In this loop, you are iterating over <code>@maxent_unchanged</code> but you should be iterating over <code>@max_score_unchanged</code>.</p> <pre><code>foreach my $lines(@max_score_unchanged) { $max_unchanged{$NM[$i]} = $max_score_unchanged[$i]; ##maxent score for unchanged seq $i++; } </code></pre> <hr> <p><code>@maxent_unchanged</code> is what you loaded all your data into, so it has twice as many lines as <code>@NM</code> and <code>@max_score_unchanged</code>.</p> <p>If you <code>use strict;</code> and <code>use warnings</code>, you'll see this error when you run:</p> <pre><code>Use of uninitialized value within @NM in hash element at test.pl line 25, &lt;DATA&gt; line 4. Use of uninitialized value within @NM in hash element at test.pl line 25, &lt;DATA&gt; line 4. </code></pre> <p>Which will point you to the right line. You could add <code>print "$i\n";</code> to that loop to see how many times it is going through, and compare it to the length of <code>@NM</code> and <code>@max_score_unchanged</code>.</p> <p>I recommend you use proper indention in your code to make it much more readable.</p> <hr> <h2>Example:</h2> <pre><code>use strict; use warnings; use Data::Dumper; my @maxent_unchanged = &lt;DATA&gt;; chomp (@maxent_unchanged); my @NM; my @max_score_unchanged; foreach my $line(@maxent_unchanged) { if ($line =~ m/[a-z]/i) { push (@NM, $line); } else { push (@max_score_unchanged, $line); } } my %max_unchanged; for (my $i = 0; $i &lt; @max_score_unchanged; $i++ ) { $max_unchanged{$NM[$i]} = $max_score_unchanged[$i]; ##maxent score for unchanged seq } print Dumper \%max_unchanged; __DATA__ TTAAGGCAGCCCACCCGCAGGCT &gt; 1 110740688 110740688 C T GCCTGGGCGGGGAGGGCTGTCACAGTGCCGGCAGCAGCCCTTAAGGCAGC[C]CACCCGCAGGCTGCCGAGCGCTACCTGTATTTCCCCAACTGGGCCATGGC splicing splicing SLC6A17:NM_001010898:exon12:c.1816-10C&gt;T 0.77 TTCTATCCTTTGTTTTACAGGAA &gt; 1 111857154 111857154 T C TTAAATGGAGGGAGTCCTGACTTTTGAAGTTTATCTGTTTCTATCCTTTG[T]TTTACAGGAACAGCCAGCTGAAAACTCTCCTGGCCATTGGAGGCTGGAAC splicing splicing CHIA:NM_201653:exon5:c.258-8T&gt;C 10.99 </code></pre> <p>I also put in an example of how you can iterate with an index over a <code>for</code> loop, instead of using a <code>foreach</code> loop since you don't use <code>$lines</code> anywhere.</p> <hr> <p>Output:</p> <pre><code>$VAR1 = { 'TTAAGGCAGCCCACCCGCAGGCT &gt; 1 110740688 110740688 C T GCCTGGGCGGGGAGGGCTGTCACAGTGCCGGCAGCAGCCCTTAAGGCAGC[C]CACCCGCAGGCTGCCGAGCGCTACCTGTATTTCCCCAACTGGGCCATGGC splicing splicing SLC6A17:NM_001010898:exon12:c.1816-10C&gt;T' =&gt; '0.77', 'TTCTATCCTTTGTTTTACAGGAA &gt; 1 111857154 111857154 T C TTAAATGGAGGGAGTCCTGACTTTTGAAGTTTATCTGTTTCTATCCTTTG[T]TTTACAGGAACAGCCAGCTGAAAACTCTCCTGGCCATTGGAGGCTGGAAC splicing splicing CHIA:NM_201653:exon5:c.258-8T&gt;C' =&gt; '10.99' }; </code></pre> <hr>
<p>Do you really need to copy the data into multiple arrays? Are the being used elsewhere in the script. If not, then I'd simply build the hash as I loop over the filehandle.</p> <pre><code>use strict; use warnings; use Data::Dumper; my %max_unchanged; while (my $line = &lt;DATA&gt;) { chomp $line; if ($line =~ /^[ACGT]/) { chomp(my $value = &lt;DATA&gt;); $max_unchanged{$line} = $value; } } print Dumper \%max_unchanged; __DATA__ TTAAGGCAGCCCACCCGCAGGCT &gt; 1 110740688 110740688 C T GCCTGGGCGGGGAGGGCTGTCACAGTGCCGGCAGCAGCCCTTAAGGCAGC[C]CACCCGCAGGCTGCCGAGCGCTACCTGTATTTCCCCAACTGGGCCATGGC splicing splicing SLC6A17:NM_001010898:exon12:c.1816-10C&gt;T 0.77 TTCTATCCTTTGTTTTACAGGAA &gt; 1 111857154 111857154 T C TTAAATGGAGGGAGTCCTGACTTTTGAAGTTTATCTGTTTCTATCCTTTG[T]TTTACAGGAACAGCCAGCTGAAAACTCTCCTGGCCATTGGAGGCTGGAAC splicing splicing CHIA:NM_201653:exon5:c.258-8T&gt;C 10.99 </code></pre>
<p>Matt has correctly pointed out the reason for your problem. In fact it would be better in this instance to iterate over a <em>list</em> of indices, like this</p> <pre><code>my %max_unchanged; for my $i (0 .. $#max_score_unchanged) { $max_unchanged{$NM[$i]} = $max_score_unchanged[$i]; } </code></pre> <p>or you could even use <code>map</code>, like this</p> <pre><code>my %max_unchanged = map { $NM[$_] =&gt; $max_score_unchanged[$_]; } 0 .. $#max_score_unchanged; </code></pre> <p>But in the end there is no clear reason to have split your file into two arrays, and you may prefer this more concise version of your program which achieves the same end. It expects the input file as a parameter on the command line.</p> <pre><code>use strict; use warnings; my %max_unchanged; while (my $key = &lt;&gt;) { next unless $key =~ /[a-z]/; chomp $key; chomp($max_unchanged{$key} = &lt;DATA&gt;); } use Data::Dump; dd \%max_unchanged; </code></pre> <p>Given your sample input data, <code>%max_unchanged</code> ends up looking like this</p> <pre><code>{ "TTAAGGCAGCCCACCCGCAGGCT &gt; 1 110740688 110740688 C T GCCTGGGCGGGGAGGGCTGTCACAGTGCCGGCAGCAGCCCTTAAGGCAGC[C]CACCCGCAGGCTGCCGAGCGCTACCTGTATTTCCCCAACTGGGCCATGGC splicing splicing SLC6A17:NM_001010898:exon12:c.1816-10C&gt;T" =&gt; 0.77, "TTCTATCCTTTGTTTTACAGGAA &gt; 1 111857154 111857154 T C TTAAATGGAGGGAGTCCTGACTTTTGAAGTTTATCTGTTTCTATCCTTTG[T]TTTACAGGAACAGCCAGCTGAAAACTCTCCTGGCCATTGGAGGCTGGAAC splicing splicing CHIA:NM_201653:exon5:c.258-8T&gt;C" =&gt; 10.99, } </code></pre>