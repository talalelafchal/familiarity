Perl is polymorphism worth it?
<p>There seem to be a number of ways to do polymorphism in Perl but they all feel "hacky" to me. I'm somewhat new to Perl so I could just be interpreting it wrong but I find most examples make your code too illegible and are controversial.</p> <p>Say you have a widget class that contains some data and methods that all widgets need. There are also a handful of widget types (i.e. calender, schedule, etc). And they need to communicate with each other (via a parent container class).</p> <p>Would playing with the namespace and making widget a prototype be worth it?<br> Should I give each widget a reference to an object (one of the types) at instantiation?<br> Just forget about types being objects and make widget a large class where only a few methods get used per instance based on what type is set. Something else?</p> <p>I come from a C/C++ background and I'm finding it difficult to decide on a Perl programming model.</p> <p>Also, I'm don't have strong type safety or private member requirements. The project is a mid sized web app with a couple developers and portability to other projects isn't a priority. Easy extensibilty without needing to decipher Perl hacks would be useful though.</p>
<p>The "Modern Perl" approach is probably to define <code>Widget</code> as a role. A role can be thought of as similar to a mixin, an interface, or an abstract base class. Do this with <a href="https://metacpan.org/pod/Moose%3a%3aRole" rel="nofollow">Moose::Role</a> or one of its more light-weight alternatives (<a href="https://metacpan.org/pod/Moo%3a%3aRole" rel="nofollow">Moo::Role</a>, <a href="https://metacpan.org/pod/Role%3a%3aTiny" rel="nofollow">Role::Tiny</a>).</p> <pre><code>{ package Widget; use Moo::Role; sub some_common_method { my $self = shift; ...; } sub another_common_method { my $self = shift; ...; } # Here we're indicating that all Widgets must # have a method called yet_another_common_method, # but we're not defining how that method should # be implemented. requires "yet_another_common_method"; } </code></pre> <p>Now you can create a class that composes that role:</p> <pre><code>{ package Calendar; use Moo; with "Widget"; # Here's a member variable. has year =&gt; (is =&gt; "ro", required =&gt; 1); # Widget requires us to implement this. sub yet_another_common_method { my $self = shift; ...; } # We can override Widget's implementation # of this method. sub some_common_method { my $self = shift; ...; } # We can install hooks ("method modifiers") # to Widget's methods. before another_common_method =&gt; sub { my $self = shift; print STDERR "Calendar ", $self-&gt;year, ": another_common_method() was called.\n"; }; } </code></pre> <p>And another:</p> <pre><code>{ package Schedule; use Moo; with "Widget", "Editable"; sub yet_another_common_method { my $self = shift; ...; } } </code></pre> <p>And use the classes:</p> <pre><code>my $calendar = Calendar-&gt;new( year =&gt; 2014 ); my $schedule = Schedule-&gt;new; my @widgets = ($calendar, $schedule); for (@widgets) { $_-&gt;some_common_method if $_-&gt;does('Widget'); } </code></pre>