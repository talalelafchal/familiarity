Perl module function call runs in spite of missing use statement
<p>I'm developing in a library consisting of multiple Perl modules.</p> <p>The following statement compiles and runs perfectly:</p> <pre><code>my $x = Foo::Bar::new(); </code></pre> <p>But the necessary <code>use</code> statement is missing from the beginning of the module:</p> <pre><code>use Foo::Bar; </code></pre> <p>How is this possible? Is <code>use</code> propagating from used or using modules?</p>
<p>You don't show any significant code, but one of the modules that you <em>do</em> use probably loads <code>Foo::Bar</code>, making it available to code in every package.</p> <p>It doesn't matter where the <code>use</code> (or <code>require</code>) appears, as long as it is done before the code that depends on it is executed</p>
<p>Some background first.</p> <pre><code>use Foo::Bar; </code></pre> <p>is short for</p> <pre><code>BEGIN { require Foo::Bar; import Foo::Bar; } </code></pre> <p><code>import Foo::Bar;</code> calls the <code>import</code> method of the module if one exists. This happens every time <code>use</code> is used. With no arguments, most modules' <code>import</code> export a default list of symbols or none at all.</p> <p>If you don't need to import anything (as is the case in your program), you can forgo the import by using </p> <pre><code>use Foo::Bar (); </code></pre> <p>It's a special case equivalent to</p> <pre><code>BEGIN { require Foo::Bar; } </code></pre> <p><code>require Foo::Bar;</code> is what loads the module. The modules is only loaded (executed) once per interpreter no matter how many times you do <code>require Foo::Bar;</code> (or <code>use Foo::Bar;</code>).</p> <p>In your case, you probably loaded a module that loaded Foo::Bar. That allows you to omit <code>use Foo::Bar ();</code> since it wouldn't have done anything anyway.</p>