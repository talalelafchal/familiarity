Replicate unpack of perl in c++
<p>I have a binary string with ASCII like this</p> <blockquote> <p>^@^@^@^A^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^A^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^A^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^A^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^A^@^@^O ^@^@^@^@^@^BÜ-^@^@^@^A^@^@^O ^@^@^@^@^@^BÜ-^@^@^@^A^@^@^<em>@^@^@^@^@^@^EÜ?^@^@^@^A^@^@^</em>@^@^@^@^@^@^EÜ?^@^@^@^A^@^@.à^@^@^@^@^@^Häð^@^@^@^A^@^@.à^@^@^@^@^@^Häð^@^@^@^A^@^@>&lt;80>^@^@^@^@^@^KÖ&lt;80>^@^@^@^A^@^@>&lt;80>^</p> </blockquote> <p>Perl code:</p> <pre><code>#!/usr/bin/env perl use warnings; use strict; use Data::Dumper; open(INDEX, $ARGV[0]); binmode(INDEX); my $buff; my $ret = read(INDEX, $buff, 4); my $fragment = unpack 'N', $buff; $ret = read(INDEX, $buff, 4); my $timestamp = unpack 'N', $buff; $ret = read(INDEX, $buff, 8); my $offset = unpack 'N', $buff; print "timestamp = $timestamp fragment # $fragment offset = $offset\n"; </code></pre> <p>Output:</p> <pre><code>timestamp = 0 fragment # 1 offset = 0 timestamp = 0 fragment # 1 offset = 0 timestamp = 0 fragment # 1 offset = 0 timestamp = 0 fragment # 1 offset = 0 timestamp = 4000 fragment # 1 offset = 187437 timestamp = 4000 fragment # 1 offset = 187437 timestamp = 8000 fragment # 1 offset = 384063 timestamp = 8000 fragment # 1 offset = 384063 timestamp = 12000 fragment # 1 offset = 582896 timestamp = 12000 fragment # 1 offset = 582896 </code></pre> <p>I want to replicate the above work done by unpack in C++ How to do it?</p> <p>What I was trying:</p> <pre><code>#include &lt;iostream&gt; #include &lt;stdlib.h&gt; using namespace std; int main () { int k; char buf1[5]; char buf2[5]; char buf3[9]; int i; char *str; //Assume str contains the entire binary data for(int i=0;str[i];) { while(k&lt;32) { buf1[k]=str[i]; ++k;++i; } k=0; while(k&lt;32) { buf2[k]=str[i]; ++k; } k=0; while(k&lt;64) { buf3[k]=str[i]; ++k;++i; } k=0; uint32_t a1,b1,a2,b2; uint64_t a3,b3; a1=atoi(buf1); b1=ntohl(a1); a2=atoi(buf2); b2=ntohl(a2); a3=atoi(buf1); b3=ntohl(a3); print "timestamp ="&lt;&lt; b2 &lt;&lt; "fragment #"&lt;&lt;b1&lt;&lt;" offset ="&lt;&lt;b3&lt;&lt;"\n"; } return 0; </code></pre> <p>}</p>
<p>Read 4 bytes, then use</p> <pre><code>uint32_t n; n = buf[0] &lt;&lt; 24 | buf[1] &lt;&lt; 16 | buf[2] &lt;&lt; 8 | buf[3] &lt;&lt; 0; </code></pre> <p>For example,</p> <pre><code>uint32_t n; unsigned char buf[4]; size_t bytes_read = fread (buf, 1, 4, stream); if (bytes_read &lt; 4) { if (ferror(stream)) { // Error // ... } else if (feof(stream)) { // Premature EOF // ... } } else { n = buf[0] &lt;&lt; 24 | buf[1] &lt;&lt; 16 | buf[2] &lt;&lt; 8 | buf[3] &lt;&lt; 0; } </code></pre>
<p>Here you go:</p> <pre><code>#include &lt;stdint.h&gt; #include &lt;iostream&gt; #include &lt;fstream&gt; using namespace std; int main( int argc, char *argv[] ) { if (argc &lt; 2) { cerr &lt;&lt; "Input filename required" &lt;&lt; endl; return 1; } ifstream f( argv[1], ios::binary ); if (!f.good()) { cerr &lt;&lt; "Cannot open input file '" &lt;&lt; argv[1] &lt;&lt; "'" &lt;&lt; endl; return 1; } while (!f.eof()) { uint8_t buf[8]; f.read( reinterpret_cast&lt; char * &gt;( buf ), 4 ); uint32_t fragment = ( ( buf[0] * 256U + buf[1] ) * 256U + buf[2] ) * 256U + buf[3]; f.read( reinterpret_cast&lt; char * &gt;( buf ), 4 ); uint32_t timestamp = ( ( buf[0] * 256U + buf[1] ) * 256U + buf[2] ) * 256U + buf[3]; f.read( reinterpret_cast&lt; char * &gt;( buf ), 8 ); uint64_t offset = ( ( ( ( ( ( buf[0] * 256LL + buf[1] ) * 256LL + buf[2] ) * 256LL + buf[3] ) * 256LL + buf[4] ) * 256LL + buf[5] ) * 256LL + buf[6] ) * 256LL + buf[7]; if (f.good()) { cout &lt;&lt; "timestamp = " &lt;&lt; timestamp; cout &lt;&lt; " fragment = " &lt;&lt; fragment; cout &lt;&lt; " offset = " &lt;&lt; offset &lt;&lt; endl; } } return 0; } </code></pre>