Perl pattern match and arithmetic operation at the same time
<p>Can i make match pattern and arithmetic operation at the same time ?</p> <pre><code> print 5 / 3 !~ /\.\d*/; </code></pre> <p>result 5 , why ?</p> <pre><code> $str = 5 / 3; print $str !~ /\.\d*/; </code></pre> <p>total correct. How can i make in the one expression ?</p>
<p>It is returning 5 because <code>3 !~ /\.\d*/</code> returns <code>1</code> and 5 / 1 = 5`. </p> <p>You can wrap your arithmetic expression in parens to have Perl evaluate it first:</p> <pre><code>print ((5 / 3) !~ /\.\d*/); </code></pre>
<p>You just need to use brackets!</p> <p>What happend in your code is basically:</p> <pre><code>print 5 / (3 !~ /\.\d*/); </code></pre> <p>So the RegEx comes first, then the <code>/</code> division.</p> <p>I think you want to do something like:</p> <pre><code>print ((5 / 3) !~ /\.\d*/); # or my $division = 5 / 3; print $division if $division !~ /\.\d*/; # or # print (5 / 3) if (5 / 3) !~ /\.\d*/; # but the calculation need to be twice here! </code></pre> <p>If i understand your problem correct, you just want to print if the division does not return a float:</p> <pre><code>print "test" if 5 / 3 == int 5 / 3 print "test 2" if 5 / 5 == int 5 / 5 </code></pre> <p>Output:</p> <pre><code>test 2 </code></pre> <p>There a way more better, faster and elegant ways to check this than using a RegExp.</p>
<p>Default order of operations is giving you the unexpected result. Instead, try:</p> <pre><code>print +(5 / 3) !~ /\.\d*/; </code></pre> <p>But, as pointed out by others, that's a terrible way to test whether 3 divides 5. You have the modulus operator for that:</p> <pre><code>print 5 % 3 == 0; </code></pre>