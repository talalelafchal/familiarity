Iterate directories in Perl, getting introspectable objects as result
<p>I'm about to start a script that may have some file lookups and manipulation, so I thought I'd look into some packages that would assist me; mostly, I'd like the results of the iteration (or search) to be returned as objects, which would have (base)name, path, file size, uid, modification time, etc as some sort of properties. </p> <p>The thing is, I don't do this all that often, and tend to forget APIs; when that happens, I'd rather let the code run on an example directory, and dump all of the properties in an object, so I can remind myself what is available where (obviously, I'd like to "dump", in order to avoid having to code custom printouts). However, I'm aware of the following:</p> <blockquote> <p><a href="http://www.perlmonks.org/?node_id=884054#884061" rel="nofollow">list out all methods of object - perlmonks.org</a><br> "Out of the box Perl doesn't do object introspection. Class wrappers like Moose provide introspection as part of their implementation, but Perl's built in object support is much more primitive than that."</p> </blockquote> <p>Anyways, I looked into:</p> <ul> <li>"Files and Directories Handling in Perl - Perl Beginners' Site" <a href="http://perl-begin.org/topics/files-and-directories/" rel="nofollow">http://perl-begin.org/topics/files-and-directories/</a></li> </ul> <p>... and started looking into the libraries referred there (also related link: <a href="http://rjbs.manxome.org/rubric/entry/1981" rel="nofollow">rjbs's rubric: the speed of Perl file finders</a>). </p> <p>So, for one, <code>File::Find::Object</code> seems to work for me; this snippet:</p> <pre><code>use Data::Dumper; @targetDirsToScan = ("./"); use File::Find::Object; my $tree = File::Find::Object-&gt;new({}, @targetDirsToScan); while (my $robh = $tree-&gt;next_obj()) { #print $robh ."\n"; # prints File::Find::Object::Result=HASH(0xa146a58)} print Dumper($robh) ."\n"; } </code></pre> <p>... prints this:</p> <pre><code># $VAR1 = bless( { # 'stat_ret' =&gt; [ # 2054, # 429937, # 16877, # 5, # 1000, # 1000, # 0, # '4096', # 1405194147, # 1405194139, # 1405194139, # 4096, # 8 # ], # 'base' =&gt; '.', # 'is_link' =&gt; '', # 'is_dir' =&gt; 1, # 'path' =&gt; '.', # 'dir_components' =&gt; [], # 'is_file' =&gt; '' # }, 'File::Find::Object::Result' ); # $VAR1 = bless( { # 'base' =&gt; '.', # 'is_link' =&gt; '', # 'is_dir' =&gt; '', # 'path' =&gt; './test.blg', # 'is_file' =&gt; 1, # 'stat_ret' =&gt; [ # 2054, # 423870, # 33188, # 1, # 1000, # 1000, # 0, # '358', # 1404972637, # 1394828707, # 1394828707, # 4096, # 8 # ], # 'basename' =&gt; 'test.blg', # 'dir_components' =&gt; [] </code></pre> <p>... which is mostly what I wanted, except the <code>stat</code> results are an array, and I'd have to know its layout (<code>($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks)</code> <a href="http://perldoc.perl.org/functions/stat.html" rel="nofollow">stat - perldoc.perl.org</a>) to make sense of the printout.</p> <p>Then I looked into <code>IO::All</code>, which I like because of utf-8 handling (but also, say, socket functionality, which would be useful to me for an unrelated task in the same script); and I was thinking I'd use this package instead. The problem is, I have a very hard time discovering what the available fields in the object returned are; e.g. with this code:</p> <pre><code>use Data::Dumper; @targetDirsToScan = ("./"); use IO::All -utf8; $io = io(@targetDirsToScan); @contents = $io-&gt;all(0); for my $contentry ( @contents ) { #print Dumper($contentry) ."\n"; # $VAR1 = bless( \*Symbol::GEN298, 'IO::All::File' ); # $VAR1 = bless( \*Symbol::GEN307, 'IO::All::Dir' ); ... #print $contentry-&gt;uid . " -/- " . $contentry-&gt;mtime . "\n"; # http://stackoverflow.com/q/24717210/printing-ret-of-ioall-w-datadumper print Dumper \%{*$contentry}; # doesn't list uid } </code></pre> <p>... I get a printout like this:</p> <pre><code># $VAR1 = { # '_utf8' =&gt; 1, # 'constructor' =&gt; sub { "DUMMY" }, # 'is_open' =&gt; 0, # 'io_handle' =&gt; undef, # 'name' =&gt; './test.blg', # '_encoding' =&gt; 'utf8', # 'package' =&gt; 'IO::All' # }; # $VAR1 = { # '_utf8' =&gt; 1, # 'constructor' =&gt; sub { "DUMMY" }, # 'mode' =&gt; undef, # 'name' =&gt; './testdir', # 'package' =&gt; 'IO::All', # 'is_absolute' =&gt; 0, # 'io_handle' =&gt; undef, # 'is_open' =&gt; 0, # '_assert' =&gt; 0, # '_encoding' =&gt; 'utf8' </code></pre> <p>... which clearly doesn't show attributes like <code>mtime</code>, etc. - even if they exist (which you can see if you uncomment the respective print line).</p> <p>I've also tried <code>Data::Printer</code>'s (<a href="http://stackoverflow.com/questions/10142530/how-can-i-perform-introspection-in-perl#10143427">How can I perform introspection in Perl?</a>) <code>p()</code> function - it prints exactly the same fields as <code>Dumper</code>. I also tried to use <code>print Dumper \%{ref ($contentry) . "::"};</code> (<a href="http://www.perlmonks.org/?node_id=884054#884061" rel="nofollow">list out all methods of object - perlmonks.org</a>), and this prints stuff like:</p> <pre><code>'O_SEQUENTIAL' =&gt; *IO::All::File::O_SEQUENTIAL, 'mtime' =&gt; *IO::All::File::mtime, 'DESTROY' =&gt; *IO::All::File::DESTROY, ... 'deep' =&gt; *IO::All::Dir::deep, 'uid' =&gt; *IO::All::Dir::uid, 'name' =&gt; *IO::All::Dir::name, ... </code></pre> <p>... but <em>only</em> if you use the <code>print $contentry-&gt;uid ...</code> line beforehand; else they are not listed! I guess that relates to this:</p> <blockquote> <p><a href="http://stackoverflow.com/questions/910430/how-do-i-list-available-methods-on-a-given-object-or-package-in-perl/911294#911294">introspection - How do I list available methods on a given object or package in Perl? #911294</a><br> In general, you can't do this with a dynamic language like Perl. The package might define some methods that you can find, but it can also make up methods on the fly that don't have definitions until you use them. Additionally, even calling a method (that works) might not define it. That's the sort of things that make dynamic languages nice. :)</p> </blockquote> <p>Still, that prints the name and type of the field - I'd want the name and value of the field instead.</p> <p>So, I guess my main question is - how can I dump an <code>IO::All</code> result, so that all fields (including <code>stat</code> ones) are printed out with their names and values (as is mostly the case with <code>File::Find::Object</code>)?</p> <p>(I noticed the <code>IO::All</code> results can be of type, say, <a href="http://search.cpan.org/~frew/IO-All-0.57/lib/IO/All/File.pm" rel="nofollow">IO::All::File</a>, but its docs defer to "See <a href="http://search.cpan.org/~frew/IO-All-0.57/lib/IO/All.pod" rel="nofollow">IO::All</a>", which doesn't discuss <code>IO::All::File</code> explicitly much at all. I thought, if I could "cast" <code>\%{*$contentry}</code> to a <code>IO::All::File</code>, maybe then <code>mtime</code> etc fields will be printed - but is such a "cast" possible at all?)</p> <p>If that is problematic, are there other packages, that would allow introspective printout of directory iteration results - but with named fields for individual <code>stat</code> properties?</p>
<p>Perl does introspection in the fact that an object will tell you what type of object it is. </p> <pre><code>if ( $object-&gt;isa("Foo::Bar") ) { say "Object is of a class of Foo::Bar, or is a subclass of Foo::Bar."; } if ( ref $object eq "Foo::Bar" ) { say "Object is of the class Foo::Bar."; } else { say "Object isn't a Foo::Bar object, but may be a subclass of Foo::Bar"; } </code></pre> <p>You can also see if an object can do something:</p> <pre><code>if ( $object-&gt;can("quack") ) { say "Object looks like a duck!"; } </code></pre> <p>What Perl can't do directly is give you a list of all the methods that a particular object can do. </p> <p>You might be able to munge some way.Perl objects are stored in package namespaces which are in the symbol table. Classes are implemented via Perl subroutines. It may be possible to go through the package namespace and then find all the subroutines.</p> <p>However, I can see several issues. First private methods (the ones you're not suppose to use) and non-method subroutines would also be included. There's no way to know which is which. Also, parent methods won't be listed.</p> <p>Many languages can generate such a list of methods for their objects (I believe both Python and Ruby can), but these usually give you a list without an explanation what these do. For example, <code>File::Find::Object::Result</code> (which is returned by the <code>next_obj</code> method of <code>File::Find::Object</code>) has a <code>base</code> method. What does it do? Maybe it's like <code>basename</code> and gives me the name of the file. Nope, it's like <code>dirname</code> and gives me the name of the directory.</p> <p>Again, some languages could give a list of those methods for an object and a description. However, those descriptions depend upon the programmer to maintain and make sure they're correct. No guaranteed of that.</p> <p>Perl doesn't have introspection, but all Perl modules stored in CPAN must be documented via POD embedded documentation, and this is printable from the command line:</p> <pre><code>$ perldoc File::Find::Object </code></pre> <p>This is the documentation you see in CPAN pages, in <a href="http://Perldoc.perl.org" rel="nofollow">http://Perldoc.perl.org</a> and in ActiveState's Perl documentation.</p> <p>It's not bad. It's not true introspection, but the documentation is usually pretty good. After all, if the documentation stunk, I probably wouldn't have installed that module in the first place. I use <code>perldoc</code> all the time. I can barely remember my kids' names let alone the way to use Perl classes that I haven't used in a few months, but I find that using <code>perldoc</code> works pretty wall.</p> <p>What you should not do is use <code>Data::Dumper</code> to dump out objects and try to figure out what they contain and possible methods. Some cleaver programmers are using <a href="http://www.stonehenge.com/merlyn/UnixReview/col63.html" rel="nofollow">Inside-Out Objects</a> to thwart peeking toms.</p> <p>So no, Perl doesn't list methods of a particular class like some languages can, but <code>perldoc</code> comes pretty close to doing what you need. I haven't use <code>File::Find::Object</code> in a long while, but going over the <code>perldoc</code>, I probably could write up such a program without much difficulty.</p>
<p>As I answered to your previous question, it is not a good idea to go relying on the guts of objects in Perl. Instead just call methods.</p> <p>If IO::All doesn't offer a method that gives you the information that you need, you might be able to write your own method for it that assembles that information using just the documented methods provided by IO::All...</p> <pre><code>use IO::All; # Define a new method for IO::All::Base to use, but # define it in a lexical variable! # my $dump_info = sub { use Data::Dumper (); my $self = shift; local $Data::Dumper::Terse = 1; local $Data::Dumper::Sortkeys = 1; return Data::Dumper::Dumper { name =&gt; $self-&gt;name, mtime =&gt; $self-&gt;mtime, mode =&gt; $self-&gt;mode, ctime =&gt; $self-&gt;ctime, }; }; $io = io('/tmp'); for my $file ( $io-&gt;all(0) ) { print $file-&gt;$dump_info(); } </code></pre>
<p>Ok, this is more-less as an exercise (and reminder for me); below is some code, where I've tried to define a class (<code>File::Find::Object::StatObj</code>) with accessor fields for all of the <code>stat</code> fields. Then, I have the hack for <code>IO::All::File</code> from <a href="http://stackoverflow.com/questions/24726359/replacing-a-class-in-perl-overriding-extending-a-class-with-same-name/24726797#24726797">Replacing a class in Perl (&quot;overriding&quot;/&quot;extending&quot; a class with same name)?</a>, where a <code>mtimef</code> field is added which corresponds to <code>mtime</code>, just as a reminder. </p> <p>Then, just to see what sort of interface I could have between the two libraries, I have <code>IO::All</code> doing the iterating; and the current file path is passed to <code>File::Find::Object</code>, from which we obtain a <code>File::Find::Object::Result</code> - which has been "hacked" to also show the <code>File::Find::Object::StatObj</code>; but that one is only generated after a call to the hacked Result's <code>full_components</code> (that might as well have been a separate function). Notice that in this case, you won't get <code>full_components</code>/<code>dir_components</code> of <code>File::Find::Object::Result</code> -- because apparently it is not <code>File::Find::Object</code> doing the traversal here, but <code>IO::All</code>. Anyways, the result is something like this:</p> <pre><code># $VAR1 = { # '_utf8' =&gt; 1, # 'mtimef' =&gt; 1403956165, # 'constructor' =&gt; sub { "DUMMY" }, # 'is_open' =&gt; 0, # 'io_handle' =&gt; undef, # 'name' =&gt; 'img/test.png', # '_encoding' =&gt; 'utf8', # 'package' =&gt; 'IO::All' # }; # img/test.png # &gt; - $VAR1 = bless( { # 'base' =&gt; 'img/test.png', # 'is_link' =&gt; '', # 'is_dir' =&gt; '', # 'path' =&gt; 'img/test.png', # 'is_file' =&gt; 1, # 'stat_ret' =&gt; [ # 2054, # 426287, # 33188, # 1, # 1000, # 1000, # 0, # '37242', # 1405023944, # 1403956165, # 1403956165, # 4096, # 80 # ], # 'basename' =&gt; undef, # 'stat_obj' =&gt; bless( { # 'blksize' =&gt; 4096, # 'ctime' =&gt; 1403956165, # 'rdev' =&gt; 0, # 'blocks' =&gt; 80, # 'uid' =&gt; 1000, # 'dev' =&gt; 2054, # 'mtime' =&gt; 1403956165, # 'mode' =&gt; 33188, # 'size' =&gt; '37242', # 'nlink' =&gt; 1, # 'atime' =&gt; 1405023944, # 'ino' =&gt; 426287, # 'gid' =&gt; 1000 # }, 'File::Find::Object::StatObj' ), # 'dir_components' =&gt; [] # }, 'File::Find::Object::Result' ); </code></pre> <p>I'm not sure how correct this would be, but what I like about this is that I could forget where the fields are; then I could rerun the dumper, and see that I could get <code>mtime</code> via (*::Result)<code>-&gt;stat_obj-&gt;size</code> - and that seems to work (here I'd need just to read these, not to set them). </p> <p>Anyways, here is the code:</p> <pre><code>use Data::Dumper; my @targetDirsToScan = ("./"); use IO::All -utf8 ; # Turn on utf8 for all io # try to "replace" the IO::All::File class { # http://stackoverflow.com/a/24726797/277826 package IO::All::File; use IO::All::File; # -base; # just do not use `-base` here?! # hacks work if directly in /usr/local/share/perl/5.10.1/IO/All/File.pm # NB: field is a sub in /usr/local/share/perl/5.10.1/IO/All/Base.pm field mtimef =&gt; undef; # hack sub file { my $self = shift; bless $self, __PACKAGE__; $self-&gt;name(shift) if @_; $self-&gt;mtimef($self-&gt;mtime); # hack #print("!! *haxx0rz'd* file() reporting in\n"); return $self-&gt;_init; } 1; } use File::Find::Object; # based on /usr/local/share/perl/5.10.1/File/Find/Object/Result.pm; # but inst. from /usr/local/share/perl/5.10.1/File/Find/Object.pm { package File::Find::Object::StatObj; use integer; use Tie::IxHash; #use Data::Dumper; sub ordered_hash { # http://stackoverflow.com/a/3001400/277826 #my (@ar) = @_; #print("# ". join(",",@ar) . "\n"); tie my %hash =&gt; 'Tie::IxHash'; %hash = @_; #print Dumper(\%hash); \%hash } my $fields = ordered_hash( # from http://perldoc.perl.org/functions/stat.html (map { $_ =&gt; $_ } (qw( dev ino mode nlink uid gid rdev size atime mtime ctime blksize blocks ))) ); #print Dumper(\%{$fields}); use Class::XSAccessor #accessors =&gt; %{$fields}, # cannot - is seemingly late # ordered_hash gets accepted, but doesn't matter in final dump; #accessors =&gt; { (map { $_ =&gt; $_ } (qw( accessors =&gt; ordered_hash( (map { $_ =&gt; $_ } (qw( dev ino mode nlink uid gid rdev size atime mtime ctime blksize blocks ))) ), #))) }, ; use Fcntl qw(:mode); sub new { #my $self = shift; my $class = shift; my @stat_arr = @_; # the rest my $ic = 0; my $self = {}; bless $self, $class; for my $k (keys %{$fields}) { $fld = $fields-&gt;{$k}; #print "$ic '$k' '$fld' ".join(", ",$stat_arr[$ic])." ; "; $self-&gt;$fld($stat_arr[$ic]); $ic++; } #print "\n"; return $self; } 1; } # try to "replace" the File::Find::Object::Result { package File::Find::Object::Result; use File::Find::Object::Result; #use File::Find::Object::StatObj; # no, has no file! use Class::XSAccessor replace =&gt; 1, accessors =&gt; { (map { $_ =&gt; $_ } (qw( base basename is_dir is_file is_link path dir_components stat_ret stat_obj ))) } ; #use Fcntl qw(:mode); #sub new # never gets called sub full_components { my $self = shift; #print("NEWCOMP\n"); my $sobj = File::Find::Object::StatObj-&gt;new(@{$self-&gt;stat_ret()}); $self-&gt;stat_obj($sobj); # add stat_obj and its fields return [ @{$self-&gt;dir_components()}, ($self-&gt;is_dir() ? () : $self-&gt;basename()), ]; } 1; } # main script start my $io = io($targetDirsToScan[0]); my @contents = $io-&gt;all(0); # Get all contents of dir for my $contentry ( @contents ) { print Dumper \%{*$contentry}; print $contentry-&gt;name . "\n"; # img/test.png # get a File::Find::Object::Result - must instantiate # a File::Find::Object; just item_obj() will return undef # right after instantiation, so must give it "next"; # no instantition occurs for $tro, though! #my $tffor = File::Find::Object-&gt;new({}, ($contentry-&gt;name))-&gt;next_obj(); my $tffo = File::Find::Object-&gt;new({}, ("./".$contentry-&gt;name)); my $tffos = $tffo-&gt;next(); # just a string! $tffo-&gt;_calc_current_item_obj(); # unfortunately, this will not calculate dir_components ... my $tffor = $tffo-&gt;item_obj(); # -&gt;full_components doesn't call new, either! # must call full_compoments, to generate the fields # (assign to unused variable triggers it fine) # however, $arrref_fullcomp will be empty, because # File::Find::Object seemingly calcs dir_components only # if it is traversing a tree... $arrref_fullcomp = $tffor-&gt;full_components; #print("# ".$tffor-&gt;stat_obj-&gt;size."\n"); # seems to work print "&gt; ". join(", ", @$arrref_fullcomp) ." - ". Dumper($tffor); } </code></pre>