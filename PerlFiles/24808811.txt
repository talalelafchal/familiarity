Speed up access to a MySQL database using Perl and DBI
<p>I am new to Perl, and am looking to cache the results of a Perl program to relieve database server load.</p> <p>I am thinking to implement a file cache for this (but not server-based caching techniques like memcached) or maybe if you recommend whatever is better.</p> <p>I want the results to be stored in a file (once it is retrieved from the database) and next time, before querying the database, the cache file is checked for the same parameters.</p> <p>I was thinking to make a CSV file but seems it is more complicated.</p> <p>This program does checking an IP of user, if IP exists in database, user is given access.</p> <pre><code>use DBI; use DBD::mysql; require 'shellwords.pl'; $| = 1; my $database = "xxxx"; my $user = "xxxx"; my $pass = "xxxx"; my $host = "xxx.xxx.xx.xx"; sub valid() { $dbh = DBI-&gt;connect("DBI:mysql:$db:$host:3306", $user, $pass) or die $DBI::errstr; my $sql = "SELECT * FROM authip WHERE ips = '$ip'"; my $sth = $dbh-&gt;prepare($sql); $sth-&gt;execute() or die $dbh-&gt;errstr; my $result = eval { $sth-&gt;fetchrow_arrayref-&gt;[0] }; } while (&lt;&gt;) { ($ip) = &amp;shellwords; if (&amp;valid($result)) { print "OK"; } else { print "ERR"; } } </code></pre>
<p>Your question is very unclear, as you don't say what it is that you want to accelerate, or why.</p> <p>The example code that you show is flawed, as follows</p> <ul> <li><p>You <em>must always</em> <code>use strict</code> and <code>use warnings</code> at the top of <em>every</em> Perl program that you write. You will also need to declare every variable that you use, which you seem to be doing fine</p></li> <li><p>Using <code>require</code> to include some external code is a bit clunky, and it is better to write a proper module - perhaps using <a href="https://metacpan.org/module/Exporter" rel="nofollow"><code>Exporter</code></a> to make specific subroutines available to the calling code</p></li> <li><p>It is much more expressive to replace <code>$|=1</code> with <code>STDOUT-&gt;autoflush</code>, which works fine if you have done <code>use IO::Handle</code>. Every version of Perl since 14 has <code>IO::File</code> required by default, so you don't even need to write the <code>use</code></p></li> <li><p><em>Never</em> write Perl subroutines with a prototype. That is the part that expresses what parameters the subroutine expects. In your case you have <code>sub valid() { ... }</code>, which insists that <code>valid</code> will take no parameters; yet you call it later with <code>if (&amp;valid($result)) { ... }</code></p></li> <li><p><em>Never</em> use <code>&amp;</code> to call a subroutine. Something like <code>&amp;shellwords</code> should be used only when you are treating the subroutine as data, for instance to get a subroutine reference like this</p> <pre><code>my $sub = \&amp;shellwords my ($ip) = $sub-&gt;(); </code></pre> <p>Amongst other things, the <code>&amp;</code> prefix has the effect of ignoring any subroutine prototypes. That is why, even though you defined <code>valid</code> to have no parameters, you may have seen it work because you called it with <code>&amp;valid($result)</code>.</p> <p>Although in this case two wrongs seem to work, they definitely don't make a right!</p></li> </ul> <p>After this is a number of semantic problems.</p> <p>You are hoping to speed up your software by caching results, yet your <code>valid</code> subroutine does <code>connect</code>, <code>prepare</code>, <code>execute</code> every time it is called. It also <em>interpolates</em> the value of <code>$ip</code> into the SQL statement to be executed: something that is poisonous on public networks, and so easy to avoid that you should invest in using a placeholder style everywhere. It will give you better security and make your code much more readable and maintainable.</p> <p>I'm not sure why you're using <code>eval</code> around the <code>fetchrow_arrayref</code> call. It will kill the program only if you choose to index it as an array without checking its value.</p> <p>Here is a refactoring of the code you show. Maybe it doesn't need a caching policy at all?</p> <pre><code>use strict; use warnings; use 5.014; use DBI; use ShellWords qw/ shellwords /; STDOUT-&gt;autoflush; my $host = 'xxx.xxx.xx.xx'; my $database = 'xxxx'; my $user = 'xxxx'; my $pass = 'xxxx'; my $dbh = DBI-&gt;connect( "DBI:mysql:$db:$host:3306", $user, $pass ) or die $DBI::errstr; my $select = $dbh-&gt;prepare('SELECT * FROM authip WHERE ips = ?'); while (&lt;&gt;) { my ($ip) = shellwords; my $is_valid = valid($ip); print $is_valid ? "OK\n" : "ERR\n"; } sub valid { my ($ip) = @_; $select-&gt;execute($ip) or die $dbh-&gt;errstr; $sth-&gt;fetchrow_arrayref; } </code></pre> <p>I hope it's clear that I have assumed <code>shellwords.pl</code> will be rewritten properly as a module in <code>ShellWords.pm</code>. Whatever is inside <code>shellwords.pl</code> it is using the values of many variables that are available only in the right context and are not passed by parameter.</p> <p>I hope this helps. Despite not answering your question directly I think I have done all I can to suggest a solution. Please explain more if my intuition is off the mark.</p>