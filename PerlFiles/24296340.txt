formatting a string from X to Y +
<p><strong>Not sure of the best way to do this but could I do this using any of bash/awk/sed/perl/...?</strong></p> <p><strong>Brief Description</strong></p> <p>I want to be able to take this </p> <pre><code>(Intra TAU success Times(SGW not change) + Intra TAU success Times(SGW change) + Period TAU success Times(SGW not change)+ Period TAU success Times(SGW change))/(Intra TAU request Times(SGW not change) + Intra TAU request Times(SGW change)+ Period TAU request Times(SGW not change)+ Period TAU request Times(SGW change)) x 100% </code></pre> <p>and format it to this </p> <pre><code>([Intra TAU success Times(SGW not change)]+[Intra TAU success Times(SGW change)]+[Period TAU success Times(SGW not change)]+[Period TAU success Times(SGW change)])/([Intra TAU request Times(SGW not change)]+[Intra TAU request Times(SGW change)]+[Period TAU request Times(SGW not change)]+[Period TAU request Times(SGW change)])*100 </code></pre> <p><strong>Detailed Description</strong></p> <p>I want to be able to take this format (this would be one line, jsut presented like this for clarity)</p> <pre><code>( Intra TAU success Times(SGW not change) + Intra TAU success Times(SGW change) + Period TAU success Times(SGW not change)+ Period TAU success Times(SGW change) )/( Intra TAU request Times(SGW not change) + Intra TAU request Times(SGW change)+ Period TAU request Times(SGW not change)+ Period TAU request Times(SGW change) ) x 100% </code></pre> <p>and produce this format:</p> <pre><code>( [Intra TAU success Times(SGW not change)]+ [Intra TAU success Times(SGW change)]+ [Period TAU success Times(SGW not change)]+ [Period TAU success Times(SGW change)] )/( [Intra TAU request Times(SGW not change)]+ [Intra TAU request Times(SGW change)]+ [Period TAU request Times(SGW not change)]+ [Period TAU request Times(SGW change)] ) *100 </code></pre> <p>what i want to do</p> <p>1 add square brackets <code>[]</code> to all counters</p> <p>take this string <br><code>Intra TAU success Times(SGW not change)</code> <br>and produce this <br><code>[Intra TAU success Times(SGW not change)]</code></p> <p><strong>Note</strong> Not all counter strings will end in a <code>)</code></p> <p>2 replace <code>x</code> with <code>*</code></p> <p>3 remove the <code>%</code></p>
<p>Given:</p> <p><code>STRING="(Intra TAU success Times(SGW not change) + Intra TAU success Times(SGW change) + Period TAU success Times(SGW not change)+ Period TAU success Times(SGW change))/(Intra TAU request Times(SGW not change) + Intra TAU request Times(SGW change)+ Period TAU request Times(SGW not change)+ Period TAU request Times(SGW change)) x 100%"</code></p> <p>This works for your example:</p> <pre><code>echo $STRING | sed 's/Intra/[&amp;/g; s/Period/[&amp;/g; s/change)/&amp;]/g; s/ x / * /g; s/\([0-9]*\)%/\1/g' </code></pre> <p>Assumptions:</p> <ul> <li>At the beginning of "Intra" or "Period" is where "[" needs to be added</li> <li>At the end of "changes)" is where "]" needs to be added</li> <li>" x " is between 2 spaces</li> <li>There is no space between a number and "%"</li> </ul> <hr> <p>With regards to <strong><code>sed</code></strong>:</p> <ul> <li><code>&amp;</code> represents "entire match" </li> <li><code>\(...\)</code> captures a group and <code>\1</code> spits out the first captured group <br/> <code>\2</code> spits out the second ... so on and so forth</li> </ul>
<p>Using a perl regex to enclose groups of letters, spaces, and balanced paranthesis in braces.</p> <pre><code>use strict; use warnings; my $data = do {local $/; &lt;DATA&gt;}; $data =~ s{\s*\bx\b\s*}{*}g; $data =~ s{%}{}g; $data =~ s{\s* ( (?:[a-z\s]+|\([a-z\s]+\))+ )(?&lt;!\s) \s*}{[$1]}ixg; print $data; __DATA__ ( Intra TAU success Times(SGW not change) + Intra TAU success Times(SGW change) + Period TAU success Times(SGW not change)+ Period TAU success Times(SGW change) )/( Intra TAU request Times(SGW not change) + Intra TAU request Times(SGW change)+ Period TAU request Times(SGW not change)+ Period TAU request Times(SGW change) ) x 100% </code></pre> <p>Outputs:</p> <pre><code>([Intra TAU success Times(SGW not change)]+[Intra TAU success Times(SGW change)]+[Period TAU success Times(SGW not change)]+[Period TAU success Times(SGW change)])/([Intra TAU request Times(SGW not change)]+[Intra TAU request Times(SGW change)]+[Period TAU request Times(SGW not change)]+[Period TAU request Times(SGW change)])*100 </code></pre>
<p>You could try this sed command also,</p> <pre><code>$ sed 's/ + /]+[/g;s/+ /]+[/g;s/(I/([I/g;s/))\//)])\//g;s/) x 100%/])*100/g' file ([Intra TAU success Times(SGW not change)]+[Intra TAU success Times(SGW change)]+[Period TAU success Times(SGW not change)]+[Period TAU success Times(SGW change)])/([Intra TAU request Times(SGW not change)]+[Intra TAU request Times(SGW change)]+[Period TAU request Times(SGW not change)]+[Period TAU request Times(SGW change)])*100 </code></pre> <p><strong>Explanation:</strong></p> <pre><code>s/ + /]+[/g; # Replace all the ` + ` with `]+[` s/+ /]+[/g; # FRom the above output it again replaces `+ ` with `]+[` s/(I/([I/g; # Again from the above result, it replaces `(I` with `([I` s/))\//)])\//g; # Again from the output of above, it replaces `))/` with `)])/` s/) x 100%/])*100/g # Again from the above output, it replaces `) x 100%` with `])*100` </code></pre>
<p>I have a feeling that some of the other solutions aren't flexible enough to handle some of the input cases that you haven't told us about (and besides, I felt like playing with Marpa), so here's a more heavy-duty solution.</p> <pre class="lang-perl prettyprint-override"><code>#!perl use strict; use warnings; use Marpa::R2; use Data::Dumper; my $grammar = Marpa::R2::Scanless::G-&gt;new({ source =&gt; \(&lt;&lt;'EOGRAMMAR') :default ::= action =&gt; ::first lexeme default = latm =&gt; 1 Expression ::= Division ('x') Percentage action =&gt; expression Division ::= Sum ('/') Sum action =&gt; division Sum ::= ('(') Sum (')') | Variable ('+') Sum action =&gt; sum | Variable Percentage ::= Number ('%') Variable ::= VariablePart+ action =&gt; variable VariablePart ::= Words action =&gt; [value] | '(' Words ')' action =&gt; [values] Words ~ [A-Za-z ]+ Number ~ [\d]+ Whitespace ~ [\s]+ :discard ~ Whitespace EOGRAMMAR }); my $recognizer = Marpa::R2::Scanless::R-&gt;new({ grammar =&gt; $grammar, semantics_package =&gt; 'action', }); sub action::expression { "$_[1]*$_[2]" } sub action::division { "($_[1])/($_[2])" } sub action::sum { "$_[1]+$_[2]" } sub action::variable { my @parts = @_; shift @parts; @parts = map @$_, @parts; s/^\s+// for @parts; s/\s+$// for @parts; return '[' . join('', @parts) . ']'; } my $input = do { local $/; &lt;&gt; }; $recognizer-&gt;read(\$input); my $output = $recognizer-&gt;value; if ($output) { print $$output, "\n"; exit 0; } else { print STDERR "Parse failed"; exit 1; } </code></pre> <p>It uses a grammar to parse the kind of expression you showed, and the grammar actions, rather than building up a parse tree, simply reconstruct the output in the format that you asked for. It's relatively free about whitespace and what can occur in "variable names" in the input, although the grammar might have to be modified if there are expressions in a format I didn't capture.</p>
<p>This might work for you (GNU sed):</p> <pre><code>sed -r 's/\s*((Intra|Period)[^)]*\))\s*/[\1]/g;s/\s*x\s*/*/;s/%//' file </code></pre> <p>Surround strings beginning with <code>Intra</code> or <code>Period</code> to the following <code>)</code> with square brackets deleting any pre/post white space. Replace <code>x</code> with <code>*</code> deleting any pre/post white space. Finally delete <code>%</code>.</p>