Iterating over a string in Perl
<p>I want to make a script which will type string letters one by one</p> <pre><code>my $str = 'Test String'; my @spl = split '',$str; for (@spl){ print "$_"; sleep(1); } print "\n"; </code></pre> <p><code>sleep()</code> doesn't do it's job! it makes me wait more than 1 second and im getting the full text immediately without any delay.</p>
<p><strong>You are <a href="http://perl.plover.com/FAQs/Buffering.html" rel="nofollow">Suffering from Buffering</a></strong>. The link provided takes you to an excellent article from The Perl Journal circa 1998 from Marc Jason Dominus (the author of Higher-Order Perl). The article may be over a decade old, but the topic is as relevant today as it was when he wrote it. </p> <p>In your case you need to do</p> <pre><code>{ local $| = 1; for (@spl){ print "$_"; sleep(1); } } </code></pre> <p>or use <code>IO::Handle</code> as mpapec suggested.</p>
<p>In your loop, you are only outputting 2 items. There is also the fact that your output may be buffered and therefore the buffer may only be flushed and printed when the <code>\n</code> gets sent.</p> <p>Try setting <code>$|</code> to a non-zero value which may disable the line buffering.</p> <p>e.g</p> <pre><code>$| = 1; $|++; // alternative often seen </code></pre> <p>Alternatively, this does the same thing:</p> <pre><code>STDOUT-&gt;autoflush(1); # Needs "use IO::Handle;" on older versions of Perl </code></pre> <p>Although probably not the issue here,<code>sleep()</code> is not a good way of waiting for a second, especially on older systems. As the <a href="http://perldoc.perl.org/functions/sleep.html" rel="nofollow">manual</a> states, there are reasons why sleep may take less than or more than 1 second.</p>
<p>Put</p> <pre><code>use IO::Handle; STDOUT-&gt;autoflush(); </code></pre> <p>before printing, to disable output buffering (and thus waiting to fill buffer first).</p>