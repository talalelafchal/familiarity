Globally defined array
<p>Is it bad practice to globally define an array, fill it with a subroutine, and then access it in another part of the script? E.g.,</p> <pre><code>use strict; use warnings; my @people = qw( Ted Bill Tom); my @names; &amp;main; sub main{ foreach(@people){ &amp;fillNames; } } sub fillNames { undef @names; print "$_\n"; push(@names,$_); } </code></pre> <p>In the above case, I could have just had the subroutine return the array, but in my program I do this with multiple arrays (as far as I know, a subroutine can't return multiple arrays). </p> <p>Another way I have seen this done is to create a file, have the subroutine print the contents of the array for each index to the file and then have the main subroutine access that file. Is that a better way to do it?</p>
<p>There's no cut and dry answer here, but I would say it depends on the size and scope of the script. </p> <p>If your script is small enough that it's easy to keep track of globals, then I'd say it's no problem. However, once you go above a certain size and level of complexity, I'd be wary about using a global array in this way.</p>
<p>The reason globals are generally avoided is that you can easily suffer 'pollution' - the more variables, modified by more sources makes it very hard to track a broken piece of code. </p> <p>For a short script, you're generally fine. </p> <p>I would really avoid using idioms like <code>&amp;fillnames;</code> though. That's doing something that you may not entirely expect. Calling a sub with in that way 'passes through' implict variables, which isn't a good style (in my opinon).</p> <p>Instead:</p> <pre><code>foreach my $person ( @people ) { fillNames ( $person ); } </code></pre> <p>subroutines can't return multiple arrays, you're right. Well, sort of - it returns a flat list, and concatenates the elements. If you want to return multiple arrays, you need to do it by reference. </p> <p>E.g.:</p> <pre><code>sub return_two_arrays { my @array1 = ( "one", "two", "three" ); my @array2 = ( "four", "five", "six" ); return ( \@array1, \@array2 ); } my ( $array1_ref, $array2_ref ) = return_two_arrays(); print join ( "\n", @$array1_ref ); </code></pre> <p>As a point of note though - your code undefines @names, and then pushes a value into it. That's probably not what you want to do - and is exactly the sort of problem that using 'globals' can cause. Because as it is, you'll only ever have the last 'name' in @names. </p>