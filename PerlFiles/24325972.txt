Perl Date conversion with Perl's built-in functions
<p>I have a date in the following format which is how it is stored in an external application </p> <pre><code>06/12/2014 6:31 PM IST </code></pre> <p>I want to change this format to which needs to check AM and PM also and rest of the minutes to be hardcoded as <code>:00+5:30</code></p> <pre><code>2014-06-12 18:31:00+05:30 </code></pre> <p>Since it is not a simple GMT to PDT change I tried with epoch, but the problem here is that the date is in different format. </p>
<p>The best thing to do is to use Perl's now built in Date/Time functions in <a href="http://perldoc.perl.org/Time%3a%3aPiece.html" rel="nofollow">Time::Piece</a>. Once you convert your time into a true Perl time, you can format it any way you please.</p> <p>The problem is that Time::Piece doesn't do a very good job at handling timezones. The easiest way of handling timezones on strings is to simply remove them:</p> <pre><code>use strict; use warnings; use Time::Piece; # This is what you have given my $input_time="6/12/2014 6:31 PM IDT"; # Remove timezone (the last four characters) my $munged_time = substr $input_time, 0, -4; # This is a description of your "format" above # You can find this by doing a "man date" on Unix. # Sometimes it's "man strftime". # # The various %x are bits that represent the time # in various formats. # %m = month %d = month date %Y = four digit year # %I = hour 01-12 %M = Minutes %p = AM/PM my $time_format="%m/%d/%Y %I:%M %p"; # Now convert the time from the format to a Time::Zone # Date Object. my $time = Time::Piece-&gt;strptime($munged_time, $time_format); # Now that the time is in a Time::Piece object, we can easily # manipulate it to do whatever we want. We could add or subtract # date times from each other, add or subtract hours, months, etc. # Here, I'm just printing out the various bits and pieces of # "datetime" that I am interested in. Note I'm using time-&gt;second # even though I never specified seconds. It's okay, Time::Piece # simply assumes that seconds are zero. # printf "%04d-%02d-%02d %02d:%02d:%02d+05:30\n", $time-&gt;year, $time-&gt;mon, $time-&gt;mday, $time-&gt;hour, $time-&gt;minute, $time-&gt;second; </code></pre>
<p>you can just do it with regex and a printf. in your particular case i suggest:</p> <pre><code>my $yourstring = '06/12/2014 6:31 PM IST'; my ($mm,$dd,$yy,$hh,$mi,$ampm) = $yourstring =~ m~(\d+)/(\d+)/(\d+)\s+(\d+):(\d+)\s+(AM|PM)\s+~; if ($ampm eq 'PM' &amp;&amp; $hh &lt; 12) { $hh += 12 } printf ('%04d-%02d-%02d %02d:%02d:00+05:30', $yy, $mm, $dd, $hh, $mi); </code></pre> <p>or look into <a href="http://search.cpan.org/~jhoblitt/DateTime-Format-DateParse-0.05/lib/DateTime/Format/DateParse.pod" rel="nofollow">DateTime::Format::DateParse</a></p>
<p>The question does not contain any information about which time formats are possible at all. Are day of month and month always with 2 digits? Is the hour in range 0 to 9 always without a leading 0? Is it possible that the minutes 0 to 9 are without a leading 0? Which time zones are possible, just <strong>IST</strong> or others as well?</p> <p>Here is a list of Perl regular expression search and replace strings which must be applied all to reformat date and time strings for time zone <strong>IST</strong> to get the date and time in format YYYY-MM-DD hh:mm:00+05:30</p> <p>Reformat all times with <strong>AM</strong> in string.</p> <p>Search: <code>([01]?\d)/([0-3]?\d)/([12][09]\d\d) +([01]?\d:[0-5]?\d) AM IST</code><br> Replace: <code>$3-$1-$2 $4:00+05:30</code></p> <p>Reformat all times with <strong>12:xx PM</strong> in string.</p> <p>Search: <code>([01]?\d)/([0-3]?\d)/([12][09]\d\d) +(12:[0-5]?\d) PM IST</code><br> Replace: <code>$3-$1-$2 $4:00+05:30</code></p> <p>Reformat all times with <strong>01:xx PM</strong> in string.</p> <p>Search: <code>([01]?\d)/([0-3]?\d)/([12][09]\d\d) +0?1(:[0-5]?\d) PM IST</code><br> Replace: <code>$3-$1-$2 13$4:00+05:30</code></p> <p>Reformat all times with <strong>02:xx PM</strong> in string.</p> <p>Search: <code>([01]?\d)/([0-3]?\d)/([12][09]\d\d) +0?2(:[0-5]?\d) PM IST</code><br> Replace: <code>$3-$1-$2 14$4:00+05:30</code></p> <p>Reformat all times with <strong>03:xx PM</strong> in string.</p> <p>Search: <code>([01]?\d)/([0-3]?\d)/([12][09]\d\d) +0?3(:[0-5]?\d) PM IST</code><br> Replace: <code>$3-$1-$2 15$4:00+05:30</code></p> <p>Reformat all times with <strong>04:xx PM</strong> in string.</p> <p>Search: <code>([01]?\d)/([0-3]?\d)/([12][09]\d\d) +0?4(:[0-5]?\d) PM IST</code><br> Replace: <code>$3-$1-$2 16$4:00+05:30</code></p> <p>Reformat all times with <strong>05:xx PM</strong> in string.</p> <p>Search: <code>([01]?\d)/([0-3]?\d)/([12][09]\d\d) +0?5(:[0-5]?\d) PM IST</code><br> Replace: <code>$3-$1-$2 17$4:00+05:30</code></p> <p>Reformat all times with <strong>06:xx PM</strong> in string.</p> <p>Search: <code>([01]?\d)/([0-3]?\d)/([12][09]\d\d) +0?6(:[0-5]?\d) PM IST</code><br> Replace: <code>$3-$1-$2 18$4:00+05:30</code></p> <p>Reformat all times with <strong>07:xx PM</strong> in string.</p> <p>Search: <code>([01]?\d)/([0-3]?\d)/([12][09]\d\d) +0?7(:[0-5]?\d) PM IST</code><br> Replace: <code>$3-$1-$2 19$4:00+05:30</code></p> <p>Reformat all times with <strong>08:xx PM</strong> in string.</p> <p>Search: <code>([01]?\d)/([0-3]?\d)/([12][09]\d\d) +0?8(:[0-5]?\d) PM IST</code><br> Replace: <code>$3-$1-$2 20$4:00+05:30</code></p> <p>Reformat all times with <strong>09:xx PM</strong> in string.</p> <p>Search: <code>([01]?\d)/([0-3]?\d)/([12][09]\d\d) +0?9(:[0-5]?\d) PM IST</code><br> Replace: <code>$3-$1-$2 21$4:00+05:30</code></p> <p>Reformat all times with <strong>10:xx PM</strong> in string.</p> <p>Search: <code>([01]?\d)/([0-3]?\d)/([12][09]\d\d) +10(:[0-5]?\d) PM IST</code><br> Replace: <code>$3-$1-$2 22$4:00+05:30</code></p> <p>Reformat all times with <strong>11:xx PM</strong> in string.</p> <p>Search: <code>([01]?\d)/([0-3]?\d)/([12][09]\d\d) +11(:[0-5]?\d) PM IST</code><br> Replace: <code>$3-$1-$2 23$4:00+05:30</code></p> <p>Insert leading 0 where missing in date (month, day of month) or time (hour, minute) string using an expression with a positive lookbehind and a positive lookahead:</p> <p>Search: <code>(?&lt;=[ \-:])(\d)(?=[ \-:])</code><br> Replace: <code>0$1</code></p> <p>In case of above expression does not work because of lookbehind/lookahead, it would be also possible to use less restrictive regular expression:</p> <p>Search: <code>\b(\d)\b</code><br> Replace: <code>0$1</code></p>