BOOST Regex global Search behavior
<p>My question is about whether the boost regex engine can do "global searches".<br> I've tried and I can't get it to do it. </p> <p>The match_results class contains the base pointer of the string, so after incrementing the<br> starting position manually then setting the <code>match_flag_type</code> to <code>match_not_bob | match_prev_avail</code>,<br> I would have thought the boost regex engine would be able to know it is in the middle of a string. </p> <p>Since I'm using this engine in my software, I'd like to know if this engine can infact do this correctly and I'm doing something wrong, or global searching is not possible with this engine. </p> <p>Below are sample code/output using BOOST regex, and an equivalent Perl script.</p> <p><em>Edit:</em> Just to clarify, in the below boost example the <code>Start</code> iterator is always treated as a boundry. The engine doesn't seem to consider text to the left of that position when making a match.<br> At least in this case.</p> <p>7/22/2014 - <strong>The Solution for Global Search</strong> </p> <p>Posting this update as the solution. Its not a workaround or kludge.<br> After googling '<em>regex_iterator</em>' I knew that regex_iterator sees the text to the left of the<br> current search position. And, I came across all the same source code. One site (like the others)<br> had an passing simple explanation of how it works that said it calls '<em>regex_search()</em>'<br> when the regex_iterator is incremented. </p> <p>So down in the bowels of the regex_iterator class, I saw that it indeed called regex_search() when<br> the iterator was incremented ->Next(). </p> <p>This 'regex_search()' overload wasn't documented and comes in only 1 type.<br> It includes a BIDI parameter at the end named 'base'. </p> <pre><code>bool regex_search(BidiIterator first, BidiIterator last, match_results&lt;BidiIterator, Allocator&gt;&amp; m, const basic_regex&lt;charT, traits&gt;&amp; e, match_flag_type flags, BidiIterator base) { if(e.flags() &amp; regex_constants::failbit) return false; re_detail::perl_matcher&lt;BidiIterator, Allocator, traits&gt; matcher(first, last, m, e, flags, base); return matcher.find(); } </code></pre> <p>It appears the base is the wall to the left of the start BIDI from where initial lookbehind's could use to check conditions.. </p> <p>So, I tested it out and it seemed to work.<br> The bottom line is to set base BIDI to the start of the input, and put the start BIDI anywhere after.<br> Effectively, this is like setting the pos() variable in Perl. </p> <p>And, to emulate global positional increment on a zero-length match, a simple conditional is all that's<br> needed: </p> <p><code>Start = ( _M[0].length() == 0) ? _M[0].first + 1 : _M[0].second;</code> (see below) </p> <p><strong>BOOST Regex 1.54 regex_search() using 'base' BIDI</strong><br> Note - in this example, Start always = _M[0].second;<br> The regex is purposely unlike the two other examples (below it), to demonstrate in fact<br> the text from '<em>Base</em>' to '<em>Start</em>' is considered each time when matching this regex.</p> <pre><code>#typedef std::string::const_iterator SITR; boost::regex Rx( "(?&lt;=(.)).", regex_constants::perl ); regex_constants::match_flag_type Flags = match_default; string str("0123456789"); SITR Start = str.begin(); SITR End = str.end(); SITR Base = Start; boost::smatch _M; while ( boost::regex_search( Start, End, _M, Rx, Flags, Base) ) { string str1(_M[1].first, _M[1].second ); string str0(_M[0].first, _M[0].second ); cout &lt;&lt; str1 &lt;&lt; str0 &lt;&lt; endl; // This line implements the Perl global match flag m//g -&gt; Start = ( _M[0].length() == 0) ? _M[0].first + 1 : _M[0].second; } output: 01 12 23 34 45 56 67 78 89 </code></pre> <p><strong>Perl 5.10</strong></p> <pre><code>use strict; use warnings; my $str = "0123456789"; while ( $str =~ /(?&lt;=(..))/g ) { print ("$1\n"); } output:** 01 12 23 34 45 56 67 78 89 </code></pre> <p><strong>BOOST Regex 1.54 regex_search() no 'base'</strong></p> <pre><code>string str("0123456789"); std::string::const_iterator Start = str.begin(); std::string::const_iterator End = str.end(); boost::regex Rx("(?&lt;=(..))", regex_constants::perl); regex_constants::match_flag_type Flags = match_default; boost::smatch _M; while ( boost::regex_search( Start, End, _M, Rx, Flags) ) { string str(_M[1].first, _M[1].second ); cout &lt;&lt; str &lt;&lt; "\n"; Flags |= regex_constants::match_prev_avail; Flags |= regex_constants::match_not_bob; Start = _M[0].second; } output: 01 23 45 67 89 </code></pre>
<p><strong>Updated</strong> in response to the comments <strong><a href="http://coliru.stacked-crooked.com/a/dcf22abe99d2929a" rel="nofollow">Live On Coliru</a></strong>:</p> <pre><code>#include &lt;boost/regex.hpp&gt; int main() { using namespace boost; std::string str("0123456789"); std::string::const_iterator start = str.begin(); std::string::const_iterator end = str.end(); boost::regex re("(?&lt;=(..))", regex_constants::perl); regex_constants::match_flag_type flags = match_default; boost::smatch match; while (start&lt;end &amp;&amp; boost::regex_search(start, end, match, re, flags)) { std::cout &lt;&lt; match[1] &lt;&lt; "\n"; start += 1; // NOTE //// some smartness that should work for most cases: // start = (match.length(0)? match[0] : match.prefix()).first + 1; flags |= regex_constants::match_prev_avail; flags |= regex_constants::match_not_bob; std::cout &lt;&lt; "at '" &lt;&lt; std::string(start,end) &lt;&lt; "'\n"; } } </code></pre> <p>Prints:</p> <pre><code>01 at '123456789' 12 at '23456789' 23 at '3456789' 34 at '456789' 45 at '56789' 56 at '6789' 67 at '789' 78 at '89' 89 at '9' </code></pre>