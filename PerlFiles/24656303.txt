Proficient way to check if 3 variables are all unique
<p>I wanted to write a script that checks if 3 variables (A,B,C) are all unique and dont equal each other. I thought of just doing a big if statement like:</p> <pre><code>if (A != B) &amp;&amp; (A != C) &amp;&amp; (B != C){ // do function } </code></pre> <p>I was just wondering if there is another way? Because the code looks kindof clunky. This is in Perl.</p>
<p>I'd do this in .NET with a <code>HashSet&lt;T&gt;</code>:</p> <pre><code>var myVariables = new List&lt;int&gt; { A, B, C }; var hashset = new HashSet&lt;int&gt;(myVariables); if (hashset.Count != myVariables.Count) { // There was at least one duplicate value / hash collision } </code></pre> <p>I imagine there are similar data structures in PERL and so forth. :)</p>
<p>With three variables, there is nothing really "big", just three comparisons.</p> <p>If you want to generalize to more variables, say N, then it becomes useful to be more efficient.</p> <p>If you compare exhaustively, you need <code>N(N-1)/2</code> comparisons (e.g. <code>N=10 -&gt; 45</code>).</p> <p>A better way is to sort and then use <code>N-1</code> comparisons (e.g. N=10 -> 9: <code>A!=B &amp;&amp; B!=C &amp;&amp; C!=D</code> ...).</p>
<p>You can use the uniq function from <a href="https://metacpan.org/pod/List%3a%3aMoreUtils"><code>List::MoreUtils</code></a> to get all of the unique elements, then compare the length to your original number of elements.</p> <pre><code>#!/usr/bin/perl use strict; use warnings; use List::MoreUtils qw(uniq); my ($A, $B, $C) = (1, 2, 3); my @elems = ($A, $B, $C); if ( uniq(@elems) == @elems ) { # do function } </code></pre>
<p>You can write a function,</p> <pre><code>sub all_unique { my %seen; return (@_ == grep !$seen{$_}++, @_); } if (all_unique($A, $B, $C)) { .. } </code></pre>
<p>Abstracting complicated details (e.g. those that "look clunky") is the point of subs. Move the logic to a sub if you don't like seeing it. Personally, that looks fine for me for three variables.</p> <p>Note that if you're moving the code to a sub, you might consider using an O(N) algorithm. Your current approach scales poorly (O(N<sup>2</sup>)).</p> <pre><code>sub are_distinct { my %seen; ++$seen{$_} for @_; return keys(%seen) == @_; } </code></pre> <hr> <p>Optimized to exit as soon as possible:</p> <pre><code>sub are_distinct { my %seen; for (@_) { return 0 if $seen{$_}++; } return 1; } </code></pre>