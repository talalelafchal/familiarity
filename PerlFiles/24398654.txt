perl parsing files for multiple strings
<p>I have been learning perl for the past two weeks. I have been writing some perl scripts for my school project. I need to parse a text file for multiple strings. I searched perl forums and got some information.The below function parses a text file for one string and returns a result. However I need the script to search the file for multiple strings. </p> <pre><code>use strict; use warnings; sub find_string { my ($file, $string) = @_; open my $fh, '&lt;', $file; while (&lt;$fh&gt;) { return 1 if /\Q$string/; } die "Unable to find string: $string"; } find_string('filename', 'string'); </code></pre> <p>Now for instance if the file contains multiple strings with regular expressions as listed below</p> <pre><code>"testing" http://www.yahoo.com =1 http://www.google.com=2 </code></pre> <p>I want the function to search for multiple strings like</p> <pre><code>find_string('filename', 'string1','string2','string3'); </code></pre> <p>Please can somebody explain me how i need to do that.It would be really helpful </p>
<p>I'm happy to see <code>use strict</code> and <code>use warnings</code> in your script. Here is one basic way to do it.</p> <pre><code>use strict; use warnings; sub find_string { my ($file, $string1, $string2, $string3) = @_; my $found1 = 0; my $found2 = 0; my $found3 = 0; open my $fh, '&lt;', $file; while (&lt;$fh&gt;) { if ( /$string1/ ) { $found1 = 1; } if ( /$string2/ ) { $found2 = 1; } if ( /$string3/ ) { $found3 = 1; } } if ( $found1 == 1 and $found2 == 1 and $found3 == 1 ) { return 1; } else { return 0; } } my $result = find_string('filename', 'string1'. 'string2', 'string3'); if ( $result == 1 ) { print "Found all three strings\n"; } else { print "Didn't find all three\n"; } </code></pre>
<p>Going through this very quickly here:</p> <p>You right now pass the name of a file, and one string. What if you pass multiple strings:</p> <pre><code> if ( find_string ( $file, @strings ) ) { print "Found a string!\n"; } else { print "No string found\n"; } .. sub find_string { my $file = shift; my @strings = @_; # # Let's make the strings into a regular expression # my $reg_exp = join "|" ,@strings; # Regex is $string1|$string2|$string3... open my $fh, "&lt;", $file or die qq(Can't open file...); while ( my $line = &lt;$fh&gt; ) { chomp $line; if ( $line =~ $reg_exp ) { return 1; # Found the string } } return 0; # String not found } </code></pre> <p>I am about to go into a meeting, so I haven't really even tested this, but the idea is there. A few things:</p> <ul> <li>You want to handle characters in your strings that could be regular expression characters. You can use either the <code>quotemeta</code> command, or use <code>\Q</code> and <code>\E</code> before and after each string.</li> <li>Think about using <code>use autodie</code> to handle files that can't be open. Then, you don't have to check your open statement (like I did above).</li> <li>There are limitations. This would be awful if you were searching for 1,000 different strings, but should be okay with a few.</li> <li>Note how I use a scalar file handle (<code>$fh</code>). Instead of opening your file via the subroutine, I would pass in a scalar file handle. This would allow you to take care of an invalid file issue in your main program. That's the big advantage of scalar file handles: They can be easily passed to subroutines and stored in class objects.</li> </ul> <hr> <h1>Tested Program</h1> <pre><code>#! /usr/bin/env perl # use strict; use warnings; use autodie; use feature qw(say); use constant { INPUT_FILE =&gt; 'test.txt', }; open my $fh, "&lt;", INPUT_FILE; my @strings = qw(foo fo+*o bar fubar); if ( find_string ( $fh, @strings ) ) { print "Found a string!\n"; } else { print "No string found\n"; } sub find_string { my $fh = shift; # The file handle my @strings = @_; # A list of strings to look for # # We need to go through each string to make sure there's # no special re characters for my $string ( @strings ) { $string = quotemeta $string; } # # Let's join the stings into one big regular expression # my $reg_exp = join '|', @strings; # Regex is $string1|$string2|$string3... $reg_exp = qr($reg_exp); # This is now a regular expression while ( my $line = &lt;$fh&gt; ) { chomp $line; if ( $line =~ $reg_exp ) { return 1; # Found the string } } return 0; # String not found } </code></pre> <ul> <li><code>autodie</code> handles issues when I can't open a file. No need to check for it.</li> <li>Notice I have three parameters in my <code>open</code>. This is the preferred way.</li> <li>My file handle is <code>$fh</code> which allows me to pass it to my <code>find_string</code> subroutine. Open the file in the main program, and I can handle read errors there.</li> <li>I loop through my <code>@strings</code> and use the <code>quotemeta</code> command to automatically escape special regular expression characters.</li> <li>Note that when I change <code>$string</code> in my loop, it actually modifies the <code>@strings</code> array.</li> <li>I use <code>qr</code> to create a regular expression.</li> <li>My regular expression is <code>/foo|fo\+\*o|bar|fubar/</code>.</li> <li>There are a few <em>bugs</em> For example, the string <code>fooburberry</code> will match with <code>foo</code>. Do you want that, or do you want your <em>strings</em> to be whole words?</li> </ul>
<p>I think you can store the file content in an array first, then grep the input in the array.</p> <pre><code>use strict; use warnings; sub find_multi_string { my ($file, @strings) = @_; my $fh; open ($fh, "&lt;$file"); #store the whole file in an array my @array = &lt;$fh&gt;; for my $string (@strings) { if (grep /$string/, @array) { next; } else { die "Cannot find $string in $file"; } } return 1; } </code></pre>