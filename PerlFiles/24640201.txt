Extracting boundaries out of given condition in Perl
<p>I have a square-shape zone described by some conditions as follows:</p> <pre><code>x &lt; b &amp;&amp; x &gt;= a &amp;&amp; y &lt; d &amp;&amp; y &gt;= c </code></pre> <p>I would like to extract the top-right and bottom-left corners coordinates. (Let's assume that the whole condition is given in $cond. Also, store the pairs in two lists <code>@xy_b</code> and <code>@xy_t</code>). For this example: <code>@xy_b = (a , c)</code> and <code>@xy_t = (b, d)</code>.</p> <p><img src="https://i.stack.imgur.com/Puedo.png" alt="enter image description here"></p> <p><strong>REMARKS</strong></p> <ul> <li>The order of conditiones might be scrambled (e.g. <code>y &lt; d &amp;&amp; x &gt;= a &amp;&amp; x &lt; d &amp;&amp; y &gt;= c</code>). </li> <li>Expect both <code>x &lt; a</code> and <code>a &gt; x</code> </li> <li>There is no condition like <code>b =&lt; x &lt; a</code>. </li> <li>Expect conditions like: <code>x &lt;= b &amp;&amp; x &gt;= a</code> or <code>x &lt; b &amp;&amp; x &gt; a</code> (treat them the same unless you have a better convention to distinguish the,).</li> <li><p>Expect some or all of the conditions may be missed. If one of the conditions is issued it should be consider correspondingly zero or infinity. For example in the following condition set:</p> <p><code>x &lt; b &amp;&amp; x &gt;= a &amp;&amp; y &gt;= c</code></p></li> </ul> <p>the upper limit for <code>y</code> must be infinity. If the lower limit is missing, it should be considered zero.</p> <p><img src="https://i.stack.imgur.com/JAje0.png" alt="enter image description here"></p>
<p>It would be very easy to over complicate this problem. </p> <p>However, the following is a proof of concept that attempts to break this down into the simplest regular expressions.</p> <ol> <li>If equal signs are ignored, just remove them.</li> <li>Match each variable boundary separately. </li> <li>For now assume each boundary can only be another variable.</li> <li>No other validation is done at this point for rules that aren't matched.</li> </ol> <p>Here is the code that demonstrates this logic:</p> <pre><code>use strict; use warnings; while (&lt;DATA&gt;) { # Remove all equals signs since we ignore that data. s{=(?=[&lt;&gt;])|(?&lt;=[&lt;&gt;])=}{}g; die "Invalid equal sign found in $_" if /=/; my %boundary; for my $var (qw(x y)) { my $min = /\b$var\b \s* &gt; \s* (\w+)/x || /(\w+) \s* &lt; \s* \b$var\b/x ? $1 : 0; my $max = /\b$var\b \s* &lt; \s* (\w+)/x || /(\w+) \s* &gt; \s* \b$var\b/x ? $1 : 'Inf'; $boundary{$var} = { min =&gt; $min, max =&gt; $max, } } print "($boundary{x}{min}, $boundary{y}{min}) to ($boundary{x}{max}, $boundary{y}{max})\n\n" } __DATA__ x &lt; b &amp;&amp; x &gt;= a &amp;&amp; y &lt; d &amp;&amp; y &gt;= c y &lt; d &amp;&amp; x &gt;= a &amp;&amp; x &lt; d &amp;&amp; y &gt;= c x &lt; b &amp;&amp; x &gt;= a &amp;&amp; y &gt;= c </code></pre> <p>Outputs:</p> <pre><code>(a, c) to (b, d) (a, c) to (d, d) (a, c) to (b, Inf) </code></pre>