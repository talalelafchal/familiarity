Regular expressions, matching operator using a string variable in Perl
<p>I am using a <code>regex</code> but am getting some odd, unexpected "matches". "Names" are sent to a subroutine to be compared to an array called <code>@ASlist</code>, which contains multiple rows. The first element of each row is also a name, followed by 0 to several synonyms. The goal is to match the incoming "name" to any row in <code>@ASlist</code> that has a matching cell. </p> <p>Sample input, from which <code>$names</code> is derived for the comparison against <code>@ASlist</code>:</p> <pre><code>13 1 13 chr7 7 70606019 74345818 Otud7a Klf13 E030018B13Rik Trpm1 Mir211 Mtmr10 Fan1 Mphosph10 Mcee Apba2 Fam189a1 Ndnl2 Tjp1 Tarsl2 Tm2d3 1810008I18Rik Pcsk6 Snrpa1 H47 Chsy1 Lrrk1 Aldh1a3 Asb7 Lins Lass3 Adamts17 </code></pre> <p>Sample lines from @ASlist:</p> <pre><code>HSPA5 BIP FLJ26106 GRP78 MIF2 NDUFA5 B13 CI-13KD-B DKFZp781K1356 FLJ12147 NUFM UQOR13 ACAN AGC1 AGCAN CSPG1 CSPGCP MSK16 SEDK </code></pre> <p>The code:</p> <pre><code>my ($name) = @_; ## this comes in from another loop elsewhere in code I did not include chomp $name; my @collectmatches = (); ## container to collect matches foreach my $ASline ( @ASlist ){ my @synonyms = split("\t", $ASline ); for ( my $i = 0; $i &lt; scalar @synonyms; $i++ ){ chomp $synonyms[ $i ]; #print "COMPARE $name TO $synonyms[ $i ]\n"; if ( $name =~m/$synonyms[$i]/ ){ print "\tname $name from block matches\n\t$synonyms[0]\n\tvia $synonyms[$i] from AS list\n"; push ( @collectmatches, $synonyms[0], $synonyms[$i] ); } else { # print "$name does not match $synonyms[$i]\n"; } } } </code></pre> <p>The script is working but also reports weird matches. Such as, when <code>$name</code> is "E030018B13Rik" it matches "NDUFA5" when it occurs in <code>@ASlist</code>. These two should not be matched up.</p> <p>If I change the regex from <code>~m/$synonyms[$i]/</code> to <code>~m/^$synonyms[$i]$/</code>, the "weird" matches go away, BUT the script misses the vast majority of matches.</p>
<p>The <code>NDUFA5</code> record contains <code>B13</code> as a pattern, which will match <code>E030018&lt;B13&gt;Rik</code>.</p> <p>If you want to be more literal, then add boundary conditions to your regular expression <code>/\b...\b/</code>. Also should probably escape regular expression special characters using <a href="http://perldoc.perl.org/functions/quotemeta.html" rel="nofollow"><code>quotemeta</code></a>.</p> <pre><code>if ( $name =~ m/\b\Q$synonyms[$i]\E\b/ ) { </code></pre> <p>Or if you want to test straight equality, then just use <a href="http://perldoc.perl.org/functions/eq.html" rel="nofollow"><code>eq</code></a></p> <pre><code>if ( $name eq $synonyms[$i] ) { </code></pre>
<p>You are using <code>B13</code> as the regular expression. As none of the characters has a special meaning, any string containing the substring <code>B13</code> matches the expression.</p> <pre><code>E030018B13Rik ^^^ </code></pre> <p>If you want the expression to match the whole string, use anchors:</p> <pre><code>if ($name =~m/^$synonyms[$i]$/) { </code></pre> <p>Or, use <code>index</code> or <code>eq</code> to detect substrings (or identical strings, respectively), as your input doesn't seem to use any features of regular expressions.</p>
<p>Since you only need to compare two strings, you can simply use eq:</p> <pre><code>if ( $name eq $synonyms[$i] ){ </code></pre>
<p>Another, more Perlish way to test for string equality is to use a hash.</p> <p>You don't show any real test data, but this short Perl program builds a hash from your array <code>@ASlist</code> of lines of match strings. After that, most of the work is done.</p> <p>The subsequent <code>for</code> loop tests just <code>E030018B13Rik</code> to see if it is one of the keys of the new <code>%ASlist</code> and prints an appropriate message</p> <pre><code>use strict; use warnings; my @ASlist = ( 'HSPA5 BIP FLJ26106 GRP78 MIF2', 'NDUFA5 B13 CI-13KD-B DKFZp781K1356 FLJ12147 NUFM UQOR13', 'ACAN AGC1 AGCAN CSPG1 CSPGCP MSK16 SEDK', ); my %ASlist = map { $_ =&gt; 1 } map /\S+/g, @ASlist; for (qw/ E030018B13Rik /) { printf "%s %s\n", $_, $ASlist{$_} ? 'matches' : 'doesn\'t match'; } </code></pre> <p><strong>output</strong></p> <pre><code>E030018B13Rik doesn't match </code></pre>