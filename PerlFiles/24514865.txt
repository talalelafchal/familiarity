Perl regex remove number/punctuation combinations
<p>I'm trying to remove all digit/punctuation combinations in a string separated by whitespace, i.e.,</p> <pre><code>$string = " 13-acetate 9-11 777 &gt;3 ctl-54 2!3 "; </code></pre> <p>should become</p> <pre><code>$string = " 13-acetate ctl-54 "; </code></pre> <p>My attempt is as follows</p> <pre><code>$string =~ s/\s+[\d*[:punct:]&gt;]+\s+//g; </code></pre> <p>But this is giving me</p> <pre><code>$string = " 13-acetate 777 ctl-54 "; </code></pre> <p>Appreciate pointers as to where I'm going wrong.</p>
<p>The problem is that you are trying to match the same space in two passes. You need to use lookarounds.</p> <pre><code>s/(?&lt;!\S)[\d\p{Punct}\p{Symbol}]+(?!\S)//g; </code></pre> <p>I used negative look aheads and look behinds so that you don't need to add leading and trailing spaces to the input string.</p>
<p>As ikegami pointed out, your problem is that you were trying to match the spaces twice.</p> <p>An alternative way to quickly fix your original regex is to create an alternation for your beginning boundary condition:</p> <pre><code>use strict; use warnings; my $string = " 13-acetate 9-11 777 &gt;3 ctl-54 2!3 "; $string =~ s/(?:\G|\s+)[\d[:punct:]]+\s+/ /g; print $string; </code></pre> <p>Outputs:</p> <pre><code> 13-acetate ctl-54 </code></pre> <p>However, this method is flawed in that it does not allow for words at the beginning or end of the string to be stripped. That's why a negative lookahead and lookbehind is superior when enforcing a boundary condition.</p> <p>If you'd like to be fancy and remove the spacing around the words in an intelligent way, than the following would work:</p> <pre><code>$string =~ s{(?:\G|(\s+))[\d[:punct:]]+(?:$|(\s+))}{ my @spaces = grep defined, $1, $2; pop @spaces; "@spaces" }eg; </code></pre> <p>Outputs:</p> <pre><code> 13-acetate ctl-54 </code></pre>