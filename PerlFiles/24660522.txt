Opening Files for Reading too Large for Memory
<p>I have a simple Perl script that reads files of an expected format, saves some pertinent information to a hash, does some operation with the hash, and then closes the file and moves onto the next file. </p> <p>I need to consider a scenario where my system memory is less than the size of the file arguments, so I thought, why not try it? So I limited my VirtualBox to 1GB of RAM, created a list of 1.5GB, and gave it to it as input. No errors are thrown, it just runs and runs.</p> <p>I took a look at the system memory in use with the "free" command and it shows near 99% of the memory being used and not increasing at all over time. I have some interrupt handling code in my Perl script and when I press that, my vbox becomes unresponsive and I have to restart it. </p> <p><strong>What I need to do</strong> is input several mail lists formatted like</p> <pre><code>1-bob@bob.com </code></pre> <p>and send emails to each email address in the mail list. I keep track of all the email addresses by adding them to a hash. As each address is processed (i.e. added to the hash) I also validate it and send an email to it if it's good.</p> <p>Is there a better way to test this? Am I doing something wrong?</p> <pre><code>use strict; use warnings; my %email_db; while (&lt;&gt;) { chomp; my ($id, $email) = split /-/; push @{ $email_db{$id} }, $email; } </code></pre> <p>The expected number of input files can range from one to five (I'm assuming here - the problem isn't specific) and the example given in terms of file sizes was 100MB system memory and 10GB file sizes. The number of entries in the hash at the end is unknown.</p> <p>Each element of the hash has </p> <pre><code>key = unique ID value = array of email addresses for that ID </code></pre>
<p>Why not use an SDBM hash? It's a hash linked to a file. This is a 'lite' solution which does not require a full database to be installed. Just plain Perl. Key size + data must be less than 1008 bytes. </p> <pre><code>use Fcntl; # Needed by SDBM_File use SDBM_File; # 'myemails' is the name of the file, and 2 files will be created: # myemails.pag and myemails.dir tie(%h, 'myemails', 'filename', O_RDWR|O_CREAT, 0666) or die "Couldn't tie SDBM file 'filename': $!; aborting"; # Now read and change the hash $h{'bob@somewhere.com'} = 1; # This email now exists in hash. print $h{'bob@somewhere.com'}."\n"; ... untie %h; </code></pre> <p>I've used a 500,000 line text file, but the script ran on our linux machine. </p> <p>Plus this file will be there very time you run the script, so you will not be sending to dupe email addresses each day/week/month. </p> <p>To clear out emails, move myemails.dir and myemails.pag to a backup file like: myemails2014-07.dir and myemails-2014-07.pag. </p> <p>EDIT: Anyone know the limit to the number of keys in an SDBM or max size of an SDBM file? Will this work with 1 million email addresses? I have one SDBM file with 10,000 keys. </p>
<p>Here is a solution that uses an SQLite database instead of a Perl hash to store the email information.</p> <p>I can't add any code to send the email or to report the group counts as you haven't specified those parts.</p> <p>As an alternative you may want to wait until all the input files have been read and inserted into the database before sending any emails.</p> <p>It may be easier to debug this code if you remove the <code>TEMPORARY</code> attribute from the <code>emails</code> table so that it doesn't disappear when the program completes.</p> <pre><code>use strict; use warnings; use DBI; my $dbh = DBI-&gt;connect( 'dbi:SQLite:dbname=email_db.sqlite', '', '', { RaiseError =&gt; 1, PrintError =&gt; 0 } ); $dbh-&gt;do(&lt;&lt;END_SQL); CREATE TEMPORARY TABLE emails ( group_id INTEGER, email TEXT, UNIQUE (group_id, email) ) END_SQL my $insert = $dbh-&gt;prepare(&lt;&lt;END_SQL); INSERT INTO emails (group_id, email) VALUES (?, ?) END_SQL $insert-&gt;{RaiseError} = 0; while (&lt;&gt;) { next unless /-/; chomp; my ($group_id, $email) = split /-/; if ($insert-&gt;execute($group_id, $email)) { # Send email } else { my $errstr = $insert-&gt;errstr; die $errstr unless $errstr =~ /UNIQUE constraint failed/; } } my $sort = $dbh-&gt;prepare(&lt;&lt;END_SQL); SELECT group_id, count(email) FROM emails GROUP BY group_id ORDER BY count(email) DESC END_SQL $sort-&gt;execute; while (my $row = $sort-&gt;fetchrow_arrayref) { printf "Group %d (%d emails)\n", @$row; } </code></pre>
<p>I would like to suggest the module <a href="http://search.cpan.org/~cangell/Tie-File-AsHash-0.08/lib/Tie/File/AsHash.pm" rel="nofollow">Tie::File::AsHash</a> or <a href="http://search.cpan.org/~toddr/Tie-File-1.00/lib/Tie/File.pm" rel="nofollow">Tie::File</a>.</p> <p>I have not used either of them myself so do not have any experience to share.</p>