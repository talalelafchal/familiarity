Perl hmac sha256 different than PHP's using pack
<p>I have to create a hash in Perl using SHA256 HMAC like this PHP example:</p> <pre><code>&lt;?php $key = pack('H*','THIS_IS_KEY'); $str ='THIS IS DE ENCODED STRING'; echo strtoupper(hash_hmac('sha256',$str, $key)); ?&gt; </code></pre> <p>I get: 601B7C81389A37FC83C05275138280E8788CF9108528BC75D5C09CEA75904D5E</p> <p>But if I do the same in a Perl script:</p> <pre><code>use Digest::SHA qw(hmac_sha256_hex); my $key = pack('H*','THIS_IS_KEY'); my $str ='THIS IS DE ENCODED STRING'; print uc(hmac_sha256_hex($str, $key)); exit; </code></pre> <p>I get: C683FD81DEFB7CDA3C031F5280682E80851FDC246310DB8C44057BC6364454E0</p> <p>If I don't pack key neither Perl or PHP I get the same result, unfortunately I have to generate Perl exactly the same result as the example using PHP "pack".</p> <p>I would appreciate if someone can help me find a solution.</p> <p>Thanks in advance</p> <p>Welch</p>
<p>The code doesn't understand how the <code>pack()</code> function actually works. The key is what is different between the PHP and Perl scripts, so let's reduce it to just that calculation. Here's a simpler PHP program:</p> <pre><code>&lt;?php $key = pack('H*', 'THIS_IS_KEY'); echo $key; ?&gt; </code></pre> <p>If we echo that into <code>php | hexdump</code>, we get:</p> <pre><code>00000000 0000 0000 000e </code></pre> <p>Here's a similar Perl program:</p> <pre><code>my $key = pack('H*', 'THIS_IS_KEY'); print $key; </code></pre> <p>And if we echo that into <code>perl | hexdump</code>, we get:</p> <pre><code>0000000 2cd1 cff2 204e </code></pre> <p>Those are two significantly different keys. In both cases, the <code>pack()</code> call is using an <code>H*</code> format, which means that <code>pack()</code> is expecting to receive an unbounded hex string (a string containing hexadecimal characters 0-9A-F). The problem is that <code>'THIS_IS_KEY'</code> is not a sequence of hex values (with the exception of the 'E'). If you run the test code through the <code>php</code> binary itself, you'll also see these lines:</p> <pre><code>PHP Warning: pack(): Type H: illegal hex digit T in - on line 2 PHP Warning: pack(): Type H: illegal hex digit H in - on line 2 PHP Warning: pack(): Type H: illegal hex digit I in - on line 2 PHP Warning: pack(): Type H: illegal hex digit S in - on line 2 PHP Warning: pack(): Type H: illegal hex digit _ in - on line 2 PHP Warning: pack(): Type H: illegal hex digit I in - on line 2 PHP Warning: pack(): Type H: illegal hex digit S in - on line 2 PHP Warning: pack(): Type H: illegal hex digit _ in - on line 2 PHP Warning: pack(): Type H: illegal hex digit K in - on line 2 PHP Warning: pack(): Type H: illegal hex digit Y in - on line 2 </code></pre> <p>Note that it's every character except for 'E' that throws an error, and note that in your hex output, every character gets converted to a null nibble <em>except</em> for 'E'. Perl actually tries to make something of nonsense characters and converts them to some sort of representation it can use (e.g. 'K' becomes 4, which kind of makes sense since it's the 5th character after F, which would correspond to 14 in hex). Anyway, it's undefined what the behavior should be passed a string that doesn't match the format.</p> <p>So, what are your solutions?</p> <p>Well, if you really need to keep <code>'THIS_IS_KEY'</code> as your key, then the equivalent Perl key is <code>'000000000E0'</code>. If your example key is only a representation of the key value, generally replace the non-hex characters from the PHP key with '0' in the Perl script. PHP appears to be treating non-hex characters as '0' in the hex string.</p> <p>As for a real solution, either convert your string key to a hex representation or use a straight hex value as your key before passing to <code>pack()</code>. I don't know the details of the key selection or why the "key" is being packed anyway. The SHA256 portion of the code just takes a byte-string as the key. It could be a straight ASCII key as far as it's concerned, as long as both scripts use the same sequence of bytes.</p>