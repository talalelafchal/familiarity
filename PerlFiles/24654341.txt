Can someone explain the logic of the recursion code and when it's best to use?
<p>I'm learning perl and I want to understand the logic better so I can improve in programming. I was wondering if anyone could explain it part by part. I think I have a good grasp of what's happening instead of this line <code>$num = $val * fact($val-1);</code> ? </p> <pre><code>#!/usr/bin/perl use warnings; use strict; print "Enter in a number\n"; my $input = &lt;&gt;; my $num = fact($input); print "The factorial of $input is $num\n"; sub fact { my $val = $_[0]; if ( $val &gt; 1 ) { $num = $val * fact( $val - 1 ); } else { $num = 1; } } exit; </code></pre>
<p>As a wise man once said: "To understand recursion, you must first understand recursion."</p> <p>Anyway - there are a bunch of algorithms that can work recursively. Factorial is one.</p> <p>A factorial of 5! = 5*4*3*2*1. This makes it quite a good case for recursion, because you could also say it's 5 * 4!. This is what the code is doing. When you supply a number to the subroutine 'fact' it calculates the factorial of one number lower, then multiplies by the original number. Except when it gets a value of 1 or less. </p> <p>So give your fact "3" to start off. (same applies to bigger numbers, but the example is longer!)</p> <ul> <li>It sets val to '3'. </li> <li>Then, because '3 > 1' it goes and gets 'fact(2)'. <ul> <li>which because 2 > 1, goes and runs 'fact(1)'. <ul> <li>which because it <em>isn't</em> >1, returns '1'. </li> </ul></li> <li>which is returned to the 'fact(2)' sub, multiple by '2' (giving 2) and returned as a result</li> </ul></li> <li>to the 'fact(3) sub, which multiplies the returned result by 3, to give 6.</li> </ul> <p>Personally I find recursion is a good way to confuse anyone who's reading your code. It's suitable for problems that are implicitly recursive - such as factorials, fibonnaci sequences and directory traversals - and generally should be avoided otherwise. </p>
<p>The first line is the shebang, which specifies which version of Perl to use.</p> <pre><code>#!/usr/bin/perl </code></pre> <p>The next two lines will help you catch mistakes in your program and make sure you are coding properly. See <a href="http://stackoverflow.com/questions/8023959/why-use-strict-and-warnings">Why use strict and warnings?</a></p> <pre><code>use warnings; use strict; </code></pre> <p><code>print</code> will <a href="http://perldoc.perl.org/functions/print.html" rel="nofollow">print</a> the message in quotes.</p> <pre><code>print "Enter in a number\n"; </code></pre> <p>The diamond operator, <code>&lt;&gt;</code>, used in this context, is the same as calling <a href="http://perldoc.perl.org/functions/readline.html" rel="nofollow">readline</a>. It will read the input from <code>STDIN</code>.</p> <pre><code> my $input=&lt;&gt;; </code></pre> <p>The next line is calling the <a href="http://perldoc.perl.org/perlsub.html" rel="nofollow">subroutine</a> <code>fact</code> with <code>$input</code> as an argument.</p> <pre><code>my $num= fact($input); </code></pre> <p>Printing the result. <code>$input</code> and <code>$num</code> will be <a href="http://perldoc.perl.org/perlsub.html" rel="nofollow">interpolated</a> because you are using double quotes.</p> <pre><code> print "The factorial of $input is $num\n"; </code></pre> <p>Finally, the part you are most interested in.</p> <pre><code>sub fact{ my $val = $_[0]; if ($val &gt; 1) { $num = $val * fact($val-1); } else { $num = 1; } } </code></pre> <p>The first line of this subroutine <code>my $val = $_[0];</code>, is setting <code>$val</code> equal to the value you call it with. The first time through, you call is with <code>$input</code>, so <code>$val</code> will be set to that value.</p> <p>Next, we have this <code>if else</code> statement. Suppose you enter <code>5</code> on the command line, so <code>$input</code> was <code>5</code>. In that case, it is greater than <code>1</code>. It will execute the statement <code>$num = $val * fact($val-1);</code>. Seeing as the value of <code>$val</code> is <code>5</code>, it would be the same as calling <code>$num = 5 * fact(4);</code>.</p> <p>If we were going to continue looking at the what code is executing, you'll see that now we are calling <code>fact(4);</code>. Since <code>4 &gt; 1</code> it will pass the if statement again, and then call <code>fact(3)</code>.</p> <p>Each time we are multiplying the number by that number minus one, such as <code>$val = 5 * 4 * 3 * 2 * 1</code>.</p> <p>From <a href="http://perldoc.perl.org/perlsub.html" rel="nofollow">perlsub</a></p> <blockquote> <p>If no return is found and if the last statement is an expression, its value is returned. If the last statement is a loop control structure like a foreach or a while , the returned value is unspecified. The empty sub returns the empty list.</p> </blockquote> <p>So this is why we don't have to <code>return $num</code> at the end of your <code>fact</code> subroutine, but it may be useful to add to increase readability.</p> <hr> <p>Just to break down what this is doing.</p> <pre><code>$num = 5 * fact(4); </code></pre> <p><code>fact(4)</code> is equivalent to <code>4 * fact(3)</code>.</p> <pre><code>$num = 5 * (4 * fact(3)); </code></pre> <p><code>fact(3)</code> is equivalent to <code>3 * fact(2)</code>.</p> <pre><code>$num = 5 * (4 * (3 * fact(2))); </code></pre> <p><code>fact(2)</code> is equivalent to <code>2 * fact(1)</code>.</p> <pre><code>$num = 5 * (4 * (3 * (2 * fact(1))); </code></pre> <p><code>fact(1)</code> is equivalent to <code>1</code>.</p> <pre><code>$num = 5 * (4 * (3 * (2 * 1)); </code></pre> <hr> <p>Search <code>recursion</code> on <a href="https://www.google.com/search?q=recursion" rel="nofollow">Google</a> for another example (did you mean <a href="https://www.google.com/search?q=recursion" rel="nofollow">recursion?</a>).</p>
<p>The reason you're having trouble learning from that code is because it's <strong>poorly</strong> designed:</p> <ol> <li>The subroutine needlessly uses a lexical variable (<code>$num</code>) from outside the subroutine. <em>Don't do this!</em></li> <li>The subroutine relies on implied return values instead of specifying <code>return</code> explicitly.</li> </ol> <p>Fixing these issues clarifies the functionality a lot:</p> <pre><code>sub fact { my $val = $_[0]; if ( $val &gt; 1 ) { return $val * fact( $val - 1 ); } else { return 1; } } </code></pre> <p>And then using a ternary to reduce more:</p> <pre><code>sub fact { my $val = shift; return $val &gt; 1 ? $val * fact( $val - 1 ) : 1; } </code></pre> <p>As for when recursion is good to use? The answer is when you need it. </p> <p>The factorial is an obvious example of where recursion could be used, but it's better to avoid using it when one has a choice. This is for both readability and functional reasons:</p> <pre><code>sub fact { my $val = shift; my $fact = 1; while ($val &gt; 1) { $fact *= $val--; } return $fact; } </code></pre>