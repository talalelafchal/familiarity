Perl not interpreting value in ticks, calling it undefined value
<p>I am writing a subroutine that uses the <a href="https://metacpan.org/module/XML%3a%3aSimple" rel="nofollow"><code>XML::Simple</code></a> module to pull out information from a config file.</p> <p>The XML file has the following structure</p> <pre><code>&lt;main&gt; &lt;server hostname="blahblah" ... more_attributes="more"/&gt; &lt;server etc./&gt; &lt;server etc./&gt; &lt;/main&gt; </code></pre> <p>The code works fine. It puts the XML data into a nested hash as expected. But when I want to isolate one server from the rest using the current system's <code>hostname</code> I run into issues.</p> <p>I think this line</p> <pre><code>my %systemHash = %{$xmlObject-&gt;{SERVER}-&gt;{`hostname`}}; </code></pre> <p>should insert the current machine's hostname into the last set of brackets. However when execute the code I get</p> <pre><code>Can't use an undefined value as a HASH reference </code></pre>
<p><strong>You should use <a href="http://search.cpan.org/perldoc?Data%3a%3aDumper" rel="nofollow">Data::Dumper</a> to dump the output from <a href="http://search.cpan.org/perldoc?XML%3a%3aSimple" rel="nofollow">XML::Simple</a></strong> like this:</p> <pre><code>use Data::Dumper; # Retrieve your data structure via XML::Simple. Then... print Dumper $xmlObject; </code></pre> <p>You will see that <strong>it's not creating the structure that you expect</strong>, which is why you're getting the <code>Can't use an undefined value as a HASH reference</code> message. That message means that either <code>$xmlObject</code> is undefined, or that <code>$xmlObject-&gt;{SERVER}</code> is undefined. <a href="http://perldoc.perl.org/perldiag.html" rel="nofollow">perldiag</a> describes the error as:</p> <blockquote> <p>A value used as either a hard reference or a symbolic reference must be a defined value. This helps to delurk some insidious errors.</p> </blockquote> <p>You are treating an undefined value as a hash reference. And as mentioned, cause is probably that the structure XML::Simple produced differs from your expectations.</p> <p><strong>XML::Simple isn't as simple as its name implies, nor as one would hope.</strong> And currently its own documentation discourages its use. There are configuration options which help to normalize the structure it produces, but without seeing more of your XML, and the code you're using to read it, that's about as detailed an explanation as I can give. The best advice with respect to how you're parsing your XML is to use a more reliable module. Two very common and well-regarded alternatives are <a href="http://search.cpan.org/perldoc?XML%3a%3aTwig" rel="nofollow">XML::Twig</a> and <a href="http://search.cpan.org/perldoc?XML%3a%3aLibXML" rel="nofollow">XML::LibXML</a>.</p> <p><strong>There's an additional bug in your code</strong>, that you will encounter next: The hostname returned by your system call to '<code>hostname</code>' has a newline at the end, so you're asking for a hash key named:</p> <pre><code>"somehost\n" </code></pre> <p>...when you really want just "<code>somehost</code>". I suspect you're not counting on that. Minimally, you'll need something like this:</p> <pre><code>chomp( my $h = `hostname` ); my %systemHash = %{$xmlObject-&gt;{SERVER}-&gt;{$h}}; </code></pre> <p>Or this:</p> <pre><code>use Sys::Hostname; my %systemHash = %{$xmlObject-&gt;{SERVER}-&gt;{hostname()}; </code></pre> <p>I would prefer the latter, as it's more portable, and the module <a href="http://search.cpan.org/perldoc?Sys%3a%3aHostname" rel="nofollow">Sys::Hostname</a> <a href="http://perldoc.perl.org/perlmodlib.html#Standard-Modules" rel="nofollow">comes with Perl</a>, so you already have it on your system. Its output will not require chomping.</p>
<p>First of all, <em>please</em> don't use <a href="https://metacpan.org/module/XML%3a%3aSimple" rel="nofollow"><code>XML::Simple</code></a>. Its own documentation says this</p> <blockquote> <p>The use of this module in new code is discouraged. Other modules are available which provide more straightforward and consistent interfaces. In particular, XML::LibXML is highly recommended.</p> <p>The major problems with this module are the large number of options and the arbitrary ways in which these options interact - often with unexpected results.</p> </blockquote> <p>You should also check the result of any subroutine call or shell command using <a href="https://metacpan.org/module/Data%3a%3aDump" rel="nofollow"><code>Data::Dump</code></a>. It would look like this</p> <pre><code>perl -MData::Dump -E'dd `hostname`' </code></pre> <p>which on my system shows</p> <pre><code>"Samurai-U\n" </code></pre> <p>Hopefully you now see the problem? The string returned by the backticks has a trailing newline character, and there is element in your <code>$xmlObject</code> hash that has a key like that. You can fix it with</p> <pre><code>chomp(my $host = `hostname`) </code></pre> <p>after which you could write</p> <pre><code>my %systemHash = %{ $xmlObject-&gt;{SERVER}{$host} } </code></pre> <p>Finally, it is wasteful to copy all of the first level of a hash as you do here</p> <pre><code>my %systemHash = %{$xmlObject-&gt;{SERVER}-&gt;{`hostname`}} </code></pre> <p>You don't go on to show what you want to use this information for, but in general it is far better to extract a hash <em>reference</em>, using</p> <pre><code>chomp( my $hostname = `hostname` ); my $systemHash = $xmlObject-&gt;{SERVER}{$hostname}; </code></pre> <hr> <p><strong>Update</strong></p> <p>It would be very much better to use a proper XML-parsing module.</p> <p>Here is an example solution using <a href="https://metacpan.org/module/XML%3a%3aLibXML" rel="nofollow"><code>XML::LibXML</code></a></p> <pre><code>use strict; use warnings; use 5.010; # For 'say' use XML::LibXML; my ($xml_file) = @ARGV; my $xml = XML::LibXML-&gt;load_xml(location =&gt; $xml_file); my @servers = $xml-&gt;findnodes('/main/server'); my @server_names = map $_-&gt;findvalue('@hostname'), @servers; say "- $_" for @server_names; </code></pre> <p><strong>input file</strong></p> <pre><code>&lt;main&gt; &lt;server hostname="server1" more_attributes="more"/&gt; &lt;server hostname="server2" more_attributes="more"/&gt; &lt;server hostname="server3" more_attributes="more"/&gt; &lt;/main&gt; </code></pre> <p><strong>output</strong></p> <pre><code>- server1 - server2 - server3 </code></pre>