How does this obfuscated Perl script work?
<p>Someone asked me to help him de-obfuscate the following Perl script that was sent to him, suspecting it was connecting to some external servers etc. However, I'm not a Perl expert, so I could not really understand all of what's going on here. </p> <p>According to him, the script should process an input.txt file and from it generate and HTML file, with some command line parameters <code>A, B, C, ...</code>. So you can run the script with:</p> <pre><code>MAGIC_NO_JAVASCRIPT=1 perl ./179252S0 gghkla5673lju-magic input.txt 1 A B C &gt; output.html </code></pre> <p>The obfuscated Perl script 179252S0 only contain the following line, followed by a ~1 MB of lines with a varying number of spaces and tabs on each line. I'll only give the 1st line, but you can download and look at the whole piece <a href="http://tinyurl.com/of933bh" rel="nofollow">here</a>.</p> <p>The first line read as follows:</p> <pre><code>$_=&lt;&lt;'';y;\r\n;;d;$_=pack'b*',$_;$_=eval;$@&amp;&amp;die$@;$_ </code></pre> <p>What is that doing, and how can I understand it? </p> <p>I actually managed to see part of the code by replacing <code>$_=eval</code> with <code>print $_</code>, but that code was also obfuscated.</p> <p><strong>EDIT:</strong> Thanks to Slade's analysis, and some manual labor, I can conclude that the remainder of this script was obfuscated with <a href="http://search.cpan.org/~jjore/Acme-Floral-1.04/lib/Acme/Floral.pm" rel="nofollow">Acme::Floral</a> using something like: </p> <pre><code>perl -MAcme::Floral my_script.pl &gt; floral_script.pl </code></pre> <p>and the network calls are made to: </p> <ul> <li>a) a webtool site to provide statistics and a page counter built-in to the resulting <code>*.html</code> page. </li> <li>b) another site to grab image files for html loading.</li> </ul> <p>But due to the last obfuscation, we cannot completely rule out that something else is happening, without a large amount of additional work.</p> <hr> <p><sub>PS. I left the original name and the cryptic "magic" argument in, as I think the de-obfuscation algorithm depend also on that.</sub></p>
<p>Let's start by cleaning up the obfuscated syntax of the first line. <code>$_=&lt;&lt;'';</code> becomes</p> <pre><code>$_ = &lt;&lt;''; </code></pre> <p>Which is just a heredoc without a delimiter; it reads everything below the line into the $_ variable.</p> <p><code>y;\r\n;;d;</code> becomes</p> <pre><code>tr/\r\n//d; </code></pre> <p>Which is just the transliteration operator using semicolons as delimiters and the sed-like <code>y///</code> form, which means the exact same thing as <code>tr///</code>. The d flag means characters without replacements will be deleted, and tr operates on $_ by default, so this statement just removes DOS-style line endings from the contents of $_.</p> <p><code>$_=pack'b*',$_;</code> becomes</p> <pre><code>$_ = pack('b*', $_); </code></pre> <p>Which takes the contents of $_ and treats it as a bitstring, turning all that whitespace into a text string of Perl code.</p> <p><code>$_=eval;$@&amp;&amp;die$@;$_</code> becomes</p> <pre><code>$_ = eval; $@ &amp;&amp; die $@; $_ </code></pre> <p>The first line here uses the "string eval" form of <code>eval</code>. It'll take the code that was transliterated and unpacked, then parse and execute it. </p> <p><code>$@ &amp;&amp; die $@;</code> is just a silly way to write <code>die $@ if $@;</code>. $@ is the eval error variable; if the code failed to parse and execute correctly, it will hold a true value, so the script will die with that error if there was one. </p> <p>The lone <code>$_</code> after that will be the last statement the interpreter sees. It got assigned the return value of the eval statement, which will be true if and only if the code given to <code>eval</code> parsed successfully. Perl modules require some true value to be the last statement in the file (usually just a <code>1;</code>). Putting the <code>$_</code> here will indicate a module load failure if something went wrong with the deobfuscation.</p> <p>Whether or not your friend was right about it connecting to external servers is much more difficult to determine. A couple of searches through it seems to indicate that it isn't importing any networking modules (the only <code>use</code> statements are <code>use strict 'refs';</code>, and there are no <code>requires</code>), and it doesn't appear to be using any suspicious built-ins (no <code>eval</code>s beyond the one in the first line; no functions that interact with the filesystem besides an <code>open</code> that presumably is used to process the input text file; none of Perl's built-in networking functions (all of which begin with 'set', 'get', or 'end'); and none of Perl's socket functions. </p> <p>Of course there's no guarantee that the JavaScript it's generating is benign, but the Perl script doesn't appear to be accessing the network. Provided the script isn't doing anything obviously harmful when executed, your friend could try using a tool like Wireshark to find any malicious networking that would otherwise require a grueling audit to discover.</p>