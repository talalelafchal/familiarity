Splitting Two Characters In a String - Perl
<p>I'm trying to split this string. Here's the code: </p> <pre><code> my $string = "585|487|314|1|1,651|365|302|1|1,585|487|314|1|1,651|365|302|1|1,656|432|289|1|1,136|206|327|1|1,585|487|314|1|1,651|365|302|1|1,585|487|314|1|1,651|365|302|1|1%656|432|289|1|1%136|206|327|1|1%654|404|411|1|1"; my @ids = split(",", $string); </code></pre> <p>What I want is to split only <code>%</code> and <code>,</code> in the string, I was told that I could use a pattern, something like this? <code>/[^a-zA-Z0-9_]/</code></p>
<p>Character classes can be used to represent a group of possible single characters that can match. And the <code>^</code> symbol at the beginning of a character class negates the class, saying "Anything matches except for ...." In the context of <code>split</code>, whatever matches is considered the delimiter.</p> <p>That being the case, `[^a-zA-Z0-9_] would match any character except for the ASCII letters 'a' through 'z', 'A' through 'Z', and the numeric digits '0' through '9', plus underscore. In your case, while this would correctly split on "," and "%" (since they're not included in a-z, A-Z, 0-9, or _), it would mistakenly also split on "|", as well as any other character not included in the character class you attempted.</p> <p>In your case it makes a lot more sense to be specific as to what delimiters to use, and to <em>not</em> use a negated class; you want to specify the exact delimiters rather than the entire set of characters that delimiters cannot be. So as <strong>mpapec</strong> stated in his comment, a better choice would be <code>[%,]</code>.</p> <p>So your solution would look like this:</p> <pre><code>my @ids = split/[%,]/, $string; </code></pre> <p>Once you split on '<code>%</code>' and '<code>,</code>', you'll be left with a bunch of substrings that look like this: <code>585|487|314|1|1</code> (or some variation on those numbers). In each case, it's five positive integers separated by '<code>|</code>' characters. It seems possible to me that you'll end up wanting to break those down as well by splitting on '<code>|</code>'.</p> <p>You could build a single data structure represented by list of lists, where each top level element represents a <code>[,%]</code> delimited field, and consists of a reference to an anonymous array consisting of the pipe-delimited fields. The following code will build that structure:</p> <pre><code>my @ids = map { [ split /\|/, $_ ] } split /[%,]/, $string; </code></pre> <p>When that is run, you will end up with something like this:</p> <pre><code>@ids = ( [ '585', '487', '314', '1', '1' ], [ '651', '365', '302', '1', '1' ], # ... ); </code></pre> <p>Now each field within an ID can be inspected and manipulated individually.</p> <p>To understand more about how character classes work, you could check <a href="http://perldoc.perl.org/perlrequick.html#Using-character-classes" rel="nofollow">perlrequick</a>, which has a nice introduction to character classes. And for more information on <code>split</code>, there's always <a href="http://perldoc.perl.org/functions/split.html" rel="nofollow">perldoc -f split</a> (as mentioned by <strong>mpapec</strong>). <code>split</code> is also discussed in chapter nine of the O'Reilly book, Learning Perl, 6th Edition.</p>