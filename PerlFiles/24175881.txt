perl/awk/sed/bash scripting: Multiple indent levels with multiple markers
<p>I'm trying to several levels indent a file based on a marker. The marker argument only signifies that the next word on the same line is a second level marker. Based on this second level marker, I'd like to indent everything up until the next occurrence of that second level marker.</p> <p>The reason I'm trying to do this is for debugging another application. I'm printing out data at the top and before returns of every function (and several things in between).</p> <p>Thanks in advance!</p> <p>Usage would be something like this: ./script.sh file marker</p> <p><b>Example data:</b><br></p> <pre><code>data thismarker m1 thismarker m2 data data thismarker m2 data data thismarker m1 data </code></pre> <p><b>Desired output of ./script.sh file thismarker:</b></p> <pre><code>data data thismarker m1 thismarker m2 data data thismarker m2 data data thismarker m1 data </code></pre> <p>Here is what I have so far. I'm currently using awk but I'll be happy with anything that works. It doesn't work with multiple levels though and I don't know how to use mymarkertwo instead of what I'm currently doing - hard coding hcmarkertwo.</p> <pre><code>#!/bin/bash file_path=$1 markerone=$2 cat ${file_path} | awk -v mone="$markerone" ' BEGIN { get_out=0; myfunc=""; } { if ( /${mone}/ ) { mymarkertwo = $2 } if ( /hcmarkertwo/ ) { get_out=0 print $0 getline do { if ( /hcmarkertwo/ ) { get_out = 1 print $0 getline } else { $0 = "\t"$0 print $0 getline } } while ( get_out == 0 ) } print $0 } ' </code></pre>
<pre><code>$ cat tst.awk $1 == marker { if ($2 == markerId[depth]) { --depth nextIndent = --indent } else { markerId[++depth] = $2 nextIndent = indent + 1 } } { printf "%*s%s\n",indent,"",$0 indent = nextIndent } </code></pre> <p>.</p> <pre><code>$ cat file data thismarker m1 thismarker m2 data thismarker m1 data data thismarker m1 data thismarker m2 data data thismarker m1 data </code></pre> <p>.</p> <pre><code>$ awk -v marker="thismarker" -f tst.awk file data thismarker m1 thismarker m2 data thismarker m1 data data thismarker m1 data thismarker m2 data data thismarker m1 data </code></pre> <p>Note that I modified your sample input file to show a case where you have <code>m1</code> within the scope of <code>m2</code> within the scope of a previous <code>m1</code> as that can typically happen with function calls and it makes a solution more complicated than if it doesn't need to be accounted for. The currently posted <code>sed</code> solution will fail given that input, I don't have <code>perl</code> on my current UNIX box and I couldn't begin to guess at what the currently posted perl incantation says so I've no idea if that'd work or not - try it if you have perl.</p>
<pre><code>sed '/thismarker m1/,/thismarker m1/{ /thismarker m1/!s/^/ / /thismarker m2/,/thismarker m2/{ /thismarker m2/!s/^/ / } }' YourFile </code></pre> <p>same concept if several level (just add a new section before the end of last level)</p> <pre><code>/thismarker mX/,/thismarker mX/{ /thismarker mX/!s/^/ / } </code></pre> <p>Explanation:</p> <p>Between 2 marker of same reference (<code>/thismarker mX/,/thismarker mX/</code>) [marker are not on the same line, it's mandatory but request specify it by it's structure], for each line without the specific marker (<code>/thismarker mX/ !</code>), substitute the beginning of the line with 3 space (<code>s/^/ /</code>). The second level is done by the same way but inside the "loop" of first level. A thrd level should do the same inside the "loop" of second level, etc ...</p>
<p>Using a perl one-liner:</p> <pre><code>perl -lne ' ($m) = $_ =~ /thismarker (\S+)/; pop(@M), $m = "" if $m &amp;&amp; @M &amp;&amp; $M[-1] eq $m; print +(" " x @M), $_; push @M, $m if $m; ' file.txt </code></pre> <h3>Explanation:</h3> <p><strong>Switches</strong>: </p> <ul> <li><code>-l</code>: Enable line ending processing, specifies line terminator</li> <li><code>-n</code>: Creates a <code>while(&lt;&gt;){..}</code> loop for each line in your input file. </li> <li><code>-e</code>: Tells <code>perl</code> to execute the code on command line. </li> </ul> <p><strong>Code</strong>:</p> <ul> <li><code>$m</code> contains current line's matched marker: <code>'m1'</code> or <code>'m2'</code></li> <li><code>@M</code> contains a stack of matched markers.</li> </ul>
<p>You need to manage a stack of levels in order to process this properly. In pseudocode</p> <pre><code>line &lt;- file.read if line.words[0] == "thismarker" if line == stack.top stack.pop print(indent=stack.size) line else print(indent=stack.size) line stack.push(line) endif else print(indent=stack.size) line endif </code></pre>