splice doesnt work well in loop in perl
<p>I am trying to understand splice. I want to remove all the elements in array one by one using splice. But still the output i get is weird. I am not able to understand it. Could somebody please explain:</p> <p><strong>Code</strong> </p> <pre><code>my @arr1=(1,2,3,4,5,6,7,8,9,10); foreach my $num(@arr1) { print $_ foreach (@arr1); print "\n Popping $num\n"; print "[0] is $arr1[0] and current element is $num \n"; splice @arr1,0,1; print "\n"; } </code></pre> <p><strong>Output:</strong></p> <pre><code> 12345678910 Popping 1 [0] is 1 and current element is 1 2345678910 Popping 3 [0] is 2 and current element is 3 345678910 Popping 5 [0] is 3 and current element is 5 45678910 Popping 7 [0] is 4 and current element is 7 5678910 Popping 9 [0] is 5 and current element is 9 </code></pre>
<p>you are changing the array whilst looping through it. the foreach goes form [0] to [1] to [2]. when you have spliced the [0], it goes to [1] which was the original [2]. when you have spliced that, it goes to [2] which now is the original [4] since you have taken the first ones away.</p> <p>hope that clears it up a little.</p> <p>you can avoid using @arr1 as the loop controller:</p> <pre><code>my @arr1=(1,2,3,4,5,6,7,8,9,10); my $max = @arr1; for (my $i=0; $i&lt;$max; $i++) { print $_ foreach (@arr1); my $num = splice @arr1,0,1; print "\n Popping $num\n"; print "[0] is $arr1[0] and current element is $num \n"; print "\n"; } </code></pre>
<p>The <a href="http://perldoc.perl.org/perlsyn.html#Foreach-Loops" rel="nofollow">foreach</a> creates a list of the original 10 array elements. You should use a <code>while</code> to modify an array.</p> <pre><code>use warnings; use strict; my @arr1=(1,2,3,4,5,6,7,8,9,10); while (@arr1) { my $num = $arr1[0]; print $_ foreach (@arr1); print "\n Popping $num\n"; print "[0] is $arr1[0] and current element is $num \n"; splice @arr1,0,1; print "\n"; } </code></pre>
<p>Don't modify the array over which you are iterating using foreach.</p> <p>Often, The solution is usually <code>grep</code>. For example, the following processes the elements in <code>@todo</code>, leaving the ones that were unsuccessfully processed in the array.</p> <pre><code>sub process { ... return 0 if error; ... return 1; } @todo = grep { !process($_) } @todo; </code></pre> <p>In this case, replace <code>foreach</code> with <code>while</code>.</p> <pre><code>my @queue = 1..10; while (@queue) { my $num = shift(@queue); print "Current element is $num\n"; } </code></pre>