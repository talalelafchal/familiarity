Unable to substitute 0 with L and 1 with H in a Perl string
<p>I am grappling with just a simple piece of code and unable to troubleshoot my way through. All I am trying to do is substitute 0 with L and 1 with H for the binary equivalent of a hex number. I need to get the hex number from the user, convert it to binary, scan through each bit of the binary and replace 0's with L's and 1's with H's. Simple requirement yet finding it hard to resolve. </p> <pre><code>use warnings; use strict; my $i2c = "80"; my $binary_string = sprintf "%08b", hex($i2c); print "$binary_string \n"; my $charz = sprintf "%s", $binary_string; print "$charz\n"; for (my $i=1; $i &lt; @charz; $i++) { if (substr($charz, $i) eq "0") substr($charz, $i) = "L"; else if (substr($charz, $i) eq "1") substr($charz, $i) = "H"; } </code></pre> <p>My output should be like this:</p> <pre><code>input hex = 80 </code></pre> <p>Therefore binary will be <code>10000000</code>. So my output has to be <code>HLLLLLLL</code>.</p> <p>I am not able to get this simple output. I tried a wide range of things to make it work (regex match and replace substring, index etc). I am not sure if I am making a basic error somewhere. Kindly help me out on this one. </p> <p>The error that I get is this:</p> <pre><code>syntax error at temp3.pl line 12, near ") substr" Execution of temp3.pl aborted due to compilation errors. </code></pre>
<p>Running your code as given, I get the error 'Global symbol "@charz" requires explicit package name at string line 11'.</p> <p>And that's true, because you're using the array @charz (in your <code>for</code> loop condition) without defining it anywhere. The fact that you don't mention this error in your question makes me think that you're not showing us the code that you're actually running. At the very least, you don't have <code>use strict</code> turned on in your real code.</p> <p>If I comment out the <code>use strict</code> line, I get the syntax error that you mentioned. That's caused by the missing braces that other people have pointed out. We can also tidy things up a bit by using <code>elsif</code> in place of <code>else if</code>.</p> <pre><code>for (my $i=1; $i &lt; @charz; $i++) { if (substr($charz, $i) eq "0") { substr($charz, $i) = "L"; } elsif (substr($charz, $i) eq "1") { substr($charz, $i) = "H"; } } </code></pre> <p>Now we get to a situation where the code runs, but nothing changes. That's because of that <code>$i &lt; @charz</code>. The array is empty, so your loop doesn't run and nothing changes.</p> <p>We can fix that by changing the foreach loop to this:</p> <pre><code>for (my $i=0; $i &lt; length$charz; $i++) { ... } </code></pre> <p>But that <strong>still</strong> doesn't work because of the <code>substr</code> issues that others have mentioned.</p> <p>So what you were actually trying to write (I think) was this:</p> <pre><code>for (my $i=0; $i &lt; length$charz; $i++) { if (substr($charz, $i, 1) eq "0") { substr($charz, $i, 1) = "L"; } elsif (substr($charz, $i, 1) eq "1") { substr($charz, $i, 1) = "H"; } } </code></pre> <p>This works as expected. But you're doing far too much work here. You should have used <code>tr///</code> :-)</p>
<p>Perl <code>if</code> statements always require <code>{</code> and <code>}</code> around the action:</p> <pre><code>if (substr($charz, $i) eq "0") { substr($charz, $i) = "L"; } else if (substr($charz, $i) eq "1") { substr($charz, $i) = "H"; } </code></pre> <p>(You should probably look at the enclosing loop indexes too; arrays index from 0 in Perl unless you really like to live dangerously. And, while we're deconstructing the code, as <a href="http://stackoverflow.com/users/725418/tlp">TLP</a> commented, the assignment to <code>$charz</code> via <code>sprintf</code> is a long-winded way of writing <code>$charz = $binary_string;</code>!)</p> <p>Also, as <a href="http://stackoverflow.com/users/152948/hobbs">hobbs</a> points out in a <a href="http://stackoverflow.com/questions/24500553/perl-unable-to-subsitute-0-with-l-and-1-with-h-in-a-string#comment37929542_24500579">comment</a>, the <code>substr()</code> operator needs a third argument to work as you want it to:</p> <pre><code>if (substr($charz, $i, 1) eq "0") { substr($charz, $i, 1) = "L"; } else if (substr($charz, $i, 1) eq "1") { substr($charz, $i, 1) = "H"; } </code></pre> <p>Or you could use:</p> <pre><code>substr($charz, $i, 1) = "L" if (substr($charz, $i, 1) eq "0"); substr($charz, $i, 1) = "H" if (substr($charz, $i, 1) eq "1"); </code></pre> <p>Or you could avoid the explicit loop and use:</p> <pre><code>$charz =~ s/1/H/g; $charz =~ s/0/L/g; </code></pre> <p>Or you could use:</p> <pre><code>$charz =~ y/01/LH/; </code></pre> <p>Or you could spell <code>y</code> as <code>tr</code>:</p> <pre><code>$charz =~ tr/01/LH/; </code></pre> <p>Or all the other ways you can do it in Perl...</p> <p>Of the mechanisms shown, I'd use <code>y</code> or <code>tr</code> (probably <code>tr</code> is preferred; <code>y</code> is for die-hard <code>sed</code> programmers); it does it all in one line: no fuss, no muss.</p>
<p>Try the following regexp:</p> <pre><code>$charz =~ s/0/L/g; $charz =~ s/1/H/g; </code></pre>
<p>Just use <a href="http://perldoc.perl.org/functions/tr.html" rel="nofollow"><code>tr</code></a>:</p> <pre><code>use warnings; use strict; my $i2c = "80"; my $binary_string = sprintf "%08b", hex($i2c); print "$binary_string \n"; $binary_string =~ tr/10/HL/; print "$binary_string\n"; </code></pre> <p>Outputs:</p> <pre><code>10000000 HLLLLLLL </code></pre>
<p>Using <code>tr//</code> is probably the best solution, as has been noted. I just wanted to add this bitwise comparison method, since you are using bits, and its fun:</p> <pre><code>use strict; use warnings; my $bin = shift // 0x80; # take arg or default my $str; for (my $n = 1; $n &lt;= $bin; $n *= 2) { # $n -&gt; 1, 2, 4, ... $str .= $bin &amp; $n ? 'H' : 'L'; # check bits } $str = reverse $str; # well... printf "Org: %b\nNew: $str\n", $bin; </code></pre> <p><strong>Some test runs:</strong></p> <pre><code>$ foo.pl Org: 10000000 New: HLLLLLLL $ foo.pl 3 Org: 11 New: HH $ foo.pl 31 Org: 11111 New: HHHHH $ foo.pl 33 Org: 100001 New: HLLLLH </code></pre>