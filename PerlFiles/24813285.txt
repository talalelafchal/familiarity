encoding json with no quote around numerical values
<p>I have a perl code snippet</p> <pre><code>use JSON::XS; $a = {"john" =&gt; "123", "mary" =&gt; "456"}; print encode_json($a),"\n"; </code></pre> <p>The output is</p> <pre><code>{"john":"123","mary":"456"} </code></pre> <p>Wonder if there is an option to cause encode_json function (from JSON::XS module) to encode it so that the values (123, 456) are not surrounded by double-quote. i.e., like</p> <pre><code>{"john":123,"mary":456} </code></pre> <p>Unfortunately I can't change the hash in $a because it's passed to me from another function. Wonder if there is any trick on encode_json().</p> <p>Thanks!</p>
<p>You shouldn't use <code>JSON::XS</code> directly, just <code>JSON</code> will already load <code>JSON::XS</code> if available.</p> <p>A scalar in Perl is tagged whether it is a string or a number, and here you're providing strings. Remove the quotes from your numbers, and they should show up unquoted as <code>JSON</code> already does that automatically.</p> <p>If you're reading strings (from say a database) then you can coerce the strings to numbers like this:</p> <pre class="lang-perl prettyprint-override"><code>{ john =&gt; 0+$john, mary =&gt; 0+$mary } </code></pre> <p><br></p> <p><strong>Update, here's a recursive replacement:</strong></p> <pre class="lang-perl prettyprint-override"><code>#!/usr/bin/env perl use JSON; use Modern::Perl; use Scalar::Util qw( looks_like_number ); my $structure = { john =&gt; "123", mary =&gt; 456, deeper =&gt; { lucy =&gt; "35zz", names =&gt; [ "john", "123", 456, ], }, }; sub make_numbers_recursively { my ( $data ) = shift; if ( ref $data eq 'HASH' ) { # Replace hash values with recurisvely updated values map { $data-&gt;{ $_ } = make_numbers_recursively( $data-&gt;{ $_ } ) } keys %$data; } elsif ( ref $data eq 'ARRAY' ) { # Replace each array value with recursively processed result map { $_ = make_numbers_recursively( $_ ) } @$data; } else { $data += 0 if looks_like_number( $data ); } return $data; } my $json = JSON-&gt;new-&gt;pretty; say $json-&gt;encode( $structure ); make_numbers_recursively( $structure ); say $json-&gt;encode( $structure ); </code></pre> <p>This outputs:</p> <pre><code>{ "mary" : 456, "deeper" : { "names" : [ "john", "123", 456 ], "lucy" : "35zz" }, "john" : "123" } { "mary" : 456, "deeper" : { "names" : [ "john", 123, 456 ], "lucy" : "35zz" }, "john" : 123 } </code></pre> <p>Beware that it modifies the structure in-place, so if you need the original data for anything you might want to <code>Clone</code> or <code>Data::Clone</code> it first.</p>
<p>You probably need to preprocess the data yourself, prior to JSON serialization.</p> <p>This solution uses <a href="https://metacpan.org/pod/Data::Leaf::Walker" rel="nofollow">Data::Leaf::Walker</a> to traverse an arbitrary structure, converting strings to numbers.</p> <pre><code>use JSON; use Data::Leaf::Walker; use Scalar::Util qw(); my $a = {"john" =&gt; "123", "mary" =&gt; ["456","aa"], "fred" =&gt; "bb", "nested" =&gt; {"Q" =&gt; undef, "A" =&gt; 42}, }; my $walker = Data::Leaf::Walker-&gt;new( $a ); while (my ( $key_path, $value ) = $walker-&gt;each ) { $walker-&gt;store($key_path, $value + 0) if Scalar::Util::looks_like_number $value; }; print to_json($a); </code></pre> <p>Output: <code>{"john":123,"nested":{"A":42,"Q":null},"mary":[456,"aa"],"fred":"bb"}</code></p>