using grep linux command with perl regex + capturing groups
<p>so I've done some research on the subject and I didn't quite find the perfect solution. For example I have a string inside a variable.</p> <pre><code>var="a1b1c2" </code></pre> <p>now what I want to do is match only "a" follow by any digit, but I only want it to return the number after "a" To match it a rule such as</p> <pre><code>'a\d' </code></pre> <p>and since I only need the digit, I tried with</p> <pre><code>'a(\d)' </code></pre> <p>and maybe it did capture it somewhere, but I don't know where, the output here is still "a1"</p> <p>I also tried a non-capturing group to ignore the "a" in the output, but no effect in perl regex:</p> <pre><code>'(?:a)\d' </code></pre> <p>for reference, this is the full command in my terminal:</p> <pre><code>[root@host ~]# var="a1b1c2" [root@host ~]# echo $var |grep -oP "a(\d)" a1 &lt;--output </code></pre> <p>Probably it's also possible without the -P (some not-perl regex format), I'm thankful for every answer :)</p> <p><strong>EDIT:</strong> using</p> <pre><code>\K </code></pre> <p>is not really the solution, since I don't necessarily need the last part of the match.</p> <p><strong>EDIT2:</strong> I need to able to get any part of the match, for instance:</p> <pre><code>[root@host ~]# var="a1b1c2" [root@host ~]# echo $var |grep -oP "(a)\d" a1 &lt;--output but the wanted output in this case would be "a" </code></pre> <p><strong>EDIT3:</strong> The problem is nearly solved using "look-behind assertions" such as:</p> <pre><code>(?&lt;=a)\d </code></pre> <p>will not return the letter "a", only the digit following it, but it needs a fixed length, for example it cannot be used as:</p> <pre><code>(?&lt;=\w+)\d </code></pre> <p><strong>EDIT4:</strong> The best way so far is either using perl or combine a combination of look-behind assertions and the \K but it still seems to have some limitations. For example:</p> <pre><code>1234_foo_1234_bar 1234567_foo_123456789_bar 1_foo_12345_bar if "foo" and "bar" are place-holders for words that don't always have the same length, there is no way to match all above examples while output "foobar", since the number between them doesn't have a fixed length, while it can't be done with \K since we need "foo" </code></pre> <p>Any further suggestions are still appreciated :)</p>
<p>You can use Perl directly, accessing the environment variables through the <code>%ENV</code> hash:</p> <pre><code>perl -lwe 'print $ENV{var} =~ /a(\d+)/;' </code></pre> <p>It will only print the capture, inside the parentheses.</p>
<p>The pattern <code>(?&lt;=a)\d</code> uses a look-behind assertion to only print a digit following the letter 'a'. This works with GNU <code>grep -Po</code>, <code>ack -o</code>, and <code>pcregrep -o</code>. The assertion is zero width, so it isn't included in the match.</p>
<blockquote> <p>After some testing I found out, that the pattern inside the look-behind assertion needs to be fixed length (something like <code>(?&lt;=\w+)something</code> will not work, any suggestions?</p> </blockquote> <p>As I posted and deleted my answer previously because you stated it did not fit your needs:</p> <p>Most of the time, <strong>you can avoid variable length lookbehinds</strong> by using <code>\K</code>. This resets the starting point of the reported match and any previously consumed characters are no longer included. (<em>throws away everything that it has matched up to that point.</em>) </p> <p>The key difference between using <code>\K</code> and a lookbehind is that, a lookbehind does not allow the use of quantifiers: the length of what you are looking for must be <strong>fixed</strong>. But <code>\K</code> can be placed anywhere in a pattern, so you are able to use any quantifiers.</p> <p>As you can see in the below example, using a quantifier in the lookbheind will not work.</p> <pre><code>echo 'foosomething' | grep -Po '(?&lt;=\w+)something' #=&gt; grep: lookbehind assertion is not fixed length </code></pre> <p>So you could do:</p> <pre><code>echo 'foosomething' | grep -Po '\w+\Ksomething' #=&gt; something </code></pre> <p>To get a substring only between two patterns, you can add Positive Lookahead into the mix.</p> <pre><code>echo 'foosomethingbar' | grep -Po 'foo\K.*?(?=bar)' #=&gt; something </code></pre> <p>Or used fixed Lookbehind combined with Lookahead.</p> <pre><code>echo 'foosomethingbar' | grep -Po '(?&lt;=foo).*?(?=bar)' #=&gt; something </code></pre>