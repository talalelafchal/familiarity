Find a number of a file in a range of numbers of another file
<p>I have this two input files:</p> <pre><code>file1 1 982444 1 46658343 3 15498261 2 238295146 21 47423507 X 110961739 17 7490379 13 31850803 13 31850989 file2 1 982400 982480 1 46658345 46658350 2 14 109 2 5000 9000 2 238295000 238295560 X 110961739 120000000 17 7490200 8900005 </code></pre> <p>And this is my desired output:</p> <pre><code>Desired output: 1 982444 2 238295146 X 110961739 17 7490379 </code></pre> <p>This is what I want: Find the column 1 element of file1 in column 1 of file2. If the number is the same, take the number of column 2 of file1 and check if it is included in the range of numbers of column2 and 3 of file2. If it is included, print the line of file1 in the output.</p> <p>Maybe is a little confusing to understand, but I'm doing my best. I have tried some things but I'm far away from the solution and any help will be really appreciated. In bash, awk or perl please.</p> <p>Thanks in advance,</p>
<p>Let's mix bash and awk:</p> <pre><code>while read col min max do awk -v col=$col -v min=$min -v max=$max '$1==col &amp;&amp; min&lt;=$2 &amp;&amp; $2&lt;=max' f1 done &lt; f2 </code></pre> <h3>Explanation</h3> <ul> <li>For each line of file2, read the min and the max, together with the value of the first column.</li> <li>Given these values, check in file1 for those lines having same first column and being 2nd column in the range specified by file 2.</li> </ul> <h3>Test</h3> <pre><code>$ while read col min max; do awk -v col=$col -v min=$min -v max=$max '$1==col &amp;&amp; min&lt;=$2 &amp;&amp; $2&lt;=max' f1; done &lt; f2 1 982444 2 238295146 X 110961739 17 7490379 </code></pre>
<p>Pure bash , <strong>based on Fedorqui solution</strong>:</p> <pre><code>#!/bin/bash while read col_2 min max do while read col_1 val do (( col_1 == col_2 &amp;&amp; ( min &lt;= val &amp;&amp; val &lt;= max ) )) &amp;&amp; echo $col_1 $val done &lt; file1 done &lt; file2 </code></pre>
<pre><code>cut -d' ' -f1 input2 | sed 's/^/^/;s/$/\\s/' | \ grep -f - &lt;(cat input2 input1) | sort -n -k1 -k3 | \ awk 'NF==3 { split(a,b,","); for (v in b) if ($2 &lt;= b[v] &amp;&amp; $3 &gt;= b[v]) print $1, b[v]; if ($1 != p) a=""} NF==2 {p=$1;a=a","$2}' </code></pre> <p><em>Produces:</em></p> <pre><code>X 110961739 1 982444 2 238295146 17 7490379 </code></pre>
<p>Just using <code>awk</code>. The solution doesn't loop through <code>file1</code> repeatedly.</p> <pre><code>#!/usr/bin/awk -f NR == FNR { # I'm processing file2 since NR still matches FNR # I'd store the ranges from it on a[] and b[] # x[] acts as a counter to the number of range pairs stored that's specific to $1 i = ++x[$1] a[$1, i] = $2 b[$1, i] = $3 # Skip to next record; Do not allow the next block to process a record from file2. next } { # I'm processing file1 since NR is already greater than FNR # Let's get the index for the last range first then go down until we reach 0. # Nothing would happen as well if i evaluates to nothing i.e. $1 doesn't have a range for it. for (i = x[$1]; i; --i) { if ($2 &gt;= a[$1, i] &amp;&amp; $2 &lt;= b[$1, i]) { # I find that $2 is within range. Now print it. print # We're done so let's skip to the next record. next } } } </code></pre> <p>Usage:</p> <pre><code>awk -f script.awk file2 file1 </code></pre> <p>Output:</p> <pre><code>1 982444 2 238295146 X 110961739 17 7490379 </code></pre> <p>A similar approach using Bash (version 4.0 or newer):</p> <pre><code>#!/bin/bash FILE1=$1 FILE2=$2 declare -A A B X while read F1 F2 F3; do (( I = ++X[$F1] )) A["$F1|$I"]=$F2 B["$F1|$I"]=$F3 done &lt; "$FILE2" while read -r LINE; do read F1 F2 &lt;&lt;&lt; "$LINE" for (( I = X[$F1]; I; --I )); do if (( F2 &gt;= A["$F1|$I"] &amp;&amp; F2 &lt;= B["$F1|$I"] )); then echo "$LINE" continue fi done done &lt; "$FILE1" </code></pre> <p>Usage:</p> <pre><code>bash script.sh file1 file2 </code></pre>
<p>Here's a Perl solution. It could be much faster but less concise if I built a hash out of <code>file2</code>, but this should be fine.</p> <pre><code>use strict; use warnings; use autodie; my @bounds = do { open my $fh, '&lt;', 'file2'; map [ split ], &lt;$fh&gt;; }; open my $fh, '&lt;', 'file1'; while (my $line = &lt;$fh&gt;) { my ($key, $val) = split ' ', $line; for my $bound (@bounds) { next unless $key eq $bound-&gt;[0] and $val &gt;= $bound-&gt;[1] and $val &lt;= $bound-&gt;[2]; print $line; last; } } </code></pre> <p><strong>output</strong></p> <pre><code>1 982444 2 238295146 X 110961739 17 7490379 </code></pre>