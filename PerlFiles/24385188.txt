Using an awk command inside a Perl script
<p>This may not be the best way to do the below, so any comments are appreciated.</p> <p>I'm currently tailing a number of log files and outputting them to screen, so that I get a quick overview of the system.</p> <p>What I would like to do is to highlight different messages <code>[INFO]</code>, <code>[WARN]</code> and <code>[ERROR]</code> </p> <p>The following syntax works fine on the command line, but fails when being called from Perl</p> <pre><code>system ("tail -n 5 $ArchiverLog | awk '{if ($4 ~ /DEBUG/)print "\033[1;33m"$0"\033[0m"; else if ($6 ~ /ERROR/) print "\033[1;31m"$0"\033[0m"; else print $0}'"); </code></pre> <p>I believe Perl can do this</p> <p>Should I read in the file line by line, match on the words and print to screen (I only want the last 10 lines). Is that a better option?</p> <p>I've also seen reference to <code>a2p</code>, which is an awk to Perl translator. Would that be people's preferred choice?</p>
<p>It seems crazy to use one powerful scripting language to call up another one so it can do something which the first one can do very well, so I would not persist with trying to call up awk from perl.</p> <p>I have not had much experience with a2p, rather I tend to just translate such snippets by hand.</p> <pre><code>#!/usr/bin/perl use strict; foreach(`tail -n 5 $ArchiverLog`) { my @f = split; if ($f[4] =~ /DEBUG/) { print "\033[1;33m$_\033[0m"; } elsif ($f[6] =~ /ERROR/) { print "\033[1;31m$_\033[0m"; } else { print $_; } } </code></pre> <p>(Hard to say if the above is completely correct without some sample input to test it with).</p> <p>As Borodin says in the comments a more elegant solution would be to use a Tailing module from CPAN rather than calling up tail as a subprocess. But for a quick tool that might be overkill.</p> <p>NB: if <code>$ArchiverLog</code> comes from anywhere you don't have control of, remember to sanitise it, otherwise you are creating a nice security hole.</p>