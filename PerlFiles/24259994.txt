How to call perl from C++?
<p>I have a perl program for processing the large taxt file in particular format. I have prepared an exe file from that perl which works as Windows Console App. But for academic use the App is needed to be written in Better GUI (C++).<br> It is impossible for me to rewrite the whole code again in C++ (Due to time constraint).<br> Is there any way to take file from C++ GUI, use perl App (.pl or .exe) for processing and again use C++ Window to display the output.<br> Any other better options are welcome.</p>
<p>You have two choices:</p> <ol> <li>Embed a Perl interpreter into your C++ program: <a href="http://perldoc.perl.org/perlembed.html" rel="nofollow">http://perldoc.perl.org/perlembed.html</a> </li> <li>Have your C++ program invoke Perl as a subprocess. Use <a href="http://www.gnu.org/software/libc/manual/html_node/Running-a-Command.html" rel="nofollow"><code>system()</code></a> or <a href="http://www.gnu.org/software/libc/manual/html_node/Pipe-to-a-Subprocess.html#Pipe-to-a-Subprocess" rel="nofollow"><code>popen()</code> or <code>fork()/exec()</code></a>, depending on how much control you need.</li> </ol>
<p>Here's a quick example using <a href="https://metacpan.org/release/Prima" rel="nofollow">Prima</a> to select an input file and run a simple report on it.</p> <p>Hopefully it illustrates that you <em>do not</em> need to rewrite your entire Perl application to add a simple GUI. The first couple of functions do the real work of processing a file and generating a report. This part of the application doesn't need to know a thing about GUIs.</p> <p>The last part provides a GUI wrapper around it. That's the only part of the application that needs to deal with Prima.</p> <pre><code>use strict; use warnings; # This is the guts of the report. # It takes a filehandle and does some serious number crunching! # Just kidding. It counts the occurrences of vowels in a text # file. But it could be doing any serious reporting work you want. # sub get_data_from_file { my ($fh) = @_; my %vowels; while (&lt;$fh&gt;) { $vowels{uc($_)}++ for /([aeiou])/gi; } return \%vowels; } # Format report in Pod because personally I find # that a bit easier to deal with than Prima::TextView. # sub format_data_as_pod { my ($data) = @_; my $pod = "=pod\n\n"; $pod .= sprintf("B&lt;%s&gt; = %d\n\n", $_, $data-&gt;{$_}) for sort keys %$data; $pod .= "=cut\n\n"; return $pod; } # Here's the GUI... # MAIN: { use Prima qw( Application Buttons FileDialog PodView ); my $mw = Prima::MainWindow-&gt;new( text =&gt; 'Vowel Counter', size =&gt; [ 300, 200 ], ); $mw-&gt;insert( Button =&gt; ( centered =&gt; 1, text =&gt; 'Choose file', onClick =&gt; sub { my $open = Prima::OpenDialog-&gt;new( filter =&gt; [ [ 'Text files' =&gt; '*.txt' ], [ 'All files' =&gt; '*' ], ], ); if ( $open-&gt;execute ) { my $filename = $open-&gt;fileName; open(my $handle, '&lt;', $filename) or die("Could not open selected file: $?"); my $data = get_data_from_file($handle); my $report = format_data_as_pod($data); my $report_window = Prima::Window-&gt;create( text =&gt; "Report for $filename", size =&gt; [ 200, 300 ], ); my $pod = $report_window-&gt;insert( PodView =&gt; ( pack =&gt; { expand =&gt; 1, fill =&gt; 'both' }, ), ); $pod-&gt;open_read; $pod-&gt;read($report); $pod-&gt;close_read; } else { die("No file chosen"); } }, ), ); Prima-&gt;run; } </code></pre> <p>If you factored out the first two functions into a module of their own, it would be trivially easy to not just provide this GUI application that calls them, but also provide an alternative text-based UI for command-line usage.</p>