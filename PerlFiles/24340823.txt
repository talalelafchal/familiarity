Finding words with doubled letters in HTML text with a regexp
<p>How would I write regular expression that finds all words with doubled letters in a document?</p> <p>By doubled letters I mean: "s in progress", "d and s in address", "o in tool" and so on. I want to match these words inside the <code>&lt;body&gt;</code> part of an HTML document ?</p> <p>Below is a bit of code that shows what I am trying to do:</p> <pre><code>while (&lt;&gt;){ if (/&lt;body(.*)&gt;/ .. /&lt;\/body&gt;/){ foreach ($_){ print $_ =~ /\b\w{0,10}(\w)\1\w{0,10}\b/; } } } </code></pre>
<p>Here's an example solution that uses <a href="https://metacpan.org/module/HTML%3a%3aTreeBuilder%3a%3aXPath" rel="nofollow"><code>HTML::TreeBuilder::XPath</code></a>. It finds all text nodes in the HTML within the <code>&lt;body&gt;</code> element, splits them into "words" (using your definition of <code>\w+</code>) and prints those that contain duplicate characters.</p> <p>Note that text nodes include the JavaScript code inside <code>&lt;script&gt;</code> tags.</p> <p>I hope you can see just how easy it is to use a real HTML parser. Several others are available if you're not comfortable with <code>XPath</code>. But please don't struggle with regular expressions to create something that is difficult to write and likely to break at any moment</p> <pre><code>use strict; use warnings; use 5.010; use HTML::TreeBuilder::XPath; my $tree = HTML::TreeBuilder::XPath-&gt;new_from_url('http://www.perl.org/'); my @body_text = $tree-&gt;findvalues('/html/body//text()'); for my $word (map /\w+/g, @body_text) { say $word if $word =~ /(.)\1/; } </code></pre> <p><strong>output</strong></p> <pre><code>Programming www Community 000 programming free books 000 community Community community 300 support discussion 000 offer opportunities programming discussion collaboration Hook Zilla Zilla 33 Zilla Moos BitTorrent 300 Current Community Need look Toolkit need www 2002 _setAccount 50555 https https ssl http www google setAttribute appendChild googleTranslateElementInit google 50555 google_translate_element </code></pre>
<p>This is not an obvious task, first off because parsing html with regex is hazardous. With all the disclaimers about doing so, here's a regex for the job:</p> <pre><code>(?s)(?:&lt;body&gt;|\G)(?:.(?!&lt;/body&gt;))*?\K\b\w*(\w)\1\w*\b </code></pre> <p>See <a href="http://regex101.com/r/nR2aE9" rel="nofollow">the demo</a>.</p> <p>In Perl:</p> <pre><code>@result = $subject =~ m%(?s)(?:&lt;body&gt;|\G)(?:.(?!&lt;/body&gt;))*?\K\b\w*(\w)\1\w*\b%g; </code></pre> <ul> <li><code>(?s)</code> allows the dot to match newlines</li> <li><code>(?:&lt;body&gt;|\G)</code> matches <code>&lt;body&gt;</code> or the ending position of the previous match</li> <li><code>(?:.(?!&lt;/body&gt;))*?</code> lazily matches chars that are not followed by the closing <code>&lt;/body&gt;</code> tag</li> <li><code>\K</code> tells the engine to drop what had been matched so far from the returned match</li> <li><code>\b\w*(\w)\1\w*\b</code> matches a word (without <code>\b</code> boundaries) made of some optional chars <code>\w*</code> then one captured char <code>(\w)</code> immediately followed by itself as referenced by the Group 1 captured <code>\1</code> and more optional chars <code>\w*</code></li> </ul> <p>If you only want to allow letters (no digits and underscores), replace all the <code>\w</code> with <code>[a-z]</code> and replace <code>(?s)</code> with <code>(?is)</code> to make it case-insensitive.</p>
<p>Use <a href="https://metacpan.org/pod/Mojo%3a%3aDOM" rel="nofollow"><code>Mojo::DOM</code></a> for parsing HTML.</p> <p>The following will easily do exactly what you mean without picking up additional values that are inside tag attributes or such:</p> <pre><code>use strict; use warnings; use Mojo::DOM; my $dom = Mojo::DOM-&gt;new(do {local $/; &lt;DATA&gt;}); for my $body ($dom-&gt;find('body')-&gt;each) { my $text = $body-&gt;all_text(); for my $word ($text =~ m{\w+}g) { print "$word\n" if $word =~ /(.)\1/; } } __DATA__ &lt;html&gt; &lt;head&gt; &lt;title&gt;Dooble, but not me&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;I'm a heeder&lt;/h1&gt; &lt;p style="color: reed"&gt;I have more woods to find in heer. How many wrrds can I misspell? Plentee without even trying&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; </code></pre> <p>Outputs:</p> <pre><code>heeder woods heer wrrds misspell Plentee </code></pre> <p>For a helpful 8 minute introduction to <code>Mojo::DOM</code> check out <a href="http://mojocasts.com/e5" rel="nofollow"><code>Mojocast Episode 5</code></a>.</p>