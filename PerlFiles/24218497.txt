List array find double and add value
<p>the original perl array is sorted and looks like this:</p> <pre><code>Original ARRARY: ccc--&gt;2 ccc--&gt;5 abc--&gt;3 abc--&gt;7 cb--&gt;6 </code></pre> <p>and i like to have the following result:</p> <pre><code>FINAL ARRARY: ccc--&gt;7 abc--&gt;10 cb--&gt;6 </code></pre> <p>Question:<br> can you please create a subroutine for that ?</p> <p><strong>this was the orig. subroutine that i used:</strong></p> <pre><code>sub read_final_dev_file { $dfcnt=0; $DEVICE_ANZSUMZW=0; $DEVICE_ANZSUM=0; open(DATA,"$log_dir1/ALLDEVSORT.$log_file_ext1") || die ("Cannot Open Logfile: $log_dir1/$log_DEV_name.$log_file_ext1 !!!!"); @lines = &lt;DATA&gt;; close(DATA); chomp(@lines); # erase the last sign from a string foreach $logline (@lines) { if ($logline =~ /(.*)--&gt;(.*)/) { $DEVICE_CODE[$dfcnt] = $1; $DEVICE_ANZAHL[$dfcnt] = $2; print "DEVICE_final = $DEVICE_CODE[$dfcnt], D_ANZAHL_final = $DEVICE_ANZAHL[$dfcnt]\n"; if ($dfcnt &gt; 0 ) { if ( $DEVICE_CODE[$dfcnt] eq $DEVICE_CODE[$dfcnt-1] ) { $DEVICE_ANZSUM = $DEVICE_ANZAHL[$dfcnt] + $DEVICE_ANZAHL[$dfcnt-1]; $DEVICE_ANZSUMZW = $DEVICE_ANZSUM++; #$DEVICE_ANZSUM = $DEVICE_ANZAHL[$dfcnt]++; #print "DEVICE_ANZAHL = $DEVICE_ANZAHL[$dfcnt],DEVICE_ANZAHL -1 = $DEVICE_ANZAHL[$dfcnt-1]\n"; print "DEVICE_eq = $DEVICE_CODE[$dfcnt], D_ANZAHL_eq = $DEVICE_ANZAHL[$dfcnt],DEVANZSUM = $DEVICE_ANZSUM,COUNT = $dfcnt\n"; }#end if if ( $DEVICE_CODE[$dfcnt] ne $DEVICE_CODE[$dfcnt-1] ) { #$DEVICE_ANZSUM=0; #splice(@data3,$dfcnt+2,1) if ($DEVICE_ANZSUM &gt; 1); push (@data3,$DEVICE_ANZSUMZW) if ($DEVICE_ANZSUM &gt; 1); push (@data3,$DEVICE_ANZAHL[$dfcnt]) if ($DEVICE_ANZSUM == 0); if ( $DEVICE_CODE[$dfcnt] ne $DEVICE_CODE[$dfcnt-1] ) { $DEVICE_ANZSUM=0; } print "DEVICE_ne = $DEVICE_CODE[$dfcnt], D_ANZAHL_ne = $DEVICE_ANZAHL[$dfcnt], DEVANZSUM = $DEVICE_ANZSUM\n"; }#end if }#end if $dfcnt $dfcnt++; }#end if logline }#end for print "@labels3\n"; print "@data3\n"; }#end sub read_final_dev_file </code></pre>
<p>You could use <code>List::UtilsBy::partition_by</code> to group the original list into partitions, by the first string:</p> <pre><code>use List::UtilsBy qw( partition_by ); my @input = ( [ ccc =&gt; 2 ], [ ccc =&gt; 5 ], [ abc =&gt; 3 ], [ abc =&gt; 7 ], [ cb =&gt; 6 ], ); my %sets = partition_by { $_-&gt;[0] } @input; </code></pre> <p>Now you have a hash, keyed by the leading strings, whose values are all the <code>ARRAY</code> refs with that key first. You can now sum the values within them, by mapping over <code>$_-&gt;[1]</code> which contains the numbers:</p> <pre><code>use List::Util qw( sum ); my %totals; foreach my $key ( keys %sets ) { $totals{$key} = sum map { $_-&gt;[1] } @{ $sets{$key} }; } </code></pre> <p>If you're inclined towards code of a more compact and functional-looking nature, you could instead use the new <code>pairmap</code> here; making the whole thing expressible in one line:</p> <pre><code>use List::UtilsBy qw( partition_by ); use List::Util qw( pairmap sum ); my %totals = pairmap { $a =&gt; sum map { $_-&gt;[1] } @$b } partition_by { $_-&gt;[0] } @input; </code></pre> <hr/> <p><strong>Edit</strong>: I should add that even though you stated in your original question that the array was sorted, this solution doesn't require it sorted. It will happily take the input in any order.</p>
<p>Probably not the best way, but this is what came to mind after seeing LeoNerd answer, since I don't have CPAN access in production and never have modules lying around:</p> <pre><code>#!/usr/bin/perl use strict; use warnings; use Data::Dumper; my @input = ( [ ccc =&gt; 2 ], [ ccc =&gt; 5 ], [ abc =&gt; 3 ], [ abc =&gt; 7 ], [ cb =&gt; 6 ], ); my %output; $output{$_-&gt;[0]} += $_-&gt;[1] for @input; print Dumper \%output; my @output = map { [ $_ =&gt; $output{$_} ] } keys(%output); print Dumper \@output; </code></pre> <p>Output:</p> <pre><code>$VAR1 = { 'abc' =&gt; 10, 'cb' =&gt; 6, 'ccc' =&gt; 7 }; $VAR1 = [ ['abc', 10], ['cb', 6], ['ccc', 7], ]; </code></pre>
<p>You can simplify your subroutine a lot by using a hash to track the counts instead of an array. The following uses an array <code>@devices</code> to track the order and a hash <code>%device_counts</code> to track the counts:</p> <pre><code>my @devices; my %device_counts; while (&lt;DATA&gt;) { # Read one line at a time from DATA if (/(.*)--&gt;(.*)/) { # This won't extract newlines so no need to chomp if (!exists $device_counts{$1}) { push @devices, $1; # Add to the array the first time we encounter a device } $device_counts{$1} += $2; # Add to the count for this device } } for my $device (@devices) { printf "%s--&gt;%s\n", $device, $device_counts{$device}; } </code></pre>