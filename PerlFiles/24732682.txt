waitpid and open3 in Perl
<p>If output of the program that is called by open3 is too large (more than 65536) waitpid will run forever.</p> <pre><code>use IPC::Open3; use POSIX ":sys_wait_h"; my ($stdin, $stdout, $stderr); my $program = "perl -e 'print \"a\" x 65537'"; my $args = []; my $pid = open3 $stdin, $stdout, $stderr, $program, @$args; waitpid($pid, 0); </code></pre> <p>The problem is solved by WNOHANG:</p> <pre><code>my $kid; while (1) { $kid = waitpid( $pid, WNOHANG ); last unless $kid &gt; 0; } </code></pre> <p>But now the return code in $? is -1. It's the return code of waitpid. It can be solved with dirty hack:</p> <pre><code>my $open3_retcode; my $kid; while (1) { $open3_retcode = $?; $kid = waitpid( $pid, WNOHANG ); last unless $kid &gt; 0; } </code></pre> <p>What is the proper way to do such things?</p> <p><strong>UPD.</strong> It seems that dirty hack is not always works.</p>
<p>If you don't read the output from the program (e.g. $stdout and $stderr) it will hang after a while, because the buffers are full. This will cause it to never return. So the proper way is to read the data the programs sends to you until you get no more data (eof). Then you can call waitpid and it will be successful.</p>