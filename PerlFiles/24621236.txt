perl: can a hash entry reference be used to delete from the hash?
<p>Here's some perl pseudo code for what I'm asking:</p> <pre><code>my %x; # initialize %x my $ref = whateverSyntacticSugarIsNeeded( $x{this}{hash}{is}{deep} ); # ... # make use of $ref multiple times # ... delete $ref; # ideally, this would delete $x{this}{hash}{is}{deep} </code></pre> <p>... where the idea is to avoid use of <code>$x{this}{hash}{is}{deep}</code> more than is absolutely necessary.</p> <p>I'm fairly sure this isn't possible and the least uses possible is 2 (the initial ref/copy of the value, then to delete the key/value pair from <code>%x</code>). However, if I'm mistaken then feel free to correct me.</p>
<p>The easiest thing is just to reference the hash one level up.</p> <p>This is especially true if you give the variable a semantically appropriate name (something other than ref):</p> <pre><code>my %x; # initialize %x my $ref = $x{this}{hash}{is}; # ... # make use of $ref multiple times # ... delete $ref-&gt;{deep}; </code></pre>
<p>It's not clear what you want exactly. If</p> <pre><code>%x = ( very =&gt; { deep =&gt; { hash =&gt; { is =&gt; "here" } } } ); </code></pre> <p>and you assign</p> <pre><code>$y = $x{very}{deep}{hash}{is} </code></pre> <p>then is's like writing</p> <pre><code>$y = 'here' </code></pre> <p>so you can't <code>delete $y</code>. You can, though,</p> <pre><code>$z = $x{very}{deep}{hash}; delete $z-&gt;{is}; </code></pre>
<p>Perl tracks whether or not a piece of memory is used by using a count to that piece of memory. If I did this:</p> <pre><code>my $ref-&gt;{this}-&gt;{is}-&gt;{a}-&gt;{deep} = "hash"; undef $ref; # Note I use "undef" and not "delete" </code></pre> <p>I free up all of that memory. All of the hash references and the actual scalar that those hash references point to. That's because I have no further way of accessing that memory.</p> <p>If I do something a bit simpler:</p> <pre><code>my %hash = ( one =&gt; 1, two =&gt; 2, ref =&gt; { three =&gt; 3, four =&gt; 4 }, five =&gt; 5 ); </code></pre> <p>Note that <code>$hash{ref}</code> is a reference to another hash. If I did this:</p> <pre><code>my $ref = $hash{ref}; </code></pre> <p>I now have two variables that can access that piece of memory. Doing this:</p> <pre><code>delete $hash{ref}; </code></pre> <p>does not free up that memory because <code>$ref</code> still points to it. However, that hash reference is no longer in my <code>%hash</code> hash.</p> <p>If I didn't delete <code>$hash{ref}</code>, but did this:</p> <pre><code>$ref-&gt;{seven} = 7; </code></pre> <p>I have changed <code>%hash</code> because <code>$ref</code> and <code>$hash{ref}</code> point to the same piece of memory: That same hash reference. Doing this:</p> <pre><code>delete $hash{ref}-&gt;{four}; </code></pre> <p>or delete $ref->{four};</p> <p>will both delete a particular entry in that hash reference. </p> <p>We don't have to do something that complex either:</p> <pre><code>my %hash = ( one =&gt; 1, two =&gt; 2, three =&gt; 3 ); my $ref = \%hash; #Creating a reference to that hash delete $ref-&gt;{three}; </code></pre> <p>This will delete $hash{three} since both are pointing to the same hash in memory. However,</p> <pre><code>undef $ref; </code></pre> <p>will not undefine <code>$hash</code> too.</p> <p>I hope this covers your question. As long as there's another way to refer to a memory location, it's not freed in Perl. However, if you point a reference to a data structure, manipulating that data structure through the reference will manipulate that data structure referenced through an array or hash variable.</p>