How do you implement non-blocking responses in a perl plack app?
<p>I'm trying to write a a perl-based webserver using <a href="https://metacpan.org/pod/Twiggy" rel="nofollow"><code>Twiggy::Server</code></a> (which means a plack app). I want to respond to a request (coming from an ajax call on a webpage) for some data by running some possibly time-consuming subroutine which generates the data and then turns it into a JSON string for returning to the client webpage.</p> <p>You can see a cut-down test version of my server here: <a href="http://pastebin.com/iNaDTVwL" rel="nofollow">http://pastebin.com/iNaDTVwL</a> That example shows the problem I'm facing with my current implementation; using <a href="https://metacpan.org/pod/AnyEvent%3a%3aForkManager" rel="nofollow"><code>AnyEvent::ForkManager</code></a> to do the non-blocking part of things results in truncation of the 'big' json response.</p> <p>This document would answer my questions perfectly (and better explains what I'm trying to do): <a href="https://github.com/jjn1056/Example-PlackStreamingAndNonblocking" rel="nofollow">https://github.com/jjn1056/Example-PlackStreamingAndNonblocking</a> ... if it was finished. I'm just missing the 'proper' way of doing non-blocking, instead of using <code>AnyEvent::ForkManager</code> which seems like a bit of a hack.</p>
<p>Personally I'd use <a href="https://metacpan.org/pod/Net::Async::HTTP::Server" rel="nofollow"><code>Net::Async::HTTP::Server::PSGI</code></a>. From its SYNOPSIS:</p> <pre><code>use Net::Async::HTTP::Server::PSGI; use IO::Async::Loop; my $loop = IO::Async::Loop-&gt;new; my $httpserver = Net::Async::HTTP::Server::PSGI-&gt;new( app =&gt; sub { my $env = shift; return [ 200, [ "Content-Type" =&gt; "text/plain" ], [ "Hello, world!" ], ]; }, ); $loop-&gt;add( $httpserver ); $httpserver-&gt;listen( addr =&gt; { family =&gt; "inet6", socktype =&gt; "stream", port =&gt; 8080 }, on_listen_error =&gt; sub { die "Cannot listen - $_[-1]\n" }, ); $loop-&gt;run; </code></pre> <p>Obviously this particularly tiny example doesn't demonstrate anything asynchronous, but you have full access to all of the <code>IO::Async</code> system in order to defer and respond later.</p>
<p>So following on from the comments - I don't know enough about the things you're using to give you a specific response, but can offer up something generic.</p> <p>Using threads to 'async' part of your Perl script:</p> <pre><code>#!/usr/bin/perl use strict; use warnings; use threads; use Thread::Queue; my $input_q = Thread::Queue -&gt; new(); my $success_q = Thread::Queue -&gt; new(); my $failure_q = Thread::Queue -&gt; new(); my $thread_count = 4; sub spinoff_thread { while ( my $target = $input_q -&gt; dequeue() ) { #do something to $target my @results = `ping -c 10 -i 1 $target`; if ( $? ) { $failure_q -&gt; enqueue ( $target ); } else { $success_q -&gt; enqueue ( $target ); } } } #main bit for ( 1..$thread_count ) { my $thr = threads -&gt; create ( \&amp;spinoff_thread ); } foreach my $server ( "server1", "server2", "server3", "server4", "server5" ) { $input_q -&gt; enqueue ( $server ); } $input_q -&gt; end(); #will cause threads to 'bail out' because that while loop will go 'undef'); #wait for threads to complete. foreach my $thr ( threads -&gt; list() ) { $thr -&gt; join(); } print "Fail:\n", join ("\n", $failure_q -&gt; dequeue() ), "\n"; print "Success:\n"; join ( "\n", $success_q -&gt; dequeue() ), "\n"; </code></pre> <p>The key points being that your threads - are basically subroutines - and can pass things back and forth using the Queues. <code>end</code> the queue is a good way to handle telling a thread to terminate - there are other ways of course. </p>