Matlab finding the center of cluster of a few pixels and counting the clusters
<p>So I have this matrix A, which is made of 1 and zeros, I have about 10 to 14 white spots of many pixels, but I want only 1 white pixel/centers coordinate for every cluster of white, how do I calculate how many cluster there are and their centers.</p> <p>Try to imagine the matrix A as the night sky with white starts in black sky and how to I count the stars and the stars centers, plus the star are made of cluster of white pixels.</p> <p>also the clusters are not all exactly the same size.</p>
<p>Here is some code using <a href="http://www.mathworks.com/help/images/ref/bwlabel.html" rel="nofollow">bwlabel</a> and/or regioprops, which are used to identify connected components in a matrix and a buch of other properties, respectively. I think it suits your problem quite well; however you might want to adapt my code a bit as its more of a starting point.</p> <pre><code>clear clc %// Create dummy matrix. BW = logical ([ 1 1 1 0 1 1 1 0 1 1 1 0 1 1 1 0 1 1 1 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 1 1 1 0 1 1 0 1 1 1 1 0 1 1 0 1 1 1 1 0 0 0 0]); %// Identify clusters. L = bwlabel(BW,4) </code></pre> <p>Matrix L looks like this:</p> <pre><code>L = 1 1 1 0 3 3 3 0 1 1 1 0 3 3 3 0 1 1 1 0 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 4 0 2 2 2 2 0 4 4 0 2 2 2 2 0 4 4 0 2 2 2 2 0 0 0 0 </code></pre> <p>Here you have many ways to locate the center of the clusters. The first one uses the output of bwlabel to find each cluster and calculate the coordinates in a loop. It works and its didactic but it's a bit long and not so efficient. The 2nd method, as mentioned by @nkjt, uses regionprops which does exactly what you want using the 'Centroid' property. So here are the 2 methods:</p> <p><strong>Method 1</strong>: a bit complicated So bwlabel identified 4 clusters, which makes sense. Now we need to identify the center of each of those clusters. My method could probably be simplified; but I'm a bit out of time so fell free to modify it as you see fit.</p> <pre><code>%// Get number of clusters NumClusters = numel(unique(L)) -1; Centers = zeros(NumClusters,2); CenterLinIdices = zeros(NumClusters,1); for k = 1:NumClusters %// Find indices for elements forming each cluster. [r, c] = find(L==k); %// Sort the elements to know hot many rows and columns the cluster is spanning. [~,y] = sort(r); c = c(y); r = r(y); NumRow = numel(unique(r)); NumCol = numel(unique(c)); %// Calculate the approximate center of the cluster. CenterCoord = [r(1)+floor(NumRow/2) c(1)+floor(NumCol/2)]; %// Actually this array is not used here but you might want to keep it for future reference. Centers(k,:) = [CenterCoord(1) CenterCoord(2)]; %// Convert the subscripts indices to linear indices for easy reference. CenterLinIdices(k) = sub2ind(size(BW),CenterCoord(1),CenterCoord(2)); end %// Create output matrix full of 0s, except at the center of the clusters. BW2 = false(size(BW)); BW2(CenterLinIdices) = 1 BW2 = 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 </code></pre> <p><strong>Method 2</strong> Using regionprops and the 'Centroid' property.</p> <p>Once you have matrix L, apply regionprops and concatenate the output to get an array containing the coordinates directly. Much simpler!</p> <pre><code>%// Create dummy matrix. BW = logical ([ 1 1 1 0 1 1 1 0 1 1 1 0 1 1 1 0 1 1 1 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 1 1 1 0 1 1 0 1 1 1 1 0 1 1 0 1 1 1 1 0 0 0 0]); %// Identify clusters. L = bwlabel(BW,4) s = regionprops(L,'Centroid'); CentroidCoord = vertcat(s.Centroid) </code></pre> <p>which gives this:</p> <pre><code>CentroidCoord = 2.0000 2.0000 2.5000 7.0000 6.0000 2.0000 6.5000 6.0000 </code></pre> <p>Which is much simpler and gives the same output once you use floor.</p> <p>Hope that helps!</p>