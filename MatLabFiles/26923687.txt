multichoice Matlab for loops
<p>Can anyone tell me how I would work this out manually?</p> <p>Consider the following MATLAB function: </p> <pre><code>function Anew = mystery( A ) N=5; for ii=2:N Anew(ii)= A(ii-1); end end </code></pre> <p>If we define <code>v = [0,1,2,3,4,5,6,7,8,9,10]</code>. What would be the output of <code>x = mystery(v)</code> be? </p> <ul> <li>a) <code>x = [1 2 3 4 5 6 7 8 9 10]</code></li> <li>b) <code>x = [1 2 3 4 5 6]</code> </li> <li>c) <code>x = [0 1 2 3 4 5]</code></li> <li>d) <code>x = [0 0 1 2 3]</code></li> </ul>
<p>OK, let's step through this code line by line.</p> <hr> <p>The first line:</p> <pre><code>N = 5; </code></pre> <p>This basically creates a variable called <code>N</code> and stores the value of 5 in it. No biggie.</p> <p>Next line:</p> <pre><code>for ii = 2 : N </code></pre> <p>This is a <code>for</code> loop, and each time the loop iterates, the value of <code>ii</code> will change by 1. The first time the loop runs, <code>ii = 2</code>, then the next time it starts again, <code>ii = 3</code> up to <code>ii = 5</code>, then the loop stops.</p> <p>So, let's start at the beginning with <code>ii = 2</code>. The statement inside the loop is equivalent to:</p> <pre><code>Anew(2) = A(2-1); </code></pre> <p>This simplifies to:</p> <pre><code>Anew(2) = A(1); </code></pre> <p>If you look at the code, <code>Anew</code> was never defined up until this point. When you try to assign a value to a location in an array that was not previously declared, MATLAB will fill up the values that are before the location of where you assigned to be zero automatically. As such, if you did:</p> <pre><code>Anew(8) = 9; %// For example </code></pre> <p><code>Anew</code> would look like this:</p> <pre><code>Anew = 0 0 0 0 0 0 0 9 </code></pre> <p>The 8th position has the value of 9, while the other positions before the 8th one are all zero. Therefore, by doing <code>Anew(2) = A(1);</code>, the first position of <code>Anew</code> is zero, while the second position of <code>Anew</code> gets the first value of <code>A</code> and puts it here. As such, <code>Anew</code> currently looks like:</p> <pre><code>Anew = 0 0 </code></pre> <p>Let's do <code>ii = 3</code>. This means that in your loop, the statement simplifies to:</p> <pre><code>Anew(3) = A(3-1); </code></pre> <p>.... which is:</p> <pre><code>Anew(3) = A(2); </code></pre> <p>This means that the third position of <code>Anew</code> gets the second element of <code>A</code> copied over here. Note that the original size of <code>Anew</code> was 2. By doing <code>Anew(3) = A(2);</code>, MATLAB will automatically adjust the size of <code>Anew</code>, and then put what <code>A(2)</code> is into the third position of <code>Anew</code>. Therefore, <code>Anew</code> looks like:</p> <pre><code>Anew = 0 0 1 </code></pre> <p>As a little test, if we were to do <code>Anew(6) = A(2);</code>, this is what it would look like:</p> <pre><code>Anew = 0 0 0 0 0 1 </code></pre> <p>Note that we previously had <code>Anew = [0 0];</code> before this point. By doing <code>Anew(6) = A(2);</code>, the 3rd, 4th and 5th positions of <code>Anew</code> get filled with 0, and the 6th position gets the value of 1, which is <code>A(2)</code>.</p> <p>You can probably see a pattern now. Each position of <code>Anew</code> gets the element of <code>A</code> shifted to the left by 1. Therefore, for <code>ii = 4</code>:</p> <pre><code>Anew(4) = A(3); </code></pre> <p>What it looks like now is:</p> <pre><code>Anew = 0 0 1 2 </code></pre> <p>Finally for <code>ii = 5</code>, we get:</p> <pre><code>Anew(5) = A(4); </code></pre> <p>What it looks like now is:</p> <pre><code>Anew = 0 0 1 2 3 </code></pre> <p>After the end of this loop, <code>Anew</code> gets returned as the output of <code>mystery</code>.</p> <p>Therefore, the answer is <strong>(d)</strong>: <code>x = [0 0 1 2 3];</code>. </p> <hr> <p>Hope this helps!</p>