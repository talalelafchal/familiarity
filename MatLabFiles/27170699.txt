Symbolic gradient differing wildly from analytic gradient
<p>I am trying to simulate a network of mobile robots that uses artificial potential fields for movement planning to a shared destination xd. This is done by generating a series of m-files (one for each robot) from a symbolic expression, as this seems to be the best way in terms of computational time and accuracy. However, I can't figure out what is going wrong with my gradient computation: the analytical gradient that is being computed seems to be faulty, while the numerical gradient is calculated correctly (see the image posted below). I have written a MWE listed below, which also exhibits this problem. I have checked the file generating part of the code, and it does return a correct function file with a correct gradient. But I can't figure out why the analytic and numerical gradient are so different.</p> <p>(A larger version of the image below can be found <a href="http://postimg.org/image/liyhtehzb/full/" rel="nofollow noreferrer">here</a>)</p> <p><img src="https://i.stack.imgur.com/741yU.jpg" alt="Faulty gradient computation"></p> <pre><code>% create symbolic variables xd = sym('xd',[1 2]); x = sym('x',[2 2]); % create a potential function and a gradient function for both (x,y) pairs % in x for i=1:size(x,1) phi = norm(x(i,:)-xd)/norm(x(1,:)-x(2,:)); % potential field function xvector = reshape(x.',1,size(x,1)*size(x,2)); % reshape x to allow for gradient computation grad = gradient(phi,xvector(2*i-1:2*i)); % compute the gradient gradx = grad(1);grady=grad(2); % split the gradient in two components % create function file names gradfun = strcat('GradTester',int2str(i),'.m'); phifun = strcat('PotTester',int2str(i),'.m'); % generate two output files matlabFunction(gradx, grady,'file',gradfun,'outputs',{'gradx','grady'},'vars',{xvector, xd}); matlabFunction(phi,'file',phifun,'vars',{xvector, xd}); end clear all % make sure the workspace is empty: the functions are in the files pause(0.1) % ensure the function file has been generated before it is called % these are later overwritten by a specific case, but they can be used for % debugging x = 0.5*rand(2); xd = 0.5*rand(1,2); % values for the Stackoverflow case x = [0.0533 0.0023; 0.4809 0.3875]; xd = [0.4087 0.4343]; xp = x; % dummy variable to keep x intact % compute potential field and gradient for both (x,y) pairs for i=1:size(x,1) % create a grid centered on the selected (x,y) pair xGrid = (x(i,1)-0.1):0.005:(x(i,1)+0.1); yGrid = (x(i,2)-0.1):0.005:(x(i,2)+0.1); % preallocate the gradient and potential matrices gradx = zeros(length(xGrid),length(yGrid)); grady = zeros(length(xGrid),length(yGrid)); phi = zeros(length(xGrid),length(yGrid)); % generate appropriate function handles fun = str2func(strcat('GradTester',int2str(i))); fun2 = str2func(strcat('PotTester',int2str(i))); % compute analytic gradient and potential for each position in the xGrid and % yGrid vectors for ii = 1:length(yGrid) for jj = 1:length(xGrid) xp(i,:) = [xGrid(ii) yGrid(jj)]; % select the position Xvec = reshape(xp.',1,size(x,1)*size(x,2)); % turn the input into a vector [gradx(ii,jj),grady(ii,jj)] = fun(Xvec,xd); % compute gradients phi(jj,ii) = fun2(Xvec,xd); % compute potential value end end [FX,FY] = gradient(phi); % compute the NUMERICAL gradient for comparison %scale the numerical gradient FX = FX/0.005; FY = FY/0.005; % plot analytic result subplot(2,2,2*i-1) hold all xlim([xGrid(1) xGrid(end)]); ylim([yGrid(1) yGrid(end)]); quiver(xGrid,yGrid,-gradx,-grady) contour(xGrid,yGrid,phi) title(strcat('Analytic result for position ',int2str(i))); xlabel('x'); ylabel('y'); subplot(2,2,2*i) hold all xlim([xGrid(1) xGrid(end)]); ylim([yGrid(1) yGrid(end)]); quiver(xGrid,yGrid,-FX,-FY) contour(xGrid,yGrid,phi) title(strcat('Numerical result for position ',int2str(i))); xlabel('x'); ylabel('y'); end </code></pre> <p>The potential field I am trying to generate is defined by an (x,y) position, in my code called <code>xd</code>. <code>x</code> is the position matrix of dimension N x 2, where the first column represents x1, x2, and so on, and the second column represents y1, y2, and so on. Xvec is simply a reshaping of this vector to x1,y1,x2,y2,x3,y3 and so on, as the matlabfunction I am generating only accepts vector inputs.</p> <p>The gradient for robot i is being calculated by taking the derivative w.r.t. x_i and y_i, these two components together yield a single derivative 'vector' shown in the quiver plots. The derivative should look like <a href="http://www.wolframalpha.com/input/?i=diff%28norm%28x-x1%29%2Fnorm%28x-y%29%2Cx%29" rel="nofollow noreferrer">this</a>, and I checked that the symbolic expression for [gradx,grady] indeed looks like that <strong>before</strong> an m-file is generated.</p>
<p>To fix the particular problem given in the question, you were actually calculating <code>phi</code> in such a way that meant you doing <code>gradient(phi)</code> was not giving the correct results compared to the symbolic gradient. I'll try and explain. Here is how you created <code>xGrid</code> and <code>yGrid</code>:</p> <pre><code>% create a grid centered on the selected (x,y) pair xGrid = (x(i,1)-0.1):0.005:(x(i,1)+0.1); yGrid = (x(i,2)-0.1):0.005:(x(i,2)+0.1); </code></pre> <p>But then in the <code>for</code> loop, <code>ii</code> and <code>jj</code> were used like <code>phi(jj,ii)</code> or <code>gradx(ii,jj)</code>, but corresponding to the same physical position. This is why your results were different. Another problem you had was you used <code>gradient</code> incorrectly. Matlab assumes that <code>[FX,FY]=gradient(phi)</code> means that <code>phi</code> is calculated from <code>phi=f(x,y)</code> where <code>x</code> and <code>y</code> are matrices created using <code>meshgrid</code>. You effectively had the elements of <code>phi</code> arranged differently to that, an so <code>gradient(phi)</code> gave the wrong answer. Between reversing the <code>jj</code> and <code>ii</code>, and the incorrect gradient, the errors cancelled out (I suspect you tried doing <code>phi(jj,ii)</code> after trying <code>phi(ii,jj)</code> first and finding it didn't work).</p> <p>Anyway, to sort it all out, on the line after you create <code>xGrid</code> and <code>yGrid</code>, put this in:</p> <pre><code>[X,Y]=meshgrid(xGrid,yGrid); </code></pre> <p>Then change the code after you load <code>fun</code> and <code>fun2</code> to:</p> <pre><code>for ii = 1:length(xGrid) %// x loop for jj = 1:length(yGrid) %// y loop xp(i,:) = [X(ii,jj);Y(ii,jj)]; %// using X and Y not xGrid and yGrid Xvec = reshape(xp.',1,size(x,1)*size(x,2)); [gradx(ii,jj),grady(ii,jj)] = fun(Xvec,xd); phi(ii,jj) = fun2(Xvec,xd); end end [FX,FY] = gradient(phi,0.005); %// use the second argument of gradient to set spacing subplot(2,2,2*i-1) hold all axis([min(X(:)) max(X(:)) min(Y(:)) max(Y(:))]) %// use axis rather than xlim/ylim quiver(X,Y,gradx,grady) contour(X,Y,phi) title(strcat('Analytic result for position ',int2str(i))); xlabel('x'); ylabel('y'); subplot(2,2,2*i) hold all axis([min(X(:)) max(X(:)) min(Y(:)) max(Y(:))]) quiver(X,Y,FX,FY) contour(X,Y,phi) title(strcat('Numerical result for position ',int2str(i))); xlabel('x'); ylabel('y'); </code></pre> <hr> <p>I have some other comments about your code. I think your potential function is ill-defined, which is causing all sorts of problems. You say in the question that <code>x</code> is an Nx2 matrix, but you potential function is defined as</p> <pre><code>norm(x(i,:)-xd)/norm(x(1,:)-x(2,:)); </code></pre> <p>which means if <code>N</code> was three, you'd have the following three potentials:</p> <pre><code>norm(x(1,:)-xd)/norm(x(1,:)-x(2,:)); norm(x(2,:)-xd)/norm(x(1,:)-x(2,:)); norm(x(3,:)-xd)/norm(x(1,:)-x(2,:)); </code></pre> <p>and I don't think the third one makes sense. I think this could be causing some confusion with the gradients.</p> <p>Also, I'm not sure if there is a reason to create the <code>.m</code> file functions in your real code, but they are not necessary for the code you posted.</p>