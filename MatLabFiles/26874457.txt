Classifying points in accordance with their coordinates
<p><code>A</code> is a coordinate matrix of several points in 3D (x,y,z). For instance:</p> <p><code>A= [1.6 2.13 3; 1.2 2.36 5; 1.4 2.4 6; 1.01 2.21 9]</code> </p> <p><code>A = 1.6 2.13 3.0 1.2 2.36 5.0 1.4 2.40 6.0 1.01 2.21 9.0</code></p> <p>I am looking for a "efficient" solution for grouping points with respect to the second column (<code>Y</code>) into "three" groups with threshold of <code>0.09</code>. means:</p> <p><code>GroupNumber = 3; threshold = (max(A(:,2))-min(A(:,2)))/GroupNumber;</code></p> <p><code>Group{1} = 1.60 2.13 3.0 1.01 2.21 9.00 Group{2} = 1.2 2.36 5.0 Group{3} = 1.4 2.40 6.0</code></p> <p>Any help would be greatly appreciated!</p>
<p>I have no access to MATLAB now, but roughly it would be something like this:</p> <p>You can get the first group as follows,</p> <pre><code>A= [1.6 2.13 3; 1.2 2.36 5; 1.4 2.4 6; 1.01 2.21 9] B = A(:,2); mean = (max(B)-min(B))/3; C = B - min(B); Group1 = A(C&lt;mean,:) </code></pre> <p>then make the new matrix from the remaining rows as follows</p> <pre><code>A = A(C&gt;=mean,:) </code></pre> <p>and then repeat until <code>isempty(A) == true</code>. There are many optimizations possible though.</p> <p><strong>Edit:</strong></p> <pre><code>A= [1.6 2.13 3; 1.2 2.36 5; 1.4 2.4 6; 1.01 2.21 9] while ~isempty(A) B = A(:,2); mean1 = (max(B)-min(B))/3; C = B - min(B); Group1 = A(C&lt;mean1,:) A = A(C&gt;=mean1,:) if size(A,1)==1 break; end end </code></pre> <p>The result would be:</p> <pre><code>A = 1.6000 2.1300 3.0000 1.2000 2.3600 5.0000 1.4000 2.4000 6.0000 1.0100 2.2100 9.0000 Group1 = 1.6000 2.1300 3.0000 1.0100 2.2100 9.0000 A = 1.2000 2.3600 5.0000 1.4000 2.4000 6.0000 Group1 = 1.2000 2.3600 5.0000 A = 1.4000 2.4000 6.0000 </code></pre>
<h2>Approach #1</h2> <p>For <code>A</code> with decent number of rows in it, you might prefer a vectorized solution -</p> <pre><code>GroupNumber = 3; sorted_A = sortrows(A,2); sorted_A_col2 = sorted_A(:,2); limits = sorted_A_col2 + (max(sorted_A_col2) - sorted_A_col2)./GroupNumber; matches = bsxfun(@le,sorted_A_col2,limits.'); %//' [~,col_ind] = max(matches,[],2); groups = arrayfun(@(x) sorted_A(col_ind == x,:), unique(col_ind),'Uniform',0); </code></pre> <p>Display output with <code>celldisp(groups)</code> for given input -</p> <pre><code>groups{1} = 1.6000 2.1300 3.0000 1.0100 2.2100 9.0000 groups{2} = 1.2000 2.3600 5.0000 groups{3} = 1.4000 2.4000 6.0000 </code></pre> <hr> <h2>Approach #2</h2> <p>For <code>A</code> with enormously huge number of rows in it, you most likely won't have memory left to work with <code>bsxfun</code> and you would be forced to use some sort of loopy approach for such a case and therefore won't be very efficient. The following could be one of those -</p> <pre><code>GroupNumber = 3; sorted_A = sortrows(A,2); sorted_A_col2 = sorted_A(:,2); limits = sorted_A_col2 + (max(sorted_A_col2) - sorted_A_col2)./GroupNumber; nrows = size(A,1); prev_matches = false(nrows,1); groups = cell(nrows,1); for iter = 1:nrows curr_matches = sorted_A_col2&lt;=limits(iter); groups{iter} = sorted_A(xor(curr_matches,prev_matches),:); prev_matches = curr_matches; end groups = groups(~cellfun('isempty',groups)); </code></pre>
<p>Generating a large set of data:</p> <pre><code> A = 100 * rand(2000000,3); tic GroupNumber = 100 ;` `% in hundred group Threshold = (length(A))/GroupNumber ; A = sortrows(A,2); Group = cell(GroupNumber,1);` for i = 1 : GroupNumber; if i == 1 Group{i} = A(1:ceil(Threshold),:); elseif i &gt; 1 &amp;&amp; i~= GroupNumber if ceil((i-1)*Threshold) == ceil(Threshold) bottum = ceil((i-1)*Threshold)+1; else end top=ceil(i*Threshold); Group{i} = A(bottum:top,:); elseif i == GroupNumber bottum = ceil((i-1)*Threshold); if ceil((i-1)*Threshold)&lt;=ceil(i*Threshold) &amp;&amp; ceil((i-1)*Threshold)&gt;top Group{i} = A(bottum:end,:); elseif ceil((i-1)*Threshold)&lt;=top Group{i} = A(bottum+1:end,:); end end end toc </code></pre> <p>Elapsed time is <strong><code>1.160457</code></strong> seconds.</p> <p>and for proposed set of data it is like:</p> <pre><code>A = [1.6 2.13 3; 1.2 2.36 5; 1.4 2.4 6; 1.01 2.21 9]; GroupNumber = 3; Group{1} = 1.6000 2.1300 3.0000 1.0100 2.2100 9.0000 Group{2} = 1.2000 2.3600 5.0000 Group{3} = 1.4000 2.4000 6.0000 </code></pre> <p>Elapsed time is <strong><code>0.000010</code></strong> seconds.</p>