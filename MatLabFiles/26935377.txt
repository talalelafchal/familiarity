Resizing and Repeating an Image
<p>I've run into a problem with images. I am trying to take an image and make it 1/4th of it's original size, then have it repeated as a 2x2 matrix. Kind-of like this:</p> <pre><code>Given an input image: --------------------- | | | | | IMG | | | | | --------------------- Firstly, shrink it to 1/4 of its original size: ----------- | img | | | |---------| Then concatenate it into a "2x2 array" of the shrunken image: --------------------- | img | img | | | | |---------|---------| | img | img | | | | --------------------- </code></pre> <p>What I am struggling with is the fact that I do not know how to make it into a 2x2 array. Any suggestions? This isn't actually HW this time :) It's for studying purposes. Here's what I've tried so far:</p> <pre><code>function[newImg] = immultiply(picture) Image = imread(picture); %// Reads in the picture [r, c, l] = size(Image); %// Finds the images rows, columns and layers rows = round(r ./ 2); %// Divides up the rows columns = round(c ./ 2); %// Divides up the columns newImg = cat(3,rows,columns,3); %// Creates my image, but just gives me a blank thing imshow(newImg) end </code></pre> <p>I will update as I work on it further. Thanks!</p>
<p>The previous answer perfectly covers what you've asked, </p> <p>however, if you don't want to use <code>imresize</code> and <code>repmat</code>,</p> <pre><code>im = imread('peppers.png'); subplot(1,2,1),imshow(im) im1 = im(1 : 2 : end, 1 : 2 : end,:); im2 = [im1 im1; im1 im1]; subplot(1,2,2),imshow(im2); </code></pre> <p><img src="https://i.stack.imgur.com/IYchR.png" alt="enter image description here"></p>
<p>The previous two answers are correct, and I originally worked on this just playing around and wasn't going to post it, but with a slight modification I think it addresses part of Luis Mendo's comments on Kamtal's answer.</p> <p>My original thought was, why throw away data? If you're downsampling to 1/4 size but plotting 4 of them, you have room for <strong>all</strong> of the data:</p> <pre><code>img1 = imread('myimage.png'); subplot(1,2,1),imshow(img1) img2 = img1([1:2:end, 2:2:end], [1:2:end, 2:2:end]); subplot(1,2,2),imshow(img2); </code></pre> <p>The resulting top-left quadrant of <code>img2</code> will be exactly what Kamtal's answer produces: a nearest-neighbor interpolation of the pixels with odd-valued x and y coordinates. The other 3 will be (even/odd), (odd/even), (even/even). Every pixel in <code>img1</code> appears in <code>img2</code> and each sub-image can be slightly different.</p> <p>If instead we want to combine the data from each of the 4 images into a single image without throwing away <em>all</em> of the data, we can change this up slightly. We just take the average of the 4 images. Note that <code>img2</code> is the same here as above, I'm just breaking out the calculations to make it obvious.</p> <pre><code>img1 = imread('myimage.png'); subplot(1,3,1),imshow(img1) img2a = img1(1:2:end, 1:2:end); img2b = img1(1:2:end, 2:2:end); img2c = img1(2:2:end, 1:2:end); img2d = img1(2:2:end, 2:2:end); img2 = [img2a img2b; img2c img2d]; subplot(1,3,2),imshow(img2); img3a = (img2a + img2b + img2c + img2d)/4; img3 = [img3a img3a; img3a img3a]; subplot(1,3,3),imshow(img3); </code></pre> <p>Here <code>img3</code> shows 4 identical images, all the result of downsampling the original image using mean filtering. </p> <p>To do this with a filter, you would use the kernel:</p> <pre><code>[0.25 0.25] [0.25 0.25] </code></pre> <p>This just takes the average of the 4 elements in the neighborhood. With the origin of the kernel at (1,1) your interpolated, downsampled image would be in the odd-numbered rows/columns as before:</p> <pre><code>img1 = imread('myimage.png'); subplot(1,2,1),imshow(img1) h = [0.25, 0.25; 0.25, 0.25] //% define the mean filter kernel img2a = imfilter(img1, h); //% filter before applying Kamtal's solution img2b = img2a(1:2:end, 1:2:end); img2 = [img2b img2b; img2b img2b]; subplot(1,2,2),imshow(img2); </code></pre> <p>The resulting image should be the same as <code>img3</code> above.</p> <p>(Incidentally, mean filtering with a 2x2 kernel and then downsampling to 1/4 size is essentially bilinear interpolation. <code>imresize</code> uses bicubic interpolation by default, so its results will be slightly different.)</p>
<p>Just use the instructions <code>imresize</code> and <code>repmat</code></p> <pre><code>i = imread('lena.png'); figure(1),subplot(1,2,1),imshow(i) [n,m,d] = size(i); newI = imresize(i,0.5); finalI = repmat(newI,2,2); figure(1),subplot(1,2,2),imshow(finalI); </code></pre> <p>newI is the image resized to 1/2. This is equivalent to shrink the image to 1/4. finalI is the final image repeated 4 times. <code>repmat</code> is concatenating the matrix 2x2 times.</p> <p>I strongly recommend you to check the documentation of these two functions: <a href="http://uk.mathworks.com/help/images/ref/imresize.html" rel="nofollow">http://uk.mathworks.com/help/images/ref/imresize.html</a> <a href="http://uk.mathworks.com/help/matlab/ref/repmat.html" rel="nofollow">http://uk.mathworks.com/help/matlab/ref/repmat.html</a></p>