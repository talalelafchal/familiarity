Replace specific columns in a matrix with a constant column vector
<p>For neural networking, I would like to represent a column vector <code>y = [1;2;3]</code> in a matrix like so:</p> <pre><code>y = [1 0 0; 0 1 0; 0 0 1] </code></pre> <p>My vector <code>y</code> is very large, and so hardcoding is not an option. Also, I would like to avoid using <code>for</code>-loops.</p> <p>What I did so far:</p> <pre><code>y1 =[y; zeros(1,length(y)) ;zeros(1,length(y))] % add two rows with zeros in orde to give y the right format idx = find(y1(1,:) == 2); % find all the columns containing a 2 y1(:,idx(1):idx(end)) = y1(:,[0;1;0]); % this does not work because now I am comparing a matrix with a vector </code></pre> <p>I also tried this:</p> <pre><code>y1( y1 == [2;0;0] )=[0;1;0]; % This of course does not work </code></pre> <p>Is there a way to specify I want to compare columns in <code>y1 == [2;0;0]</code>, or is there another way to solve this?</p>
<p>From the context of your question, you wish to find a matrix where each column is an <strong>identity vector</strong>. For an identity vector, each column in this matrix is a non-zero vector where 1 is set in the position of the vector denoted by each position of <code>y</code> and 0 otherwise. Therefore, let's say we had the following example: </p> <pre><code>y = [1 5 4 3] </code></pre> <p>You would have <code>y_out</code> as the final matrix, which is:</p> <pre><code>y_out = 1 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 1 0 0 </code></pre> <hr> <p>There are several ways to do this. The easiest one would be to declare the identity matrix with <a href="http://www.mathworks.com/help/matlab/ref/eye.html" rel="nofollow"><code>eye</code></a>, then let <code>y</code> pick out those columns that you want from this matrix and place them as columns into your final matrix. If <code>y</code> had all unique values, then we would simply be rearranging the columns of this identity matrix based on <code>y</code>. As such:</p> <pre><code>y_out = eye(max(y)); y_out = y_out(:,y) y_out = 1 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 1 0 0 </code></pre> <hr> <p>Another way would be to declare a <a href="http://www.mathworks.com/help/matlab/ref/sparse.html" rel="nofollow"><code>sparse</code></a> matrix, where each row index is simply those elements from <code>y</code> and each column index is increasing from 1 up to as many elements as we have <code>y</code>:</p> <pre><code>y_out = sparse(y, 1:numel(y), 1, max(y), numel(y)); y_out = full(y_out) y_out = 1 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 1 0 0 </code></pre> <hr> <p>One more way would be to use <a href="http://www.mathworks.com/help/matlab/ref/sub2ind.html" rel="nofollow"><code>sub2ind</code></a> to find linear indices into your matrix, then access those elements and set them to 1. Therefore:</p> <pre><code>ind = sub2ind([max(y) numel(y)], y, 1:numel(y)); y_out = zeros(max(y), numel(y)); y_out(ind) = 1 y_out = 1 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 1 0 0 </code></pre>
<p>Not as efficient as the @rayryeng's answer but this might also help,</p> <p>Also if there are repeated values in <code>y</code> this code works fine.</p> <pre><code>a = [1 2 3 2 5 7 6 8]; [X,Y] = meshgrid(a,1 : length(a)); A = X == Y; A = 1 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 </code></pre>
<p>This works even if <code>y</code> has "missing" values:</p> <pre><code>n = numel(y); y_matrix = zeros(n, max(y)); y_matrix((1:n) + (y-1)*n) = 1; </code></pre> <p>Example:</p> <pre><code>y = [1 5 3 2]; </code></pre> <p>gives</p> <pre><code>y_matrix = 1 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 1 0 0 0 </code></pre>
<p>You can use <a href="http://se.mathworks.com/help/matlab/ref/bsxfun.html" rel="nofollow"><code>bsxfun</code></a>:</p> <pre><code>y_out = bsxfun(@eq, (1:max(y)).', y); </code></pre>