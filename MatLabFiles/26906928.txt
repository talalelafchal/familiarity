Separate two overlapping circles in an image using MATLAB
<p>How do I separate the two connected circles in the image below, using MATLAB? I have tried using <code>imerode</code>, but this does not give good results. Eroding does not work, because in order to erode enough to separate the circles, the lines disappear or become mangled. In other starting pictures, a circle and a line overlap, so isolating the overlapping objects won't work either.</p> <p>The image shows objects identified by <code>bwboundaries</code>, each object painted a different color. As you can see, the two light blue circles are joined, and I want to disjoin them, producing two separate circles. Thanks</p> <p><img src="http://s29.postimg.org/spkab8oef/image.jpg" alt=""></p>
<p>I would recommend you use the Circular Hough Transform through <a href="http://www.mathworks.com/help/images/ref/imfindcircles.html" rel="nofollow noreferrer"><code>imfindcircles</code></a>. However, you need version 8 of the Image Processing Toolbox, which was available from version R2012a and onwards. If you don't have this, then unfortunately this won't work :(... but let's go with the assumption that you do have it. However, if you are using something older than R2012a, Dev-iL in his/her comment above linked to some code on MATLAB's File Exchange on an implementation of this, most likely created before the Circular Hough Transform was available: <a href="http://www.mathworks.com/matlabcentral/fileexchange/9168-detect-circles-with-various-radii-in-grayscale-image-via-hough-transform/" rel="nofollow noreferrer">http://www.mathworks.com/matlabcentral/fileexchange/9168-detect-circles-with-various-radii-in-grayscale-image-via-hough-transform/</a></p> <hr> <p>This is a special case of the Hough Transform where you are trying to find circles in your image rather than lines. The beauty with this is that you are able to find circles even when the circle is partially completed or overlapping.</p> <p>I'm going to take the image that you provided above and do some post-processing on it. I'm going to convert the image to binary, and remove the border, which is white and contains the title. I'm also going to fill in any holes that result so that all of the objects are filled in with solid white. There is also some residual quantization noise after I do this step, so I'm going to a small opening with a 3 x 3 square element. After, I'm going to close the shapes with a 3 x 3 square element, as I see that there are noticeable gaps in the shapes. Therefore:</p> <p>Therefore, directly reading in your image from where you've posted it:</p> <pre><code>im = imread('http://s29.postimg.org/spkab8oef/image.jpg'); %// Read in the image im_gray = im2double(rgb2gray(im)); %// Convert to grayscale, then [0,1] out = imclearborder(im_gray &gt; 0.6); %// Threshold using 0.6, then clear the border out = imfill(out, 'holes'); %// Fill in the holes out = imopen(out, strel('square', 3)); out = imclose(out, strel('square', 3)); </code></pre> <p>This is the image I get:</p> <p><img src="https://i.stack.imgur.com/kzjuL.png" alt="enter image description here"></p> <p>Now, apply the Circular Hough Transform. The general syntax for this is:</p> <pre><code>[centres, radii, metric] = imfindcircles(img, [start_radius, end_radius]); </code></pre> <p><code>img</code> would be the binary image that contains your shapes, <code>start_radius</code> and <code>end_radius</code> would be the smallest and largest radius of the circles you want to find. The Circular Hough Transform is performed such that it will find any circles that are within this range (in pixels). The outputs are:</p> <ol> <li><code>centres</code>: Which returns the <code>(x,y)</code> positions of the centres of each circle detected</li> <li><code>radii</code>: The radius of each circle</li> <li><code>metric</code>: A measure of purity of the circle. Higher values mean that the shape is more probable to be a circle and vice-versa. </li> </ol> <p>I searched for circles having a radius between 30 and 60 pixels. Therefore:</p> <pre><code>[centres, radii, metric] = imfindcircles(out, [30, 60]); </code></pre> <p>We can then demonstrate the detected circles, as well as the radii by a combination of <code>plot</code> and <a href="http://www.mathworks.com/help/images/ref/viscircles.html" rel="nofollow noreferrer"><code>viscircles</code></a>. Therefore:</p> <pre><code>imshow(out); hold on; plot(centres(:,1), centres(:,2), 'r*'); %// Plot centres viscircles(centres, radii, 'EdgeColor', 'b'); %// Plot circles - Make edge blue </code></pre> <p>Here's the result:</p> <p><img src="https://i.stack.imgur.com/DxtYK.png" alt="enter image description here"></p> <p>As you can see, even with the overlapping circles towards the top, the Circular Hough Transform was able to detect two distinct circles in that shape.</p> <hr> <h1>Edit - November 16th, 2014</h1> <p>You wish to ensure that the objects are separated before you do <code>bwboundaries</code>. This is a bit tricky to do. The only way I can see you do this is if you don't even use <code>bwboundaries</code> at all and do this yourself. I'm assuming you'll want to analyze each shape's properties by themselves after all of this, so what I suggest you do is iterate through every circle you have, then place each circle on a new blank image, do a <code>regionprops</code> call on that shape, then append it to a separate array. You can also keep track of all of the circles by having a separate array that adds the circles one at a time to this array. </p> <p>Once you've finished with all of the circles, you'll have a structure array that contains all of the measured properties for all of the measured circles you have found. You would use the array that contains only the circles from above, then use these and remove them from the original image so you get just the lines. You'd then call one more <code>regionprops</code> on this image to get the information for the lines and append this to your final structure array.</p> <p>Here's the first part of the procedure I outlined above:</p> <pre><code>num_circles = numel(radii); %// Get number of circles struct_reg = []; %// Save the shape analysis per circle / line here %// For creating our circle in the temporary image [X,Y] = meshgrid(1:size(out,2), 1:size(out,1)); %// Storing all of our circles in this image circles_img = false(size(out)); for idx = 1 : num_circles %// For each circle we have... %// Place our circle inside a temporary image r = radii(idx); cx = centres(idx,1); cy = centres(idx,2); tmp = (X - cx).^2 + (Y - cy).^2 &lt;= r^2; % // Save in master circle image circles_img(tmp) = true; %// Do regionprops on this image and save struct_reg = [struct_reg; regionprops(tmp)]; end </code></pre> <hr> <p>The above code may be a bit hard to swallow, but let's go through it slowly. I first figure out how many circles we have, which is simply looking at how many radii we have detected. I keep a separate array called <code>struct_reg</code> that will append a <code>regionprops</code> <code>struct</code> for each circle and line we have in our image. I use <a href="http://www.mathworks.com/help/matlab/ref/meshgrid.html" rel="nofollow noreferrer"><code>meshgrid</code></a> to determine the <code>(X,Y)</code> co-ordinates with respect to the image containing our shapes so that I can draw one circle onto a blank image at each iteration. To do this, you simply need to find the Euclidean distance with respect to the centre of each circle, and set the pixels to <code>true</code> only if that location has its distance less than <code>r</code>. After doing this operation, you will have created only one circle and filtered all of them out. You would then use <code>regionprops</code> on this circle, add it to our <code>circles_img</code> array, which will only contain the circles, then continue with the rest of the circles.</p> <p>At this point, we will have saved all of our circles. This is what <code>circles_img</code> looks like so far:</p> <p><img src="https://i.stack.imgur.com/hc5ds.png" alt="enter image description here"></p> <p>You'll notice that the circles drawn are clean, but the actual circles in the original image are a bit jagged. If we tried to remove the circles with this clean image, you will get some residual pixels along the border and you won't completely remove the circles themselves. To illustrate what I mean, this is what your image looks like if I tried to remove the circles with <code>circles_img</code> by itself:</p> <p><img src="https://i.stack.imgur.com/viTXf.png" alt="enter image description here"></p> <p>... not good, right?</p> <p>If you want to completely remove the circles, then do a morphological reconstruction through <a href="http://www.mathworks.com/help/images/ref/imreconstruct.html" rel="nofollow noreferrer"><code>imreconstruct</code></a> where you can use this image as the seed image, and specify the original image to be what we're working on. The job of morphological reconstruction is essentially a flood fill. You specify seed pixels, and an image you want to work on, and the job of <code>imreconstruct</code> is from these seeds, flood fill with white until we reach the boundaries of the objects that the seed pixels resided in. Therefore:</p> <pre><code>out_circles = imreconstruct(circles_img, out); </code></pre> <p>Therefore, we get this for our final reconstructed circles image:</p> <p><img src="https://i.stack.imgur.com/ETvmZ.png" alt="enter image description here"></p> <p>Great! Now, use this and remove the circles from the original image. Once you do this, run <code>regionprops</code> again on this final image and append to your <code>struct_reg</code> variable. Obviously, save a copy of the original image before doing this:</p> <pre><code>out_copy = out; out_copy(out_circles) = false; struct_reg = [struct_reg; regionprops(out_copy)]; </code></pre> <p>Just for sake of argument, this is what the image looks like with the circles removed:</p> <p><img src="https://i.stack.imgur.com/Ylqkr.png" alt="enter image description here"></p> <p>Now, we have analyzed all of our shapes. Bear in mind I did the full <code>regionprops</code> call because I don't know exactly what you want in your analysis... so I just decided to give you everything.</p> <hr> <p>Hope this helps!</p>
<p>erosion is the way to go. You should probably use a larger structuring element.</p>
<p>How about </p> <p>1 erode</p> <p>2 detect your objects</p> <p>3 dilate each object for itself using the same structuring element</p>