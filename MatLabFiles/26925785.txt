how to split a matrix of size 88x88 in 4 parts in matlab
<p>so far i have done Declare a random Matrix M of size 88 x 88 Type of M should be uint8 (all values should be between 0 to 255). Spilt the Matrix into 4 parts: p1, p2, p3, p4 Transpose all parts Concatenate all these four parts into new matrix N</p>
<p>Another approach would be to use <a href="http://www.mathworks.com/help/matlab/ref/mat2cell.html" rel="nofollow"><code>mat2cell</code></a> to split up the matrix into a 2 x 2 grid of cells, transpose each of the cell's contents using <a href="http://www.mathworks.com/help/matlab/ref/cellfun.html" rel="nofollow"><code>cellfun</code></a>, then piece them all together using <a href="http://www.mathworks.com/help/matlab/ref/cell2mat.html" rel="nofollow"><code>cell2mat</code></a>. Therefore:</p> <pre><code>[rows, cols] = size(M); C = mat2cell(M, [rows/2, rows/2], [cols/2, cols/2]); D = cellfun(@transpose, C, 'uni', 0); out = cell2mat(D); </code></pre> <p>Minor note: This only works when the rows and columns are both even.</p>
<p>You are not much clear in the question, Maybe this helps,</p> <pre><code>M = uint8(randi([0 255],[88 88])); p1 = M(1:end/2 ,1:end/2 ); p2 = M(1:end/2 ,end/2+1:end); p3 = M(end/2+1:end,1:end/2 ); p4 = M(end/2+1:end,end/2+1:end); N = [p1' p2';p3' p4']; </code></pre>
<h2>Approach #1</h2> <p>If you have the Image Processing Toolbox, you can use <strong><a href="http://www.mathworks.in/help/images/ref/blockproc.htm" rel="nofollow"><code>blockproc</code></a></strong> for a pretty straight-forward solution to this -</p> <pre><code>fun = @(block_struct) transpose(block_struct.data); N = blockproc(M, [size(M,1)/2 size(M,2)/2], fun) </code></pre> <hr> <h2>Approach #2</h2> <p>Let's suppose you have an input matrix of size <code>m x n</code> and you would like to partition it into <code>dim1p</code> parts along the rows and <code>dim2p</code> parts along the columns, so that each block is of size <code>m/dim1p x n/dim2p</code> and you would like transpose them and finally concatenate them back to form a 2D array. This could be thought of as a <strong><code>general case</code></strong> of what you had proposed in the question.</p> <p>To solve such a case with performance in mind, you can use this -</p> <pre><code>[m,n] = size(M); %// Get size dim1p = 2; %// number of parts to be partitioned along dimension-1 (rows) dim2p = 2; %// number of parts to be partitioned along dimension-2 (columns) %// Split and transpose, resulting in a 3D array A = reshape(permute(reshape(M, m, n/dim2p, []), [2 1 3]), n/dim2p, m/dim1p, []); %// Join the 3D slices back into a 2D array for the desired output nrows = n*dim1p/dim2p; N = reshape(permute(reshape(permute(A,[1 3 2]),nrows,dim2p,[]),[1 3 2]),nrows,[]) </code></pre> <p>Sample run (assuming M as <code>9 x 8</code> sized and partitioning it into <code>3</code> and <code>4</code> parts along the rows and columns respectively so that each block is of size <code>3 x 2</code>) -</p> <pre><code>M = 5 6 2 6 4 2 1 3 2 8 8 1 3 8 3 7 5 1 6 8 4 1 6 8 6 5 7 3 3 6 7 1 4 3 9 3 2 2 5 3 4 9 5 7 6 2 2 1 7 6 2 5 9 3 5 6 8 9 5 6 9 6 7 1 1 1 3 3 4 9 1 3 dim1p = 3 dim2p = 4 N = 5 2 5 2 8 6 4 3 4 1 3 6 6 8 1 6 1 8 2 8 1 3 7 8 6 4 4 7 9 5 3 2 6 7 5 2 5 3 9 3 3 7 6 2 2 1 3 1 7 8 1 2 5 3 9 9 4 5 7 1 6 9 1 5 6 3 3 6 9 6 1 3 </code></pre>