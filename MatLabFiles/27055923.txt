MATLAB crashes when it reaches mxSetPr in a mex file
<p>I am writing a function within in a <code>mex</code> file which calls a <code>MATLAB</code> function. Unfortunately, when it comes to <code>mxSetPr</code>, <code>MATLAB</code> crashes and does not proceed further. Could someone kindly tell me how I can fix this?</p> <pre><code>void myconv2( double * Ain , double *Aout, int AnRows , int AnCols, double* kernel, int kernelnRows, int kernelnCols ) { mxArray *rhs[3], *lhs[1]; rhs[0] = mxCreateNumericMatrix( 0, 0, mxDOUBLE_CLASS, mxREAL ); rhs[1] = mxCreateNumericMatrix( 0, 0, mxDOUBLE_CLASS, mxREAL ); rhs[2] = mxCreateString ( "same" ); mxSetPr( rhs[0], Ain ); mxSetM ( rhs[0], AnRows ); mxSetN ( rhs[0], AnCols ); mxSetPr( rhs[1], kernel ); mxSetM ( rhs[1], kernelnRows ); mxSetN ( rhs[1], kernelnCols ); mexCallMATLAB(1, lhs, 3, rhs, "conv2"); Aout = mxGetPr( lhs[0] ); } </code></pre>
<p>The memory passed to <code>mxSetPr</code> must be allocated with <code>mxMalloc</code> or <code>mxCalloc</code>, NOT with <code>malloc</code>, <code>new</code>, etc. From the <a href="http://www.mathworks.com/help/matlab/apiref/mxsetpr.html#bqvozb3-3" rel="nofollow"><code>mxSetPr</code> docs page</a>:</p> <blockquote> <p><code>void mxSetPr(mxArray *pm, double *pr);</code><br> ...<br> <code>pr</code></p> <p>Pointer to the first element of an array. Each element in the array contains the real component of a value. The array must be in dynamic memory; <strong>call <code>mxCalloc</code> to allocate this memory. Do not use the ANSIÂ® C <code>calloc</code> function, which can cause memory alignment issues leading to program termination</strong>. If <code>pr</code> points to static memory, memory leaks and other memory errors can result.</p> </blockquote> <p>Another issues is with your declaration for <code>myconv2</code>, where the output argument is <code>double *Aout</code>. Inside the function, <code>Aout</code> itself is modified, not whatever <code>Aout</code> originally points to, if anything. To modify the pointer, either pass by reference (<code>double *&amp;Aout</code>), or pass a double pointer (<code>double **Aout</code>) and change your calling convention. Its easiest to use a reference if you are compiling as C++.</p> <p>This will get you past the <code>mxSetPr</code> commands and allow you to run <code>mexCallMATLAB</code>, but the next issue is that the <code>mxArray</code> pointed to by <code>plhs[1]</code> is created <em>inside <code>myconv2</code></em>, which means it will be deallocated by the MATLAB memory manager whenever it likes after the program termination. You should either copy the data out of <code>lhs[1]</code> and into <code>Aout</code> (I think this is what you want since you pass the pointer by value) or allocate <code>Aout</code> outside of <code>myconv2</code> with <code>mxMalloc</code> or <code>mxCalloc</code>.</p> <p>Another fun surprise with having <code>mxSetPr</code> in a different function from the one that created the <code>mxArray*</code> being assigned is that when <code>myconv2</code> exists, MATLAB will also try to destroy each <code>mxArray</code> in <code>rhs[]</code>. Assuming you want the caller to be responsible for these arrays, then set the pointers to <code>NULL</code> before <code>myconv2</code> exits. I've never had come across this situation before, but this might be a valid approach.</p> <hr> <p>Copying the data inside <code>myconv</code></p> <pre><code>#include "mex.h" void myconv2(double * Ain, double *Aout, int AnRows, int AnCols, double* kern, int kernelnRows, int kernelnCols) { mxArray *rhs[3], *lhs[1]; rhs[0] = mxCreateNumericMatrix(0, 0, mxDOUBLE_CLASS, mxREAL); rhs[1] = mxCreateNumericMatrix(0, 0, mxDOUBLE_CLASS, mxREAL); rhs[2] = mxCreateString("same"); mxSetPr(rhs[0], Ain); mxSetM(rhs[0], AnRows); mxSetN(rhs[0], AnCols); mxSetPr(rhs[1], kern); mxSetM(rhs[1], kernelnRows); mxSetN(rhs[1], kernelnCols); mexCallMATLAB(1, lhs, 3, rhs, "conv2"); // prevent `Ain` and `kern` from being destroyed on `myconv2` return mxSetPr(rhs[0], NULL); mxSetPr(rhs[1], NULL); // copy each element of output double *d = mxGetPr(lhs[0]); for (int i = 0; i &lt; AnRows*AnCols; ++i) Aout[i] = d[i]; } void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[]) { int nrows = 256, ncols = 256; double *Aout = new double[nrows * ncols]; // allocate with `mxMalloc` double *Ain = (double*)mxMalloc(nrows * ncols * sizeof(double)); double *kern = (double*)mxMalloc(5 * 5 * sizeof(double)); myconv2(Ain, Aout, nrows, ncols, kern, 5, 5); // free here, not in `myconv2` mxFree(Ain); mxFree(kern); // do something with Aout mexPrintf("%p\n", Aout); delete[] Aout; } </code></pre> <hr> <p>Creating <code>lhs</code> outside of <code>myconv2</code> to avoid any copies</p> <pre><code>void myconv2(double *Ain, mxArray *&amp;lhs, int AnRows, int AnCols, double *kern, int kernelnRows, int kernelnCols) { mxArray *rhs[3]; rhs[0] = mxCreateNumericMatrix(0, 0, mxDOUBLE_CLASS, mxREAL); rhs[1] = mxCreateNumericMatrix(0, 0, mxDOUBLE_CLASS, mxREAL); rhs[2] = mxCreateString("same"); mxSetPr(rhs[0], Ain); mxSetM(rhs[0], AnRows); mxSetN(rhs[0], AnCols); mxSetPr(rhs[1], kern); mxSetM(rhs[1], kernelnRows); mxSetN(rhs[1], kernelnCols); mexCallMATLAB(1, &amp;lhs, 3, rhs, "conv2"); mxSetPr(rhs[0], NULL); mxSetPr(rhs[1], NULL); } void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[]) { mxArray *AoutMX; int nrows = 256, ncols = 256; double *Ain = (double*)mxMalloc(nrows * ncols * sizeof(double)); double *kern = (double*)mxMalloc(5 * 5 * sizeof(double)); myconv2(Ain, AoutMX, nrows, ncols, kern, 5, 5); mxFree(Ain); mxFree(kern); // do something with AoutMX mexPrintf("%x\n", mxGetPr(AoutMX)); } </code></pre> <p>Although, it's important to note that when you call <code>conv2</code>, it always creates a <strong>new <code>mxArray</code>, even if you use the same <code>mxArray*</code></strong>.</p> <hr> <p>For completeness, it is worth noting that there are low-level hacks that let you assign any pointer (not just those created with <code>mxMalloc</code> and <code>mxCalloc</code>), but these involve guessing the structure of the opaque type <code>mxArray</code> and doing something like ths:</p> <pre><code>// effectively, mxSetPr(mxmat, Pr + n); ((mxArray_type_guess*)(mxmat))-&gt;data.number_array.pdata = (Pr + n); </code></pre> <p>See the <a href="http://www.mathworks.com/matlabcentral/fileexchange/24576-inplacearray--a-semi-pointer-package-for-matlab" rel="nofollow">InplaceArray FEX submission</a> for more info. The <code>mxArray</code> struct guesses are probably badly out of date though. Supposedly you can determine the right structure with <a href="http://www.mathworks.com/matlabcentral/fileexchange/23576-min-max-selection/content/MinMaxSelection/buildInternal_mxArrayDef.m" rel="nofollow">this code</a>.</p>