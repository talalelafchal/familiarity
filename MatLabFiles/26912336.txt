Dimension reduction for logical arrays
<p>I have measurements of 5 devices at two different points of time. A measurement basically consists of an array of ones and zeros corresponding to a bit value at the corresponding location:</p> <pre><code>whos measurement1_dev1_time1 Name Size Bytes Class Attributes measurement1_dev1_time1 4096x8 32768 logical </code></pre> <p>I assume that for a specific device the changes between time 1 and 2 of the measurements are unique. However, since I am dealing with 32768 bits at different locations, it is quite hard to visualize if there is some kind of dependency. </p> <p>As every bit at location <code>x</code>can be regarded as one dimension of an observation I thought to use PCA to reduce the number of dimensions.</p> <p>Thus, for every of the 5 devices:</p> <ol> <li>I randomly sample <code>n</code> measurements at point <code>t1</code>and <code>t2</code> seperatly</li> <li>I prepare an array as input for <code>pca()</code> with <code>m</code>*n columns (<code>m</code>&lt; 32768; its a subset of all the observed bits, as the original data might be too big for pca) and 4 rows (one row for each device).</li> <li>On this array <code>A</code> I calculate the pca: ``[coeff score latent] = pca(zscore(A))```</li> <li>Then I try to visualize it using <code>biplot</code>: <code>biplot(coeff(:,1:2), 'score', score(:,1:2))</code></li> </ol> <p>However, this gives me really strange results. Maybe PCA is not the right approach for this problem? I also modified the input data to do the PCA not on the logical bit array itself. Instead, I created a vector, which holds the indices where there is a '1' in the original measurement array. Also this produces strange results.</p> <p>As I am completely new to PCA I want to ask you if you either see a flaw in the process or if PCA is just not the right approach for my goal and I better look for other dimension reduction approaches or clustering algorithms.</p>
<p>Can this 'some kind of dependency' be just pairwise correlation of your data points? Or what do you want to find out?</p> <p>Do you get 'expected results' if you do:</p> <pre><code>meas_norm = 2*measurement1_dev1_time1 - 1; CovarianceMatrix = meas_norm' * meas_norm; figure pcolor(CovarianceMatrix ) </code></pre> <p>Can there be a problem of data type? Try feeding <code>double(data)</code>. (Please add proper code into your example)</p> <p>if you look for dimension reduction, you can also think about <a href="https://en.wikipedia.org/wiki/Independent_component_analysis" rel="nofollow">ICA</a>.</p> <hr> <p>UPD: can you probe it with <code>xor</code>? As you cannot do <code>xor</code> on rows or columns, you can trick <code>all(x, dimension)</code></p> <pre><code>example = imread('cameraman.tif')&gt;128; meas_points = numel(example); num_sensors = 4; %// simulate data for t1 meas_before = repmat(example(:), 1, num_sensors); flickering_before = (rand(meas_points, num_sensors)&lt;0.001); meas_before(flickering_before) = ~meas_before(flickering_before); %// simulate position of changing pixels, let's say 8% true_change = (rand(num_sensors,1)&lt;0.08); %// simulate data for t2 meas_after = repmat(example(:), 1, num_sensors); meas_after(true_change) = ~meas_after(true_chage); flickering_after = (rand(meas_points, num_sensors)&lt;0.001); meas_after(flickering_after) = ~meas_after(flickering_after); stable_points_after = all(meas_after, 2) | all(~meas_after, 2); stable_point_fraction = sum(stable_points_after)./ meas_points; %// similarly for the states before (i.e. t1) stable_points_before = all(meas_before, 2) | all(~meas_before, 2); %// now see which change coherently stable_chage = meas_after(stable_points_after, 1) &amp; meas_before(stable_points_before, 1) </code></pre>