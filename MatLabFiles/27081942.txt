Getting FFT peaks from data
<p>I am developing a speech recognition system from scratch using Octave. I am trying to detect phonemes by detecting differences in frequency. Currently I have read in a wav file, organized the values into blocks and applied <code>fft</code> to the overall data. After, I plot the new data with <code>plot(abs(real(fft(q))))</code> which creates this graph: <img src="https://i.stack.imgur.com/yguDM.png" alt="fft graph"></p> <p>How could I get the frequency values (the peaks of the graph)?</p>
<p>If you don't have access to <code>findpeaks</code>, the basic premise behind how it works is that for each point in your signal, it searches a three element window that is centred at this point and checks to see whether the centre of this window is larger than the left and right element of this window. You want to be able to find both positive and negative peaks, so you'd need to check the absolute value.</p> <p>As such, what you can do is make two additional signals that shift the signal to the left by 1 and to the right by 1. When we do this, we will actually be checking for peaks starting at the <strong>second element</strong> in your signal, in order to make room for looking to the left. We keep checking up until the <strong>second last element</strong>, in order to make room for looking to the right. Therefore, we will actually be checking for peaks on a <code>N - 2</code> version of the signal where <code>N</code> is the length of your signal. Therefore, when we create the left shifted signal, we extract the first element of the signal up until the <strong>third last element</strong>. When we create the right shifted signal, we extract from the <strong>third element</strong> up until the last element. The original signal will simply have its first and last elements removed.</p> <p>Therefore, by checking for peaks this way, we will lose out on the first and last point of your data, but that should be suitable as there most likely won't be any peaks at the beginning and at the end. After, creating all of these signals, simply use logical indexing to see whether the corresponding values in the original signal (without the first and last elements) are larger than the other two signals in their corresponding positions.</p> <p>As such, supposing your signal was stored in <code>f</code>, you would do the following:</p> <pre><code>f1 = abs(f(2:end-1)); %// Original signal f2 = abs(f(1:end-2)); %// Left shift f3 = abs(f(3:end)); %// Right shift idx = find(f1 &gt; f2 &amp; f1 &gt; f3) + 1; %// Get the locations of where we find our peaks </code></pre> <p><code>idx</code> will contain the index locations of where the peaks occur. Bear in mind that we started searching for peaks at the <strong>second</strong> position, and so you need to <strong>add 1</strong> to accommodate for this shift. If you wanted to find the actual time (or frequency in your case) values, you would just use <code>idx</code> to index into the time (or frequency) array that was used to generate your signal and find them. As such, let's use an artificial case where I generate a sinusoid from 0 to 3 seconds with a frequency of 1 Hz. Therefore:</p> <pre><code>t = 0 : 0.01 : 3; f = sin(2*pi*t); </code></pre> <p>Now, if we ran the above code with this signal, we'd find the location of our peaks. We can then use these locations to index into <code>t</code> and <code>f</code> and plot the signal as well as where we have detected our peaks. Therefore:</p> <pre><code>plot(t, f, t(idx), f(idx), 'r.') </code></pre> <p>This is what I get:</p> <h2><img src="https://i.stack.imgur.com/jUFwh.png" alt="enter image description here"></h2> <p>Bear in mind that this is a very simple way of detecting peaks, but that is what is essentially done in <code>findpeaks</code>. If you used the above code, it would basically find <strong>all peaks</strong>. As such, the code would find dozens of peaks in that above graph, because there are local maxima all over your spectrum. You probably want to determine where the <strong>strong</strong> peaks are located. What people usually do is use a <strong>threshold</strong> to signify how large the peak should be before deciding whether that is a valid peak. As such, you can enforce a threshold, and do something like this:</p> <pre><code>thresh = ... ; %// Define threshold here idx = find(f1 &gt; f2 &amp; f1 &gt; f3 &amp; f1 &gt; thresh) + 1; %// Get the locations of where we find our peaks </code></pre> <p>In your case for your graph, you may want to set this so that you find any peaks whose magnitude is larger than 10 perhaps.</p> <hr> <p>There are a lot of other things that <code>findpeaks</code> does, such as filtering out noisy peaks and some other robust measures. If you want to use <code>findpeaks</code>, you need to make sure that you install signal package. You can simply use <code>pkg install</code> from the Octave Command Prompt and install the <code>signal</code> package. Specifically, try this:</p> <pre><code>pkg install -forge signal </code></pre> <p>Once you install the <code>signal</code> package, you can load it into the Octave environment by doing:</p> <pre><code>pkg load signal </code></pre> <p>If you have to install dependencies, it'll tell you when you try to install the <code>signal</code> package. Check out this link for more details: <a href="https://www.gnu.org/software/octave/doc/interpreter/Installing-and-Removing-Packages.html" rel="nofollow noreferrer">https://www.gnu.org/software/octave/doc/interpreter/Installing-and-Removing-Packages.html</a></p> <p><code>mkoctfile</code> stands for making / compiling an Octave file. If you don't have <code>mkoctfile</code>, make sure you have the most recent version of Octave installed. What I recommend you do to make things simple is to install either <a href="http://brew.sh" rel="nofollow noreferrer">Homebrew</a> or <a href="https://www.macports.org/" rel="nofollow noreferrer">MacPorts</a> and get Octave in that fashion. Once you install it, then you should be able to get <code>mkoctfile</code> working. However, if you still can't, you may need to have a compatible compiler installed. The easy approach is to install the Command Line Developer tools from Xcode. Go <a href="https://developer.apple.com/xcode/downloads/" rel="nofollow noreferrer">to this link</a> then go to Additional Tools. </p> <p>Good luck!</p>
<p>You can use findpeaks function from octave signal package:</p> <p><a href="http://octave.sourceforge.net/signal/function/findpeaks.html" rel="nofollow">http://octave.sourceforge.net/signal/function/findpeaks.html</a></p>