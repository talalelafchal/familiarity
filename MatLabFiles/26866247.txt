How to count the number of overlapping blocks in an Image
<p>I have a 512X512 size of image and I have made 4x4 overlapping blocks for the entire image.How can i count the number of overlapping blocks and save it in an Array in matlab. I have done like below for 4x4 overlapping blocks. Now how to count the no of blocks and store it using an Array.</p> <pre><code>[e f] = size(outImg); l=0; for i=2:e-2 for j=2:f-2 H =double(outImg((i-1:i+2),(j-1:j+2))); eval(['out_' num2str(l) '=H']); l=l+1 end; end; </code></pre>
<p>The answer is very simple. Each loop iteration will access 1 overlapping block in your image. All you have to do is count how many times the loop iterates, which is <code>((e-2) - 2 + 1) x ((f - 2) - 2 + 1) = (e - 3) x (f - 3)</code>. There's no need to keep a loop iteration variable.</p> <hr> <p>Minor note. Under no circumstances should you use <code>eval</code> unless absolutely necessary. The MATLAB gods will smite any offenders swiftly. That code to assign a new variable to each increment of <code>l</code> is absolutely unnecessary. If you were to have 10000 overlapping blocks, you would have 10000 variables. You can just simply take a look at <code>l</code> at the end and this would tell you how many overlapping blocks you have.</p> <p><strong>Remove that line of code. WE HATES IT. IT BURNS US.</strong></p> <p><img src="http://img2.wikia.nocookie.net/__cb20090913022310/lotr/images/c/cf/Gollum_011.JPG" alt=""></p> <hr> <p>See <a href="http://blogs.mathworks.com/loren/2005/12/28/evading-eval/" rel="nofollow">this post by Loren Shure for more details</a> on why using <code>eval</code> is bad.</p>
<p>From what I understand the question, you want to know how many blocks of 4x4 can fit in the image, and then store them.</p> <p>Calculating the number of blocks is trivial, in the code that you give as example, <code>l</code> is the number of element counted. Of course, that its value is deterministic (determined by <code>f</code> and <code>e</code>). No need to loop over them to get the value of the count.</p> <pre><code>count = (f-3)*(e-3); </code></pre> <p>If you want to save the values in an array (assuming that you mean here a matrix and not a cell array) you need to decide how to represent it, you can store it as a 4D <code>e-3 x f-3 x 4 x 4</code> matrix (as @Steffen suggested), or as a 3D <code>4 x 4 x count</code> matrix, I think that the later is more intuitive. In any case you should assign the memory for the matrix in advance and not on the fly:</p> <pre><code>[e f] = size(outImg); count = (f-3)*(e-3); outMat = zeros(4,4,count); % assign the memory for the matrix l = 0; for i=2:e-2 for j=2:f-2 l = l + 1; outMat(:,:,l) = double(outImg((i-1:i+2),(j-1:j+2))); end; end; </code></pre> <p>The number of blocks is stored as both <code>count</code> and <code>l</code>, but calculating <code>count</code> in advance allows to assign the needed memory in advance, the <code>i</code> block is stored as <code>outMat(:,:,i)</code>.</p> <p>An implementation using the 4D matrix would be:</p> <pre><code>[e f] = size(outImg); count = (f-3)*(e-3); outMat = zeros((f-3),(e-3),4,4); % assign the memory for the matrix for i=2:e-2 for j=2:f-2 outMat(i,j,:,:) = double(outImg((i-1:i+2),(j-1:j+2))); end; end; </code></pre> <p>In this case, <code>l</code> isn't needed and each block (indexed <code>i</code>,<code>j</code>) is located at <code>outMat(i,j,:,:)</code></p> <p>Regarding cell array vs. a matrix, since a matrix requires a continuous place in the memory, you may want to consider using a cell array instead of a matrix. A 512x512x4 matrix of doubles requires (assuming 8 Byte representation) 8MB (512*512*8*4 = 8*1024*1024). If the dimensions were bigger, or if you are strapped for (continuous) memory a cell array may be a better solution. You can read more about the difference at <a href="http://stackoverflow.com/questions/13000923/difference-between-cell-and-matrix-in-matlab">Difference between cell and matrix in matlab?</a>.</p> <p>The implementation would be very similar.</p> <pre><code>[e f] = size(outImg); count = (f-3)*(e-3); outArray = cell(1,count); l = 0; for i=2:e-2 for j=2:f-2 l = l + 1; outArray{1,l} = double(outImg((i-1:i+2),(j-1:j+2))); end; end; </code></pre>
<p>For the 1-D case, the correct formula to estimate the total number of overlapping blocks is:</p> <p>(#Of_blocks) = (#Image_width - #Block_width) / (#Block_width - #Block_overlap) + 1 </p> <p>If the result is not integer you just take the floor of #Of_blocks, this means that the whole interval can't be covered using that setup.</p>