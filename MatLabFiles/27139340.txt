Matlab: Unable to perform inverse operation - How to create non-singular square matrix
<p>I am trying Matrix operations. The data is a time series model - Autoregressive model, AR(2) where the model order <code>p =2</code> represented by the variable <code>Y</code> excited by white Gaussian noise, <code>epsilon</code>. I am stuck with conceptual questions for which I will be grateful for answers. The code computes the autocorrelation matrix after multiplying the 1 sampled time delayed vector Y with the transpose of the 1 samples time delayed vector. The general formula for correlation is <code>E(Y*Y')</code>. In this case I need to do <code>E(Y(1:end)*Y(1:end)')</code>. The answer is a scalar if done this way. But, based on the reply by Walter Roberts <a href="http://www.mathworks.com/matlabcentral/answers/25441-mathematical-expectation" rel="nofollow noreferrer">mathematical expectation</a> I am able to get a <code>9 by 9 matrix</code>. However, I am not getting a non-singular matrix. </p> <p>How do I create a singular matrix for the autocorrelation matrix such that the inverse can be computed? Please help</p> <p>THE CODE:</p> <pre><code>clc; clear all; var_eps = 1; epsilon = sqrt(var_eps)*randn(5000,1); % Gaussian signal exciting the AR model Y(1) = 0.0; Y(2) = 0.0; for n= 3:5000 Y(n)= 0.1950*Y(n-1) -0.9500*Y(n-2)+ epsilon(n); %AR(2) model end y_tminus1 = Y(1:end-1).'; mult = y_tminus1*y_tminus1'; %This creates a square matrix autocorr = xcorr2(mult); %To perform autocorrelation of 1 sampled lag time series with itself(1 sampled lag) inverse_autocorr = inv(autocorr); **%PROBLEM** %Warning: Matrix is singular to working precision. trace_inv=trace(inverse_autocorr); </code></pre> <p>UPDATE: I am facing this problem since I am trying to implement the terms of the matrix in Expression of Eq(20) and the RHS of Eq(24) <img src="https://i.stack.imgur.com/57T9u.png" alt="img1"><br> <img src="https://i.stack.imgur.com/wrPeN.png" alt="img2"></p> <p><strong>UPDATE : 01 Dec</strong></p> <p>In this code, the issues, the analytical form of variables </p> <pre><code>CRB_LHS = (b_transpose_b/N)*tr(inv(E[y(t-1)y(t-1)'])) CRB_RHS = sigma2_v*tr(inv(sum_t =1 to N E[y(t-1)y(t-1)'])) </code></pre> <p>where <strong>y(t-1)</strong> = </p> <pre><code>[y(t-1), y(t-2),..,y(t-p)]' </code></pre> <p>The CRB_LHS is calculated from Eq(19) of the paper</p> <pre><code>`Y_ARMA(n)= 0.1950*Y_ARMA(n-1)- 0.1950*Y_ARMA(n-2) + b*x_gauss(n);` where x_gauss = N(0,1) </code></pre> <p>The CRB_RHS is calculated from Eq(1)</p> <p>Y_AR(n) = 0.1950*Y_AR(n-1) -0.9500*Y_AR(n-2) + x_chaos(n); where </p> <pre><code>x_chaos(n)= f(x(n-1),x(n-2),...,x(n-d)); d = 2 </code></pre> <p>I have assumed the coefficients <code>b = 1</code> for the white noise in ARMA model of Eq(19).</p> <p>For each SNR level, <code>snrbd = -3:1:2</code> I am simulating <code>M</code> number of time series (M independent runs). There are 2 doubts regarding the implementation : (1) for the RHS of Eq(25), in the code the Expectation is taken over the independent runs (according to the suggestion in the answer, provided I understood correctly) - the expression shows that the sum is taken over all the data points &amp; Expectation over M samples for (t-1). This is confusing to implement. (2) The code throws error due to the inverse. Unable to solve this. </p> <p>The result should be <code>CRB_LHS &gt; CRB_RHS</code> for each snr.</p> <pre><code>clc; clear all; N = 10; M = 100; % number of independent runs over which the snrdb = -3:1:2; for snr_levels = 1:length(snrdb) for monte_carlo = 1: M x_gauss = randn(1,N); x_chaos(1) = rand(); % generate the chaotic code for i =1 : N x_chaos(i+1) = 4*x_chaos(i)*(1-x_chaos(i)); end x_chaos = x_chaos-mean(x_chaos); Y_AR(1) = 0.0; Y_AR(2) = 0.0; Y_ARMA(1) = 0.0; Y_ARMA(2) = 0.0; for n= 3:N Y_ARMA(n)= 0.1950*Y_ARMA(n-1)- 0.1950*Y_ARMA(n-2) + x_gauss(n); %Eq(19) model Y_AR(n) = 0.1950*Y_AR(n-1) -0.9500*Y_AR(n-2) + x_chaos(n); %Eq(1) end % signalPower_Y_AR = var(Y_AR); signalPower_Y_AR = 1; sigma2_v = signalPower_Y_AR .*(10^(-snrdb(snr_levels))) ; v = sqrt(sigma2_v)*randn(1,length(Y_AR)); z = Y_AR + v; %Eq(3) Y_LHS = Y_ARMA(end-2:end-1).'; Y_RHS = z(end-2:end-1).'; A1(:,monte_carlo) = Y_LHS; B1(monte_carlo,:) = Y_LHS.'; A2(:,monte_carlo) = Y_RHS; B2(monte_carlo,:) = Y_RHS.'; end dimension = length(Y_LHS); sum_of_products_LHS = zeros(dimension,dimension); sum_prod_RHS = zeros(dimension,dimension); for runs = 1:M A = A1(:,runs); B = B1(runs,:); mult_LHS = A*B; C = A2(:,runs); D = B2(runs,:); mult_RHS = C*D; sum_of_products_LHS = sum_of_products_LHS+ mult_LHS; sum_of_products_RHS = sum_prod_RHS + mult_RHS; end b_transpose_b = 1; Expectation_LHS = mean(sum_of_products_LHS); % Inverse_LHS = inv(Expectation_LHS); % trace_LHS = tr(Inverse_LHS); Expectation_RHS = mean(sum_of_products_RHS); % Inverse_RHS = inv(Expectation_RHS); % trace_RHS = tr(Inverse_RHS); %MANUALLY MAKING A SQUARE MATRIX size_Inverse = 7; InverseMatrix_LHS = eye(size_Inverse,size_Inverse); InverseMatrix_RHS = eye(size_Inverse,size_Inverse); for i = 1:size_Inverse InverseMatrix_LHS(i:size_Inverse,i) = Expectation_LHS(1:size_Inverse-i+1); InverseMatrix_LHS(i,i:size_Inverse) = Expectation_LHS(1:size_Inverse-i+1); InverseMatrix_RHS(i:size_Inverse,i) = Expectation_RHS(1:size_Inverse-i+1); InverseMatrix_RHS(i,i:size_Inverse) = Expectation_RHS(1:size_Inverse-i+1); end trace_LHS = tr(InverseMatrix_LHS); CRLB_RHS(snr_levels)= (b_transpose_b/N).*trace_RHS; trace_RHS = tr(InverseMatrix_RHS); CRLB_RHS(snr_levels)= sigma2_v*trace_RHS; end </code></pre>
<p>For p=2, expression for y_tminus1 should be (see expressions after Eq.1 in the paper)</p> <pre><code>y_tminus1 = Y(end-2:end-1).' </code></pre> <p>Your mult is OK. For Eq. 20 you need to take expectation E(mult). For this you need to generate multiple paths and take an average over them. For the RHS of Eq. 25, you need to use y_tminus1 for every step of your ARMA process, sum corresponding mult matrices, take expectation over ensemble and only after that take an inverse. Maybe, try to adjust your code along these lines and i'll correct it.</p>