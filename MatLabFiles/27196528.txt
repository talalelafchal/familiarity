Subscript indices must either be real positive integers or logicals error within Matlab decay program
<p>I am having issues with a code of mine dealing with decay. The error "Subscript indices must either be real positive integers or logicals" continues to occur no matter how many times I attempt to fix the line of code: M=M(t)+h.*F</p> <p>Here is the complete code so that it may be easier to solve the issue:</p> <pre><code> M=10000; M=@(t) M*exp(-4.5*t); F=-4.5*M(t); h=.1; t(1)=0; tmax=20; n=(tmax-t(1))/h; i=1; while h&lt;=.5 while i&lt;=n t=t+h; M=M(t)+h.*F; data_out=[t,M]; dlmwrite('single_decay_euler_h.txt',data_out,'delimiter','\t','-append'); i=i+1; end h=h+.1; end </code></pre> <p>Thanks for any help.</p>
<p>The problem is caused by <code>M(t)</code> in your code, because <code>t</code> is not an integer or logical (t=1,1.1,1.2,...)</p> <p>You need to change your code to pass an integer as a subscript. Either multiply t by 10, or don't use the matrix <code>M</code> if you don't need it.</p>
<p>In the start, you're setting <code>M = 5000;</code>. In the following line, you're creating an anonymous function also called <code>M</code>:</p> <pre><code>M=@(t) M*exp(-4.5*t); </code></pre> <p>Now, your initial <code>M = 5000</code> variable has been overwritten, and is substituted by the function:</p> <pre><code>M(t) = 5000 * exp(-4.5*t); %// Note that the first M is used to get 5000 </code></pre> <p>Thereafter you do <code>F = -4.5*M(t)</code>. I don't know what the value <code>t</code> is here, but you're giving <code>F</code> the value <code>-4.5 * 5000 * exp(-4.5*t)</code>, for some value of <code>t</code>. You are <em>not</em> creating a function <code>F</code>.</p> <p>In the first iteration of the loop, <code>M=M(t)+h.*F;</code> is interpreted as:</p> <pre><code>M = 5000 * exp(-4.5*0) + 0.1*F %// Where F has some value determined by previous %// the function above and the previous value of t %// -4.5*0 is because t = 0 </code></pre> <p><code>M</code> is now no longer a function, but a single scalar value. The next iteration <code>t = 0.1</code>. When you do: <code>M=M(t)+h.*F;</code> now, it interprets both the first and second <code>M</code> as a variable, not a function. <code>t</code> is therefore used as an index, instead of being an input parameter to the function <code>M</code> (since you have overwritten it). </p> <p>When you are writing <code>M(t)</code>, you are trying to access the 0.1'th element of the 1x1 matrix (scalar) <code>M</code>, which obviously isn't possible. </p> <hr> <p>Additional notes:</p> <p>The outer while loop has no purpose as it stands now, since <code>i</code> isn't reset after the inner loop. When you're finished with the first iteration of the outer loop, <code>i</code> is already <code>&gt;n</code>, so it will never enter the inner loop again. </p> <p>You shouldn't mix variable and function names (as you do with <code>M</code>. Use different names, <em>always</em>. Unless you have a <em>very</em> good reason not to.</p> <p><code>data_out=[t,M];</code> is a growing vector inside a loop. This is considered very bad practice, ans is very slow. It's better to pre-allocate memory for the vector, for instance using <code>data_out = zeros(k,1)</code>, and insert new values using indexes, <code>data_out(ii) = M</code>.</p> <p>It's recommended not to use <code>i</code> and <code>j</code> as variable names in MATLAB as these also represent the imaginary unit <code>sqrt(-1)</code>. This might cause some strange bugs if you're not paying attention to it. </p> <p>You can almost certainly do what you're trying to do without loops. However, the function you have written is not functioning, and it's not explained all too well what you're trying to do, so it's hard to give advice as to how you can get what you want (but I'll give it a try). I'm skipping the <code>dlmwrite</code>-part, because I don't really understand what you want to output.</p> <pre><code>M = 5000; t0 = 0; tmax = 20; h = 0.1; %// I prefer leading zeros in decimal numbers t = t0: h: tmax; data_out = M .* exp(-4.5 * t); </code></pre>