imresize - trying to understand the bicubic interpolation
<p>I'm trying to understand the function:</p> <pre><code>function [weights, indices] = contributions(in_length, out_length, ... scale, kernel, ... kernel_width, antialiasing) if (scale &lt; 1) &amp;&amp; (antialiasing) % Use a modified kernel to simultaneously interpolate and % antialias. h = @(x) scale * kernel(scale * x); kernel_width = kernel_width / scale; else % No antialiasing; use unmodified kernel. h = kernel; end </code></pre> <p>I don't really understand what does this line means</p> <pre><code> h = @(x) scale * kernel(scale * x); </code></pre> <p>my scale is 0.5 <br> kernel is cubic.</p> <p>But other than that what does it mean? I think it is like creating a function which will be called later ?</p>
<p><code>imresize</code> accomplishes anti-aliasing when downsizing an image by simply broadening the cubic kernel, rather than a discrete pre-processing step.</p> <p>For a <code>kernel_width</code> of 4 pixels (8 after re-scaled), where the <code>contributions</code> function utilizes 10 neighbors for each pixel, the <code>kernel</code> vs <code>h</code> (scaled kernel) look like (unnormalized, ignore x-axis):</p> <p><img src="https://i.stack.imgur.com/Nj4ww.png" alt="enter image description here"></p> <p>This is easier than first performing a low-pass filter or Gaussian convolution in a separate pre-processing step.</p> <p>The cubic kernel is defined at the bottom of <code>imresize.m</code> as:</p> <pre><code>function f = cubic(x) % See Keys, "Cubic Convolution Interpolation for Digital Image % Processing," IEEE Transactions on Acoustics, Speech, and Signal % Processing, Vol. ASSP-29, No. 6, December 1981, p. 1155. absx = abs(x); absx2 = absx.^2; absx3 = absx.^3; f = (1.5*absx3 - 2.5*absx2 + 1) .* (absx &lt;= 1) + ... (-0.5*absx3 + 2.5*absx2 - 4*absx + 2) .* ... ((1 &lt; absx) &amp; (absx &lt;= 2)); </code></pre> <p><a href="http://verona.fi-p.unam.mx/boris/practicas/CubConvInterp.pdf" rel="nofollow noreferrer">PDF of the referenced paper.</a></p> <p>The relevant part is equation (15):</p> <p><img src="https://i.stack.imgur.com/BWK85.png" alt="enter image description here"></p> <p>This is a specific version of the general interpolation equations for <code>a = -0.5</code> in the following equations:</p> <p><img src="https://i.stack.imgur.com/wmSVp.png" alt="enter image description here"></p> <p><code>a</code> is usually set to -0.5, or -0.75. Note that <code>a = -0.5</code> corresponds to the <a href="http://en.wikipedia.org/wiki/Cubic_Hermite_spline" rel="nofollow noreferrer">Cubic Hermite spline</a>, which will be continuous and have a continuous first derivitive. <a href="https://github.com/Itseez/opencv/blob/master/modules/imgproc/src/imgwarp.cpp#L155" rel="nofollow noreferrer">OpenCV seems to use -0.75</a>.</p> <p>However, if you edit [OPENCV_SRC]\modules\imgproc\src\imgwarp.cpp and change the code :</p> <pre><code>static inline void interpolateCubic( float x, float* coeffs ) { const float A = -0.75f; ... </code></pre> <p>to:</p> <pre><code>static inline void interpolateCubic( float x, float* coeffs ) { const float A = -0.50f; ... </code></pre> <p>and rebuild OpenCV (tip: disable CUDA and the gpu module for short compile time), then you get the same results. See the matching output in <a href="http://stackoverflow.com/a/26812346/2778484">my other answer</a> to a related question by the OP.</p>
<p>This is sort of a follow-up to your <a href="http://stackoverflow.com/questions/26812289/matlab-vs-c-vs-opencv-imresize">previous</a> <a href="http://stackoverflow.com/questions/26815141/bicubic-interpolation-matlab-to-c">questions</a> about the difference between <code>imresize</code> in MATLAB and <code>cv::resize</code> in OpenCV given a bicubic interpolation.</p> <p>I was interested myself in finding out why there's a difference. These are my findings (as I understood the algorithms, please correct me if I make any mistakes).</p> <hr> <p>Think of resizing an image as a planar transformation from an input image of size <code>M-by-N</code> to an output image of size <code>scaledM-by-scaledN</code>.</p> <p>The problem is that the points do not necessarily fit on the discrete grid, therefore to obtain intensities of pixels in the output image, we need to interpolate the values of some of the neighboring samples (usually performed in the reverse order, that is for each output pixel, we find the corresponding non-integer point in the input space, and interpolate around it).</p> <p>This is where interpolation algorithms differ, by choosing the size of the neighborhood and the weight coefficients giving to each point in that neighborhood. The relationship can be first or higher order (where the variable involved is the distance from the inverse-mapped non-integer sample to the discrete points on the original image grid). Typically you assign higher weights to closer points.</p> <p>Looking at <code>imresize</code> in MATLAB, here are the weights functions for the linear and cubic kernels:</p> <pre><code>function f = triangle(x) % or simply: 1-abs(x) for x in [-1,1] f = (1+x) .* ((-1 &lt;= x) &amp; (x &lt; 0)) + ... (1-x) .* ((0 &lt;= x) &amp; (x &lt;= 1)); end function f = cubic(x) absx = abs(x); absx2 = absx.^2; absx3 = absx.^3; f = (1.5*absx3 - 2.5*absx2 + 1) .* (absx &lt;= 1) + ... (-0.5*absx3 + 2.5*absx2 - 4*absx + 2) .* ((1 &lt; absx) &amp; (absx &lt;= 2)); end </code></pre> <p>(These basically return the interpolation weight of a sample based on how far it is from an interpolated point.)</p> <p>This is how these functions look like:</p> <pre><code>&gt;&gt; subplot(121), ezplot(@triangle,[-2 2]) % triangle &gt;&gt; subplot(122), ezplot(@cubic,[-3 3]) % Mexican hat </code></pre> <p><img src="https://i.stack.imgur.com/JJ6ll.png" alt="interpolation_kernels"></p> <p>Note that the linear kernel (piece-wise linear functions on [-1,0] and [0,1] intervals, and zeros elsewhere) works on the 2-neighboring points, while the cubic kernel (piece-wise cubic functions on the intervals [-2,-1], [-1,1], and [1,2], and zeros elsewhere) works on 4-neighboring points.</p> <p>Here is an illustration for the 1-dimensional case, showing how to interpolate the value <code>x</code> from the discrete points <code>f(x_k)</code> using a cubic kernel:</p> <p><img src="https://i.stack.imgur.com/eHSvT.png" alt="1d_interpolation"></p> <p>The kernel function <code>h(x)</code> is centered at <code>x</code>, the location of the point to be interpolated. The interpolated value <code>f(x)</code> is the weighted sum of the discrete neighboring points (2 to the left and 2 to the right) scaled by the value of interpolation function at those discrete points.</p> <p>Say if the distance between <code>x</code> and the nearest point is <code>d</code> (<code>0 &lt;= d &lt; 1</code>), the interpolated value at location <code>x</code> will be:</p> <pre><code>f(x) = f(x1)*h(-d-1) + f(x2)*h(-d) + f(x3)*h(-d+1) + f(x4)*h(-d+2) </code></pre> <p>where the order of points is depicted below (note that <code>x(k+1)-x(k) = 1</code>):</p> <pre><code>x1 x2 x x3 x4 o--------o---+----o--------o \___/ distance d </code></pre> <p>Now since the points are discrete and sampled at uniform intervals, and the kernel width is usually small, the interpolation can be formulated concisely as a <strong>convolution</strong> operation:</p> <p><img src="https://i.stack.imgur.com/Aghi4.png" alt="interp_conv_equation"></p> <p>The concept extends to 2 dimensions simply by first interpolating along one dimension, and then interpolating across the other dimension using the results of the previous step.</p> <p>Here is an example of bilinear interpolation, which in 2D considers 4 neighboring points:</p> <p><img src="https://i.stack.imgur.com/RBHwC.png" alt="bilinear_interpolation"></p> <p>The bicubic interpolation in 2D uses 16 neighboring points:</p> <p><img src="https://i.stack.imgur.com/MmBCw.png" alt="bicubic"></p> <p>First we interpolate along the rows (the red points) using the 16 grid samples (pink). Then we interpolate along the other dimension (red line) using the interpolated points from the previous step. In each step, a regular 1D interpolation is performed. In this the equations are too long and complicated for me to work out by hand!</p> <hr> <p>Now if we go back to the <code>cubic</code> function in MATLAB, it actually matches the definition of the convolution kernel shown in the <a href="http://verona.fi-p.unam.mx/boris/practicas/CubConvInterp.pdf" rel="nofollow noreferrer">reference paper</a> as equation (4). Here is the same thing taken from <a href="https://en.wikipedia.org/wiki/Bicubic_interpolation#Bicubic_convolution_algorithm" rel="nofollow noreferrer">Wikipedia</a>:</p> <blockquote> <p><img src="https://i.stack.imgur.com/Dn6rm.png" alt="conv_kernel"></p> </blockquote> <p>You can see that in the above definition, MATLAB chose a value of <code>a=-0.5</code>.</p> <p>Now the difference between the implementation in MATLAB and OpenCV is that <a href="https://github.com/Itseez/opencv/blob/master/modules/imgproc/src/imgwarp.cpp#L153" rel="nofollow noreferrer">OpenCV</a> chose a value of <code>a=-0.75</code>.</p> <pre><code>static inline void interpolateCubic( float x, float* coeffs ) { const float A = -0.75f; coeffs[0] = ((A*(x + 1) - 5*A)*(x + 1) + 8*A)*(x + 1) - 4*A; coeffs[1] = ((A + 2)*x - (A + 3))*x*x + 1; coeffs[2] = ((A + 2)*(1 - x) - (A + 3))*(1 - x)*(1 - x) + 1; coeffs[3] = 1.f - coeffs[0] - coeffs[1] - coeffs[2]; } </code></pre> <p>This might not be obvious right away, but the code does compute the terms of the cubic convolution function (listed right after equation (25) in the paper):</p> <p><img src="https://i.stack.imgur.com/sb53K.png" alt="bicubic_kernel"></p> <p>We can verify that with the help of the Symbolic Math Toolbox:</p> <pre><code>A = -0.5; syms x c0 = ((A*(x + 1) - 5*A)*(x + 1) + 8*A)*(x + 1) - 4*A; c1 = ((A + 2)*x - (A + 3))*x*x + 1; c2 = ((A + 2)*(1 - x) - (A + 3))*(1 - x)*(1 - x) + 1; c3 = 1 - c0 - c1 - c2; </code></pre> <p>Those expressions can be rewritten as:</p> <pre><code>&gt;&gt; expand([c0;c1;c2;c3]) ans = - x^3/2 + x^2 - x/2 (3*x^3)/2 - (5*x^2)/2 + 1 - (3*x^3)/2 + 2*x^2 + x/2 x^3/2 - x^2/2 </code></pre> <p>which match the terms from the equation above.</p> <p>Obviously the difference between MATLAB and OpenCV boils down to using a different value for the free term <code>a</code>. According to the authors of the paper, a value of <code>0.5</code> is the preferred choice because it implies better properties for the approximation error than any other choice for <code>a</code>.</p>