Size of cell elements
<p>I have five classes of data stored in a <code>cell</code>,</p> <pre><code>DataCell = [74035x14 single] [8063x14 single] [7244x14 single] [6895x14 single] [2510x14 single] </code></pre> <p>I want to get the prior probabilities of each class,</p> <p>So want it's pretty simple,</p> <pre><code>SumData = 74032 + 8063 + 7244 + 6895 + 2510; prior = [74035 8063 7244 6895 2510] / SumData; </code></pre> <p>I was wondering if there is a way to avoid loop and get the answer.</p> <p>Thanks,</p>
<p>Store the counts of the <code>DataCell</code> into an array, then "nomalize" it:</p> <pre><code>data_counts = cellfun(@(x) size(x,1), DataCell); prior = data_counts / sum(data_counts(:)); </code></pre> <p>The <code>data_counts(:)</code> is just a funny way of summing all the elements of data_counts, no matter what shape they're in.</p>
<p>To add to CST-Link's answer, <code>cellfun</code> has a special flag where if you specify <code>'size'</code>, you can determine the size of of elements inside each cell in a cell array. You simply specify which dimension you're measuring the size of and it'll return an array of elements that denote the size of each cell in a particular dimension. It will also respect whatever the shape of your cell array was before you call <code>cellfun</code>. For example, if you have a 2 x 2 cell array, after using <code>'size'</code>, it will return a 2 x 2 numeric matrix where each element is the size of the dimension you specified.</p> <p>Therefore, do this:</p> <pre><code>data_counts = cellfun('size', DataCell, 1); prior = data_counts / sum(data_counts(:)); </code></pre> <p>To add to the <code>data_counts(:)</code> statement, this is MATLAB's way of <strong>unrolling a matrix</strong>. What this will do is that it transforms <code>data_counts</code> into a single vector, where it is composed of columns of <code>A</code> stacked on top of each other. For example, if you had a matrix like so:</p> <pre><code>A = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 </code></pre> <p>Doing <code>A(:)</code> would give you:</p> <pre><code>1 5 9 13 2 6 10 14 3 7 11 15 4 8 12 16 </code></pre> <p>However, if <code>A</code> is <strong>already a 1D array</strong>, then this has no effect at all. The only thing that it will do is that if your array was a row vector, this will transform the array so that it's column vector. If it was already a column vector, then this won't change anything. This is a neat trick to ensure that a 1D array is always a column vector.</p>