Unique (finite length) combinations of a given set of elements - Implementation in Matlab
<p>I have the following problem. I need to reproduce all the unique combinations of 0s and 1s that include exactly m zeros and exactly n ones. For example if I have 2 zeros and 3 ones the combinations I am looking for are the 10 following: </p> <p>1) 0 0 1 1 1</p> <p>2) 0 1 0 1 1</p> <p>3) 0 1 1 0 1</p> <p>4) 0 1 1 1 0</p> <p>5) 1 0 0 1 1</p> <p>6) 1 0 1 0 1</p> <p>7) 1 0 1 1 0</p> <p>8) 1 1 0 0 1</p> <p>9) 1 1 0 1 0</p> <p>10) 1 1 1 0 0</p> <p>Right now, I am using A=perms([0 0 1 1 1]) and then unique(A,'rows') but this is really time consuming if the length of the vector is more than 10. Can anybody think of a more efficient solution?</p>
<p><strong>Approach 1</strong>:</p> <ol> <li><p>Generate all "combinations" of <code>m+n</code> elements taken from the set <code>[0 1]</code>. This can be done efficiently using <a href="http://stackoverflow.com/questions/21895335/generate-a-matrix-containing-all-combinations-of-elements-taken-from-n-vectors">this approach</a>.</p></li> <li><p>Keep only those combinations that contain <code>n</code> ones.</p></li> </ol> <p>Code:</p> <pre><code>m = 7; %// number of zeros n = 9; %// number of ones L = m+n; vectors = repmat({[0 1]}, 1, L); combs = cell(1,L); [combs{end:-1:1}] = ndgrid(vectors{end:-1:1}); combs = cat(L+1, combs{:}); combs = reshape(combs,[],L); combs = combs(sum(combs,2)==n,:); </code></pre> <p>Example result for <code>m=2; n=3</code>:</p> <pre><code>combs = 0 0 1 1 1 0 1 0 1 1 0 1 1 0 1 0 1 1 1 0 1 0 0 1 1 1 0 1 0 1 1 0 1 1 0 1 1 0 0 1 1 1 0 1 0 1 1 1 0 0 </code></pre> <p><strong>Approach 1 modified</strong></p> <p>To save memory, use <code>uint8</code> values in step 1, and convert to <code>double</code> at the end of step 2:</p> <pre><code>m = 7; %// number of zeros n = 9; %// number of ones L = m+n; vectors = repmat({uint8([0 1])}, 1, L); combs = cell(1,L); [combs{end:-1:1}] = ndgrid(vectors{end:-1:1}); combs = cat(L+1, combs{:}); combs = reshape(combs,[],L); combs = double(combs(sum(combs,2)==n,:)); </code></pre> <p><strong>Approach 2</strong>:</p> <p>Similar to approach 1, but in step 1 generate all combinations as binary expressions of all integers from <code>0</code> to <code>2^(m+n)-1</code>, using <a href="http://es.mathworks.com/help/matlab/ref/dec2bin.html" rel="nofollow"><code>dec2bin</code></a>. This produces a <code>char</code> array, so it should be as memory-efficient as approach 1 modified. Then, step 2 should be slightly adapted to use <code>char</code>s, and a final conversion to numeric values is required:</p> <pre><code>m = 7; %// number of zeros n = 9; %// number of ones combs = dec2bin(0:2^(m+n)-1); combs = combs(sum(combs=='1',2)==n,:)-'0'; </code></pre>