Speed-efficient classification in Matlab
<p>I have an image of size as RGB <code>uint8(576,720,3)</code> where I want to classify each pixel to a set of colors. I have transformed using <code>rgb2lab</code> from RGB to LAB space, and then removed the L layer so it is now a <code>double(576,720,2)</code> consisting of AB.</p> <p>Now, I want to classify this to some colors that I have trained on another image, and calculated their respective AB-representations as:</p> <pre><code>Cluster 1: -17.7903 -13.1170 Cluster 2: -30.1957 40.3520 Cluster 3: -4.4608 47.2543 Cluster 4: 46.3738 36.5225 Cluster 5: 43.3134 -17.6443 Cluster 6: -0.9003 1.4042 Cluster 7: 7.3884 11.5584 </code></pre> <p>Now, in order to classify/label each pixel to a cluster 1-7, I currently do the following (pseudo-code):</p> <pre><code>clusters; for each x for each y ab = im(x,y,2:3); dist = norm(ab - clusters); // norm of dist between ab and each cluster [~, idx] = min(dist); end end </code></pre> <p>However, this is terribly slow (52 seconds) because of the image resolution and that I manually loop through each x and y.</p> <p>Are there some built-in functions I can use that performs the same job? There must be. </p> <p>To summarize: <strong>I need a classification method that classifies pixel images to an already defined set of clusters.</strong></p>
<p>Use <a href="http://es.mathworks.com/help/stats/pdist2.html" rel="nofollow"><code>pdist2</code></a> (Statistics Toolbox) to compute the distances in a vectorized manner: </p> <pre><code>ab = im(:,:,2:3); % // get A, B components ab = reshape(ab, [size(im,1)*size(im,2) 2]); % // reshape into 2-column dist = pdist2(clusters, ab); % // compute distances [~, idx] = min(dist); % // find minimizer for each pixel idx = reshape(idx, size(im,1), size(im,2)); % // reshape result </code></pre> <p>If you don't have the Statistics Toolbox, you can replace the third line by</p> <pre><code>dist = squeeze(sum(bsxfun(@minus, clusters, permute(ab, [3 2 1])).^2, 2)); </code></pre> <p>This gives squared distance instead of distance, but for the purposes of minimizing it doesn't matter.</p>
<h1>Approach #1</h1> <p>For a <code>N x 2</code> sized points/pixels array, you can avoid <code>permute</code> as suggested in the <a href="http://stackoverflow.com/a/26994433/3293881">other solution by Luis</a>, which could slow down things a bit, to have a kind of <code>"permute-unrolled"</code> version of it and also let's <code>bsxfun</code> work towards a <code>2D</code> array instead of a <code>3D</code> array, which must be better with performance.</p> <p>Thus, assuming clusters to be ordered as a <code>N x 2</code> sized array, you may try this other <code>bsxfun</code> based approach -</p> <pre><code>%// Get a's and b's im_a = im(:,:,2); im_b = im(:,:,3); %// Get the minimum indices that correspond to the cluster IDs [~,idx] = min(bsxfun(@minus,im_a(:),clusters(:,1).').^2 + ... bsxfun(@minus,im_b(:),clusters(:,2).').^2,[],2); idx = reshape(idx,size(im,1),[]); </code></pre> <hr> <h1>Approach #2</h1> <p>You can try out another approach that leverages <a href="http://stackoverflow.com/questions/6058139/why-is-matlab-so-fast-in-matrix-multiplication"><strong><code>fast matrix multiplication in MATLAB</code></strong></a> and is based on <a href="http://stackoverflow.com/a/23911671/3293881">this smart solution</a> -</p> <pre><code>d = 2; %// dimension of the problem size im23 = reshape(im(:,:,2:3),[],2); numA = size(im23,1); numB = size(clusters,1); A_ext = zeros(numA,3*d); B_ext = zeros(numB,3*d); for id = 1:d A_ext(:,3*id-2:3*id) = [ones(numA,1), -2*im23(:,id), im23(:,id).^2 ]; B_ext(:,3*id-2:3*id) = [clusters(:,id).^2 , clusters(:,id), ones(numB,1)]; end [~, idx] = min(A_ext * B_ext',[],2); %//' idx = reshape(idx, size(im,1),[]); %// Desired IDs </code></pre> <h2>What’s going on with the matrix multiplication based distance matrix calculation?</h2> <p>Let us consider two matrices <code>A</code> and <code>B</code> between whom we want to calculate the distance matrix. For the sake of an easier explanation that follows next, let us consider <code>A</code> as <code>3 x 2</code> and <code>B</code> as <code>4 x 2</code> sized arrays, thus indicating that we are working with X-Y points. If we had <code>A</code> as <code>N x 3</code> and <code>B</code> as <code>M x 3</code> sized arrays, then those would be <code>X-Y-Z</code> points.</p> <p>Now, if we have to manually calculate the first element of the square of distance matrix, it would look like this –</p> <pre><code>first_element = ( A(1,1) – B(1,1) )^2 + ( A(1,2) – B(1,2) )^2 </code></pre> <p>which would be –</p> <pre><code>first_element = A(1,1)^2 + B(1,1)^2 -2*A(1,1)* B(1,1) + ... A(1,2)^2 + B(1,2)^2 -2*A(1,2)* B(1,2) … Equation (1) </code></pre> <p>Now, according to our proposed matrix multiplication, if you check the output of <code>A_ext</code> and <code>B_ext</code> after the loop in the earlier code ends, they would look like the following –</p> <p><img src="https://i.stack.imgur.com/U3M4w.png" alt="enter image description here"></p> <p><img src="https://i.stack.imgur.com/aMR1R.png" alt="enter image description here"></p> <p>So, if you perform matrix multiplication between <code>A_ext</code> and transpose of <code>B_ext</code>, the first element of the product would be the sum of elementwise multiplication between the first rows of <code>A_ext</code> and <code>B_ext</code>, i.e. sum of these –</p> <p><img src="https://i.stack.imgur.com/I08OI.png" alt="enter image description here"></p> <p>The result would be identical to the result obtained from <code>Equation (1)</code> earlier. This would continue for all the elements of <code>A</code> against all the elements of <code>B</code> that are in the same column as in <code>A</code>. Thus, we would end up with the complete squared distance matrix. That’s all there is!!</p> <h2>Vectorized Variations</h2> <p>Vectorized variations of the matrix multiplication based distance matrix calculations are possible, though there weren't any big performance improvements seen with them. Two such variations are listed next.</p> <p><strong>Variation #1</strong></p> <pre><code>[nA,dim] = size(A); nB = size(B,1); A_ext = ones(nA,dim*3); A_ext(:,2:3:end) = -2*A; A_ext(:,3:3:end) = A.^2; B_ext = ones(nB,dim*3); B_ext(:,1:3:end) = B.^2; B_ext(:,2:3:end) = B; distmat = A_ext * B_ext.'; </code></pre> <p><strong>Variation #2</strong></p> <pre><code>[nA,dim] = size(A); nB = size(B,1); A_ext = [ones(nA*dim,1) -2*A(:) A(:).^2]; B_ext = [B(:).^2 B(:) ones(nB*dim,1)]; A_ext = reshape(permute(reshape(A_ext,nA,dim,[]),[1 3 2]),nA,[]); B_ext = reshape(permute(reshape(B_ext,nB,dim,[]),[1 3 2]),nB,[]); distmat = A_ext * B_ext.'; </code></pre> <p>So, these could be considered as experimental versions too.</p>