The summation of piecewise functions in Matlab
<p>I have a piecewise function <code>F_m(x)</code> as below, where <code>x_m</code> and <code>\alpha</code> are constants, <code>m</code> is the subscript.</p> <p><img src="https://i.stack.imgur.com/YyaFv.png" alt="piecewise function"></p> <p>I need to solve the following equation that involves <code>F_m(x)</code>, where <code>N</code> and <code>C</code> are constants, <code>tau</code> is the variable I want to solve.</p> <p><img src="https://i.stack.imgur.com/nPIzi.png" alt="equation"></p> <p>So I resort this question to Matlab. First I write an function in a .m file:</p> <pre><code>function y=pareto_CDF(x, xm) alpha = 2; %set alpha to 2 if x &lt; xm y = 0; else y = 1-(xm/x)^alpha; end </code></pre> <p>Then in another .m file I write:</p> <pre><code>syms x; C = 1000; N = 20000; %Pareto Distribution CDF: F(x)=1-(xm/x)^alpha. %alpha is set to 2 in this program alpha = 2; j=1:1:N; f=sum(pareto_CDF(x, 1/(alpha*rand()))); a = f - C; tau = solve(a,'x'); </code></pre> <p>However, I got the following error from Matlab when running it:</p> <pre><code>Conversion to logical from sym is not possible. Error in pareto_CDF (line 4) if x &lt; xm </code></pre> <p>The problem now is: I need to declare <code>x</code> as <code>sym</code> because it is the variable in the equation, since I invoke <code>pareto_CDF(x, xm)</code>, the <code>x</code> in this function is also <code>sym</code>, but Matlabt does not support the comparison between a <code>sym</code> and a value (xm). This error actually stems from the piecewise nature of function <code>F(x)</code>.</p> <p>So, how can I solve this problem? </p>
<p>Using <code>heaviside()</code> function resolves my problem. Rewrite the function .m file as follows:</p> <pre><code>function y=pareto_CDF(x, xm) alpha = 2; %set alpha to 2 y = heaviside(x-xm).*(1-(xm/x).^alpha); </code></pre> <p>The reason I use element-by-element product/division (.*, ./) is because the input may be a vector.</p>
<p>What about changing pareto_CDF such that it takes vector as input and returns vector as output:</p> <pre><code>xm = 4; % test with scalar x pareto_CDF( 1, xm ) % =&gt; 0 pareto_CDF( 6, xm ) % =&gt; 0.556 % test with vector x pareto_CDF( [1,6] , xm ) =&gt; [0, 0.556] end function y = pareto_CDF(x, xm) alpha = 2; %set alpha to 2 y = 1-(xm./x).^alpha; y( x &lt; xm ) = 0; end </code></pre>