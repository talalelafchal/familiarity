Indices of constant consecutive values in a matrix, and number of constant values
<p>I have a matrix with constant consecutive values randomly distributed throughout the matrix. I want the indices of the consecutive values, and further, I want a matrix of the same size as the original matrix, where the number of consecutive values are stored in the indices of the consecutive values. For Example</p> <pre><code> original_matrix = [1 1 1;2 2 3; 1 2 3]; output_matrix = [3 3 3;2 2 0;0 0 0]; </code></pre> <p>I have struggled mightily to find a solution to this problem. It has relevance for meteorological data quality control. For example, if I have a matrix of temperature data from a number of sensors, and I want to know what days had constant consecutive values, and how many days were constant, so I can then flag the data as possibly faulty.</p> <p>temperature matrix is number of days x number of stations and I want an output matrix that is also number of days x number of stations, where the consecutive values are flagged as described above. </p> <p>If you have a solution to that, please provide! Thank you.</p>
<p>For this kind of problems, I made my own utility function <code>runlength</code>:</p> <pre><code>function RL = runlength(M) % calculates length of runs of consecutive equal items along columns of M % work along columns, so that you can use linear indexing % find locations where items change along column jumps = diff(M) ~= 0; % add implicit jumps at start and end ncol = size(jumps, 2); jumps = [true(1, ncol); jumps; true(1, ncol)]; % find linear indices of starts and stops of runs ijump = find(jumps); nrow = size(jumps, 1); istart = ijump(rem(ijump, nrow) ~= 0); % remove fake starts in last row istop = ijump(rem(ijump, nrow) ~= 1); % remove fake stops in first row rl = istop - istart; assert(sum(rl) == numel(M)) % make matrix of 'derivative' of runlength % don't need last row, but needs same size as jumps for indices to be valid dRL = zeros(size(jumps)); dRL(istart) = rl; dRL(istop) = dRL(istop) - rl; % remove last row and 'integrate' to get runlength RL = cumsum(dRL(1:end-1,:)); </code></pre> <p>It only works along columns since it uses <a href="http://www.mathworks.it/help/matlab/math/matrix-indexing.html#f1-85511" rel="nofollow">linear indexing</a>. Since you want do something similar along rows, you need to transpose back and forth, so you could use it for your case like so:</p> <pre><code>&gt;&gt; original = [1 1 1;2 2 3; 1 2 3]; &gt;&gt; original = original.'; % transpose, since runlength works along columns &gt;&gt; output = runlength(original); &gt;&gt; output = output.'; % transpose back &gt;&gt; output(output == 1) = 0; % see hitzg's comment &gt;&gt; output output = 3 3 3 2 2 0 0 0 0 </code></pre>