Partitioning a number into a number of almost equal partitions
<p>I would like to partition a number into an almost equal number of values in each partition. The only criteria is that each partition must be in between 60 to 80.</p> <p>For example, if I have a <code>value = 300</code>, this means that <code>75 * 4 = 300</code>.</p> <p>I would like to know a method to get this <code>4</code> and <code>75</code> in the above example. In some cases, all partitions don't need to be of equal value, but they should be in between <code>60 and 80</code>. Any constraints can be used (addition, subtraction, etc..). However, the outputs must not be floating point.</p> <p>Also it's not that the total must be exactly <code>300</code> as in this case, but they can be up to a maximum of <code>+40</code> of the total, and so for the case of <code>300</code>, the numbers can sum up to <code>340</code> if required.</p>
<p>Assuming only addition, you can formulate this problem into a <a href="http://en.wikipedia.org/wiki/Linear_programming" rel="nofollow">linear programming problem</a>. You would choose an objective function that would maximize the sum of all of the factors chosen to generate that number for you. Therefore, your objective function would be:</p> <p><img src="http://latex.codecogs.com/gif.latex?f%28x%29%20%3D%20x_1%20&plus;%20x_2%20&plus;%20%5Cldots%20&plus;%20x_n" alt="">.</p> <p>In this case, <code>n</code> would be the number of factors you are using to try and decompose your number into. Each <img src="http://latex.codecogs.com/gif.latex?x_i" alt=""> is a particular factor in the overall sum of the value you want to decompose. I'm also going to assume that none of the factors can be floating point, and can only be integer. As such, you need to use a special case of linear programming called <a href="http://en.wikipedia.org/wiki/Integer_programming" rel="nofollow">integer programming</a> where the constraints and the actual solution to your problem are all in integers. In general, the integer programming problem is formulated thusly:</p> <p><img src="http://latex.codecogs.com/gif.latex?%5Cmin_%7Bx%7Df%5E%7BT%7Dx%7Es.t.%20%5Cbegin%7Bcases%7D%20Ax%20%5Cleq%20b%20%5C%5C%20A_%7Beq%7Dx%20%3D%20b_%7Beq%7D%20%5C%5C%20lb%20%5Cleq%20x%20%5Cleq%20ub%20%5C%5C%20x%20%5Cin%20%5Cboldsymbol%7BI%7D%5Cend%7Bcases%7D" alt=""></p> <p>You are actually trying to minimize this objective function, such that you produce a parameter vector of <code>x</code> that are subject to all of these constraints. In our case, <code>x</code> would be a vector of numbers where each element forms part of the sum to the value you are trying to decompose (300 in your case).</p> <p>You have inequalities, equalities and also boundaries of <code>x</code> that each parameter in your solution must respect. You also need to make sure that each parameter of <code>x</code> is an integer. As such, MATLAB has a function called <a href="http://www.mathworks.com/help/optim/ug/intlinprog.html" rel="nofollow"><code>intlinprog</code></a> that will perform this for you. However, this function assumes that you are minimizing the objective function, and so if you want to maximize, simply minimize on the negative. <code>f</code> is a vector of weights to be applied to each value in your parameter vector, and with our objective function, you just need to set all of these to <code>-1</code>.</p> <p>Therefore, to formulate your problem in an integer programming framework, you are actually doing:</p> <p><img src="http://latex.codecogs.com/gif.latex?%5Cmin_%7Bx%7D%20-x_1%20-%20x_2%20-%20%5Cldots%20-%20x_n%20%7Es.t.%20%5Cbegin%7Bcases%7D%20x_1%20&plus;%20x_2%20&plus;%20%5Cldots%20&plus;x_n%20%3D%20V%20%5C%5C%2060%20%5Cleq%20x%20%5Cleq%2080%20%5C%5C%20x%20%5Cin%20%5Cboldsymbol%7BI%7D%5Cend%7Bcases%7D" alt=""></p> <p><code>V</code> would be the value you are trying to decompose (so 300 in your example).</p> <hr> <p>The standard way to call <code>intlinprog</code> is in the following way:</p> <pre><code>x = intlinprog(f,intcon,A,b,Aeq,beq,lb,ub); </code></pre> <p><code>f</code> is the vector that weights each parameter of the solution you want to solve, <code>intcon</code> denotes which of your parameters need to be integer. In this case, you want all of them to be integer so you would have to supply an increasing vector from 1 to <code>n</code>, where <code>n</code> is the number of factors you want to decompose the number <code>V</code> into (same as before). <code>A</code> and <code>b</code> are matrices and vectors that define your inequality constraints. Because you want equality, you'd set this to empty (<code>[]</code>). <code>Aeq</code> and <code>beq</code> are the same as <code>A</code> and <code>b</code>, but for equality. Because you only have one constraint here, you would simply create a matrix of 1 row, where each value is set to 1. <code>beq</code> would be a single value which denotes the number you are trying to factorize. <code>lb</code> and <code>ub</code> are the lower and upper bounds for each value in the parameter set that you are bounding with, so this would be 60 and 80 respectively, and you'd have to specify a vector to ensure that each value of the parameters are bounded between these two ranges.</p> <p>Now, because you don't <strong>know</strong> how many factors will evenly decompose your value, you'll have to <strong>loop</strong> over a given set of factors (like between 1 to 10, or 1 to 20, etc.), place your results in a <code>cell</code> array, then you have to manually examine yourself whether or not an integer decomposition was successful. </p> <pre><code>num_factors = 20; %// Number of factors to try and decompose your value V = 300; results = cell(1, num_factors); %// Try to solve the problem for a number of different factors for n = 1 : num_factors x = intlinprog(-ones(n,1),1:n,[],[],ones(1,n),V,60*ones(n,1),80*ones(n,1)); results{n} = x; end </code></pre> <p>You can then go through <code>results</code> and see which value of <code>n</code> was successful in decomposing your number into that said number of factors.</p> <p>One small problem here is that we also don't know <strong>how many factors we should check up to</strong>. That unfortunately I don't have an answer to, and so you'll have to play with this value until you get good results. This is also an unconstrained parameter, and I'll talk about this more later in this post.</p> <hr> <p>However, <code>intlinprog</code> was only released in recent versions of MATLAB. If you want to do the same thing without it, you can use <a href="http://www.mathworks.com/help/optim/ug/linprog.html" rel="nofollow"><code>linprog</code></a>, which is the floating point version of integer programming... actually, it's just the core linear programming framework itself. You would call <code>linprog</code> this way:</p> <pre><code>x = linprog(f,A,b,Aeq,beq,lb,ub); </code></pre> <p>All of the variables are the same, except that <code>intcon</code> is not used here... which makes sense as <code>linprog</code> may generate floating point numbers as part of its solution. Due to the fact that <code>linprog</code> can generate floating point solutions, what you can do is if you want to ensure that for a given value of <code>n</code>, you could loop over your results, take the floor of the result and subtract with the final result, and sum over the result. If you get a value of 0, this means that you had a completely integer result. Therefore, you'd have to do something like:</p> <pre><code>num_factors = 20; %// Number of factors to try and decompose your value V = 300; results = cell(1, num_factors); %// Try to solve the problem for a number of different factors for n = 1 : num_factors x = linprog(-ones(n,1),[],[],ones(1,n),V,60*ones(n,1),80*ones(n,1)); results{n} = x; end %// Loop through and determine which decompositions were successful integer ones out = cellfun(@(x) sum(abs(floor(x) - x)), results); %// Determine which values of n were successful in the integer composition. final_factors = find(~out); </code></pre> <p><code>final_factors</code> will contain which number of factors you specified that was successful in an integer decomposition. Now, if <code>final_factors</code> is empty, this means that it wasn't successful in finding anything that would be able to decompose the value into integer factors. Noting your problem description, you said you can allow for tolerances, so perhaps scan through <code>results</code> and determine which overall sum best matches the value, then choose whatever number of factors that gave you that result as the final answer.</p> <hr> <p>Now, noting from my comments, you'll see that this problem is very unconstrained. You don't know <strong>how many</strong> factors are required to get an integer decomposition of your value, which is why we had to semi-brute-force it. In fact, this is a more general case of the <a href="http://en.wikipedia.org/wiki/Subset_sum_problem" rel="nofollow">subset sum problem</a>. This problem is <a href="http://en.wikipedia.org/wiki/NP-complete" rel="nofollow">NP-complete</a>. Basically, what this means is that it is not known whether there is a polynomial-time algorithm that can be used to solve this kind of problem and that the only way to get a valid solution is to brute-force each possible solution and check if it works with the specified problem. Usually, brute-forcing solutions requires exponential time, which is very intractable for large problems. Another interesting fact is that modern cryptography algorithms use NP-Complete intractability as part of their ciphertext and encrypting. Basically, they're banking on the fact that the only way for you to determine the right key that was used to encrypt your plain text is to check all possible keys, which is an intractable problem... especially if you use 128-bit encryption! This means you would have to check <code>2^128</code> possibilities, and assuming a moderately fast computer, the worst-case time to find the right key will take more than the current age of the universe. Check out this cool <a href="http://en.wikipedia.org/wiki/Large_numbers#Computers_and_computational_complexity" rel="nofollow">Wikipedia post for more details in intractability</a> with regards to key breaking in cryptography.</p> <p>In fact, NP-complete problems are very popular and there have been many attempts to determine whether there <strong>is</strong> or there <strong>isn't</strong> a polynomial-time algorithm to solve such problems. An interesting property is that if you can find a polynomial-time algorithm that will solve one problem, you will have found an algorithm to solve them all.</p> <p>The Clay Mathematics Institute has what are known as <a href="http://www.claymath.org/millennium-problems" rel="nofollow">Millennium Problems</a> where if you solve any problem listed on their website, you get a million dollars. </p> <p>Also, that's for <strong>each</strong> problem, so <code>one problem solved == 1 million dollars</code>!</p> <p><img src="http://www.quickmeme.com/img/76/762195e1666497074ede151e0cbeb39738a411d967572cbbe24b90cf8db6011f.jpg" alt=""></p> <p>The NP problem is amongst one of the seven problems up for solving. If I recall correctly, only one problem has been solved so far, and these problems were first released to the public in the year 2000 (hence millennium...). So... it has been about 14 years and only one problem has been solved. Don't let that discourage you though! If you want to invest some time and try to solve one of the problems, please do!</p> <hr> <p>Hopefully this will be enough to get you started. Good luck!</p>