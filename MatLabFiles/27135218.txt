Complete partial circles in an image using MATLAB
<p>I have binary images and they have semi or less circles. My aim is to find these circles, make them whole circles and remove all other objects . I found <a href="http://www.mathworks.com/help/images/examples/detect-and-measure-circular-objects-in-an-image.html" rel="nofollow noreferrer">this</a> but it is for MATLAB R2013a. I am using R2011b and it doesn't have the function <code>centers = imfindcircles(A,radius)</code>.</p> <p>How can I do that in MATLAB version R2011b?</p> <p>Images: <img src="https://i.stack.imgur.com/wQLPi.jpg" alt="enter image description here"> <img src="https://i.stack.imgur.com/qychC.jpg" alt="enter image description here"> <img src="https://i.stack.imgur.com/mZMBA.jpg" alt="enter image description here"></p> <p>Edit: My aim is to get whole circle. I show this below for the last image.</p> <p><img src="https://i.stack.imgur.com/tXfWO.png" alt="enter image description here"> </p>
<p>Too bad about <code>imfindcircles</code>! One thing I can suggest is to invoke <a href="http://www.mathworks.com/help/images/ref/regionprops.html" rel="nofollow noreferrer"><code>regionprops</code></a> and specify the <code>'Area'</code> and <code>'BoundingBox'</code> flags. <code>regionprops</code> was available in MATLAB for as long as I can remember, so we can certainly use it here.</p> <p>What this will do is that whatever distinct objects that are seen in the image that are connected, we will find both their areas and their bounding boxes that bound them. After you do this, threshold on the area so that any objects that have a very large area most likely contain circles of interest. Bear in mind that I'm only assuming that you have circles in your image. Should you have any objects that have a large area, this method will extract those out too. </p> <p>As such, let's read in your image directly from Stack Overflow. When you uploaded the image, it's a RGB image, so I'll have to convert to binary:</p> <pre><code>im = imread('http://i.stack.imgur.com/wQLPi.jpg'); im_bw = im2bw(im); </code></pre> <p>Next, call <code>regionprops</code>:</p> <pre><code>s = regionprops(im_bw, 'Area', 'BoundingBox'); </code></pre> <p>Now, collect all of the areas, and let's take a look at all of the <strong>unique</strong> areas of all objects seen in this image:</p> <pre><code>areas = [s.Area].'; unique(areas) ans = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 19 20 23 24 25 28 29 38 43 72 73 85 87 250 465 3127 </code></pre> <p>If you take a look at the very end, you'll see that we have an object that has 3127 pixels in it. This probably contains our circle. As such, let's pick out that single element that contains this object:</p> <pre><code>s2 = s(areas == 3127); </code></pre> <p>In general, you'll probably have more than one circle in your image, so you should threshold the area to select those potential circles. Something like:</p> <pre><code>s2 = s(areas &gt; 2000); </code></pre> <p>Now, let's create a new blank image that is the same size as the original image, then simply use the <code>BoundingBox</code> property to extract out the area that encompasses the circle in the original image and copy it over to the same location in the output image. The <code>BoundingBox</code> field is structured in the following way:</p> <pre><code>[x y w h] </code></pre> <p><code>x</code> and <code>y</code> are the top-left corner of the bounding box. <code>x</code> would be the column and <code>y</code> would be the row. <code>w</code> and <code>h</code> are the width and height of the bounding box. As such, we can use this directly to access our image and copy those pixels over into the output image.</p> <pre><code>out = false(size(im_bw)); bb = floor(s2.BoundingBox); %// Could be floating point, so floor it out(bb(2):bb(2)+bb(4)-1, bb(1):bb(1)+bb(3)-1) = im_bw(bb(2):bb(2)+bb(4)-1, bb(1):bb(1)+bb(3)-1); </code></pre> <p>This is what I get:</p> <p><img src="https://i.stack.imgur.com/snwgq.png" alt="enter image description here"></p> <p>What you should probably do is <strong>loop</strong> over the circles in case we have more than one. The above code assumes that you detected just one circle. Therefore, do something like this:</p> <pre><code>out = false(size(im_bw)); for idx = 1 : numel(s2) %// For each potential circle we have... bb = floor(s2(idx).BoundingBox); %// Could be floating point, so floor it %// Copy over pixels from original bw image to output out(bb(2):bb(2)+bb(4)-1, bb(1):bb(1)+bb(3)-1) = im_bw(bb(2):bb(2)+bb(4)-1, bb(1):bb(1)+bb(3)-1); end </code></pre> <p>A small thing to note is that the bounding box encompasses the entire object, but there could also be some noisy pixels that are disconnected that are within that bounding box. You may have to apply some morphology to get rid of those pixels. A binary opening could suffice.</p> <hr> <p>Here's what I get with your other images. I thresholded the area to search for those that have 2000 pixels or more (I did this above):</p> <p><img src="https://i.stack.imgur.com/z1H4P.png" alt="enter image description here"></p> <p><img src="https://i.stack.imgur.com/5CinZ.png" alt="enter image description here"></p> <hr> <p>Just for self-containment and your copy-and-pasting pleasure, here's the code in one segment:</p> <pre><code>clear all; close all; %im = imread('http://i.stack.imgur.com/qychC.jpg'); %im = imread('http://i.stack.imgur.com/wQLPi.jpg'); im = imread('http://i.stack.imgur.com/mZMBA.jpg'); im_bw = im2bw(im); s = regionprops(im_bw, 'Area', 'BoundingBox'); areas = [s.Area].'; s2 = s(areas &gt; 2000); out = false(size(im_bw)); for idx = 1 : numel(s2) %// For each potential circle we have... bb = floor(s2(idx).BoundingBox); %// Could be floating point, so floor it %// Copy over pixels from original bw image to output out(bb(2):bb(2)+bb(4)-1, bb(1):bb(1)+bb(3)-1) = im_bw(bb(2):bb(2)+bb(4)-1, bb(1):bb(1)+bb(3)-1); end imshow(out); </code></pre> <p>All three images are there in the code. You just have to uncomment whichever one you want to use, comment out the rest, then run the code. It will display an image with all of your detected circles.</p> <hr> <h1>Edit</h1> <p>You would like to draw complete circles, instead of extracting the shape themselves. That isn't a problem to do. All you need to do is determine the best "radii" that can be enclosed inside each of the bounding boxes. This is simply the maximum of the width and height of each bounding box, then divide these quantities by 2.</p> <p>After, create a 2D grid of co-ordinates through <a href="http://www.mathworks.com/help/matlab/ref/meshgrid.html" rel="nofollow noreferrer"><code>meshgrid</code></a> that is the same size as the original image itself, then create a binary image such that the Euclidean distance between the centre of this bounding box with any point in this 2D grid less than the radius is set to logical <code>true</code> while the other positions are set to logical <code>false</code>.</p> <p>In other words, do this:</p> <pre><code>clear all; close all; im = imread('http://i.stack.imgur.com/qychC.jpg'); %im = imread('http://i.stack.imgur.com/wQLPi.jpg'); %im = imread('http://i.stack.imgur.com/mZMBA.jpg'); im_bw = im2bw(im); s = regionprops(im_bw, 'Area', 'BoundingBox'); areas = [s.Area].'; s2 = s(areas &gt; 2000); out = false(size(im_bw)); for idx = 1 : numel(s2) %// For each potential circle we have... bb = floor(s2(idx).BoundingBox); %// Could be floating point, so floor it %// Copy over pixels from original bw image to output out(bb(2):bb(2)+bb(4)-1, bb(1):bb(1)+bb(3)-1) = im_bw(bb(2):bb(2)+bb(4)-1, bb(1):bb(1)+bb(3)-1); end figure; imshow(out); %// Image that contains all of our final circles out2 = false(size(im_bw)); [X,Y] = meshgrid(1:size(im_bw,2), 1:size(im_bw,1)); %// Find a 2D grid of co-ordinates for idx = 1 : numel(s2) %// For each circle we have... bb = floor(s2(idx).BoundingBox); %// Could be floating point, so floor it cenx = bb(1) + (bb(3) / 2.0); %// Get the centre of the bounding box ceny = bb(2) + (bb(4) / 2.0); radi = max(bb(3), bb(4)) / 2; %// Find the best radius tmp = ((X - cenx).^2 + (Y - ceny).^2) &lt;= radi^2; %// Draw our circle and place in a temp. image out2 = out2 | tmp; %// Add this circle on top of our output image end figure; imshow(out2); </code></pre> <p>This script now shows you the original extracted shapes, and the best "circles" that describes these shapes in two separate figures. Bear in mind that this is a bit different than what I showed you previously with one circle. What I have to do now is allocate a blank image, then incrementally add each circle to this new image. For each circle, I create a temporary binary image that has just a circle I'm looking for, then I add this on top of the new image. At the end, we will show all of the circles in the image that are fully drawn as you desire.</p> <hr> <p>This is what I get for the best circle for each of your images:</p> <p><img src="https://i.stack.imgur.com/lQW8T.png" alt="enter image description here"></p> <p><img src="https://i.stack.imgur.com/BK9n8.png" alt="enter image description here"></p> <p><img src="https://i.stack.imgur.com/yju7H.png" alt="enter image description here"></p> <p>Good luck!</p>