How to set a max value for histogram
<p>Image first: <img src="https://i.stack.imgur.com/fv1tS.jpg" alt="enter image description here"></p> <p>As you can see, I have a set of normal distributions. Made for a presentation purpose, there was a feedback that those plots should be "normalized", for what I understood having the plot values set to some maximum value and the curvature of the plot set to fit this anyways. The goal is to make those plots easier to compare visually - I hope this makes sense. I'm using <code>histfit</code> for this plot. </p> <p>Do you know of some method how can I possible make those graphs more comparable in that way?</p> <p>EDIT: As it was marked as a duplicate, it's not really the case. I'm not really looking for the probability density to fit the histogram, I want to set a maximum value for each probability density curve. I know about the market topics, I just couldn't find my anwser there.</p> <p>EDIT2:</p> <p>Those are exercpts from my code with the solutions they produce:</p> <pre><code>[f1,x1] = hist(data1); [f2,x2] = hist(data2); [f3,x3] = hist(data3); avg = mean(data1); stdev = std(data1); VERT1 = sort(data1); y1 = exp(- 0.5 * ((VERT1 - avg) / stdev) .^ 2) / (stdev * sqrt(2 * pi)); y11 = y1/max(data1); avg = mean(data2); stdev = std(data2); VERT2 = sort(data2); y2 = exp(- 0.5 * ((VERT2 - avg) / stdev) .^ 2) / (stdev * sqrt(2 * pi)); y22 = y2/max(data2); % avg = mean(data3); stdev = std(data3); VERT3 = sort(data3); y3 = exp(- 0.5 * ((VERT3 - avg) / stdev) .^ 2) / (stdev * sqrt(2 * pi)); y33 = y3/max(data3); </code></pre> <p><img src="https://i.stack.imgur.com/A385U.jpg" alt="enter image description here"></p> <p>Direct link for clarity: <a href="https://i.imgur.com/YPrcM3R.jpg" rel="nofollow noreferrer">http://i.imgur.com/YPrcM3R.jpg</a></p> <p>From <a href="http://stackoverflow.com/questions/5320677/how-to-normalize-a-histogram-in-matlab">this explanation</a> I get this:</p> <pre><code>[f1,x1] = hist(data1); [f2,x2] = hist(data2); [f3,x3] = hist(data3); avg = mean(data1); stdev = std(data1); VERT1 = sort(data1); y1 = exp(- 0.5 * ((VERT1 - avg) / stdev) .^ 2) / (stdev * sqrt(2 * pi)); avg = mean(data2); stdev = std(data2); VERT2 = sort(data2); y2 = exp(- 0.5 * ((VERT2 - avg) / stdev) .^ 2) / (stdev * sqrt(2 * pi)); avg = mean(data3); stdev = std(data3); VERT3 = sort(data3); y3 = exp(- 0.5 * ((VERT3 - avg) / stdev) .^ 2) / (stdev * sqrt(2 * pi)); h1 = bar(x1,f1/trapz(x1,f1));hold on; h2 = bar(x2,f2/trapz(x2,f2),'r');hold on; h3 = bar(x3,f3/trapz(x3,f3),'g');hold on; plot(VERT1,y1,'b-');hold on; plot(VERT2,y2,'r-');hold on; plot(VERT3,y3,'g-');hold off; </code></pre> <p>Which results in: <img src="https://i.stack.imgur.com/e2PdJ.jpg" alt="enter image description here"></p> <p>Hope this explains everything.</p>
<p>What you have are two plots with non-zero means and non-unit standard deviations. Such distributions are hard to compare. What normalization means in this context (as far I think) is to make the mean of the fitted bell curve 0 and standard deviation 1. This can be achieved quite simply. Here is a toy example:</p> <pre><code>clf; data1 = random('normal',300,30,100,1); %Randomly generated first dataset data2 = random('normal',250,10,100,1); %Randomly generated second dataset h1=histfit(data1); %Plot the data hold on; h2=histfit(data2); delete(h1(1)); delete(h2(1)); set(h2(2),'color','b') </code></pre> <p>This yields:</p> <p><img src="https://i.stack.imgur.com/sZiZJ.jpg" alt="enter image description here"></p> <p>To normalize, simply replace the <code>data</code> that you're fitting with normalized data as:</p> <pre><code>h1=histfit( (data1-mean(data1)) / std(data1) ); h2=histfit( (data2-mean(data2)) / std(data2) ); </code></pre> <p>To yield: <img src="https://i.stack.imgur.com/BnZrX.jpg" alt="enter image description here"></p> <p>making the comparison of the graphs much cleaner. </p>