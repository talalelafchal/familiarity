Get all the neighborhood of point x of distance r using matlab
<p>I have a n-dimensional point, and would like to get all its neighborhood of distance r.</p> <p>I know matlab has rangesearch() to get the neighborhood of distance r in a candidate set, but in my problem I don not have a candidate set. </p> <p>Is there any matlab code can do this job?</p> <p>Thanks!</p> <p>I mean I want to create the subset of the points that are within this ball. For instance, I have a point (3,1) and the radius r is 5, so I want to find all the points within r of 5 to the point (3,1). The incremental would be 1 in this case, which means the possible answer could be point (4,1), (3,2), (5,1)...Am I making myself clear?</p>
<p>You can create a candidate set using <code>ndgrid</code>. In your 2-D example, you want a grid of points with a spacing of 1. </p> <pre><code>xrange = -10:10; yrange = -10:10; [X, Y] = ndgrid(xrange, yrange); </code></pre> <p>This produces two 2-D matrices of points. To get it into the format expected by <code>rangesearch</code>:</p> <pre><code>candidate_set = [X(:), Y(:)]; </code></pre> <p>And then you can call <code>rangesearch</code> to find which of these are within the radius of your selected point:</p> <pre><code>test_pt = [3, 1]; radius = 5; idx = rangesearch( candidate_set, test_pt, radius ); </code></pre> <p>This returns a cell array (one element for each test point). In your case, you only have a single test point, so we're only interested in <code>idx{1}</code>:</p> <pre><code>neighborhood = candidate_set(idx{1}, :); </code></pre> <p>One more note: we could be a bit more clever about generating the candidate set. We know that the neighborhood will be bounded by a hypercube centered around the test point, and so we could start by using the points in the hypercube as the candidate set:</p> <pre><code>range_min = test_pt - radius; range_max = test_pt + radius; </code></pre> <p>And then we can construct a candidate set from this range:</p> <pre><code>xrange = ceil(range_min(1)):floor(range_max(1)); yrange = ceil(range_min(2)):floor(range_max(2)); [X, Y] = ndgrid(xrange, yrange); candidate_set = [X(:), Y(:)]; </code></pre> <p>In an arbitrary number of dimensions:</p> <pre><code>nDims = length(test_pt); grid_vecs = cell(nDims, 1); grid_mats = cell(nDims, 1); for ii = 1:nDims grid_vecs{ii} = ceil(range_min(ii)):floor(range_max(ii)); end [grid_mats{:}] = ndgrid(grid_vecs{:}); for ii = 1:nDims grid_mats{ii} = grid_mats{ii}(:); end candidate_set = horzcat( grid_mats{:} ); </code></pre>