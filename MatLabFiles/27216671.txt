Cartesian product of sets in Scilab
<p>I've been looking for a fucntion that is building Cartesian product of given sets, just like this:</p> <pre><code>Example: A = [-1 -3 -5]; B = [10 11]; C = [0 1]; X = SETPROD(A,B,C) X = -5 10 0 -3 10 0 -1 10 0 -5 11 0 -3 11 0 -1 11 0 -5 10 1 -3 10 1 -1 10 1 -5 11 1 -3 11 1 -1 11 1 </code></pre> <p>Actually I was able to find such function for Matlab <a href="http://www.mathworks.com/matlabcentral/fileexchange/5898-setprod" rel="nofollow">http://www.mathworks.com/matlabcentral/fileexchange/5898-setprod</a> but unfortunately that doesn't work in Scilab.</p> <p>I know this problem is pretty straightforward, but this is my first program that I'm doing in Scilab. Thank you!</p>
<p>If you know the number of factors in the product (for example, you will be multiplying 3 sets), then <code>ndgrid</code> does everything for you:</p> <pre><code>A = [-1 -3 -5] B = [10 11] C = [0 1] [X, Y, Z] = ndgrid(A, B, C) P = [X(:) Y(:) Z(:)] </code></pre> <p>where the matrix P lists the elements of the products in the form you want. </p> <hr> <p>For a variable number of factors, <a href="http://stackoverflow.com/questions/21895335/">MATLAB approach</a> does not seem to work (or I could not figure out how to pass a variable number of arguments to <code>ndgrid</code> in Scilab). Instead, I looked up the <a href="http://cgit.scilab.org/cgit.cgi/scilab/plain/scilab/modules/elementary_functions/macros/ndgrid.sci" rel="nofollow">source of ndgrid</a> and followed its logic.</p> <pre><code> // input is a cell array of row vectors c = cell() n = // number of vectors for k=1:n c(k).entries = // your k-th vector end // Here the code that receives the cell array c and finds the product n = length(c) dim = zeros(1,n) for k=1:n dim(k) = length(c(k).entries) end P = zeros(prod(dim),n) for k=1:n f1 = ones(1,prod(dim(k+1:$))) f2 = ones(1,prod(dim(1:k-1))) P(:,k) = (f1.*.(c(k).entries).*.f2)' end </code></pre> <p>Again, P has the elements of the product, one in each row. Note that <code>.*.</code> is not a typo: it's the Kronecker product of vectors. For example, </p> <pre><code>[1 2 3].*.[1 1] = [1 1 2 2 3 3] [1 1].*.[1 2 3] = [1 2 3 1 2 3] </code></pre> <p>Kronecker product with 1-vectors <code>f1</code> and <code>f2</code> ensures that the entries are repeated in the correct pattern to produce all product elements. Swapping <code>f1</code> and <code>f2</code> results in a different ordering of elements, which may be more to your liking.</p>