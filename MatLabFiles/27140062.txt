Checking to See if an Image is the Same
<p>Alrighty, so I am working on writing a function that reads two images and determines whether or not the images are the same. There are two different things it has to check for:</p> <pre><code>1. The dimensions are the same 2. The dimensions are the same, but the picture itself is different </code></pre> <p>If it is the second case, then I need my function to output white where the image pixels are the same and black where the image pixels are different. This should be pretty simple, but for some reason I am struggling. If the pictures are the same, then I want it to read out 'The images are the same'. If the dimensions are different, then I want it to say 'The images have different dimensions.' If the dimensions match, but the picture is different then:</p> <pre><code>(1) Create an output image that highlights the differences between the two images. This image should be exclusively black and white, where it is white everywhere that the two images have the same RGB values, but black wherever the RGB values of the images differ. This image should be named by the following naming convention: '&lt;imageName1&gt;_vs_&lt;imageName2&gt;.png.' (2) Output the string 'The RBG values are different: see %s.', where you should print the name of your output file into the '%s' </code></pre> <p>I have the two first cases working. It's the third one that I am having problems with. I just get a white picture.</p> <pre><code>Test case: oranges :http://tinypic.com/r/2072gaq/8 tangerines: http://tinypic.com/r/2ufy2bn/8 Solution: http://tinypic.com/r/nqvbep/8 out3 = checkImage('oranges.png', 'tangerines.png'); oute =&gt; 'The RGB values are different: see oranges_vs_tangerines.png.' - oranges_vs_tangerines.png should look like oranges_vs_tangerines_soln.png </code></pre> <p>This is what I have so far:</p> <pre><code>function[comparison] = checkImage(pic1,pic2) %// Reads in the images img1 = imread(pic1); img2 = imread(pic2); %//Extracts the layers for both pictures red1 = img1(:,:,1); green1 = img1(:,:,2); blue1 = img1(:,:,3); red2 = img2(:,:,1); green2 = img2(:,:,2); blue2 = img2(:,:,3); %// Finds the dimensions of both pictures [r1, c1, l1] = size(img1); [r2, c2, l2] = size(img2); %// My lovely comparison loop if size(img1) == size(img2) %// Subcase to check if image is the same if red1 == red2 &amp; green1 == green2 &amp; blue1 == blue2 comparison = 'The images are the same'; %//Something down here has to be wrong elseif red1 ~= red2 &amp; green1 == green2 &amp; blue1 == blue2 red = 0; green = 255; blue = 255; elseif red1 ~= red2 &amp; green1 ~= green2 &amp; blue1 == blue2 red = 0; green = 0; blue = 255; elseif red1 ~= red2 &amp; green1 ~= green2 &amp; blue1 ~= blue2 red = 0; green = 0; blue =0; elseif red1 == red2 &amp; green1 ~= green2 &amp; blue1 == blue2 red = 255; green = 0; blue = 255; elseif red1 == red2 &amp; green1 ~= green2 &amp; blue1 ~= blue2 red = 255; green = 0; blue = 0; else red = 255; green = 255; blue = 0; %// This part could be the issue, but I am unsure newpic = cat(3,red,green,blue); name1 = pic1(1:end-4); name2 = pic2(1:end); picture = [name1 '_vs_' name2]; imwrite(newpic,picture); comparison = sprintf('The RBG values are different: see %s.',picture); end %// This appears to work fine elseif r1 &amp; c1 &amp; l1 ~= r2 &amp; c2 &amp; l2 comparison = 'The images have different dimensions.'; else %// I put this in for S&amp;G comparison = 'My code is wrong'; end end </code></pre> <p>I appreciate any help/suggestions. I think I over-complicated this code a lot.</p> <p>Edit: I realize I have my code correcting the values, but I haven't actually written in their place. Like, it doesn't know how to put the colors in where there's a mismatch. I know I know how to do this. I just need to think harder.</p> <p>Attempt two:</p> <pre><code>function[comparison] = checkImage(pic1,pic2) img1 = imread(pic1); img2 = imread(pic2); red1 = img1(:,:,1); green1 = img1(:,:,2); blue1 = img1(:,:,3); red2 = img2(:,:,1); green2 = img2(:,:,2); blue2 = img2(:,:,3); [r1, c1, l1] = size(img1); [r2, c2, l2] = size(img2); mask1 = red1 ~= red2 &amp; green1 == green2 &amp; blue1 == blue2; mask2 = red1 ~= red2 &amp; green1 ~= green2 &amp; blue1 == blue2; mask3 = red1 ~= red2 &amp; green1 ~= green2 &amp; blue1 ~= blue2; mask4 = red1 == red2 &amp; green1 ~= green2 &amp; blue1 == blue2; mask5 = red1 == red2 &amp; green1 ~= green2 &amp; blue1 ~= blue2; mask6 = red1 ~= red2 &amp; green1 ~= green2 &amp; blue1 ~= blue2; color1 = [red1 green1 blue1]; color2 = [red2 green2 blue2]; if size(img1) == size(img2) if red1 == red2 &amp; green1 == green2 &amp; blue1 == blue2 comparison = 'The images are the same'; elseif mask1 == 1 red1(mask1) = 0; green1(mask1) = 255; blue1(mask1) = 255; elseif mask2 == 1 red1(mask2) = 0; green1(mask2) = 0; blue1(mask2) = 255; elseif mask3 == 1 red1(mask3) = 0; green1(mask3) = 0; blue1(mask3) =0; elseif mask4 == 1 red1(mask4) = 255; green1(mask4) = 0; blue1(mask4) = 255; elseif mask5 == 1 red1(mask5) = 255; green1(mask5) = 0; blue1(mask5) = 0; else red1(mask6) = 255; green1(mask6) = 255; blue1(mask6) = 0; newpic = cat(3,red1,green1,blue1); name1 = pic1(1:end-4); name2 = pic2(1:end); picture = [name1 '_vs_' name2]; imwrite(newpic,picture); comparison = sprintf('The RBG values are different: see %s.',picture); end elseif r1 &amp; c1 &amp; l1 ~= r2 &amp; c2 &amp; l2 comparison = 'The images have different dimensions.'; else comparison = 'My code is wrong'; end end </code></pre>
<p>OK, let's simplify the problem description... mainly because it'll allow me to answer this more quickly, and allow me to capture a better understanding of what needs to be done:</p> <p>Given two images:</p> <ol> <li>We need to check if the dimensions are the same for both.</li> <li>If the dimensions match, then we need to check if both pictures are exactly the same. If they are, then we will output that the images are the same.</li> <li>If they're not, then you need to go through each pixel for both images, then mark whether the location has the same RGB values in white, or they don't have the same values in black.</li> </ol> <p>Also, you've provided example images and ground truth:</p> <h1>Image #1</h1> <p><img src="http://oi59.tinypic.com/2072gaq.jpg" alt=""></p> <h1>Image #2</h1> <p><img src="http://oi58.tinypic.com/2ufy2bn.jpg" alt=""></p> <h1>Ground Truth (Cute!)</h1> <p><img src="http://oi59.tinypic.com/nqvbep.jpg" alt=""></p> <p>Be advised that the images are quantized using JPEG quantization, and so you won't get exactly the same output due to quantization noise. You'll get a bit of spurious pixels here and there, but the overall picture should look the same.</p> <hr> <p>Let's assume that the images are loaded in as <code>img1</code> and <code>img2</code>. </p> <pre><code>img1 = imread('http://oi59.tinypic.com/2072gaq.jpg'); img2 = imread('http://oi58.tinypic.com/2ufy2bn.jpg'); </code></pre> <p>First, let's check if the dimensions are the same:</p> <pre><code>img1Rows = size(img1, 1); img1Cols = size(img1, 2); img2Rows = size(img2, 1); img2Cols = size(img2, 2); if (img1Rows ~= img2Rows) || (img1Cols ~= img2Cols) disp('Image dimensions are not the same'); return; end </code></pre> <p>The above code reads in the dimensions (rows and columns) of each image, and checks to see whether the rows and columns of both images match up. If they don't, we output that they're not the same dimensions then exit.</p> <p>Now, if they are the same, then let's check to see whether the images are exactly the same. What I recommend you do is take each of the images and reshape them so that they fit into a single vector. After you do this, do a point by point difference and add up all of these differences. Should the images be <strong>exactly</strong> the same, then the summation of all the differences will be zero. I'm also going to convert the images to <code>double</code> precision to allow for negative differences. Not sure if you've covered data types, but images are usually unsigned 8-bit integer, meaning that the valid range of numbers goes between <code>[0,255]</code>. Any values below 0 get clipped to 0 while any values greater than 255 get clipped to 255. As such, if you did <code>0 - 1</code> and this was unsigned 8-bit integer, this would register as a difference of 0, which is not correct. Therefore, let's convert the images to <code>double</code>, and take the <strong>absolute</strong> value to ensure that we don't get a situation where we have some negative and positive numbers cancelling to give us our zero sum. Therefore:</p> <pre><code>img1_double = double(img1); img2_double = double(img2); if sum( abs( img1_double(:) - img2_double(:) ) ) == 0.0 disp('The images are the same'); return; end </code></pre> <hr> <p>Now, we get to the situation where the images don't have the same content. What I would do is extract each colour plane, then do a huge equality operator to see whether or not we have the same RGB values in the corresponding positions. In other words:</p> <pre><code>out = (img1(:,:,1) == img2(:,:,1)) &amp; (img1(:,:,2) == img2(:,:,2)) &amp; (img1(:,:,3) == img2(:,:,3)); out = 255*uint8(cat(3,out,out,out)); </code></pre> <p>This basically checks if the image has the same RGB values in the corresponding positions. This produces a binary image that indicates our criteria we defined above. Because you need to return a colour image, we simply replicate the image three times in the third dimension, cast to <code>uint8</code>, then multiply by 255 to convert this into a RGB image. </p> <p>What you can also do is you can prettify this into a <code>for</code> loop. Allocate an image that is all logical <code>true</code> first, then extract pairs of colour planes per image, find where each colour plane is equal, then logical AND the result and append this to <code>out</code>. We are basically achieving the same thing as we did above, but it's more compacted. Therefore:</p> <pre><code>out = true(size(img1,1), size(img1,2)); for p = 1 : 3 img1_plane = img1(:,:,p); img2_plane = img2(:,:,p); out = out &amp; (img1_plane == img2_plane); end out = 255*uint8(cat(3,out,out,out)); </code></pre> <p>If we show this image with <code>imshow(out);</code>, we get:</p> <p><img src="https://i.stack.imgur.com/nBrR2.png" alt="enter image description here"></p> <p>Sweet. Now, all we have to do is display the appropriate message. You've already done that in your code above. Now, if we want to wrap this all up into a nice function, we would do:</p> <pre><code>function [comparison] = checkImage(pic1,pic2) img1 = imread(pic1); img2 = imread(pic2); img1Rows = size(img1, 1); img1Cols = size(img1, 2); img2Rows = size(img2, 1); img2Cols = size(img2, 2); if (img1Rows ~= img2Rows) || (img1Cols ~= img2Cols) comparison = 'Image dimensions are not the same'; return; end img1_double = double(img1); img2_double = double(img2); if sum( abs( img1_double(:) - img2_double(:) ) ) == 0.0 comparison = 'The images are the same'; return; end out = (img1(:,:,1) == img2(:,:,1)) &amp; (img1(:,:,2) == img2(:,:,2)) &amp; (img1(:,:,3) == img2(:,:,3)); % // OR %out = true(size(img1,1), size(img1,2)); %for p = 1 : 3 % img1_plane = img1(:,:,p); % img2_plane = img2(:,:,p); % out = out &amp; (img1_plane == img2_plane); %end out = 255*uint8(cat(3,out,out,out)); picture = [pic1(1:end-4) '_vs_' pic2(1:end-4) '.png']; imwrite(out, picture); comparison = sprintf('The RGB values are different: see %s.',picture); </code></pre> <hr> <p>Take note of the last three lines of code. We create our string of what the image is going to be saved as by extracting everything but the last four characters for both of the image names, then put in a <code>_vs_</code> string in the middle, and append <code>.png</code> at the end of the string. We write this binary image stored in <code>out</code> to file as well. I've also changed my <code>disp</code> statements to write the string to <code>comparison</code>, as you have put that in your function. This is the string that gets returned in your function, but as a side-effect, we also write the image to file in that naming convention.</p> <hr> <p>Have fun! </p>