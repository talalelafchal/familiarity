element by element matrix multiplication in Matlab
<p>So I have the following matrices:</p> <pre><code>A = [1 2 3; 4 5 6]; B = [0.5 2 3]; </code></pre> <p>I'm writing a function in MATLAB that will allow me to multiply a vector and a matrix by element as long as the number of elements in the vector matches the number of columns. In <code>A</code> there are 3 columns:</p> <pre><code>1 2 3 4 5 6 </code></pre> <p><code>B</code> also has 3 elements so this should work. I'm trying to produce the following output based on <code>A</code> and <code>B</code>:</p> <pre><code>0.5 4 9 2 10 18 </code></pre> <p>My code is below. Does anyone know what I'm doing wrong?</p> <pre><code>function C = lab11(mat, vec) C = zeros(2,3); [a, b] = size(mat); [c, d] = size(vec); for i = 1:a for k = 1:b for j = 1 C(i,k) = C(i,k) + A(i,j) * B(j,k); end end end end </code></pre>
<p>Referencing MrAzzaman, <a href="http://www.mathworks.com/help/matlab/ref/bsxfun.html" rel="nofollow"><code>bsxfun</code></a> is the way to go with this. However, judging from your function name, this looks like it's homework, and so let's stick with what you have originally. As such, you need to only write two <code>for</code> loops. You would use the second <code>for</code> loop to index into both the vector and the columns of the matrix at the same time. The outer most <code>for</code> loop would access the rows of the matrix. In addition, you are referencing <code>A</code> and <code>B</code>, which are variables that don't exist in your code. You are also initializing the output matrix <code>C</code> to be 2 x 3 <strong>always</strong>. You want this to be the same size as <code>mat</code>. I also removed your checking of the length of the vector because you weren't doing anything with the result.</p> <p>As such:</p> <pre><code>function C = lab11(mat, vec) [a, b] = size(mat); C = zeros(a,b); for i = 1:a for k = 1:b C(i,k) = mat(i,k) * vec(k); end end end </code></pre> <p>Take special note at what I did. The outer-most <code>for</code> loop accesses the rows of <code>mat</code>, while the inner-most loop accesses the columns of <code>mat</code> as well as the elements of <code>vec</code>. Bear in mind that the number of columns of <code>mat</code> need to be the same as the number of elements in <code>vec</code>. You should probably check for this in your code.</p> <hr> <p>If you don't like using the <code>bsxfun</code> approach, one alternative is to take the vector <code>vec</code> and make a matrix out of this that is the same size as <code>mat</code> by stacking the vector <code>vec</code> on top of itself for as many times as we have rows in <code>mat</code>. After this, you can do element-by-element multiplication. You can do this stacking by using <a href="http://www.mathworks.com/help/matlab/ref/repmat.html" rel="nofollow"><code>repmat</code></a> which repeats a vector or matrices a given number of times in any dimension(s) you want. As such, your function would be simplified to:</p> <pre><code>function C = lab11(mat, vec) rows = size(mat, 1); vec_mat = repmat(vec, rows, 1); C = mat .* vec_mat; end </code></pre> <hr> <p>However, I would personally go with the <code>bsxfun</code> route. <code>bsxfun</code> basically does what the <code>repmat</code> paradigm does under the hood. Internally, it ensures that both of your inputs have the same size. If it doesn't, it replicates the smaller array / matrix until it is the same size as the larger array / matrix, then applies an element-by-element operation to the corresponding elements in both variables. <code>bsxfun</code> stands for <strong>Binary Singleton EXpansion FUNction</strong>, which is a fancy way of saying exactly what I just talked about.</p> <p>Therefore, your function is further simplified to:</p> <pre><code>function C = lab11(mat, vec) C = bsxfun(@times, mat, vec); end </code></pre> <hr> <p>Good luck!</p>
<p>MATLAB already has functionality to do this in the <a href="http://www.mathworks.com/help/matlab/ref/bsxfun.html" rel="nofollow"><code>bsxfun</code></a> function. <code>bsxfun</code> will take two matrices and duplicate singleton dimensions until the matrices are the same size, then perform a binary operation on the two matrices. So, for your example, you would simply do the following:</p> <pre><code>C = bsxfun(@times,mat,vec); </code></pre>