Matlab: Is there a function to locate an 'n' digit in a number (i.e 2nd digit in '75673', so 5)
<p>I have a number <code>A=7654321</code>.</p> <p>I need the number at location 5 (from beginning, or number 3 from end), which in this case is 3.</p> <p>Is there a function which does something like: <code>getdigit(A,n)</code>, where A is the number and n is the position of the number that I want?</p> <p>I could convert the number to a text string, find the number at position n, and convert it back to a number (<code>num2str</code> and <code>str2double</code>), but it does not seem like a good solution to me, are there any better ways you know of?</p>
<p>The most efficient way I can think of is to do exactly what you didn't want to do, though slightly more efficient! Convert your number to a string, break up each digit into separate locations, then pull out the digit you want. Therefore:</p> <pre><code>function [out] = getDigit(A,n) C = num2str(A) - 48; out = C(n); end </code></pre> <hr> <p>The first statement is a bit tricky. Use <a href="http://www.mathworks.com/help/matlab/ref/num2str.html" rel="nofollow"><code>num2str</code></a> to convert your number into a character array. Now, you need to know a bit about MATLAB internals for what I'm about to do next. By casting the string to <code>double</code>, it will convert each character into its <a href="http://en.wikipedia.org/wiki/ASCII" rel="nofollow">ASCII</a> representation and place each character into a separate entry in a numeric array, which assigns a unique ID to each character that exists on your keyboard. You'll notice that the number zero starts at ID 48, and linearly increases from there. As such, I subtract by 48 to bring the numbers back to 0-9. In fact, if you just subtract the string by 48, it will automatically be cast to <code>double</code> for you (thanks Luis!).</p> <p>Once I do this, I pick out the position I want, which is <code>n</code>. Therefore, after running this by doing <code>C = getdigit(7654321, 5);</code>, we get:</p> <pre><code>C = 3 </code></pre> <hr> <p>However, if you really really don't want to do use the ASCII trick, you can use information about dividing by powers of 10 and remainders.... actually, Anders Forsgren linked you to a nice post in Java, but let's do that in MATLAB.</p> <p>Simply take the modulus of <code>A</code> by <code>10^n</code>, divide this by <code>10^(n-1)</code> and take the <code>floor</code>. However, one caveat is that this method counts <strong>from the end</strong>, so you would have to make <code>n</code> equal to 3.</p> <p>Therefore:</p> <pre><code>function [out] = getDigit(A,n) out = floor(mod(A, 10^n) / 10^(n-1)); end </code></pre> <p>Doing <code>C = getDigit(7654321, 3)</code> gives us:</p> <pre><code>C = 3 </code></pre> <h1>Edit</h1> <p>If you want to stick with your convention and go from left to right, rather than right to left, you can calculate how many digits exist in the number, then simply use the logic that I have above and wrap around by taking your value of <code>n</code> and subtracting this from the number of digits minus one (borrowed from badjr). Therefore:</p> <pre><code>function [out] = getDigit(A,n) n = (floor(log10(A)) + 1) - (n - 1); out = floor(mod(A, 10^n) / 10^(n-1)); end </code></pre> <p>The first part of recalculating <code>n</code> is to determine how many digits we have to represent our number. We need to take <code>n</code> and reformulate it so that we are referring to the digit position from right to left, rather than left to right. This is in order to use the logic I defined previously. You need to make sure that you wrap around by subtracting with <code>n - 1</code>, because if you subtracted with just <code>n</code>, this actually makes the extract <strong>zero-indexed</strong> based. If you want to respect your function definition where <code>n = 1</code> is the first digit of the number to extract and not the second, we have to offset by 1.</p> <p>By doing <code>C = getDigit(7654321, 5);</code>, we get:</p> <pre><code>C = 3 </code></pre>
<p>Defining a function <code>getdigit(A, n)</code> (in a file <code>getdigit.m</code>):</p> <pre><code>function d = getdigit(A, n) numDigits = floor(log10(abs(A))) + 1; d = mod(floor(A/10^(numDigits - n)), 10); end </code></pre> <p>Then,</p> <pre><code>&gt;&gt;A=7654321; &gt;&gt;getdigit(A, 5) </code></pre> <p>gives</p> <pre><code>ans = 3 </code></pre>