Using Euler's Method in Matlab
<p>First time post here. Pretty frustrated right now working on this assignment for class. </p> <p>Basically, the idea is to use Euler's method to simulate and graph an equation of motion. The equation of motion is in the form of an ODE. </p> <p>My professor has already put down some code for slightly similar system and would like us to derive the equation of motion using Lagrange. I believe that I have derived the EOM correctly, however I am running into problems on the Matlab side of things. </p> <p>What's weird is that using a similar technique on another, seperate EOM, I have no issues. So I am unsure what I am doing wrong. </p> <p>Here's the code for the part that is working correctly:</p> <p><div class="snippet" data-lang="js" data-hide="false"> <div class="snippet-code"> <pre class="snippet-code-js lang-js prettyprint-override"><code>close all; clear all; clc; % System parameters w = 2*pi; c = 0.02; % Time vectors dt = 1e-5; t = 0:dt:4; theta = zeros(size(t)); thetadot = zeros(size(t)); % Initial conditions theta(1)=pi/2; %theta(0) thetadot(1)=0; %thetadot(0) for I = 1 : length(t)-1; thetaddot = -c*thetadot(I)-w^2*sin(theta(I)); thetadot(I+1)=thetadot(I)+thetaddot*dt; theta(I+1)=theta(I)+thetadot(I)*dt ; end figure(1); plot(t,theta,'b'); xlabel('time(s)'); ylabel('theta'); title('Figure 1'); zoom on; % Output the plot to a pdf file, and make it 6 inches by 4 inches printFigureToPdf('fig1.pdf', [6,4],'in'); % Open the pdf for viewing open fig1.pdf</code></pre> </div> </div> </p> <p>Everything runs fine, except Matlab complains about the printFigureToPdf command.</p> <p>Now, here is the code for the problem that I am having issues with. </p> <p><div class="snippet" data-lang="js" data-hide="false"> <div class="snippet-code"> <pre class="snippet-code-js lang-js prettyprint-override"><code>close all; clear all; clc; clf % System parameters m=0.2; g=9.81; c=.2; d=0.075; L=0.001; %L is used for Gamma B=0.001; %B is used for Beta W=210*pi; %W is used for Omega %Time vectors dt = 1e-6; %Time Step t=0:dt:10; %Range of times that simulation goes through x=zeros(size(t)); xdot=zeros(size(t)); %Initialconditions x(1)=0;%x(0) xdot(1)=0; %xdot(0) for I = 1 : length(t)-1; xddot =-1/m*(c*xdot(I)-c*L*W*cos(W)+m*g-3*B*((d+x-L*W*sin(W*t)).^(-4)-(d-x-L*W*sin(W*t)).^(-4))); xdot(I+1)=xdot(I)+xddot*dt; x(I+1)=x(I)+xdot(I+1)*dt ; end figure(1); plot(t,x,'b'); xlabel('time(s)'); ylabel('distance(m)'); title('Figure 2'); zoom on; % Output the plot to a pdf file, and make it 6 inches by 4 inches printFigureToPdf('fig1.pdf', [6,4],'in'); % Open the pdf for viewing open fig1.pdf</code></pre> </div> </div> </p> <p>With this code, I followed the same procedure and is giving an error on line 23: "In an assignment A(I) = B, the number of elements in B and I must be the same."</p> <p>Like I said, I am confused because the other code worked okay, and this second set of code gives an error. </p> <p>If anyone could give me a hand with this, I would greatly appreciate it.</p> <p>Thanks in advance, Dave</p> <p>Edit: As suggested, I changed x(I+1)=x(I)+xdot(I+1)*dt to x(I+1)=x(I)+xdot(I)*dt. However, I am still getting an error for line 23: "In an assignment A(I) = B, the number of elements in B and I must be the same."</p> <p>Line 23 is: xdot(I+1)=xdot(I)+xddot*dt;</p> <p>So, I tried adjusting the code as suggested for the other line to xdot(I+1)=xdot(I)+xddot(I)*dt;</p> <p>After making this change, Matlab gets stuck, I tried letting it run for a few minutes but won't execute. I ended up having to close and reopen the application. </p>
<p>The error <code>In an assignment A(I) = B, the number of elements in B and I must be the same.</code> is something you should understand because it may pop up frequently in Matlab if you are not careful.</p> <p>In your case, you are trying to assign <strong>1</strong> element value <code>xdot(I+1)</code> with something which has more than 1 element <code>xdot(I)+xddot*dt</code>.</p> <p>Indeed, if you step through the code line by line and observe your workspace, you will notice that <code>xddot</code> is not a scalar value as intended, but a full blown vector the size of <code>t</code>. This is because in the precedent line where you define <code>xddot</code>:</p> <pre><code>xddot =-1/m*(c*xdot(I)-c*L*W*cos(W)+m*g-3*B*((d+x-L*W*sin(W*t)).^(-4)-(d-x-L*W*sin(W*t)).^(-4))); </code></pre> <p>you still have many references to <code>x</code> (<em>full vector</em>) and <code>t</code> (<em>full vector</em>). You have to replace all these references to full vectors to only one index of them, i.e use <code>x(I)</code> and <code>t(I)</code>. The line becomes:</p> <pre><code>xddot =-1/m*(c*xdot(I)-c*L*W*cos(W)+m*g-3*B*((d+x(I)-L*W*sin(W*t(I))).^(-4)-(d-x(I)-L*W*sin(W*t(I))).^(-4))); </code></pre> <p>With that your code runs just fine. However, it is far from optimized and it runs relatively slow. I have a powerful machine and it still takes a long time to run for me. I suggest you reduce your time step to something more sensible, at least when you are still trying your code. If you really need that kind of precision, first make sure your code runs fine then when it is ready let it run at full precision and go have a coffee while your computer is doing the work.</p> <p>The snippet below is the <code>loop</code> part of your code with the correct assignment for <code>xddot</code>. I also added a simple progress bar so you can see that your code is doing something.</p> <pre><code>hw = waitbar(0,'Please wait...') ; npt = length(t)-1 ; for I = 1 : npt xddot =-1/m*(c*xdot(I)-c*L*W*cos(W)+m*g-3*B*((d+x(I)-L*W*sin(W*t(I))).^(-4)-(d-x(I)-L*W*sin(W*t(I))).^(-4))); xdot(I+1) = xdot(I)+xddot*dt; x(I+1) = x(I)+xdot(I+1)*dt ; pcdone = I / npt ; waitbar(pcdone,hw,[num2str(pcdone*100,'%5.2f') '% done']) end close(hw) </code></pre> <p>I strongly suggest you reduce your time step to <code>dt = 1e-3;</code> until you are satisfied with everything else. </p> <p>In the final version, you can remove or comment the calls to the <code>waitbar</code> as it slows down things too.</p>