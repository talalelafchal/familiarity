Convert binary image to a Gussian points
<p>I have a binary image <strong>A</strong> that contains some white points. Now I want an image <strong>B</strong> where for every white point in <strong>A</strong> the intensity is spread to its neighbors so that these points have a value of 1 and the value decrease around it. So that the final image <strong>B</strong> has values range of [0 1] where 1 happens at the my white points.</p> <p>My approach:</p> <p>I convolved the image with Gaussian function using this code:</p> <pre><code>x=-ceil(siz/2):ceil(siz/2); H = exp(-(x.^2/(2*sigma^2))); H = H/sum(H(:));%normalize the kernel Hx=reshape(H,[length(H) 1]); Hy=reshape(H,[1 length(H)]); I=imfilter(imfilter(I,Hx, 'same' ,'replicate'),Hy, 'same' ,'replicate'); </code></pre> <p>Problem: As I do this to the whole image, I face a problem when I have two successive white neighbors, the convolution at these points has a high value, thus , when normalizing <strong>B</strong> the maximum happens at this location, and my original white points has a values less than 1.</p> <p>Is there any way where I can spread the intensity individually (treat each point as a source regardless of its neighbors) and the final image is the maximum of this operations ,so that at the location of 2 white points, the two points have values of 1 and their neighbors have maximum of the 2 Gaussians ??<img src="https://i.stack.imgur.com/347XQ.png" alt="enter image description here"><img src="https://i.stack.imgur.com/k73lH.png" alt="enter image description here"></p>
<p>You could try a hard cap.</p> <p>Either save the locations of the white points before the convolution or find the location of all points > 1 and set them to 1 like this:</p> <pre><code>B(B&gt;1) = 1 </code></pre>