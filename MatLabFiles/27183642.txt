How to compare two unsorted lists in Matlab?
<p>I have two lists of 2-dimensional points given as M x 2 - and N x 2 - matrices, respectively, with M and N possibly being very large.</p> <p>What is the fastest way to determine how many of them are equal?</p>
<p>I am not sure whether you want to count repetitive entries, but if not you could use <code>intersect</code> or some quite intuitive algorithm based on sorting (see below). I would not prefer a nested-loop version...</p> <pre><code>function test_compareVecs() %% create some random data N = 31415; M1 = 100000; M2 = 200000; vec = rand(N,2); v1 = [rand(M1-N,2); vec]; v2 = [rand(M2-N,2); vec]; v1 = v1(randperm(M1),:); v2 = v2(randperm(M2),:); %% intersect disp('intersect:'); tic s = size(intersect(v1,v2,'rows'),1); toc; s %% alternative approach disp('alternative approach:'); tic; s = compareVecs(v1,v2); toc; s end function s = compareVecs(v1,v2) %% create help vector help_vec = [[v1,zeros(size(v1,1),1)]; ... [v2,ones(size(v2,1),1)]]; %% sort by first column % note: for some reason "sortrows(help_vec,1)" is slower hash_vec = help_vec(:,1); % dummy hash [~,sidx] = sort(hash_vec); help_vec = help_vec(sidx,:); %% diff + compare help_vec = diff(help_vec); s = sum(help_vec(:,1) == 0 &amp; ... help_vec(:,2) == 0 &amp; ... help_vec(:,3) ~= 0); end </code></pre> <p><strong>Result</strong></p> <pre><code>intersect: Elapsed time is 0.145717 seconds. s = 31415 alternative approach: Elapsed time is 0.048084 seconds. s = 31415 </code></pre>
<p>Compute all pair-wise distances with <a href="http://es.mathworks.com/help/stats/pdist2.html" rel="nofollow"><code>pdist2</code></a> and then count pairs with zero distance. If the coordinates are float values, you may want to use a tolerance instead of comparing against zero:</p> <pre><code>%// Data: M = 10; N = 8; listM = randi(10,M,2)-1; listN = randi(10,N,2)-1; tol = 1e-6; %// Distance matrix: d = pdist2(listM, listN); %// Count: count = sum(d(:)&lt;tol); </code></pre>
<p>This should work irrespective of the order of the points in each list, or their lengths. It is a hash-table/dictionary solution that should be fast but with memory demand linear with the lengths of the lists. Please, note that the syntax below may not be perfect, but a quick reference to the main data structures mentioned should make corrections trivial.</p> <p>(1) populate a dictionary-like <a href="http://www.mathworks.com/help/matlab/ref/containers.map-class.html" rel="nofollow">containers.Map</a>, in a way that the key is a unique function of the points, e.g. <code>num2str(M(i,1))'-'num2str(M(i,2))</code>.</p> <p>(2) Then, go over all elements of the second list, create the key just as in (1) and check if it exists. If it does, set <code>map(key)=1</code> else set it to 0. In the end, all the keys consisting of common points will have 1s stored, and the rest will be zeros.</p> <p>(3) Finalize by summing over the values of the map (something like <code>sum(map.values())</code>) which should give you the total number of <strong>unique</strong> intersections among the two sets, irrespective of the order these points appear in each list.</p> <p>OBS: if you don't want to count just unique intersections but <strong>all repeated points</strong>, in (2), rather than making <code>map(key)=1</code>, add 1 to <code>map(key)</code>. The rest is the same.</p>