Flexible Array in matlab
<p>i have some cities, these cities have some neighbors and count of these neighbors are not similar.<br> i have a function: </p> <pre><code>function [cityN,neighbor,neghbor2:neghborN]] = makeneighbor(x,y) cityN=x; neighbor=y; end % this function is false and i just told what is in my mind </code></pre> <p>for example: </p> <pre><code> //city1 have 2 neighbors: [city1,neighbor1,neghbor2] //but city2 have 4 neighbors: [city2,neighbor1,neghbor2,neighbor3,neghbor4] //and city3 have just a neighbor [city3,neighbor1] </code></pre> <p>i need a flixeble array for this, many thanks...</p>
<p>Not sure is this is exactly what you need, but:</p> <pre><code>all_cities = {} all_cities{end+1} = {'New York','Boston', 'Mscow'} all_cities{end+1} = {'Moscow','Town1', 'St.Petersburg'} </code></pre> <p>All cities is a cell array that contains all cities. Every alement of this cell array is cell array too. Every nested cell array contains as a first element the main city, from the second element to the last one neighbors are stored.</p> <p>Say, if we speak about New York,</p> <pre><code>new_york = all_cities{1}; new_york_neighbors = new_york{2:end}; </code></pre> <p>You also should check if new_york_neighbors is empty while processing it. Use function <em>isempty()</em></p>
<p>I am not quite sure if I understood your question. To handle different array sizes you could return a struct for your <code>makeneighbor</code> function with 1 field that contains the city name and a second field that contains a cell array with all neighborhoods: </p> <pre><code>function [] = main_func() x1 = 'new york'; y1 = {'brooklyn'; 'queens'}; city1 = makeneighbor(x1, y1); x2 = 'los angeles'; y2 = {'hollywood'; 'downtown'; 'mid-city'; 'bel air'}; city2 = makeneighbor(x2, y2); % acces to cities city1.name city1.neighbor city2.name city2.neighbor end % function that returns a struct function city = makeneighbor(x, y) % generate struct with two fields city.name = x; city.neighbor = y; end </code></pre>
<p>You could use an <a href="http://en.wikipedia.org/wiki/Adjacency_matrix" rel="nofollow">adjacency matrix</a></p> <pre><code>cities = {'City1','City2', 'City3', 'City4'} A = 0 1 0 1 (1 is neighbours with 2 and 4) 1 0 1 0 (2 is neighbours with 1 and 3) 0 1 0 0 (3 is only neighbours with 2) 1 0 0 0 (4 is only neighbours with 4) </code></pre> <p>(<code>A</code> should be of type logical)</p> <p>Then, for any city, the list of neighbours is:</p> <pre><code>n = strfind('City1',cities); neighbours = cities(A(n,:)); </code></pre> <p>And the list with itself and neighbours would be</p> <pre><code>self_neighbours = [cities(n),cities(A(n,:))]; </code></pre> <p>The count of number of neighbours is just:</p> <pre><code>num_neighbours = sum(A(n,:)); </code></pre> <p>The advantages of keeping a list of who is neighbours with who in something like an adjacency matrix is that it makes it much easier to perform calculations. If you have access to the Bioinformatics Toolbox, you also then can use this to do various useful things:</p> <pre><code>b = biograph(A,cities); %makes biograph object view(b); % shows connection between cities [dist,path,pred] = shortestpath(b,1,3); % finds path between 1 and 3 </code></pre>