Classifying numbers which have same labels and same neighborhood in MATLAB
<p>If <code>A</code> is a matrix which its second column(<code>A(:,2)</code>) represent labels of different <code>"categories"</code>:</p> <pre><code>A = { 3x2 cell} [ 1] { 2x2 cell} [ 2] { 3x2 cell} [ 3] { 4x2 cell} [ 4] </code></pre> <p>and each <code>"category"</code> include some <code>"numbers"</code> which classified in some <code>"sub-categories"</code>. It means <code>A{i}(:,2)</code> are labels of <code>"sub-categories"</code>. For instance:</p> <pre><code>%copy-paste A into MATALB A{1} = {[2.5] [1]; % sub-category is [A] [1.49] [2]; % sub-category is [B] [0.35] [3]}; % sub-category is [C] A{2} = {[3.8] [1]; % sub-category is [A] [1.09] [2]}; % sub-category is [B] A{3} = {[6.95] [1]; % sub-category is [A] [7.04] [2]; % sub-category is [B] [2.85] [3]}; % sub-category is [C] A{4} = {[5.5] [1]; % sub-category is [A] [3.1] [2]; % sub-category is [B] [6.76] [3]; % sub-category is [C] [9.8] [4]}; % sub-category is [D] A=A.' A{1,2}=1; A{2,2}=2; A{3,2}=3; A{4,2}=4 </code></pre> <p>The goal(<code>B</code>) is to classified <code>"numbers"</code> <strong>(2.5, 1.49, etc.)</strong> in accordance to their <code>"sub-category"</code> labels <strong>(A,B,C and D)</strong>. Moreover, the most important point is that the classifying should be done only for those <code>"sub-categories"</code> which are neighbors to each other. It means, those <code>"numbers"</code> should be selected in a same group which they have same <code>"sub-category"</code> and they were searched only in next and previous <code>"categories"</code> <strong>(1,2,3 and 4)</strong>. Therefore, in our example we would like to get:</p> <pre><code>% First column shows the number % Second column shows the sub-category % Third column shows the category % For [2.5] which has sub-category "A" or better to say "[1]", % it has only one neighborhood in category [2]: B{1}= [2.5] [1] [1] [3.8] [1] [2] % For [1.49] which has sub-category "B" or it is better to say "[2]", % it has also one neighborhood in category [2]: B{2}= [1.49] [2] [1] [1.09] [2] [2] % For [2.5] which has sub-category "A" or it is better to say "[1]", % it has two neighborhood in category [2] &amp; [3]: B{3}= [2.5] [1] [1] [3.8] [1] [2] [6.95] [1] [3] % For [1.49] which has sub-category "B" or it is better to say "[2]", % it has two neighborhood in category [2] &amp; [3]: B{4}= [1.49] [2] [1] [1.09] [2] [2] [7.04] [2] [3] % For [2.85] which has sub-category "C" or it is better to say "[3]", % it has one neighborhood in category [4]: B{5}= [2.85] [3] [3] [6.76] [3] [4] % For [6.95] which has sub-category "A" or it is better to say "[1]", % it has two neighborhood in category [2] &amp; [4]: B{6}= [6.95] [1] [3] [3.8] [1] [2] [5.5] [1] [4] % For [5.5] which has sub-category "A" or it is better to say "[1]", % it has one neighborhood in category [3]: B{7}= [5.5] [1] [4] [6.95] [1] [3] % For [9.8] which has sub-category "D" or it is better to say "[4]", % there is no number with the same label: B{8}= [9.8] [4] [4] % And finally, for [0.35]; although, there are some number with the same label, % there is no neighborhood in the next category( means category 2): B{9}= [0.35] [3] [1] </code></pre> <p>In order to clarify the problem, I was asked to add some explanation. Therefore, firstly, we should search the <code>"sub-category"</code> labels of each number. Then, among those numbers which have the same label, we need to check whether they have any neighbor in next or last <code>"category"</code> with the same <code>"sub-category"</code> or not. It would be great if the proper code probably be written with <code>cellfun</code> or <code>bsxfun</code> functions instead of using a loop as it is probably more efficient. Thanks</p>