Assigning the result of a vector-valued MATLAB function in a loop
<p>Consider the vector-values function <code>foo()</code>,</p> <pre><code>function [x, y] = foo() x = exp(0); y = exp(1); end </code></pre> <p>and a script that calls <code>foo()</code> a total of <code>N</code> times,</p> <pre><code>N=5; Results = zeros(N,2); for i=1:N Results(i,:) = foo(); end </code></pre> <p>Desired contents of <code>Results</code>:</p> <pre><code>1 2.7183 1 2.7183 1 2.7183 1 2.7183 1 2.7183 </code></pre> <p>Actual contents of <code>Results</code>:</p> <pre><code>1 1 1 1 1 1 1 1 1 1 </code></pre> <p>Is there a simple fix for this? Thanks!</p>
<p>When you define <code>function [x,y] = foo()</code>, the function should be called as <code>[x,y]=foo()</code>, or in your case <code>[Results(i,1), Results(i,2)]=foo()</code>.</p> <p>If you do <code>Results(i,:)=foo()</code>, it will return only the first argument of <code>foo()</code>, which is 1.0, and broadcast to <code>Results(i,:)</code>.</p>
<p>Your <code>foo</code> function works fine. However, within the loop, the output of <code>foo</code> only gets assigned to one variable, even though you are trying to place both values from <code>foo</code> into a row in your matrix. This is a technicality with MATLAB that may seem annoying at first. It's actually treating the entire row of your matrix as a single variable, and so we are only getting the first variable from <code>foo</code>. The second variable gets discarded. Because it only returns one variable, your assignment in your loop at each iteration is assigning an entire row to be the same number, which is the first output of <code>foo</code>.</p> <p>There are three possible ways that you can get this to work:</p> <h1>1. Modify your <code>foo</code> function (à la Divakar)</h1> <p>If you want to produce a vector of outputs to be assigned to a matrix, you need to return one variable and concatenate both of the values of <code>exp(0)</code> and <code>exp(1)</code> to the output. As such:</p> <pre><code>function x = foo() x = [exp(0) exp(1)]; end </code></pre> <p>You can then use your loop code accordingly.</p> <h1>2. Use temporary variables in your loop</h1> <p>You can leave <code>foo</code> untouched, but you need to retrieve both of the output variables from <code>foo</code> first, then assign it to your matrix. As such:</p> <pre><code>N=5; Results = zeros(N,2); for i=1:N [x, y] = foo(); Results(i,:) = [x, y]; end </code></pre> <h1>3. Modify how you're writing to <code>Results</code> (à la David)</h1> <p>You can do away with the temporary variables by modifying how you are calling <code>foo</code>. You would have to index into <code>Results</code> yourself to access each value from the output of <code>foo</code> in your call. Therefore:</p> <pre><code>N=5; Results = zeros(N,2); for i=1:N [Results(i,1), Results(i,2)] = foo(); end </code></pre> <p>I don't like this method because it just looks messy, but this is one way if you don't want to use temporary variables.</p>