Piecewise constant surface in MATLAB
<p>I would like to produce a piecewise constant surface which is zero outside of some rectangle. More specifically, for t = (x,y) in R^2, I want</p> <pre><code>f(t) = 1 when 5&lt;y&lt;10 and 0&lt;x&lt;1; -1 when 0&lt;y&lt;5 and 0&lt;x&lt;1; 1 when -5&lt;y&lt;0 and 0&lt;x&lt;1; 0 elsewhere </code></pre> <p>But, the surface I get doesn't look like what I want. I'm somewhat of a Matlab novice, so I suspect the problem is in the logical operators. My code is:</p> <pre><code>x = -2:.01:2; y = -15:15 [X,Y] = meshgrid(x,y); %Make domain for i = 1:numel(X) %Piecewise function for j = 1:numel(Y) if Y(j) &gt;= 0 &amp;&amp; Y(j)&lt;= 5 &amp;&amp; X(i)&gt;=0 &amp;&amp; X(i)&lt;=1 h2(i,j)= -1; elseif Y(j)&gt;5 &amp;&amp; Y(j) &lt;= 10 &amp;&amp;X(i)&gt;=0 &amp;&amp;X(i)&lt;=1 h2(i,j) = 1; elseif Y(j)&lt;0 &amp;&amp; Y(j)&gt;=-5 &amp;&amp;X(i)&gt;=0 &amp;&amp;X(i)&lt;=1 h2(i,j) = 1; elseif X(i) &lt;0 || X(i)&gt;1 || Y(j)&lt;-5 || Y(j)&gt;10 h2(i,j) = 0; end end end %Normalize C = trapz(abs(h2)); c = trapz(C); h2 = c^(-1)*h2; </code></pre> <p>Thank you for your help and please let me know if you'd like me to specify more clearly what function I want. </p>
<p>You can just use logical indexing:</p> <pre><code>x = -2:.01:2; y = -15:15; [X,Y] = meshgrid(x,y); %// Make domain h2=zeros(size(X)); h2(5&lt;Y &amp; Y&lt;10 &amp; 0&lt;X &amp; X&lt;1)=1; h2(0&lt;Y &amp; Y&lt;5 &amp; 0&lt;X &amp; X&lt;1)=-1; h2(-5&lt;Y &amp; Y&lt;0 &amp; 0&lt;X &amp; X&lt;1)=1; </code></pre> <p>This statement: <code>5&lt;Y &amp; Y&lt;10 &amp; 0&lt;X &amp; X&lt;1</code> returns a matrix of 1's and 0's where a 1 means that all 4 inequalities are satisfied, and a 0 means at least one is not. Where that matrix has a one, <code>h2</code> will be modified to the value you want.</p>
<p>You can very easily achieve what you want vectorized using a combination of logical operators. Avoid using <code>for</code> loops for something like this. Define your <code>meshgrid</code> like you did before, but allocate a matrix of zeroes, then only set the values within the <code>meshgrid</code> that satisfy the requirements you want to be the output values of <code>f(t)</code>. In other words, do this:</p> <pre><code>%// Your code x = -2:0.1:2; y = -15:15; [X,Y] = meshgrid(x,y); %Make domain %// New code Z = zeros(size(X)); Z(Y &gt; 5 &amp; Y &lt; 10 &amp; X &gt; 0 &amp; X &lt; 1) = 1; Z(Y &gt; 0 &amp; Y &lt; 5 &amp; X &gt; 0 &amp; X &lt; 1) = -1; Z(Y &gt; -5 &amp; Y &lt; 0 &amp; X &gt; 0 &amp; X &lt; 1) = 1; mesh(X,Y,Z); view(-60,20); %// Adjust for better angle </code></pre> <p>The above code allocates a matrix of zeroes, then starts to go through each part of your piecewise definition and searches for those <code>x</code> and <code>y</code> values that satisfy the particular range of interest. It then sets the output of <code>Z</code> to be whatever the output of <code>f(t)</code> is given those constraints. Take note that the otherwise condition is already handled by setting the whole matrix to be zero first. I then use <a href="http://www.mathworks.com/help/matlab/ref/mesh.html" rel="nofollow noreferrer"><code>mesh</code></a> to visualize the surface, then adjust the azimuthal and elevation angle of the plot for a better view. Specifically, I set these to -60 degrees and 20 degrees respectively. Also take note that I decreased the resolution of the <code>x</code> values to have a step size of 0.1 instead of 0.01 for a lesser amount of granularity. This is solely so that you can see the <code>mesh</code> better.</p> <p>This is the graph I get:</p> <p><img src="https://i.stack.imgur.com/xz3lT.png" alt="enter image description here"></p>