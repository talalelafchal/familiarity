Use of excel solver function in matlab for multiple optimization
<p>I have multiple sets of <code>x</code> and <code>y</code>. One of them is as follows:</p> <pre><code>x = [ 1.4 15.15 49.395 98.8 151.475 184.41 230.51 259.2 ] y = [ 12.15 21.2125 25.15125 25.3 24.63125 28.8975 29.8725 35.2 ] </code></pre> <p>In addition to that, I have two parameters <code>k</code> and <code>n</code> which are related to <code>x</code> as follows</p> <pre><code>q = k.* x^-n </code></pre> <p>I have three functions:</p> <pre><code>e = q.*q - y.*y f = q-y g = (q-y)^1/2 </code></pre> <p>First I want to minimize function <code>e</code> related to <code>y</code> as follows:</p> <pre><code>e = q.*q - y.*y </code></pre> <p>Afterwards I want to simultaneously minimize function <code>f</code>, followed by <code>g</code>.</p>
<pre><code>@Nras I have modified the syntax and thanks for your help </code></pre> <p>%// Data x = [ 1.4 15.15 49.395 98.8 151.475 184.41 230.51 259.2 ]; y = [ 12.15 21.2125 25.15125 25.3 24.63125 28.8975 29.8725 35.2 ];</p> <p>%// create model function q with parameters p(1) = k and p(2) = n q = @(p, x) p(1)*x.^(-p(2));</p> <p>%// create the desired error-functions for minimization e = @(p) sum((y.^2 - q(p, x)).^2); %// minimization function f = @(p) sum(abs(y - q(p, x))); %// better sum over absolute values g = @(p) sum(sqrt(abs(q(p, x) - y))); %// better take square roots of absolute values h = @(p) sum((q(p, x) - y).^2); %// default minimizaton function</p> <pre><code>p0 = [1, 0.5]; % an initial guess A = []; b=[]; Aeq = []; beq=[]; lb = [-inf,0]; ub = [inf,1]; nonlcon= [] options = optimset('Display','iter','Algorithm','active-set'); options.MaxFunEvals = 100000; options.MaxIter = 100000 [p_fit_e, r_e] = fmincon(e,p0,A,b,Aeq,beq,lb,ub,nonlcon,options) % Optimize [p_fit_f, r_f] = fmincon(f, p0,A,b,Aeq,beq,lb,ub,nonlcon,options) % Optimize [p_fit_g, r_g] = fmincon(g, p0,A,b,Aeq,beq,lb,ub,nonlcon,options) % Optimize [p_fit_h, r_h] = fmincon(h,p0,A,b,Aeq,beq,lb,ub,nonlcon,options)% Optimize [minVal minInd] = min(r_e) [minVal minInd] = min(r_f) [minVal minInd] = min(r_g) [minVal minInd] = min(r_h) e1 = p_fit_e(1)*x.^(-p_fit_e(2)); f1 = p_fit_f(1)*x.^(-p_fit_f(2)); g1 = p_fit_g(1)*x.^(-p_fit_g(2)); h1 = p_fit_h(1)*x.^(-p_fit_h(2)); figure(1) plot(x,e1) hold on plot(x,y) figure(2) plot(x,f1) hold on plot(x,y) figure(3) plot(x,g1) hold on plot(x,y) figure(4) plot(x,h1) hold on plot(x,y) </code></pre>
<p>There are several flaws in your code.</p> <ol> <li>your "functions" are not functions, but vectors. --> function handle</li> <li>your minimization "function" f makes no sense, as positive and negative errors can cancel each other out --> absolute values</li> <li>your minimization "function" g can produce imaginary numbers, as q-y can get negative --> absolute values</li> </ol> <p>Here comes some code, which techically does, what you want. Also i added the function <code>h</code>, which minimizes the sum of squared errors, which is the default minimization function</p> <pre><code>%// Data x = [ 1.4 15.15 49.395 98.8 151.475 184.41 230.51 259.2 ]; y = [ 12.15 21.2125 25.15125 25.3 24.63125 28.8975 29.8725 35.2 ]; %// create model function q with parameters p(1) = k and p(2) = n q = @(p, x) p(1)*x.^(-p(2)); %// create the desired error-functions for minimization e = @(p) sum((y.^2 - q(p, x)).^2); %// minimization function f = @(p) sum(abs(y - q(p, x))); %// better sum over absolute values g = @(p) sum(sqrt(abs(q(p, x) - y))); %// better take square roots of absolute values h = @(p) sum((q(p, x) - y).^2); %// default minimizaton function p0 = [1, -0.5]; % an initial guess [p_fit_e, r_e] = fminsearch(e, p0) % Optimize [p_fit_f, r_f] = fminsearch(f, p0) % Optimize [p_fit_g, r_g] = fminsearch(g, p0) % Optimize [p_fit_h, r_h] = fminsearch(h, p0) % Optimize %// visualization figure plot(x,y,'ko') hold on X = linspace(min(x), max(x), 100); plot(X, q(p_fit_e, X), 'r-') plot(X, q(p_fit_f, X), 'g-') plot(X, q(p_fit_g, X), 'b-') plot(X, q(p_fit_h, X), 'k-') </code></pre> <p>The optimization for you error-function <code>e</code> seems to fail. Please note that for the default case of function <code>h</code> you can also use <code>nlinfit</code> like so:</p> <pre><code>p_fit_h_nlinfit = nlinfit(x, y, q, p0); </code></pre> <p>which in this case produces the same result:</p> <pre><code>p_fit_h_nlinfit = 12.3018 -0.1675 p_fit_h = 12.3018 -0.1675 </code></pre>