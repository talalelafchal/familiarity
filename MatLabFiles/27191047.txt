Calculating the Local Ternary Pattern of an image?
<p>I am calculating the Local Ternary Pattern of an image. My code is given below. Am I going in the right direction or not?</p> <pre><code>function [ I3 ] = LTP(I2) m=size(I2,1); n=size(I2,2); for i=2:m-1 for j=2:n-1 J0=I2(i,j); I3(i-1,j-1)=I2(i-1,j-1)&gt;J0; end end </code></pre> <p><code>I2</code> is the image LTP is applied to.</p>
<p>This isn't quite correct. Here's an example of LTP given a 3 x 3 image patch and a threshold <code>t</code>:</p> <p><img src="http://www.hindawi.com/journals/tswj/2014/373254.fig.004.jpg" alt=""></p> <p>The range that you assign a pixel in a window to 0 is when the threshold is between <code>c - t</code> and <code>c + t</code>, where <code>c</code> is the centre intensity of the pixel. Therefore, because the intensity is 34 in the centre of this window, the range is between <code>[29,39]</code>. Any values that are beyond <code>39</code> get assigned 1 and any values that are below <code>29</code> get assigned -1. Once you determine the ternary codes, you split up the codes into upper and lower patterns. Basically, any values that get assigned a -1 get assigned 0 for upper patterns and any values that get assigned a -1 get assigned 1 for lower patterns. Also, for the lower pattern, any values that are 1 from the original window get mapped to 0. The final pattern is reading the bit pattern starting from the east location with respect to the centre (row 2, column 3), then going around counter-clockwise. Therefore, you should probably modify your function so that you're outputting both <strong>lower</strong> patterns and <strong>upper</strong> patterns in your image.</p> <p>Let's write the corrected version of your code. Bear in mind that I will not give an optimized version. Let's get a basic algorithm working, and it'll be up to you on how you want to optimize this. As such, change your code to something like this, bearing in mind all of the stuff I talked about above. BTW, your function is not defined properly. You can't use spaces to define your function, as well as your variables. It will interpret each word in between spaces as variables or functions, and that's not what you want. Assuming your neighbourhood size is 3 x 3 and your image is grayscale, try something like this:</p> <pre><code>function [ ltp_upper, ltp_lower ] = LTP(im, t) %// Get the dimensions rows=size(im,1); cols=size(im,2); %// Reordering vector - Essentially for getting binary strings reorder_vector = [8 7 4 1 2 3 6 9]; %// For the upper and lower LTP patterns ltp_upper = zeros(size(im)); ltp_lower = zeros(size(im)); %// For each pixel in our image, ignoring the borders... for row = 2 : rows - 1 for col = 2 : cols - 1 cen = im(row,col); %// Get centre %// Get neighbourhood - cast to double for better precision pixels = double(im(row-1:row+1,col-1:col+1)); %// Get ranges and determine LTP out_LTP = zeros(3, 3); low = cen - t; high = cen + t; out_LTP(pixels &lt; low) = -1; out_LTP(pixels &gt; high) = 1; out_LTP(pixels &gt;= low &amp; pixels &lt;= high) = 0; %// Get upper and lower patterns upper = out_LTP; upper(upper == -1) = 0; upper = upper(reorder_vector); lower = out_LTP; lower(lower == 1) = 0; lower(lower == -1) = 1; lower = lower(reorder_vector); %// Convert to a binary character string, then use bin2dec %// to get the decimal representation upper_bitstring = char(48 + upper); ltp_upper(row,col) = bin2dec(upper_bitstring); lower_bitstring = char(48 + lower); ltp_lower(row,col) = bin2dec(lower_bitstring); end end </code></pre> <p>Let's go through this code slowly. First, I get the dimensions of the image so I can iterate over each pixel. Also, bear in mind that I'm assuming that the image is <strong>grayscale</strong>. Once I do this, I allocate space to store the upper and lower LTP patterns per pixel in our image as we will need to output this to the user. I have decided to ignore the border pixels where when we consider a pixel neighbourhood, if the window goes out of bounds, we ignore these locations.</p> <p>Now, for each valid pixel that is within the valid borders of the image, we extract our pixel neighbourhood. I convert these to double precision to allow for negative differences, as well as for better precision. I then calculate the low and high ranges, then create a LTP pattern following the guidelines we talked about above.</p> <p>Once I calculate the LTP pattern, I create two versions of the LTP pattern, <code>upper</code> and <code>lower</code> where any values of -1 for the upper pattern get mapped to 0 and 1 for the lower pattern. Also, for the lower pattern, any values that were 1 from the original window get mapped to 0. After, this, I extract out the bits in the order that I laid out - starting from the east, go counter-clockwise. That's the purpose of the <code>reorder_vector</code> as this will allow us to extract those exact locations. These locations will now become a 1D vector.</p> <p>This 1D vector is important, as we now need to convert this vector into character string so that we can use <a href="http://www.mathworks.com/help/matlab/ref/bin2dec.html" rel="nofollow"><code>bin2dec</code></a> to convert the value into a decimal number. These numbers for the upper and lower LTPs are what are finally used for the output, and we place those in the corresponding positions of both output variables.</p> <hr> <p>This code is untested, so it'll be up to you to debug this if it doesn't work to your specifications.</p> <p>Good luck!</p>