How can I (efficiently) compute a moving average of a vector?
<p>I've got a vector and I want to calculate the moving average of it (using a window of width 5).</p> <p>For instance, if the vector in question is <code>[1,2,3,4,5,6,7,8]</code>, then</p> <ul> <li>the first entry of the resulting vector should be the sum of all entries in <code>[1,2,3,4,5]</code> (i.e. <code>15</code>);</li> <li>the second entry of the resulting vector should be the sum of all entries in <code>[2,3,4,5,6]</code> (i.e. <code>20</code>);</li> <li>etc.</li> </ul> <p>In the end, the resulting vector should be <code>[15,20,25,30]</code>. How can I do that?</p>
<p>The <a href="http://uk.mathworks.com/help/matlab/ref/conv.html" rel="nofollow noreferrer"><code>conv</code></a> function is right up your alley:</p> <pre><code>&gt;&gt; x = 1:8; &gt;&gt; y = conv(x, ones(1,5), 'valid') y = 15 20 25 30 </code></pre> <h1>Benchmark</h1> <p>Three answers, three different methods... Here is a quick benchmark (different input sizes, fixed window width of 5) using <a href="http://uk.mathworks.com/help/matlab/ref/timeit.html" rel="nofollow noreferrer"><code>timeit</code></a>; feel free to poke holes in it (in the comments) if you think it needs to be refined.</p> <p><code>conv</code> emerges as the fastest approach; it's about twice as fast as <a href="http://stackoverflow.com/a/26982654/2541573">coin's approach (using <code>filter</code>)</a>, and about four times as fast as <a href="http://stackoverflow.com/a/26984386/2541573">Luis Mendo's approach (using <code>cumsum</code>)</a>.</p> <p><img src="https://i.stack.imgur.com/fQNUH.png" alt="enter image description here"></p> <p>Here is another benchmark (fixed input size of <code>1e4</code>, different window widths). Here, <a href="http://stackoverflow.com/a/26984386/2541573">Luis Mendo's <code>cumsum</code> approach</a> emerges as the clear winner, because its complexity is primarily governed by the length of the input and is insensitive to the width of the window.</p> <p><img src="https://i.stack.imgur.com/61zbb.png" alt="enter image description here"></p> <h1>Conclusion</h1> <p>To summarize, you should</p> <ul> <li>use the <code>conv</code> approach if your window is relatively small,</li> <li>use the <code>cumsum</code> approach if your window is relatively large.</li> </ul> <h1>Code (for benchmarks)</h1> <pre class="lang-matlab prettyprint-override"><code>function benchmark clear all w = 5; % moving average window width u = ones(1, w); n = logspace(2,6,60); % vector of input sizes for benchmark t1 = zeros(size(n)); % preallocation of time vectors before the loop t2 = t1; th = t1; for k = 1 : numel(n) x = rand(1, round(n(k))); % generate random row vector % Luis Mendo's approach (cumsum) f = @() luisMendo(w, x); tf(k) = timeit(f); % coin's approach (filter) g = @() coin(w, u, x); tg(k) = timeit(g); % Jubobs's approach (conv) h = @() jubobs(u, x); th(k) = timeit(h); end figure hold on plot(n, tf, 'bo') plot(n, tg, 'ro') plot(n, th, 'mo') hold off xlabel('input size') ylabel('time (s)') legend('cumsum', 'filter', 'conv') end function y = luisMendo(w,x) cs = cumsum(x); y(1,numel(x)-w+1) = 0; %// hackish way to preallocate result y(1) = cs(w); y(2:end) = cs(w+1:end) - cs(1:end-w); end function y = coin(w,u,x) y = filter(u, 1, x); y = y(w:end); end function jubobs(u,x) y = conv(x, u, 'valid'); end </code></pre> <hr> <pre><code>function benchmark2 clear all w = round(logspace(1,3,31)); % moving average window width n = 1e4; % vector of input sizes for benchmark t1 = zeros(size(n)); % preallocation of time vectors before the loop t2 = t1; th = t1; for k = 1 : numel(w) u = ones(1, w(k)); x = rand(1, n); % generate random row vector % Luis Mendo's approach (cumsum) f = @() luisMendo(w(k), x); tf(k) = timeit(f); % coin's approach (filter) g = @() coin(w(k), u, x); tg(k) = timeit(g); % Jubobs's approach (conv) h = @() jubobs(u, x); th(k) = timeit(h); end figure hold on plot(w, tf, 'bo') plot(w, tg, 'ro') plot(w, th, 'mo') hold off xlabel('window size') ylabel('time (s)') legend('cumsum', 'filter', 'conv') end function y = luisMendo(w,x) cs = cumsum(x); y(1,numel(x)-w+1) = 0; %// hackish way to preallocate result y(1) = cs(w); y(2:end) = cs(w+1:end) - cs(1:end-w); end function y = coin(w,u,x) y = filter(u, 1, x); y = y(w:end); end function jubobs(u,x) y = conv(x, u, 'valid'); end </code></pre>
<p>If you want to preserve the size of your input vector, I suggest using <code>filter</code></p> <pre><code>&gt;&gt; x = 1:8; &gt;&gt; y = filter(ones(1,5), 1, x) y = 1 3 6 10 15 20 25 30 &gt;&gt; y = (5:end) y = 15 20 25 30 </code></pre>
<p>Another possibility is to use <a href="http://es.mathworks.com/help/matlab/ref/cumsum.html" rel="nofollow"><code>cumsum</code></a>. This approach probably requires fewer operations than <code>conv</code> does:</p> <pre><code>x = 1:8 n = 5; cs = cumsum(x); result = cs(n:end) - [0 cs(1:end-n)]; </code></pre> <p>To save a little time, you can replace the last line by</p> <pre><code>%// clear result result(1,numel(x)-n+1) = 0; %// hackish way to preallocate result result(1) = cs(n); result(2:end) = cs(n+1:end) - cs(1:end-n); </code></pre>