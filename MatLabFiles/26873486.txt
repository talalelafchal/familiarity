matlab aggregate bounding box area in an image
<p>I have an image I, and a set of bounding box positions in a matrix A, A=[x10 y10 x11 y11; x20 y20 x21 y21...xn0 yn0 xn1 yn1]. Those boxes can be visualized on the image like below. </p> <pre><code> imshow(I); numparts = floor(size(A, 2)/4); for i = 1:numparts x1 = A(1,1+(i-1)*4); y1 = A(1,2+(i-1)*4); x2 = A(1,3+(i-1)*4); y2 = A(1,4+(i-1)*4); line([x1 x1 x2 x2 x1]',[y1 y2 y2 y1 y1]','color',colorset{i},'linewidth',2); end </code></pre> <p>How can I aggregate those bounding box areas, so that pixels in the those boxes are labeled as 1, otherwise labeled as 0? I don't want an all-inclusive bounding box which includes all bounding boxes in A. I need a more precise area map which aggregates bounding boxes in A.<img src="https://i.stack.imgur.com/OHUcA.jpg" alt="enter image description here"></p>
<p>If I understand you correctly, you want to find the outer perimeter of all of the bounding boxes placed together, then set the entire interior of the shape to be all 1. I'm also going to assume that your array is structured such that for each row, the first two co-ordinates are the top left corner while the next two co-ordinates are the bottom right corner of a particular bounding box.</p> <p>What you can do is create a binary image and draw each <strong>filled</strong> bounding box into this binary image. You would then obtain a shape that contains all of the bounding boxes together with the entire interior set to 1. As such, do something like:</p> <pre><code>%// Declare mask mask = false(size(I,1), size(I,2)); %// Go through each bounding box pair of co-ordinates and draw a bounding box %// inside the mask %// Directly using your code... though you can do this more efficiently numparts = floor(size(A, 2)/4); for i = 1:numparts x1 = floor(A(1,1+(i-1)*4)); y1 = floor(A(1,2+(i-1)*4)); x2 = floor(A(1,3+(i-1)*4)); y2 = floor(A(1,4+(i-1)*4)); %// Draw bounding box here mask(y1:y2,x1:x2) = true; end %// Show the original image as well as the mask beside it figure; subplot(1,2,1); imshow(I); subplot(1,2,2); imshow(final_mask); </code></pre> <hr> <p><code>final_mask</code> should now contain what you are seeking. The assumption I'm taking here is that <code>x</code> is horizontal while <code>y</code> is vertical. If this is not the case, then simply swap the first and second dimension indexing in the final statement of the <code>for</code> loop to suit your purposes.</p> <p>Take special note that I took the <code>floor</code> of each <code>(x,y)</code> co-ordinate because I'm not sure whether or not you have these locations as floating point or integer. To be able to use what I did, you must make sure that the co-ordinates are integer to be able to index into the mask I'm trying to make.</p> <p>Also, this code does not provide any error checking. If any of your bounding boxes go outside of the image boundaries, MATLAB will generate an error informing you of this fact. I'll leave it to you to do additional error checking on drawing a bounding box in the mask that is outside of the image boundaries. If you're not worried about this, then you don't have to code this step.</p> <p>I've also written code to display the original image as well as the aggregation mask beside it in one window.</p> <p>Good luck!</p>