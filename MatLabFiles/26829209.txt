Create faster Fibonacci function for n &gt; 100 in MATLAB / octave
<p>I have a function that tells me the nth number in a Fibonacci sequence. The problem is it becomes very slow when trying to find larger numbers in the Fibonacci sequence does anyone know how I can fix this?</p> <pre><code>function f = rtfib(n) if (n==1) f= 1; elseif (n == 2) f = 2; else f =rtfib(n-1) + rtfib(n-2); end </code></pre> <p>The Results,</p> <pre><code>tic; rtfib(20), toc ans = 10946 Elapsed time is 0.134947 seconds. tic; rtfib(30), toc ans = 1346269 Elapsed time is 16.6724 seconds. </code></pre> <p>I can't even get a value after 5 mins doing <code>rtfib(100)</code></p> <p>PS: I'm using octave 3.8.1</p>
<p>To reach large numbers you can use symbolic computation. The following works in Matlab R2010b.</p> <pre><code>syms x y %// declare variables z = x + y; %// define formula xval = '0'; %// initiallize x, y values yval = '1'; for n = 2:300 zval = subs(z, [x y], {xval yval}); %// update z value disp(['Iteration ' num2str(n) ':']) disp(zval) xval = yval; %// shift values yval = zval; end </code></pre>
<p>If you have access to the Symbolic Math Toolbox in MATLAB, you could always <a href="http://www.mathworks.com/help/symbolic/evalin.html" rel="nofollow">just</a> <a href="http://www.mathworks.com/help/symbolic/call-built-in-mupad-functions-from-the-matlab-command-window.html" rel="nofollow">call</a> the Fibonacci function from <a href="http://www.mathworks.com/help/symbolic/mupad_ref/numlib-fibonacci.html" rel="nofollow">MuPAD</a>:</p> <pre><code>&gt;&gt; fib = @(n) evalin(symengine, ['numlib::fibonacci(' num2str(n) ')']) &gt;&gt; fib(274) ans = 818706854228831001753880637535093596811413714795418360007 </code></pre> <p>It is pretty fast:</p> <pre><code>&gt;&gt; timeit(@() fib(274)) ans = 0.0011 </code></pre> <hr> <p>Plus you can you go for as large numbers as you want (limited only by how much RAM you have!), it is still blazing fast:</p> <pre><code>% see if you can beat that! &gt;&gt; tic &gt;&gt; x = fib(100000); &gt;&gt; toc % Elapsed time is 0.004621 seconds. % result has more than 20 thousand digits! &gt;&gt; length(char(x)) % 20899 </code></pre> <p>Here is the full value of <code>fib(100000)</code>: <a href="http://pastebin.com/f6KPGKBg" rel="nofollow">http://pastebin.com/f6KPGKBg</a></p>
<p>You can do it in O(log n) time with matrix exponentiation:</p> <pre><code>X = [0 1 1 1] </code></pre> <p>X^n will give you the nth fibonacci number in the lower right-hand corner; X^n can be represented as the product of several matrices X^(2^i), so for example X^11 would be X^1 * X^2 * X^8, i &lt;= log_2(n). And X^8 = (X^4)^2, etc, so at most 2*log(n) matrix multiplications.</p>
<p>One performance issue is that you use a recursive solution. Going for an iterative method will spare you of the argument passing for each function call. As Olivier pointed out, it will reduce the complexity to linear.</p> <p>You can also look <strong><a href="http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/fibFormula.html#formula" rel="nofollow">here</a></strong>. Apparently there's a formula that computes the n'th member of the Fibonacci sequence. I tested it for up to 50'th element. <strong>For higher n values it's not very accurate.</strong></p>
<p>Seems like fibonaacci series follows the <strong><a href="http://en.wikipedia.org/wiki/Golden_ratio" rel="nofollow"><code>golden ratio</code></a></strong>, as talked about in some detail <a href="http://www.mathsisfun.com/numbers/fibonacci-sequence.html" rel="nofollow"><strong><code>here</code></strong></a>.</p> <p>This was used in <a href="http://www.mathworks.in/matlabcentral/fileexchange/29991-vectorized-fibonacci/content//fibonacci.m" rel="nofollow">this MATLAB File-exchange code</a> and I am writing here, just the esssence of it -</p> <pre><code>sqrt5 = sqrt(5); alpha = (1 + sqrt5)/2; %// alpha = 1.618... is the golden ratio fibs = round( alpha.^n ./ sqrt5 ) </code></pre> <p>You can feed an integer into <code>n</code> for the <code>nth</code> number in <code>Fibonacci Series</code> or feed an array <code>1:n</code> to have the whole series.</p> <p>Please note that this method holds good till <code>n = 69</code> only.</p>
<p>If <strong>time</strong> is important (not programming techniques):</p> <pre><code>function f = fib(n) if (n == 1) f = 1; elseif (n == 2) f = 2; else fOld = 2; fOlder = 1; for i = 3 : n f = fOld + fOlder; fOlder = fOld; fOld = f; end end end </code></pre> <p><code>tic;fib(40);toc; ans = 165580141; Elapsed time is 0.000086 seconds.</code></p> <p>You could even use <code>uint64</code>. <code>n = 92</code> is the most you can get from <code>uint64</code>:</p> <p><code>tic;fib(92);toc; ans = 12200160415121876738; Elapsed time is 0.001409 seconds.</code></p> <p>Because,</p> <p><code>fib(93) = 19740274219868223167 &gt; intmax('uint64') = 18446744073709551615</code></p> <h1>Edit</h1> <p>In order to get <code>fib(n)</code> up to <code>n = 183</code>, It is possible to <strong>use two uint64 as one number</strong>,</p> <p>with a special function for summation,</p> <pre><code>function [] = fib(n) fL = uint64(0); fH = uint64(0); MaxNum = uint64(1e19); if (n == 1) fL = 1; elseif (n == 2) fL = 2; else fOldH = uint64(0); fOlderH = uint64(0); fOldL = uint64(2); fOlderL = uint64(1); for i = 3 : n [fL q] = LongSum (fOldL , fOlderL , MaxNum); fH = fOldH + fOlderH + q; fOlderL = fOldL; fOlderH = fOldH; fOldL = fL; fOldH = fH; end end sprintf('%u',fH,fL) end </code></pre> <p><code>LongSum</code> is:</p> <pre><code>function [s q] = LongSum (a, b, MaxNum) if a + b &gt;= MaxNum q = 1; if a &gt;= MaxNum s = a - MaxNum; s = s + b; elseif b &gt;= MaxNum s = b - MaxNum; s = s + a; else s = MaxNum - a; s = b - s; end else q = 0; s = a + b; end </code></pre> <p><strong>Note</strong> some complications in <code>LongSum</code> might seem unnecessary, but they are not!</p> <p>(All the deal with inner <code>if</code> is that I wanted to avoid <code>s = a + b - MaxNum</code> in one command, because it might overflow and store an irrelevant number in <code>s</code>)</p> <p><em>Results</em></p> <p><code>tic;fib(159);toc; Elapsed time is 0.009631 seconds.</code></p> <p><code>ans = 1226132595394188293000174702095995</code></p> <p><code>tic;fib(183);toc;</code> <strong>Elapsed time is 0.009735 seconds.</strong></p> <p><strong>fib(183) = 127127879743834334146972278486287885163</strong></p> <p>However, you have to be careful about <code>sprintf</code>. </p> <p>I also did it with three uint64, and I could get up to,</p> <p><code>tic;fib(274);toc;</code> <strong>Elapsed time is 0.032249 seconds.</strong></p> <p><strong>ans = 1324695516964754142521850507284930515811378128425638237225</strong></p> <p>(It's pretty much the same code, but I could share it if you are interested).</p> <p><strong>Note</strong> that we have <code>fib(1) = 1 , fib(2) = 2</code>according to question, while it is more common with <code>fib(1) = 1 , fib(2) = 1</code>, first 300 fibs are listed <a href="http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/fibtable.html" rel="nofollow">here</a> (thanks to @Rick T). </p>