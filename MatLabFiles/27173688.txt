Using Gabor filter on an image
<p>I'm looking to write some code in opencv/matlab that'll apply the Gabor filter to images to spot interesting image regions. I've read quite a lot of literature and seen some of the previous matlab/opencv code, but I'd like to attempt it all myself to make sure I fully understand. </p> <p>I have the equation for the Gabor function and an image. I am unsure of the steps I should take in my algorithm. The general idea I got was to take the discrete Fourier transform of the image, multiply it (convolve?) it with the Gabor function then take the inverse Fourier transform for the result. Any pointers appreciated. Thanks!</p> <pre><code>#include &lt;opencv2/core/core.hpp&gt; #include &lt;opencv2/imgproc/imgproc.hpp&gt; #include &lt;opencv2/highgui/highgui.hpp&gt; #include &lt;math.h&gt; using namespace cv; int main(int argc, char** argv) { int ks = 47; int hks = (ks-1)/2; int kernel_size=21; double sig = 7; double th = 200; double ps = 90; double lm = 0.5+ps/100.0; double theta = th*CV_PI/180; double psi = ps*CV_PI/180; double del = 2.0/(ks-1); double sigma = sig/ks; double x_theta; double y_theta; Mat image = imread("C:\\users\\michael\\desktop\\tile1.tif",1), dest, src, src_f; if (image.empty()) { return -1; } imshow("Src", image); cvtColor(image, src, CV_BGR2GRAY); src.convertTo(src_f, CV_32F, 1.0/255, 0); if (!ks%2) { ks+=1; } Mat kernel(ks,ks, CV_32F); for (int y=-hks; y&lt;=hks; y++) { for (int x=-hks; x&lt;=hks; x++) { x_theta = x*del*cos(theta)+y*del*sin(theta); y_theta = -x*del*sin(theta)+y*del*cos(theta); kernel.at&lt;float&gt;(hks+y,hks+x) = (float)exp(-0.5*(pow(x_theta,2)+pow(y_theta,2))/pow(sigma,2))* cos(2*CV_PI*x_theta/lm + psi); } } filter2D(src_f, dest, CV_32F, kernel); imshow("Gabor", dest); Mat Lkernel(kernel_size*20, kernel_size*20, CV_32F); resize(kernel, Lkernel, Lkernel.size()); Lkernel /= 2.; Lkernel += 0.5; imshow("Kernel", Lkernel); Mat mag; pow(dest, 2.0, mag); imshow("Mag", mag); waitKey(0); return 0; } </code></pre>