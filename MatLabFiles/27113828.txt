Organizing and Searching for (dates , strings , countries) in matlab
<p>I just got done doing a project here on R and am now doing some work with matlab. </p> <p>I need to make 3 vectors :</p> <ol> <li>DOD </li> <li>Country </li> <li>Age </li> </ol> <p>Count and store a .txt list with 236 data points the data in the text file looks like this: </p> <pre><code>Unknown woman Cause of death: found dead, with eyes removed. Location of death: Jardim dos Ipês Itaquaquecetuba, São Paulo, Brazil Date of death: August 9th, 2014 Cris Cause of death: multiple gunshot wounds Location of death: Portal da Foz, Foz do Iguaçu, Brazil Date of death: September 13th, 2014 Betty Skinner (52 years old) Cause of death: blunt force trauma to the head Location of death: Cleveland, Ohio, USA Date of death: December 4th, 2013 Brittany Stergis (22 years old) Cause of death: gunshot wound to the head Location of death: Cleveland, Ohio, USA Date of death: December 5th, 2013 </code></pre> <p>I have no idea how to look for string and organize them but would appreciate any ideas how to get started. </p>
<p>You can use <code>textscan</code> to read the file into a cell array of strings, and then use <code>regexp</code> to parse the strings to get your desired fields.</p> <p>First, we read the text file into a cell array of strings:</p> <pre><code>fid = fopen('deaths.txt'); scanned_fields = textscan(fid, '%s', 'Delimiter','\n'); text_array = scanned_fields{1}; fclose(fid); </code></pre> <p>While <code>textscan</code> is capable of some rudimentary parsing, it's not sophisticated enough for what we're doing. So we're just using it to read each line as a single string: format <code>%s</code> means we are expecting a string, and setting <code>Delimiter</code> to <code>\n</code> means that the strings are separated by newline characters.</p> <p>Next, we can unleash the awesome power of regular expressions to parse your string of dead women:</p> <pre><code>format = { '(?&lt;name&gt;[ \w]*)' ' \(' '(?&lt;age&gt;[\d]*)' ' years old\) - Cause of death: ' '(?&lt;cause&gt;[ \w]*)' ' - Location of death: ' '(?&lt;city&gt;[ \w]*)' ', ' '(?&lt;province&gt;[ \w]*)' ', ' '(?&lt;country&gt;[ \w]*)' ' - Date of death: ' '(?&lt;date&gt;[ ,\w]*)' }; format = [format{:}]; </code></pre> <p>Here we're just defining a format string. I've broken it up like this to make it a little clearer what's going on. Let's go through it line-by-line:</p> <ul> <li><code>(?&lt;name&gt;[ \w]*)</code> The parentheses indicate that this is a chunk of text (a.k.a. a "token") that we wish to capture. The <code>?&lt;name&gt;</code> says that we will call this token "name". Finally, the <code>[ \w]*</code> specifies what kind of text to match. The stuff inside the square brackets specifies which characters to look for: spaces (<code></code>) and/or alphanumeric characters (<code>\w</code>). The <code>*</code> outside the square brackets indicates that we will accept any number of these characters.</li> <li><code>\(</code> Next we are looking for a space and an open parenthesis. The backslash in front of the parenthesis is to indicate that we are looking for a literal parenthesis, i.e. this parenthesis should not be interpreted as the start of another token to capture.</li> <li><code>(?&lt;age&gt;[\d]*)</code> Another token to capture. This one is called "age" and contains any number of <code>\d</code> (numeric characters).</li> <li><code>years old \) - Cause of death:</code> More text to look for. Again, we will be matching this text, but we will not capturing it (because it is not enclosed in parentheses).</li> <li><code>(?&lt;city&gt;[ \w]*)</code> Another token to capture. This one is called "city" and contains any number of spaces and/or alphanumeric characters.</li> <li><code>,</code> Comma, space</li> <li><code>(?&lt;province&gt;[ \w]*), (?&lt;country&gt;[ \w]*) - Date of death:</code> You get the idea</li> <li><code>(?&lt;date&gt;[ ,\w]*)</code> Our final token, called "date", which contains any number of spaces, commas, and/or alphanumeric characters.</li> </ul> <p>Then we parse the strings into a struct array:</p> <pre><code>parsed_fields = regexp(text_array, format, 'names'); parsed_fields = [parsed_fields{:}]' </code></pre> <p>This is what the output should look like:</p> <pre><code>&gt;&gt; parsed_fields(1) ans = name: 'Jacqueline Cowdrey' age: '50' cause: 'unknown' city: 'Worthing' province: 'West Sussex' country: 'United Kingdom' date: 'November 20th, 2013' </code></pre> <p>So you can get your vector of countries pretty straightforward-ly:</p> <pre><code>Country = {parsed_fields.country}'; </code></pre> <p>Age is a simple numeric conversion:</p> <pre><code>Age_str = {parsed_fields.age}; Age = cellfun(@str2double, Age_str)'; </code></pre> <p>Date as a string is pretty easy:</p> <pre><code>Date_str = {parsed_fields.date}'; </code></pre> <p>But it's nice to have it as a MATLAB "serial date number", which allows arithmetic computations and reformatting into different types of representation formats. Unfortunately, having the day as "20th" instead of "20" is incompatible with the conversion functions, so we'll need to first strip off the "st", "nd", "rd" from "1st", "2nd", "3rd", etc:</p> <pre><code>Date_str = regexprep(Date_str, '(?&lt;day&gt;[\d]+)(st|nd|rd|th)', '$&lt;day&gt;'); Date_num = datenum(Date_str, 'mmmm dd, yyyy'); </code></pre> <p>Some other notes:</p> <ul> <li><p>If the file is very large, you may wish to use <code>fgetl</code> to read it one line at a time (and then also parse it one line at a time) rather than reading the entire file into memory as we did above.</p></li> <li><p>In your example, it looks like the entries are separated by an extra newline. I'm not sure if that's case in your actual data or if that's just a stackoverflow thing, but if you need to remove these newlines you can do so with:</p> <pre><code>is_empty_line = cellfun(@isempty, text_array); text_array = text_array(~is_empty_line); </code></pre></li> <li><p>In your example, there were a lot of typos (an extra space here and there, sometimes the colons or dashes were other symbols). If these typos exist in your actual data, you will need to adjust the format specification to account for this. For example, instead of using <code>-</code> to match (space, dash, space), you can use <code>\s*\W\s*</code> to match (any number of whitespace characters, a single non-alphanumeric character, any number of whitespace characters).</p></li> <li><p>If syntax like <code>format = [format{:}];</code> or <code>Country = {parsed_fields.country}';</code> look strange to you, these are equivalent to:</p> <pre><code>format = [format{1} format{2} format{3} ... format{end}]; Country = cell(length(parsed_fields),1); for ii = 1:length(parsed_fields) Country{ii} = parsed_fields(ii).country; end </code></pre></li> <li><p>MATLAB R2014b added a new <code>datetime</code> class, so there may be a better way to deal with that nowadays.</p></li> </ul>
<p>Sorry about my previous answer; I had misunderstood how exactly the data is formatted.</p> <p>As before, let's first read the text file into a cell array of strings:</p> <pre><code>fid = fopen('deaths.txt'); scanned_fields = textscan(fid, '%s', 'Delimiter','\n'); text_array = scanned_fields{1}; fclose(fid); </code></pre> <p>While <code>textscan</code> is capable of some rudimentary parsing, it's not sophisticated enough for what we're doing. So we're just using it to read each line as a single string: format <code>%s</code> means we are expecting a string, and setting <code>Delimiter</code> to <code>\n</code> means that the strings are separated by newline characters.</p> <p>In the sample data you posted, each entry is 4 lines (name, cause, location, date) followed by an empty line. As long as we can rely on this formatting, this provides an easy way to split up the data (instead of the <code>regexp</code> parsing I proposed in my previous answer).</p> <pre><code>name_str_array = text_array(1:5:end); cause_str_array = text_array(2:5:end); loc_str_array = text_array(3:5:end); date_str_array = text_arary(4:5:end); </code></pre> <p>So for example, <code>name_strs</code> is going to be every 5th line, starting with line #1. Likewise, <code>cause_strs</code> is every 5th line, starting with line #2. Just be careful that there are not any extra or missing lines in the data.</p> <p>Next we will parse each of these to get the information that we want. In my previous answer, I proposed parsing all of the strings at once, but I think it would be easier to understand if we went through it one entry at a time. For example, let's consider the first entry.</p> <pre><code>name_str = name_str_array{1}; loc_str = loc_str_array{1}; date_str = date_str_array{1}; </code></pre> <hr> <p>Let's start with the easiest one: parsing the date.</p> <pre><code>date_format = 'Date of death:\s*(?&lt;date&gt;.*)'; parsed_fields = regexp(date_str, date_format, 'names'); DOD = parsed_fields.date; </code></pre> <p>The format we're looking for is the string <code>Date of death:</code>, followed by any number of whitespace characters (<code>\s*</code>), followed by the chunk of text (aka "token") that we wish to capture: <code>(?&lt;date&gt;.*)</code></p> <p>The parentheses indicate that this is a token we wish to capture, the <code>?&lt;date&gt;</code> indicates that we wish to call this token "date", and the <code>.*</code> specifies which characters to look for. The <code>.</code> is the universal wildcard, i.e. it matches all possible characters. The <code>*</code> indicates that we are interested in any number of repeats. So in essence, this <code>.*</code> means "match all remaining characters in the string".</p> <p>Calling <code>regexp</code> with the <code>names</code> option causes it to return a struct with the named tokens as its fields.</p> <hr> <p>Next, let's do the country. This one is a little trickier because there is a variable number of city/region specifiers. But the country will always be the last one, so that's the one we'll grab.</p> <pre><code>country_format = '(?&lt;country&gt;\w[ \w]*)$'; parsed_fields = regexp(loc_str, country_format, 'names'); Country = parsed_fields.country; </code></pre> <p>This format specification is the token <code>(?&lt;country&gt;\w[ \w]*)</code> followed by the end of the string (denoted by the special character <code>$</code>). In the token specification we are matching an alphanumeric character (<code>\w</code>) followed by any number of spaces and/or alphanumeric characters (<code>[ \w]*</code>). The reason for specifying this leading <code>\w</code> is so that we don't match the space between the previous comma and the start of the country name.</p> <hr> <p>Finally, let's do the age. This one is tricky because not every entry has an age. At least it's easy because the age (if it exists) is the only numeric data in the line. Hence:</p> <pre><code>age_format = '(?&lt;age&gt;[\d]+)'; parsed_fields = regexp(name_str, age_format, 'names'); if isempty(parsed_fields) Age = -1; else Age = str2double(parsed_fields.age); end </code></pre> <p>The format specification is simply the token <code>(?&lt;age&gt;[\d]+)</code>, which specifies that we are looking for numeric characters (<code>\d</code>), and we are looking for one or more of them (<code>+</code>).</p> <p>After parsing, we check whether or not there was a match. If not (<code>parsed_fields</code> is empty), then we assign <code>Age</code> a value of -1. Otherwise, we convert the parsed age field into a number.</p> <hr> <p>So putting it all together:</p> <pre><code>date_format = 'Date of death:\s*(?&lt;date&gt;.*)'; country_format = '(?&lt;country&gt;\w[ \w]*)[\W]?$'; age_format = '(?&lt;age&gt;[\d]+)'; nEntries = length(date_str_array); DOD = cell(nEntries, 1); Country = cell(nEntries, 1); Age = zeros(nEntries, 1); for ii = 1:nEntries name_str = name_str_array{ii}; loc_str = loc_str_array{ii}; date_str = date_str_array{ii}; parsed_fields = regexp(date_str, date_format, 'names'); assert(~isempty(parsed_fields), 'Could not parse date from:\n%s', date_str); DOD{ii} = parsed_fields.date; parsed_fields = regexp(loc_str, country_format, 'names'); assert(~isempty(parsed_fields), 'Could not parse country from:\n%s', loc_str); Country{ii} = parsed_fields.country; parsed_fields = regexp(name_str, age_format, 'names'); if isempty(parsed_fields) Age(ii) = -1; else Age(ii) = str2double(parsed_fields.age); end end </code></pre> <p>I added the <code>assert</code> statements to help debug what's going on if you encounter errors in parsing.</p> <p>For example, you may also notice that I added an <code>[\W]?</code> to the country format. This is because while running it on your example data, I encountered one country that contained a period at the end of the line (i.e. it ended with "Brazil." instead of just "Brazil"). So now we're looking to match a non-alphanumeric character (<code>\W</code>) repeated zero or 1 times (<code>?</code>), and it's outside of the parentheses so it is not being captured as part of the "country" token.</p>