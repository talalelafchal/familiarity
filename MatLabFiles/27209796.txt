Kmeans Clustering using kmeans on matlab
<p>I have this matrix: </p> <pre><code>x=[ 2+2*i 2-2*i -2+2*i -2-2*i]; </code></pre> <p>I want to simulate transmitting it and adding noise to it. I represented the components of the complex number as below:</p> <pre><code>A=randn(150,2)+2*ones(150,2); C=randn(150,2)-2*ones(150,2); </code></pre> <p>At the receiver, I received the below vector, where the components are ordered based on what I sent originally <em>i.e.</em> the components of x). </p> <pre><code>X = [A A A C C A C C]; </code></pre> <p>Now I want to apply the <code>kmeans(X)</code> to have 4 clusters, so <code>kmeans(X,4)</code>. I am experiencing the following problems: </p> <ol> <li>I am not sure if I can represent the complex numbers as shown in <code>X</code> above. </li> <li>I can't plot the result of the <code>kmeans</code> to show the clusters. </li> <li>I could not understand the clusters centroid results. </li> <li>How to find the best error rate, if this example was to represent a communication system and at the receiver, <code>k-means</code> clustering was used in order to decide what the transmitted signal was?</li> </ol>
<p>If you don't "understand" the cluster centroid results, then you don't understand how <code>k</code>-means works. I'll present a small summary here. </p> <p>How <em>k</em>-means works is that for some data that you have, you want to group them into <em>k</em> groups. You initially choose <em>k</em> random points in your data, and these will have labels from <code>1,2,...,k</code>. These are what we call the <strong>centroids</strong>. Then, you determine how close the rest of the data are to each of these points. You then group those points so that whichever points are closest to any of these <em>k</em> points, you assign those points to belong to that particular group (<code>1,2,...,k</code>). After, for all of the points for each group, you update the <strong>centroids</strong>, which actually is defined as the representative point for each group. For each group, you compute the average of all of the points in each of the <em>k</em> groups. These become the <strong>new</strong> centroids for the next iteration. In the next iteration, you determine how close each point in your data is to <strong>each of the centroids</strong>. You keep iterating and repeating this behaviour until the centroids don't move anymore, or they move very little. </p> <hr> <p>Now, let's answer your questions one-by-one.</p> <h1>1. Complex number representation</h1> <p><code>k</code>-means in MATLAB doesn't define how complex data is handled. A common way for people to deal with complex numbered data is to split up the real and imaginary parts into separate dimensions as you have done. This is a perfectly valid way to use <code>k</code>-means for complex valued data.</p> <p>See this post on the MathWorks MATLAB forum for more details: <a href="https://www.mathworks.com/matlabcentral/newsreader/view_thread/78306" rel="nofollow noreferrer">https://www.mathworks.com/matlabcentral/newsreader/view_thread/78306</a></p> <h1>2. Plot the results</h1> <p>You aren't constructing your matrix <code>X</code> properly. Note that <code>A</code> and <code>C</code> are both 150 x 2 matrices. You need to structure <code>X</code> such that each <strong>row</strong> is a point, and each column is a variable. Therefore, you need to concatenate your <code>A</code> and <code>C</code> <strong>row-wise</strong>. Therefore:</p> <pre><code>X = [A; A; A; C; C; A; C; C]; </code></pre> <p>Note that you have <strong>duplicate points</strong>. This is actually no different than doing <code>X = [A; C];</code> as far as <code>kmeans</code> is concerned. Perhaps you should generate <code>X</code>, then add the noise in rather than taking <code>A</code> and <code>C</code>, adding noise, then constructing your signal.</p> <p>Now, if you want to plot the results as well as the centroids, what you need to do is use the <strong>two output version</strong> of <code>kmeans</code> like so:</p> <pre><code>[idx, centroids] = kmeans(X, 4); </code></pre> <p><code>idx</code> will contain the cluster number that each point in <code>X</code> belongs to, and <code>centroids</code> will be a 4 x 2 matrix where each row tells you the mean of each cluster found in the data. If you want to plot the data, as well as the clusters, you simply need to do following. I'm going to loop over each cluster membership and plot the results on a figure. I'm also going to colour in where the mean of each cluster is located:</p> <pre><code>x = X(:,1); y = X(:,2); figure; hold on; colors = 'rgbk'; for num = 1 : 4 plot(x(idx == num), y(idx == num), [colors(num) '.']); end plot(centroids(:,1), centroids(:,2), 'c.', 'MarkerSize', 14); grid; </code></pre> <p>The above code goes through each cluster, plots them in a different colour, then plots the centroids in cyan with a slightly larger thickness so you can see what the graph looks like.</p> <p>This is what I get:</p> <p><img src="https://i.stack.imgur.com/VHezG.png" alt="enter image description here"></p> <h1>3. Understanding centroid results</h1> <p>This is probably because you didn't construct <code>X</code> properly. This is what I get for my centroids:</p> <pre><code>centroids = -1.9176 -2.0759 1.5980 2.8071 2.7486 1.6147 0.8202 0.8025 </code></pre> <p>This is pretty self-explanatory and I talked about how this is structured earlier.</p> <h1>4. Best representation of the signal</h1> <p>What you can do is repeat the clustering a number of times, then the algorithm will decide what the best clustering was out of these times. You would simply use the <code>Replicates</code> flag and denote how many times you want this run. Obviously, the more times you run this, the better your results may be. Therefore, do something like:</p> <pre><code>[idx, centroids] = kmeans(X, 4, 'Replicates', 5); </code></pre> <p>This will run <code>kmeans</code> 5 times and give you the best centroids of these 5 times.</p> <p>Now, if you want to determine what the best sequence that was transmitted, you'd have to split up your <code>X</code> into 150 rows each (as your random sequence was 150 elements), then run a separate <code>kmeans</code> on each subset. You can try to find the best representation of each part of the sequence by using the <code>Replicates</code> flag each time.... so you can do something like:</p> <pre><code>for num = 1 : 8 %// Look at 150 points at a time [idx, centroids] = kmeans(X((num-1)*150 + 1 : num*150, :), 4, 'Replicates', 5); %// Do your analysis %//... %//... end </code></pre> <p><code>idx</code> and <code>centroids</code> would be the results for each portion of your transmitted signal. You probably want to look at <code>centroids</code> at each iteration to determine what symbol was transmitted at a particular time.</p> <hr> <p>If you want to plot the decision regions, then you're probably looking for a <a href="http://en.wikipedia.org/wiki/Voronoi_diagram" rel="nofollow noreferrer">Voronoi diagram</a>. All you do is given a set of points that are defined within the domain of your problem, you just have to determine which cluster each point belongs to. Given that our data spans between <code>-5 &lt;= (x,y) &lt;= 5</code>, let's go through each point in the grid and determine which cluster each point belongs to. We'd then colour the appropriate point according to which cluster it belongs to.</p> <p>Something like:</p> <pre><code>colors = 'rgbk'; [X,Y] = meshgrid(-5:0.05:5, -5:0.05:5); X = X(:); Y = Y(:); figure; hold on; for idx = 1 : numel(X) [~,ind] = min(sum(bsxfun(@minus, [X(idx) Y(idx)], centroids).^2, 2)); plot(X(idx), Y(idx), [colors(ind), '.']); end plot(centroids(:,1), centroids(:,2), 'c.', 'MarkerSize', 14); </code></pre> <hr> <p>The above code will plot the decision regions / Voronoi diagram of the particular configuration, as well as where the cluster centres are located. Note that the code is rather unoptimized and it'll take a while for the graph to generate, but I wanted to write something quick to illustrate my point.</p> <p>Here's what the decision regions look like:</p> <p><img src="https://i.stack.imgur.com/79PUX.png" alt="enter image description here"></p> <hr> <p>Hope this helps! Good luck!</p>