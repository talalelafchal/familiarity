Convolution in Matlab hands on
<p>I got the matrix below:</p> <pre><code> 9 18 27 36 45 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 </code></pre> <p>and the kernel:</p> <p><code>-0.5+0.8662i 1 -0.5-0.8662i</code></p> <p>I'm trying to perform the convolution using valid mode:</p> <p><code>ans = conv2(matrix,kernel,'valid');</code></p> <p>The matlab returns:</p> <p><code>0.0000+15.5916i 0.0000+15.5916i 0.0000+15.5916i</code></p> <p>My question is how I can achieve the same results like matlab. I'm trying to do in the matlab in the first point, but the results is different.</p> <pre><code>a = matrix(1,1) * kernel(1); a = a + matrix(1,2) * kernel(2); a = a + matrix(1,3) * kernel(3); </code></pre> <p><code>Result: 0-15.5916i</code></p> <p>For some reason the sign of the imaginary is positive using convolution. Why ?</p>
<p>In the convolution process the kernel is <em>flipped</em>. So you have to flip it too in your check; that is, swap <code>kernel(1)</code> and <code>kernel(3)</code>, as follows:</p> <pre><code>&gt;&gt; a = matrix(1,1) * kernel(3); &gt;&gt; a = a + matrix(1,2) * kernel(2); &gt;&gt; a = a + matrix(1,3) * kernel(1) a = 27.0000 +15.5916i </code></pre> <p>This is in accordance with the result of the convolution:</p> <pre><code>&gt;&gt; A = conv2(matrix,kernel,'valid'); &gt;&gt; A(1,1) ans = 27.0000 +15.5916i </code></pre>
<p>I believe convolution is usually performed by "flipping" the kernel (left-right, up-down) and then sliding it across the matrix to perform a sum of multiplications.</p> <p>In other words, what matlab is actually computing is:</p> <pre><code>a = matrix(1,1) * kernel(3); a = a + matrix(1,2) * kernel(2); a = a + matrix(1,3) * kernel(1); </code></pre>