Updat geodesic distance matrix with additional vertices
<p>I have a geodesic ditance matrix computed for a partiuclar undirected graph and would like to update this matrix with some added vertices. Is there any way around to include the vertices without doing the whole computation for the every point?</p> <p>To be elaborate, I do estimate the adjancy weighted matrix for the added vertices and re-execute the shortest-path algorithm, e.g. Dijkstra's and Floyd-Warshall algorithms. Please correct me if there is something wrong or missing.</p> <p>Thanks for any clue and advice...</p>
<p>You don't have to compute <strong>all</strong> of the paths again, you can just update the distance matrix with the new vertex.</p> <p>Let <code>n</code> be the new vertex. First you need to compute the distances between each vertex <code>1..(n-1)</code> and <code>n</code> going through each intermediate vertex <code>k</code> (in matlab-ish pseudo-code):</p> <pre><code>//% distance matrix is initially equal to adjacency matrix distance(n,:) = adjacency(n,:); for kk = 1:n-1 for ii = 1:n-1 if (distance(ii,kk) + distance(kk,n)) &lt; distance(ii,n) distance(ii,n) = distance(ii,kk) + distance(kk,n); //% distance(n,ii) = distance(ii,kk) + distance(kk,n); //% ^^ the above for undirected graphs //% also update parent matrix, if used end end end </code></pre> <p>Now, use vertex <code>n</code> as a new <code>k</code> intermediate vertex to update all of the distances between each vertex <code>1..n-1</code> and every other vertex. The logic is the same with just an adjustment on which indices we use:</p> <pre><code>for ii = 1:n-2 for jj = 1:n-1 //% or ii+1:n-1 for undirected graphs if (distance(ii,n) + distance(n,jj)) &lt; distance(ii,jj) distance(ii,jj) = distance(ii,n) + distance(n,jj) //% same notes as above end end end </code></pre> <p>As you can see, we're removing one loop from the original Floyd-Warshall algorithm each time, so our time complexity is <code>O(|V^2|)</code> rather than <code>O(|V^3|)</code> for re-executing the whole algorithm.</p>
<p>Here is my code as @beaker noted.</p> <pre><code>//%% function to update geodesic distance matrix with new adjancy matrix function Dgwaug = updateGeoDis(W,Dgw) //% W: weighted adjancy matrix //% Dgw : current geodesics-distance matrix nmX = length(Dgw); //% number of vertices in the current graph nmXaug = length(W); //% number of vertices in the augmented graph nmXnew = nmXaug - nmX; //% number of new vertices to be included //% initialize the distance matrix for augmented graph Dgwaug = W; Dgwaug(1:nmX,1:nmX) = Dgw; //% compute the distances between each vertex 1..nmX and each added vertex 1..nXnew (j) going through each intermediate vertex (i) for j=1:nmXnew for i=1:nmX Dgwaug(1:nmX,nmX+j) = min(Dgwaug(1:nmX,nmX+j),Dgwaug(1:nmX,i) + repmat(Dgwaug(i,nmX+j),[nmX 1])); Dgwaug(nmX+j,:) = transpose(Dgwaug(:,nmX+j)); end end //% compute the distances between each vertex 1..nmX and each vertex 1..nmX going through the each intermediate added vertex k for k=1:nmXnew Dgwaug(1:nmX,1:nmX) = min(Dgwaug(1:nmX,1:nmX),repmat(Dgwaug(1:nmX,nmX+k),[1 nmX])+ repmat(Dgwaug(nmX+k,1:nmX),[nmX 1])); end </code></pre> <p>This my code for Floyd-Warshal using the whole data.</p> <pre><code>//%% function to update geodesic distance matrix with new adjancy matrix function Dgw = compGeoDis(W) //% W: weighted adjancy matrix nmX = length(W); //% number of vertices in the graph //% initialize the distance matrix for augmented graph Dgwaug = W; //% compute the distances between each vertex 1..nmX and each vertex 1..nmX going through the each intermediate vertex k for k=1:nmX Dgw = min(Dgw,repmat(Dgw(:,k),[1 nmX])+ repmat(Dgw(k,:),[nmX 1])); end </code></pre>