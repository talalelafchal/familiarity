Why is my FFT Function not working well
<p>i've made a function for FFT using AForge. It seems to work but when i'm checking with my supervisor he says the output is not correct. He is using the PWelch function from MatLab. We've already found out we were using different windows but changing them didn't make a significant difference. So again, the function does work but according to my supervisor the output is incorrect. Please Help! </p> <p>This is my Function, i hope anyone sees something that's wrong because i've been looking at it for allmost two weeks now. The DATA that goes into it is already made equidistant.</p> <pre><code>private void FastFoulierMethod() { int NFFT = 64; int N_OVERLAP = 32; int numberOfEpochs = samples.Count / NFFT; int numberOfSamplesToSelectFromFFT = NFFT-1; double[] dataaa = new double[samples.Count]; for (int i = 0; i &lt; samples.Count - 1; i++) { dataaa[i] = samples[i].GetValue();//lijst met doubles die we gebruiken } double[,] pFrame = new double[numberOfEpochs, numberOfSamplesToSelectFromFFT]; // The first epoch in the page starts at index 0 int beginIndexOfEpoch = 0; for (int i = 0; i &lt; numberOfEpochs; i++) { // This will get the current epoch by retrieving samples from the sample list // starting at 'beginIndex' with length 'NFFT'. This epoch will need to be detrended next. List&lt;double&gt; smapletemp = new List&lt;double&gt;(); for (int x = beginIndexOfEpoch; x &lt; beginIndexOfEpoch+NFFT; x++) { smapletemp.Add(dataaa[x]); } double[] epoch = smapletemp.ToArray(); if (epoch.Length == 0) { break; } // Create array of X-axis values 1,2,3,4 ... n // which will be used to perform linear regression. double[] xValues = new double[epoch.Length]; for (int j = 0; j &lt; xValues.Length; j++) { xValues[j] = j; } // Perform linear regression on the epoch. This will result in some data that is used later. Dictionary&lt;String, double&gt; linearRegressionData = math.performLinearRegression(xValues.ToList(), epoch.ToList()); // Detrend the epoch for (int j = 0; j &lt; epoch.Length; j++) { double intercept = linearRegressionData["Alpha"]; // Get the intercept from the data. double slope = linearRegressionData["Beta"]; // Get the slope from the data. //if (1 &gt;= math.StdDev(epoch)) //{ epoch[j] = epoch[j] - intercept - (slope * j); // Detrend the epoch by subtracting the intercept and the slope * j. //} } // Create Complex from the epoch for windowing and FFT processing. Complex[] cmplx = new Complex[epoch.Length]; for (int j = 0; j &lt; cmplx.Length; j++) { cmplx[j] = new Complex(epoch[j], 0); } // Perform Hann window function on the Complex. math.hann(cmplx); // Perform Fast Fourier Transform on the Complex. FourierTransform.FFT(cmplx, FourierTransform.Direction.Backward); // Create an array for all powers. double[] powers = new double[cmplx.Length]; for (int j = 0; j &lt; epoch.Length; j++) { powers[j] = cmplx[j].SquaredMagnitude; } // Add the powers to the power frame. for (int j = 0; j &lt; powers.Length-1; j++) { pFrame[i, j] = powers[j]; } // Shift index for the next epoch. beginIndexOfEpoch += NFFT - N_OVERLAP; if ( beginIndexOfEpoch + NFFT &gt; samples.Count) { break; } } // Create an array for the nan-mean values of all epochs. // Nan-mean calculates the mean of a set of doubles, ignoring NaN's. double[] nanMeanValues = new double[numberOfSamplesToSelectFromFFT]; List&lt;double[]&gt; Y = new List&lt;double[]&gt;(); for (int i = 0; i &lt; numberOfSamplesToSelectFromFFT; i++) { // The sum for calculating the mean. double sum = 0.0; // The number of elements (doubles) for calculating the mean. int count = 0; // For all epochs... for (int j = 0; j &lt; numberOfEpochs; j++) { // ...the mean for all doubles at index 'i' is calculated. double sample = pFrame[j, i]; if (!Double.IsNaN(sample)) { // Only take the double into account when it isn't a NaN. sum += sample; count++; } } // Actually calculate the mean and add it to the array. nanMeanValues[i] = sum / count; } // We now have the mean of all power arrays (or epochs). // Create an array with Root Mean Square values. double[] squareRootedNanMeans = new double[nanMeanValues.Length]; for (int i = 0; i &lt; squareRootedNanMeans.Length; i++) { squareRootedNanMeans[i] = Math.Sqrt(nanMeanValues[i]); } Y.Add(squareRootedNanMeans); </code></pre>
<p>It's been ages since I studied FFT's but, unless you academic assignment is to produce an fft function, I advise you to use some library. It is great to program your own stuff to learn, but if you need results, go for the sure thing.</p> <p>You can use Alglib {<a href="http://www.alglib.net/fasttransforms/fft.php" rel="nofollow">http://www.alglib.net/fasttransforms/fft.php</a>}, which has a free version.</p> <p>Hope this helps.</p>