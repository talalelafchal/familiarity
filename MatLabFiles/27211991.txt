mapping a curve equation to a staright line equation
<p>I dont know whether it is possible or not but i have a curve and i have found the equation of that curve now i want to map all the points on this curve to a straight line. How it can be done ?</p> <p>Curve Equation:</p> <pre><code>K3x^3 + k2x^2 + k1x + k0 = y </code></pre> <p>then what would be the corresponding equation of line which contains all the points which are in curve. And if i make a equation of line by using end points of the curve then how do i map or fit all the points on that curve to this line.</p> <p>for example I have attached an image, so can we make this curve to a straight line by using some kind of equation conversion. thanks<img src="https://i.stack.imgur.com/x65VY.png" alt="enter image description here"></p> <p>I need output to be transformed as following image. <img src="https://i.stack.imgur.com/1FVUk.png" alt="trasformed image "></p>
<p>So i did this by simply subtracting curve equation from line equation and then I got another equation(result of subtraction of equations) which i have used to map all the points of curve on to line. </p> <pre><code>void mapCurvePointsToLine(IplImage *img, double *coeff) { // algo: mapping equation = line equation - curve equation int i, y; double m; struct points p; p.x = malloc(sizeof(*p.x) * img-&gt;widthStep); p.y = malloc(sizeof(*p.y) * img-&gt;widthStep); p.np = img-&gt;widthStep; for( i = 0; i &lt; img-&gt;widthStep; i++) { y = round( (pow(i,3)*coeff[3]) + (pow(i,2)*coeff[2]) + (i*coeff[1]) + coeff[0]); p.x[i] = i; p.y[i] = y; img-&gt;imageData[(y*img-&gt;widthStep) + i] = 255u; } //calculate slope and interspect of line m = (p.y[(p.np - 1)] - p.y[0] ) / (p.x[(p.np - 1)] - p.x[0]); for( i = 0; i &lt; img-&gt;widthStep; i++) { y = p.y[i] + round( (pow(i,3)* (-1 * coeff[3]) ) + (pow(i,2)* ( -1 * coeff[2])) + (i* ( m - coeff[1]) ) ) ; //y = y + round( (pow(i,3)* (-1 * coeff[3]) ) + (pow(i,2)* ( -1 * coeff[2])) ) ; img-&gt;imageData[(y*img-&gt;widthStep) + i] = 255u; } } </code></pre> <p>I got the result with some distortion in line, may be because of rounding the calculated values in integer. See the output image i have attached.<img src="https://i.stack.imgur.com/NwLHH.png" alt="mapped image to line from a curve"></p>
<ol> <li><p>any 2D curve can be expressed like this:</p> <ul> <li><code>p(t)=p0+p1*t+p2*t*t+p3*t*t*t+...</code></li> <li>where <code>p,p0,p1,...</code> are vectors</li> <li><code>t</code> is parameter <code>&lt;0,1&gt;</code></li> <li>you already have this</li> <li><code>p.x(t)=x0+(x1-x0)*t+0*t*t+0*t*t*t;</code></li> <li><code>p.y(t)=k0+k1*t+k2*t*t+k3*t*t*t;</code></li> <li>which is the same ...</li> <li><code>x0,x1</code> are your <code>x</code> constraints</li> </ul></li> <li><p>you want q(p(t)) that lies on line <code>p(0)+(p(1)-p(0))*u;</code></p> <ul> <li>where <code>u</code> is parameter <code>&lt;0,1&gt;</code></li> <li>so if we assume that parameters <code>t,u</code> are proportional to curve distance from start</li> <li>then <code>u=curve_distance(p(t),p(0))/curve_distane(p(1),p(0));</code></li> <li>so write function <code>curve_distance</code> that integrates the path length at interval &lt;0,t></li> <li>and that is all you need</li> </ul></li> <li><p>curve_distance</p> <ul> <li>first you need to find the t parameter for each point</li> <li>one point is always the start point so t0=0</li> <li>the second you need to find from your parametric equations and input point coordinates</li> <li>then just write for cycle with small enough step summing the distance</li> <li>or solve it algebraically for used polynomial and compute directly in O(1)</li> </ul></li> </ol>