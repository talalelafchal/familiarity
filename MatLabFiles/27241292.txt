How do I group the pairs of pixels on MATLAB
<p>I have an image that was read in using the <code>imread</code> function. My goal is to collect pairs of pixels in an image in MATLAB. Specifically, I have read a paper, and I am trying to recreate the following scenario:</p> <blockquote> <p>First, the original image is grouped into pairs of pixel values. A pair consists of two neighboring pixel values or two with a small difference value. The pairing could be done horizontally by pairing the pixels on the same row and consecutive columns, or vertically, or by a key-based specific pattern. The pairing could be through all pixels of the image or just a portion of it.</p> </blockquote> <p>I am looking to recreate the horizontal pairing scenario. I'm not quite sure how I would do this in MATLAB.</p>
<p>Assuming your image is grayscale, we can easily generate a 2D grid of co-ordinates using <a href="http://www.mathworks.com/help/matlab/ref/ndgrid.html" rel="nofollow"><code>ndgrid</code></a>. We can use these to create one grid, then shift the horizontal co-ordinates to the right to make another grid and then use <a href="http://www.mathworks.com/help/matlab/ref/sub2ind.html" rel="nofollow"><code>sub2ind</code></a> to convert the 2D grid into linear indices. We can finally use these linear indices to create our pixel pairings that you have described in your comments (you should really add that to your post BTW). What's important is that you need to skip over every other column in a row to ensure unique pixel pairings.</p> <p>I'm also going to assume that your image is <strong>grayscale</strong>. If we go to colour, this will be slightly more complicated, and I'll leave that to you as a learning exercise. Therefore, assuming your image was read in through <code>imread</code> and is stored in <code>im</code>, do something like this:</p> <pre><code>[rows,cols] = size(im); [X,Y] = ndgrid(1:rows,1:2:cols); ind = sub2ind(size(im), X, Y); ind_shift = sub2ind(size(im), X, Y+1); pixels1 = im(ind); pixels2 = im(ind_shift); pixels = [pixels1(:) pixels2(:)]; </code></pre> <p><code>pixels</code> will be a 2D array, where each row gives you the pixel intensities of a particular pairing in the image. Bear in mind that I processed each row independently. As such, as soon as we are done with one row, we simply move on to the next row and continue the procedure. This also assumes that your image has an <strong>even</strong> number of columns. Should it not, you have a decision to make. You need to either pad the image with one column at the end, and this column can be anything you want, or you can remove this column from the image before processing. If you want to fill in this column, you can either make it all zeroes, or perhaps replicate the last column and place this beside the last column in the original image. Therefore, an appropriate pre-processing step may look something like this:</p> <pre><code>if mod(cols,2) ~= 0 im = im(:,1:end-1); end </code></pre> <p>The above code simply removes the last column in the image if the number of columns is odd. Once you run through this code, you can run the first bit of code that I had above.</p> <hr> <p>Good luck!</p>