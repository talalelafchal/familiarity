How to vectorize a piecewise periodic function in MATLAB?
<p>I've noticed that matlab builtin functions can handle either scalar or vector parameters. Example:</p> <pre><code>sin(pi/2) ans = 1 sin([0:pi/5:pi]) ans = 0 0.5878 0.9511 0.9511 0.5878 0.0000 </code></pre> <p>If I write my own function, for example, a piecewise periodic function:</p> <pre><code>function v = foo(t) t = mod( t, 2 ) ; if ( t &lt; 0.1 ) v = 0 ; elseif ( t &lt; 0.2 ) v = 10 * t - 1 ; else v = 1 ; end </code></pre> <p>I can call this on individual values:</p> <pre><code>[foo(0.1) foo(0.15) foo(0.2)] ans = 0 0.5000 1.0000 </code></pre> <p>however, if the input for the function is a vector, it is not auto-vectorized like the builtin function:</p> <pre><code>foo([0.1:0.05:0.2]) ans = 1 </code></pre> <p>Is there a syntax that can be used in the definition of the function that indicates that if a vector is provided, a vector should be produced? Or do builtin functions like sin, cos, ... check for the types of their input, and if the input is a vector produce the same result?</p>
<p>A simple approach that minimizes the number of operations is:</p> <pre><code>function v = foo(t) t = mod(t, 2); v = ones(size(t)) .* (t &gt; 0.1); v(t &lt; 0.2) = 10*t(t &lt; 0.2) - 1; end </code></pre> <p>If the vectors are large, it might be faster to do <code>ind = t &lt; 0.2</code>, and use that in the last line. That way you only search through the array once. Also, the multiplication might be substituted by an extra line with logical indices.</p>
<p>You need to change your syntax slightly to be able to handle data of any size. I typically use logical filters to vectorise if-statements, as you're trying to do:</p> <pre><code>function v = foo(t) v = zeros(size(t)); t = mod( t, 2 ) ; filt1 = t&lt;0.1; filt2 = ~filt1 &amp; t&lt;0.2; filt3 = ~filt1 &amp; ~filt2; v(filt1) = 0; v(filt2) = 10*t(filt2)-1; v(filt3) = 1; </code></pre> <p>In this code, we've got three logical filters. The first picks out all elements such that <code>t&lt;0.1</code>. The second picks out all of the elements such that <code>t&lt;0.2</code> that weren't in the first filter. The final filter gets everything else.</p> <p>We then use this to set the vector <code>v</code>. We set every element of <code>v</code> that matches the first filter to <code>0</code>. We set everything in <code>v</code> which matches the second filter to <code>10*t-1</code>. We set every element of <code>v</code> which matches the third filter to <code>1</code>.</p> <p>For a more comprehensive coverage of vectorisation, check the <a href="http://www.mathworks.com/help/matlab/matlab_prog/vectorization.html" rel="nofollow">MATLAB help page</a> on it.</p>
<p>I repeatedly hit the same problem, thus I was looking for a more generic solution and came up with this:</p> <pre><code>%your function definition c={@(t)(mod(t,2))&lt;0.1,0,... @(t)(mod(t,2))&lt;0.2,@(t)(10 * t - 1),... true,1}; %call pw which returns the function foo=pw(c{:}); %example evaluation foo([0.1:0.05:0.2]) </code></pre> <p>Now the code for pw</p> <pre><code>function f=pw(varargin) for ip=1:numel(varargin) switch class(varargin{ip}) case {'double','logical'} varargin{ip}=@(x)(repmat(varargin{ip},size(x))); case 'function_handle' %do nothing otherwise error('wrong input class') end end c=struct('cnd',varargin(1:2:end),'fcn',varargin(2:2:end)); f=@(x)pweval(x,c); end function y=pweval(x,p) todo=true(size(x)); y=x.*0; for segment=1:numel(p) mask=todo; mask(mask)=logical(p(segment).cnd(x(mask))); y(mask)=p(segment).fcn(x(mask)); todo(mask)=false; end assert(~any(todo)); end </code></pre>