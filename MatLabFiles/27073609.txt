Passing mxArray to mexCallMatlab fails
<p>I am writing a mex file in which <code>conv2</code> function is called. This <code>mex</code> file will get an image of size <code>(M, N)</code> and apply convolution several time using <code>conv2</code>.</p> <pre><code>#include "mex.h" void myconv( mxArray *Ain, mxArray *Kernel, mxArray *&amp;Aout ) { mxArray *rhs[3]; rhs[0] = mxCreateNumericMatrix( 0, 0, mxDOUBLE_CLASS, mxREAL ); rhs[1] = mxCreateNumericMatrix( 0, 0, mxDOUBLE_CLASS, mxREAL ); rhs[2] = mxCreateString ( "same" ); double *ainPtr = mxGetPr( Ain ); mxSetPr( rhs[0], ainPtr ); mxSetM ( rhs[0], mxGetM(Ain) ); mxSetN ( rhs[0], mxGetM(Ain) ); double *kernelPtr = mxGetPr( Kernel ); mxSetPr( rhs[1], kernelPtr ); mxSetM ( rhs[1], mxGetM(Kernel) ); mxSetN ( rhs[1], mxGetN(Kernel) ); mexCallMATLAB(1, &amp;Aout, 3, rhs, "conv2"); mxSetPr( rhs[0], NULL ); mxSetPr( rhs[1], NULL ); } void myconv_combine( mxArray *Ain, mxArray *&amp;Aout ) { mxArray *mask = mxCreateDoubleMatrix( 1, 5, mxREAL ); double *maskPtr = mxGetPr( mask ); maskPtr[0] = 0.05; maskPtr[1] = 0.25; maskPtr[2] = 0.4; maskPtr[3] = 0.25; maskPtr[4] = 0.05; mxArray *maskTranspose = mxCreateDoubleMatrix( 0, 0, mxREAL ); mxSetPr( maskTranspose, maskPtr ); mxSetM ( maskTranspose, mxGetN(mask) ); mxSetN ( maskTranspose, mxGetM(mask) ); mxArray *AinConvolved = mxCreateDoubleMatrix( (mwSize)mxGetM(Ain), (mwSize)mxGetN(Ain), mxREAL ); double *AinConvolvedPtr = mxGetPr( AinConvolved ); myconv( Ain, mask, AinConvolved ); // Some modifications. mxArray *Temp = mxCreateDoubleMatrix( (mwSize)mxGetM(Ain), (mwSize)mxGetN(Ain), mxREAL ); double *TempPtr = mxGetPr( Temp ); for( int i = 0; i &lt; (mwSize)mxGetM(Ain)*(mwSize)mxGetN(Ain); i++ ) TempPtr[ i ] = 2.0*AinConvolvedPtr[ i ]; // Some other convolution. mxArray *TempConvolved = mxCreateDoubleMatrix( (mwSize)mxGetM(Ain), (mwSize)mxGetN(Ain), mxREAL ); double *TempConvolvedPtr = mxGetPr( TempConvolved ); myconv( Temp, maskTranspose, TempConvolved ); // Some other modifications. double *AoutPtr = mxGetPr( Aout ); for( int i = 0; i &lt; (mwSize)mxGetM(Ain)*(mwSize)mxGetN(Ain); i++ ) AoutPtr[ i ] = 2.0*TempConvolvedPtr[ i ]; } void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[]) { mxArray *Ain = mxCreateDoubleMatrix( 100, 100, mxREAL ); mxArray *Aout = mxCreateDoubleMatrix( 100, 100, mxREAL ); myconv_combine( Ain, Aout ); } </code></pre> <p>In my actual code, when it reaches the line:</p> <pre><code>myconv( Temp, maskTranspose, TempConvolved ); </code></pre> <p>MATLAB crashes which I have no clue why this happens and unfortunately I could not duplicate the same error in the example code I provided above. In my actual code, the image is convolved successfully by line:</p> <pre><code>myconv( Ain, mask, AinConvolved ); </code></pre> <p>However, as soon as it wants to apply a second convolution:</p> <pre><code>myconv( Temp, maskTranspose, TempConvolved ); </code></pre> <p>It crashes and when I debug it, it occurs when <code>mexCallMATLAB</code> is called on <code>myconv</code> function. What can be the difference between <code>Temp</code>/<code>TempConvolved</code> and <code>Ain</code>/<code>AinConvolved</code> that makes the former crash at the time of <code>mexCallMATLAB</code>?</p> <p>Could someone kindly help me fix this issue?</p>
<p><strong>Reusing data buffers</strong></p> <p>Reusing the data pointer from <code>mxArray *mask</code> for <code>mxArray *maskTransposed</code> is asking for trouble, as MATLAB has rigorous mechanisms for reference counting as shared-data arrays are an important part of MATLAB's memory optimizations. Instead, duplicate the whole thing with <a href="http://www.mathworks.com/help/matlab/apiref/mxduplicatearray.html?refresh=true" rel="nofollow"><code>mxDuplicateArray</code></a>:</p> <pre><code>mxArray *maskTranspose = mxDuplicateArray(mask); </code></pre> <p>There is an undocumented <a href="http://stackoverflow.com/a/19850676/2778484"><code>mxCreateSharedDataCopy</code></a> that emulates MATLAB's lazy-copy mechanism, but that's really overkill for a 5-element array.</p> <p><strong>Superfluous-to-problematic <code>mxArray</code> initialization prior to <code>mexCallMATLAB</code></strong></p> <p>Also, do not bother initializing <code>mxArray *AinConvolved</code> before calling <code>mexCallMATLAB</code>. Just pass a NULL pointer and it will create it for you. If you don't it will just wipe the old one (send it to garbage collection) and create a fresh one for the output of <code>conv2</code>. Which reminds me this demonstrates how this is a problem in your code:</p> <pre><code>mxArray *AinConvolved = mxCreateDoubleMatrix(mxGetM(Ain), mxGetN(Ain), mxREAL); double *AinConvolvedPtr0 = mxGetPr(AinConvolved); myconv(Ain, mask, AinConvolved); double *AinConvolvedPtr = mxGetPr(AinConvolved); mexPrintf("%p\n%p\n", AinConvolvedPtr0, AinConvolvedPtr); </code></pre> <p>Output in MATLAB:</p> <pre><code>00000000B852FA20 0000000026B8EB00 </code></pre> <p>As you can see, if you try to use the pointer you got with <code>mxGetPr</code> before using <code>mexCallMATLAB</code>, you're probably using the wrong data, possibly already deallocated memory..</p> <p><strong>Automatic separable filtering with <code>imfilter</code></strong></p> <p>Also, note that if you have <code>imfilter</code>, you don't need to implement separable convolution because it has that functionality built in. Just have a look at <code>imfilter.m</code> and note the <code>isSeparable</code> function. See <a href="http://stackoverflow.com/a/19284313/2778484">here for more information</a>.</p> <p>Try that, I'll post a test.</p>