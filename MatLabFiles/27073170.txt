Building all possible arrays from vector of subarrays. With recursion
<p>I'm trying to build all possible arrays of length n of a vector of n elements with at least 2 integers in each position. I should be getting 2^n combinations, 16 in this case. My code is generating only half of them, and not saving the output to an array</p> <pre><code>allinputs = {[1 2] [2 3] [3 4] [5 6]} A = [] </code></pre> <p>the command I run is </p> <pre><code>inputArray = inputBuilder(A,[],allinputs,1) </code></pre> <p>for the function</p> <pre><code>function inputArray = inputBuilder(A,currBuild, allInputs, currIdx) if currIdx &lt;= length(allInputs) for i = 1:length(allInputs{currIdx}) mybuild = [currBuild allInputs{currIdx}(i)]; inputBuilder(A,mybuild,allInputs,currIdx + 1); end if currIdx == length(allInputs) A = [A mybuild]; %debug output mybuild end if currIdx == 1 inputArray = A; end end end </code></pre> <p>I want all 16 arrays to get output in a vector. Or some easy way to access them all. How can I do this?</p> <p>EDIT: Recursion may be a requirement because allinputs will have subarrays of different lengths. allinputs = {[1] [2 3] [3 4] [5 6 7]}</p> <p>with this array it will be 1*2*2*3 or 12 possible arrays built</p>
<p>Not sure exactly if this is what you want, but one way of doing what I think you want to do is as follows:</p> <pre><code> allinputs = {[1 2] [2 3] [3 4] [5 6]}; comb_results = combn([1 2],4); A = zeros(size(comb_results)); for rowi = 1:size(comb_results, 1) indices = comb_results(rowi,:); for idxi = 1:numel(indices) A(rowi, idxi) = allinputs{idxi}(indices(idxi)); end end </code></pre> <p>This gives:</p> <pre><code>A = 1 2 3 5 1 2 3 6 1 2 4 5 1 2 4 6 1 3 3 5 1 3 3 6 1 3 4 5 1 3 4 6 2 2 3 5 2 2 3 6 2 2 4 5 2 2 4 6 2 3 3 5 2 3 3 6 2 3 4 5 2 3 4 6 </code></pre> <p><strong>combn</strong> is <a href="http://au.mathworks.com/matlabcentral/fileexchange/7147-combn--4-3-" rel="nofollow">here</a>.</p>