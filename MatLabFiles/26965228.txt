Split up a binary image using their white boundaries in MATLAB
<p>I'm trying to read the values in <a href="http://puu.sh/cU3Nj/b020b60f0b.png" rel="nofollow">this image</a> into variables using OCR in MATLAB. I'm having trouble doing so, so I tried to split up this image into smaller parts using the white boundary lines then trying to read it, but I dont know how to do this. Any help would be appreciated, thanks.</p>
<p>If the blocks are always delimited by a completely vertical line, you can find where they are by comparing the original image (here transformed from RGB to grayscale to be a single plane) to a matrix that is made of repeats of the first row of the original image only. Since the lines are vertical the intensity of the pixels in the first line will be the same throughout. This generates a binary mask that can be used in conjunction with a quick thresholding to reject those lines that are all black pixels in every row. Then invert this mask and use <code>regionprops</code> to locate the bounding box of each region. Then you can pull these out and do what you like.</p> <p>If the lines dividing the blocks of text are not always vertical or constant intensity throughout then there's a bit more work that needs to be done to locate the dividing lines, but nothing that's impossible. Some example data would be good to have in that case, though. </p> <pre><code>img = imread('http://puu.sh/cU3Nj/b020b60f0b.png'); imshow(img); imgGray = rgb2gray(img); imgMatch = imgGray == repmat(imgGray(1,:), size(imgGray, 1), 1); whiteLines = imgMatch &amp; (imgGray &gt; 0); boxes = regionprops(~whiteLines, 'BoundingBox'); for k = 1:6 subplot(3,2,k) boxHere = round(boxes(k).BoundingBox); imshow(img(boxHere(2):(boxHere(2)+boxHere(4)-1), boxHere(1):(boxHere(1)+boxHere(3)-1), :)); end </code></pre>
<p>You can <code>sum</code> along the columns of a binary image corresponding to that input image and find peaks from the <code>sum</code> values. This is precisely achieved in the code here -</p> <pre><code>img = imread('http://puu.sh/cU3Nj/b020b60f0b.png'); BW = im2bw(img,0.1); %// convert to a binary image with a low threshold peak_sum_max = 30; %// max of sum of cols to act as threshold to decide as peak peaks_min_width = 10; %// min distance between peaks i.e. min width of each part idx = find( sum(BW,1)&gt;=peak_sum_max ); split_idx = [1 idx( [true diff(idx)&gt;peaks_min_width ] )]; split_imgs = arrayfun(@(x) img(:,split_idx(x):split_idx(x+1)),... 1:numel(split_idx)-1,'Uni',0); %// Display split images for iter = 1:numel(split_imgs) figure,imshow(split_imgs{iter}) end </code></pre> <p>Please note that the final output <code>split_imgs</code> is a cell array with each cell holding image data for each split image.</p> <hr> <p>If you would like to have the split images directly without the need for messing with cell arrays, after you have <code>split_idx</code>, you can do this -</p> <pre><code>%// Get and display split images for iter = 1:numel(split_idx)-1 split_img = img(:,split_idx(iter):split_idx(iter+1)); figure,imshow(split_img) end </code></pre>
<p>There is now a built-in <code>ocr</code> function in the Computer Vision System Toolbox.</p>