Separating a string for different substrings
<p>Assuming I have a string: <code>akobabyd</code>, how can I make an array of its substrings every 3 chars without using a <code>for</code> loop? Expected output: <code>ako kob oba bab aby byd</code></p> <p>*This is NOT homework, just a step I need to think of on the way towards solution.</p> <p>Thanks</p>
<p>What about this one:</p> <pre><code>A = 'akobabyd'; C = arrayfun(@(ii) A(ii-1:ii+1), [2:numel(A)-1] , 'UniformOutput', 0); C(:) ans = 'ako' 'kob' 'oba' 'bab' 'aby' 'byd' </code></pre>
<p>If you can use built-in functions, you can use <a href="http://www.mathworks.com/help/matlab/ref/hankel.html" rel="nofollow"><code>hankel</code></a> to generate a windowing sequence where you can extract three characters at a time and place them into a 2D matrix where each row is a 3 character sequence. In general, supposing you wanted to find <code>len</code> substrings (in our case, <code>len = 3</code>), therefore if we did:</p> <pre><code>len = 3; ind = hankel(1:len, len:length(s)) </code></pre> <p>We would get:</p> <pre><code>ind = 1 2 3 4 5 6 2 3 4 5 6 7 3 4 5 6 7 8 </code></pre> <p>You can see that each <strong>column</strong> has indices that are three elements long, and have one position overlapping in between the windows. Therefore, we would just use these indices to access the corresponding characters in our string and produce a 2D array of characters. However, we want to have <strong>rows</strong> of strings, and so we need to transpose this result, then access our string. </p> <p>Therefore:</p> <pre><code>s = 'akobabyd'; len = 3; subseqs = s(hankel(1:len, len:length(s)).') subseqs = ako kob oba bab aby byd </code></pre> <p>This could can generalize to whichever length of substring you want. Just change <code>len</code>.</p> <p>As such, to access a particular row <code>idx</code>, you would just do:</p> <pre><code>t = subseqs(idx,:); </code></pre> <hr> <h1>Edit</h1> <p>You said you wanted to do this without using <code>hankel</code>. Looking at the <code>hankel</code> source, this is what we get:</p> <pre><code>function H = hankel(c,r) r = r(:); %-- force column structure nr = length(r); x = [ c; r((2:nr)') ]; %-- build vector of user data cidx = (ones(class(c)):nc)'; ridx = zeros(class(r)):(nr-1); H = cidx(:,ones(nr,1)) + ridx(ones(nc,1),:); % Hankel subscripts H(:) = x(H); % actual data </code></pre> <p>You can see that it only uses <code>ones</code> and <code>zeros</code>, as well as <code>class</code> to ensure that whatever data we get in is what comes out. We can simplify this as we know only numeric data (specifically <code>double</code>) is coming in. Therefore, the simplified version of the Hankel script, as well as extracting those characters you want would be:</p> <pre><code>s = 'akobabyd'; %// Define string here %// Hankel starts here c = (1 : len).'; r = (len : length(s)).'; nr = length(r); nc = length(c); x = [ c; r((2:nr)') ]; %-- build vector of user data cidx = (1:nc)'; ridx = 0:(nr-1); H = cidx(:,ones(nr,1)) + ridx(ones(nc,1),:); % Hankel subscripts ind = x(H); % actual data %// End Hankel script %// Now get our data subseqs = s(ind.'); </code></pre>
<p>One-line solution with the mighty <a href="http://es.mathworks.com/help/matlab/ref/bsxfun.html" rel="nofollow"><code>bsxfun</code></a> function:</p> <pre><code>s = 'akobabyd'; %// input string n = 3; %// number of chars of each substring result = s(bsxfun(@plus, 1:n, (0:(numel(s)-n)).')); </code></pre>