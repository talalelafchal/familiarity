MATLAB Optimisation of Weighted Gram-Schmidt Orthogonalisation
<p>I have a function in MATLAB which performs the <a href="https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process" rel="nofollow noreferrer">Gram-Schmidt Orthogonalisation</a> with a very important weighting applied to the inner-products (I don't think MATLAB's built in function supports this). This function works well as far as I can tell, however, it is too slow on large matrices. What would be the best way to improve this?</p> <p>I have tried converting to a MEX file but I lose parallelisation with the compiler I'm using and so it is then slower.</p> <p>I was thinking of running it on a GPU as the element-wise multiplications are highly parallelised. (But I'd prefer the implementation to be easily portable)</p> <p>Can anyone vectorise this code or make it faster? I am not sure how to do it elegantly ...</p> <p>I know the stackoverflow minds here are amazing, consider this a challenge :)</p> <h2><strong>Function</strong></h2> <pre><code>function [Q, R] = Gram_Schmidt(A, w) [m, n] = size(A); Q = complex(zeros(m, n)); R = complex(zeros(n, n)); v = zeros(n, 1); for j = 1:n v = A(:,j); for i = 1:j-1 R(i,j) = sum( v .* conj( Q(:,i) ) .* w ) / ... sum( Q(:,i) .* conj( Q(:,i) ) .* w ); v = v - R(i,j) * Q(:,i); end R(j,j) = norm(v); Q(:,j) = v / R(j,j); end end </code></pre> <p>where <code>A</code> is an <code>m x n</code> matrix of complex numbers and <code>w</code> is an <code>m x 1</code> vector of real numbers.</p> <h2><strong>Bottle-neck</strong></h2> <p>This is the expression for <code>R(i,j)</code> which is the slowest part of the function (not 100% sure if the notation is correct): <img src="https://i.stack.imgur.com/s0tHT.jpg" alt="Weighted Inner-Product"></p> <p>where <code>w</code> is a non-negative weight function. The weighted inner-product is mentioned on several Wikipedia pages, <a href="http://en.wikipedia.org/wiki/Weight_function#Inner_product" rel="nofollow noreferrer">this is one on the weight function</a> and <a href="https://en.wikipedia.org/wiki/Orthogonality#Orthogonal_functions" rel="nofollow noreferrer">this is one on orthogonal functions</a>.</p> <h2><strong>Reproduction</strong></h2> <p>You can produce results using the following script:</p> <pre><code>A = complex( rand(360000,100), rand(360000,100)); w = rand(360000, 1); [Q, R] = Gram_Schmidt(A, w); </code></pre> <p>where <code>A</code> and <code>w</code> are the inputs. </p> <h2><strong>Speed and Computation</strong></h2> <p>If you use the above script you will get profiler results synonymous to the following: <img src="https://i.stack.imgur.com/qVszN.png" alt="Profiler Times"> <img src="https://i.stack.imgur.com/x4Q7l.png" alt="Profiler Code Times"></p> <h2><strong>Testing Result</strong></h2> <p>You can test the results by comparing a function with the one above using the following script:</p> <pre><code>A = complex( rand( 100, 10), rand( 100, 10)); w = rand( 100, 1); [Q , R ] = Gram_Schmidt( A, w); [Q2, R2] = Gram_Schmidt2( A, w); zeros1 = norm( Q - Q2 ); zeros2 = norm( R - R2 ); </code></pre> <p>where <code>Gram_Schmidt</code> is the function described earlier and <code>Gram_Schmidt2</code> is an alternative function. The results <code>zeros1</code> and <code>zeros2</code> should then be very close to zero.</p> <h2><strong>Note:</strong></h2> <p>I tried speeding up the calculation of <code>R(i,j)</code> with the following but to no avail ...</p> <pre><code>R(i,j) = ( w' * ( v .* conj( Q(:,i) ) ) ) / ... ( w' * ( Q(:,i) .* conj( Q(:,i) ) ) ); </code></pre>
<p>It is possible to vectorize this so only one loop is necessary. The important fundamental change from the original algorithm is that if you swap the inner and outer loops you can vectorize the projection of the reference vector to all remaining vectors. Working off <strong>@Amro</strong>'s solution, I found that an inner loop is actually faster than the matrix subtraction. I do not understand why this would be. Timing this against <strong>@Amro</strong>'s solution, it is about 45% faster.</p> <pre><code>function [Q, R] = Gram_Schmidt5(A, w) Q = A; n_dimensions = size(A, 2); R = zeros(n_dimensions); R(1, 1) = norm(Q(:, 1)); Q(:, 1) = Q(:, 1) ./ R(1, 1); for i = 2 : n_dimensions Qw = (Q(:, i - 1) .* w)' * Q(:, (i - 1) : end); R(i - 1, i : end) = Qw(2:end) / Qw(1); %% Surprisingly this loop beats the matrix multiply for j = i : n_dimensions Q(:, j) = Q(:, j) - Q(:, i - 1) * R(i - 1, j); end %% This multiply is slower than above % Q(:, i : end) = ... % Q(:, i : end) - ... % Q(:, i - 1) * R(i - 1, i : end); R(i, i) = norm(Q(:,i)); Q(:, i) = Q(:, i) ./ R(i, i); end </code></pre>
<h1>1)</h1> <p>My first attempt at vectorization:</p> <pre><code>function [Q, R] = Gram_Schmidt1(A, w) [m, n] = size(A); Q = complex(zeros(m, n)); R = complex(zeros(n, n)); for j = 1:n v = A(:,j); QQ = Q(:,1:j-1); QQ = bsxfun(@rdivide, bsxfun(@times, w, conj(QQ)), w.' * abs(QQ).^2); for i = 1:j-1 R(i,j) = (v.' * QQ(:,i)); v = v - R(i,j) * Q(:,i); end R(j,j) = norm(v); Q(:,j) = v / R(j,j); end end </code></pre> <p>Unfortunately, it turned out to be slower than the original function.</p> <hr> <h1>2)</h1> <p>Then I realized that the columns of this intermediate matrix <code>QQ</code> are built incrementally, and that previous ones are not modified. So here is my second attempt:</p> <pre><code>function [Q, R] = Gram_Schmidt2(A, w) [m, n] = size(A); Q = complex(zeros(m, n)); R = complex(zeros(n, n)); QQ = complex(zeros(m, n-1)); for j = 1:n if j&gt;1 qj = Q(:,j-1); QQ(:,j-1) = (conj(qj) .* w) ./ (w.' * (qj.*conj(qj))); end v = A(:,j); for i = 1:j-1 R(i,j) = (v.' * QQ(:,i)); v = v - R(i,j) * Q(:,i); end R(j,j) = norm(v); Q(:,j) = v / R(j,j); end end </code></pre> <p>Technically no major vectorization was done; I've only precomputed intermediate results, and moved the computation outside the inner loop.</p> <p>Based on a quick benchmark, this new version is definitely faster:</p> <pre><code>% some random data &gt;&gt; M = 10000; N = 100; &gt;&gt; A = complex(rand(M,N), rand(M,N)); &gt;&gt; w = rand(M,1); % time &gt;&gt; timeit(@() Gram_Schmidt(A,w), 2) % original version ans = 1.2444 &gt;&gt; timeit(@() Gram_Schmidt1(A,w), 2) % first attempt (vectorized) ans = 2.0990 &gt;&gt; timeit(@() Gram_Schmidt2(A,w), 2) % final version ans = 0.4698 % check results &gt;&gt; [Q,R] = Gram_Schmidt(A,w); &gt;&gt; [Q2,R2] = Gram_Schmidt2(A,w); &gt;&gt; norm(Q-Q2) ans = 4.2796e-14 &gt;&gt; norm(R-R2) ans = 1.7782e-12 </code></pre> <hr> <h1>EDIT:</h1> <p>Following the comments, we can rewrite the second solution to get rid of the if-statmenet, by moving that part to the end of the outer loop (i.e immediately after computing the new column <code>Q(:,j)</code>, we compute and store the corresponding <code>QQ(:,j)</code>).</p> <p>The function is identical in output, and timing is not that different either; the code is just a bit shorter!</p> <pre><code>function [Q, R] = Gram_Schmidt3(A, w) [m, n] = size(A); Q = zeros(m, n, 'like',A); R = zeros(n, n, 'like',A); QQ = zeros(m, n, 'like',A); for j = 1:n v = A(:,j); for i = 1:j-1 R(i,j) = (v.' * QQ(:,i)); v = v - R(i,j) * Q(:,i); end R(j,j) = norm(v); Q(:,j) = v / R(j,j); QQ(:,j) = (conj(Q(:,j)) .* w) ./ (w.' * (Q(:,j).*conj(Q(:,j)))); end end </code></pre> <p>Note that I used the <code>zeros(..., 'like',A)</code> syntax (new in recent MATLAB versions). This allows us to run the function unmodified on the GPU (assuming you have the Parallel Computing Toolbox):</p> <pre><code>% CPU [Q3,R3] = Gram_Schmidt3(A, w); </code></pre> <p>vs. </p> <pre><code>% GPU AA = gpuArray(A); [Q3,R3] = Gram_Schmidt3(AA, w); </code></pre> <p>Unfortunately in my case, it wasn't any faster. In fact it was many times slower to run on the GPU than on the CPU, but it was worth a shot :)</p>
<p>There is a long discussion here, but, to jump to the answer. You have weighted the numerator and denominator of the R calculation by a vector w. The weighting occurs on the inner loop, and consist of a triple dot product, A dot Q dot w in the numerator, and Q dot Q dot w in the denominator. If you make one change, I think the code will run significantly faster. Write num = (A dot sqrt(w)) dot (Q dot sqrt(w)) and write den = (Q dot sqrt(w)) dot (Q dot sqrt(w)). That moves the (A dot sqrt(w)) and (Q dot sqrt(w)) product calculations out of the inner loop.</p> <p>I would like to give an description of the formulation to Gram Schmidt Orthogonalization, that, hopefully, in addition to giving an alternate computational solution, gives further insight into the advantage of GSO. </p> <p>The "goals" of GSO are two fold. First, to enable the solution of an equation like Ax=y, where A has far more rows than columns. This situation occurs frequently when measuring data, in that it is easy to measure more data than the number of states. The approach to the first goal is to rewrite A as QR such that the columns of Q are orthogonal and normalized, and R is a triangular matrix. The algorithm you provided, I believe, achieves the first goal. The Q represents the basis space of the A matrix, and R represents the amplitude of each basis space required to generate each column of A. </p> <p>The second goal of GSO is to rank the basis vectors in order of significance. This the step that you have not done. And, while including this step, may increase the solution time, the results will identify which elements of x are important, according the data contained in the measurements represented by A.</p> <p>But, I think, with this implementation, the solution is faster than the approach you presented.</p> <p>Aij = Qij Rij where Qj are orthonormal and Rij is upper triangular, Ri,j>i=0. Qj are the orthogonal basis vectors for A, and Rij is the participation of each Qj to create a column in A. So, </p> <pre><code>A_j1 = Q_j1 * R_1,1 A_j2 = Q_j1 * R_1,2 + Q_j2 * R_2,2 A_j3 = Q_j1 * R_1,3 + Q_j2 * R_2,3 + Q_j3 * R_3,3 </code></pre> <p>By inspection, you can write</p> <pre><code>A_j1 = ( A_j1 / | A_j1 | ) * | A_j1 | = Q_j1 * R_1,1 </code></pre> <p>Then you project Q_j1 onto from every other column A to get the R_1,j elements</p> <pre><code>R_1,2 = Q_j1 dot Aj2 R_1,3 = Q_j1 dot Aj3 ... R_1,j(j&gt;1) = A_j dot Q_j1 </code></pre> <p>Then you subtract the elements of project of Q_j1 from the columns of A (this would set the first column to zero, so you can ignore the first column</p> <pre><code>for j = 2,n A_j = A_j - R_1,j * Q_j1 end </code></pre> <p>Now one column from A has been removed, the first orthonormal basis vector, Q,j1, was determined, and the contribution of the first basis vector to each column, R_1,j has been determined, and the contribution of the first basis vector has been subtracted from each column. Repeat this process for the remaining columns of A to obtain the remaining columns of Q and rows of R. </p> <pre><code>for i = 1,n R_ii = |A_i| A_i is the ith column of A, |A_i| is magnitude of A_i Q_i = A_i / R_ii Q_i is the ith column of Q for j = i, n R_ij = | A_j dot Q_i | A_j = A_j - R_ij * Q_i end end </code></pre> <p>You are trying to weight the rows of A, with w. Here is one approach. I would normalize w, and incorporate the effect into R. You "removed" the effects of w by multiply and dividing by w. An alternative to "removing" the effect is to normalize the amplitude of w to one.</p> <pre><code>w = w / | w | for i = 1,n R_ii = |A_i inner product w| # A_i inner product w = A_i .* w Q_i = A_i / R_ii for j = i, n R_ij = | (A_i inner product w) dot Q_i | # A dot B = A' * B A_j = A_j - R_ij * Q_i end end </code></pre> <p>Another approach to implementing w is to normalize w and then premultiply every column of A by w. That cleanly weights the rows of A, and reduces the number of multiplications.</p> <p>Using the following may help in speeding up your code</p> <pre><code>A inner product B = A .* B A dot w = A' w (A B)' = B'A' A' conj(A) = |A|^2 </code></pre> <p>The above can be vectorized easily in matlab, pretty much as written.</p> <p>But, you are missing the second portion of ranking of A, which tells you which states (elements of x in A x = y) are significantly represented in the data</p> <p>The ranking procedure is easy to describe, but I'll let you work out the programming details. The above procedure essentially assumes the columns of A are in order of significance, and the first column is subtracted off all the remaining columns, then the 2nd column is subtracted off the remaining columns, etc. The first row of R represents the contribution of the first column of Q to each column of A. If you sum the absolute value of the first row of R contributions, you get a measurement of the contribution of the first column of Q to the matrix A. So, you just evaluate each column of A as the first (or next) column of Q, and determine the ranking score of the contribution of that Q column to the remaining columns of A. Then select the A column that has the highest rank as the next Q column. Coding this essentially comes down to pre estimating the next row of R, for every remaining column in A, in order to determine which ranked R magnitude has the largest amplitude. Having a index vector that represents the original column order of A will be beneficial. By ranking the basis vectors, you end up with the "principal" basis vectors that represent A, which is typically much smaller in number than the number of columns in A.</p> <p>Also, if you rank the columns, it is not necessary to calculate every column of R. When you know which columns of A don't contain any useful information, there's no real benefit to keeping those columns.</p> <p>In structural dynamics, one approach to reducing the number of degrees of freedom is to calculate the eigenvalues, assuming you have representative values for the mass and stiffness matrix. If you think about it, the above approach can be used to "calculate" the M and K (and C) matrices from measured response, and also identify the "measurement response shapes" that are significantly represented in the data. These are diffenrent, and potentially more important, than the mode shapes. So, you can solve very difficult problems, i.e., estimation of state matrices and number of degrees of freedom represented, from measured response, by the above approach. If you read up on N4SID, he did something similar, except he used SVD instead of GSO. I don't like the technical description for N4SID, too much focus on vector projection notation, which is simply a dot product.</p> <p>There may be one or two errors in the above information, I'm writing this off the top of my head, before rushing off to work. So, check the algorithm / equations as you implement... Good Luck</p> <p>Coming back to your question, of how to optimize the algorithm when you weight with w. Here is a basic GSO algorithm, without the sorting, written compatible with your function.</p> <p>Note, the code below is in octave, not matlab. There are some minor differences.</p> <pre><code>function [Q, R] = Gram_Schmidt_2(A, w) [m, n] = size(A); Q = complex(zeros(m, n)); R = complex(zeros(n, n)); # Outer loop identifies the basis vectors for j = 1:n aCol = A(:,j); # Subtract off the basis vector for i = 1:(j-1) R(i,j) = ctranspose(Q(:,j)) * aCol; aCol = aCol - R(i,j) * Q(:,j); end amp_A_col = norm(aCol); R(j,j) = amp_A_col; Q(:,j) = aCol / amp_A_col; end end </code></pre> <p>To get your algorithm, only change one line. But, you lose a lot of speed because "ctranspose(Q(:,j)) * aCol" is a vector operation but "sum( aCol .* conj( Q(:,i) ) .* w )" is a row operation.</p> <pre><code>function [Q, R] = Gram_Schmidt_2(A, w) [m, n] = size(A); Q = complex(zeros(m, n)); R = complex(zeros(n, n)); # Outer loop identifies the basis vectors for j = 1:n aCol = A(:,j); # Subtract off the basis vector for i = 1:(j-1) # R(i,j) = ctranspose(Q(:,j)) * aCol; R(i,j) = sum( aCol .* conj( Q(:,i) ) .* w ) / ... sum( Q(:,i) .* conj( Q(:,i) ) .* w ); aCol = aCol - R(i,j) * Q(:,j); end amp_A_col = norm(aCol); R(j,j) = amp_A_col; Q(:,j) = aCol / amp_A_col; end end </code></pre> <p>You can change it back to a vector operation by weighting aCol and Q by the sqrt of w.</p> <pre><code>function [Q, R] = Gram_Schmidt_3(A, w) [m, n] = size(A); Q = complex(zeros(m, n)); R = complex(zeros(n, n)); Q_sw = complex(zeros(m, n)); sw = w .^ 0.5; for j = 1:n aCol = A(:,j); aCol_sw = aCol .* sw; # Subtract off the basis vector for i = 1:(j-1) # R(i,j) = ctranspose(Q(:,i)) * aCol; numTerm = ctranspose( Q_sw(:,i) ) * aCol_sw; denTerm = ctranspose( Q_sw(:,i) ) * Q_sw(:,i); R(i,j) = numTerm / denTerm; aCol_sw = aCol_sw - R(i,j) * Q_sw(:,i); end aCol = aCol_sw ./ sw; amp_A_col = norm(aCol); R(j,j) = amp_A_col; Q(:,j) = aCol / amp_A_col; Q_sw(:,j) = Q(:,j) .* sw; end end </code></pre> <p>As pointed out by JacobD, the above function does not run faster. Possibly it takes time to create the additional arrays. Another grouping strategy for the triple product is to group w with conj(Q). Hope this is faster...</p> <pre><code>function [Q, R] = Gram_Schmidt_4(A, w) [m, n] = size(A); Q = complex(zeros(m, n)); R = complex(zeros(n, n)); for j = 1:n aCol = A(:,j); for i = 1:(j-1) cqw = conj(Q(:,i)) .* w; R(i,j) = ( transpose( aCol ) * cqw) ... / (transpose( Q(:,i) ) * cqw); aCol = aCol - R(i,j) * Q(:,i); end amp_A_col = norm(aCol); R(j,j) = amp_A_col; Q(:,j) = aCol / amp_A_col; end end </code></pre> <p>Here's a driver function to time different versions. </p> <pre><code>function Gram_Schmidt_tester_2 nSamples = 360000; nMeas = 100; nMeas = 15; A = complex( rand(nSamples,nMeas), rand(nSamples,nMeas)); w = rand(nSamples, 1); profile on; [Q1, R1] = Gram_Schmidt_basic(A); profile off; data1 = profile ("info"); tData1=data1.FunctionTable(1).TotalTime; approx_zero1 = A - Q1 * R1; max_value1 = max(max(abs(approx_zero1))); profile on; [Q2, R2] = Gram_Schmidt_w_Orig(A, w); profile off; data2 = profile ("info"); tData2=data2.FunctionTable(1).TotalTime; approx_zero2 = A - Q2 * R2; max_value2 = max(max(abs(approx_zero2))); sw=w.^0.5; profile on; [Q3, R3] = Gram_Schmidt_sqrt_w(A, w); profile off; data3 = profile ("info"); tData3=data3.FunctionTable(1).TotalTime; approx_zero3 = A - Q3 * R3; max_value3 = max(max(abs(approx_zero3))); profile on; [Q4, R4] = Gram_Schmidt_4(A, w); profile off; data4 = profile ("info"); tData4=data4.FunctionTable(1).TotalTime; approx_zero4 = A - Q4 * R4; max_value4 = max(max(abs(approx_zero4))); profile on; [Q5, R5] = Gram_Schmidt_5(A, w); profile off; data5 = profile ("info"); tData5=data5.FunctionTable(1).TotalTime; approx_zero5 = A - Q5 * R5; max_value5 = max(max(abs(approx_zero5))); profile on; [Q2a, R2a] = Gram_Schmidt2a(A, w); profile off; data2a = profile ("info"); tData2a=data2a.FunctionTable(1).TotalTime; approx_zero2a = A - Q2a * R2a; max_value2a = max(max(abs(approx_zero2a))); profshow (data1, 6); profshow (data2, 6); profshow (data3, 6); profshow (data4, 6); profshow (data5, 6); profshow (data2a, 6); sprintf('Time for %s is %5.3f sec with %d samples and %d meas, max value is %g', data1.FunctionTable(1).FunctionName, data1.FunctionTable(1).TotalTime, nSamples, nMeas, max_value1) sprintf('Time for %s is %5.3f sec with %d samples and %d meas, max value is %g', data2.FunctionTable(1).FunctionName, data2.FunctionTable(1).TotalTime, nSamples, nMeas, max_value2) sprintf('Time for %s is %5.3f sec with %d samples and %d meas, max value is %g', data3.FunctionTable(1).FunctionName, data3.FunctionTable(1).TotalTime, nSamples, nMeas, max_value3) sprintf('Time for %s is %5.3f sec with %d samples and %d meas, max value is %g', data4.FunctionTable(1).FunctionName, data4.FunctionTable(1).TotalTime, nSamples, nMeas, max_value4) sprintf('Time for %s is %5.3f sec with %d samples and %d meas, max value is %g', data5.FunctionTable(1).FunctionName, data5.FunctionTable(1).TotalTime, nSamples, nMeas, max_value5) sprintf('Time for %s is %5.3f sec with %d samples and %d meas, max value is %g', data2a.FunctionTable(1).FunctionName, data2a.FunctionTable(1).TotalTime, nSamples, nMeas, max_value2a) end </code></pre> <p>On my old home laptop, in Octave, the results are</p> <pre><code>ans = Time for Gram_Schmidt_basic is 0.889 sec with 360000 samples and 15 meas, max value is 1.57009e-16 ans = Time for Gram_Schmidt_w_Orig is 0.952 sec with 360000 samples and 15 meas, max value is 6.36717e-16 ans = Time for Gram_Schmidt_sqrt_w is 0.390 sec with 360000 samples and 15 meas, max value is 6.47366e-16 ans = Time for Gram_Schmidt_4 is 0.452 sec with 360000 samples and 15 meas, max value is 6.47366e-16 ans = Time for Gram_Schmidt_5 is 2.636 sec with 360000 samples and 15 meas, max value is 6.47366e-16 ans = Time for Gram_Schmidt2a is 0.905 sec with 360000 samples and 15 meas, max value is 6.68443e-16 </code></pre> <p>These results indicate the fastest algorithm is the sqrt_w algorithm above at 0.39 sec, followed by the grouping of conj(Q) with w (above) at 0.452 sec, then version 2 of Amro solution at 0.905 sec, then the original algorithm in the question at 0.952, then a version 5 which interchanges rows / columns to see if row storage presented (code not included) at 2.636 sec. These results indicate the sqrt(w) split between A and Q is the fastest solution. But these results are not consistent with JacobD's comment about sqrt(w) not being faster.</p>