Fast and generic use of lambda functions
<h2>Motivation</h2> <p>I created a header file which wraps Matlab's mex functionality in c++11 classes; especially for MxNxC images. Two functions I created are forEach, which iterates over each pixel in the image, and also a forKernel, which given a kernel and pixel in the image, iterates over the kernel around that pixel, handling all kinds of nifty, boiler-plate indexing mathematics.</p> <p>The idea is that one could program sliding-windows like this:</p> <pre class="lang-cpp prettyprint-override"><code>image.forEach([](Image &amp;image, size_t row, size_t col) { //kr and lc specify which pixel is the center of the kernel image.forKernel&lt;double&gt;(row, col, kernel, kr, kc, [](Image &amp;image, double w, size_t row, size_t col) { // w is the weight/coefficient of the kernel, row/col are the corresponding coordinates in the image. // process ... }); }); </code></pre> <h2>Problem</h2> <p>This provides a nice way to</p> <ul> <li>increase readability: the two function calls are a lot clearer than the corresponding 4 for-loops to do the same,</li> <li>stay flexible: lambda functions allow you to scope all kinds of variables by value or reference, which are invisible to the implementer of forEach / forKernel, and</li> <li>increase execution time, unfortunately: this executes around 8x slower than using just for loops.</li> </ul> <p>The latter point is the problem, of course. I was hoping g++ would be able to optimize the lambda-functions out and inline all the code. This does not happen. Hence I created a minimal working example on 1D data:</p> <pre class="lang-cpp prettyprint-override"><code>#include &lt;iostream&gt; #include &lt;functional&gt; struct Data { size_t d_size; double *d_data; Data(size_t size) : d_size(size), d_data(new double[size]) {} ~Data() { delete[] d_data; } double &amp;operator[](size_t i) { return d_data[i]; } inline void forEach(std::function&lt;void(Data &amp;, size_t)&gt; f) { for (size_t index = 0; index != d_size; ++index) f(*this, index); } }; int main() { Data im(50000000); im.forEach([](Data &amp;im, size_t i) { im[i] = static_cast&lt;double&gt;(i); }); double sum = 0; im.forEach([&amp;sum](Data &amp;im, size_t i) { sum += im[i]; }); std::cout &lt;&lt; sum &lt;&lt; '\n'; } </code></pre> <p>source: <a href="http://ideone.com/hviTwx" rel="nofollow">http://ideone.com/hviTwx</a></p> <p>I'm guessing the compiler is not able to compile the code for forEach per lambda-function, as the lambda function is not a template variable. The good thing is that one can compile once and link to it more often with different lambda functions, but the bad thing is that it is slow.</p> <p>Moreover, the situation discussed in the motivation already contains templates for the data type (double, int, ...), hence the 'good thing' is overruled anyway.</p> <p>A fast way to implement the previous would be like this:</p> <pre class="lang-cpp prettyprint-override"><code>#include &lt;iostream&gt; #include &lt;functional&gt; struct Data { size_t d_size; double *d_data; Data(size_t size) : d_size(size), d_data(new double[size]) {} ~Data() { delete[] d_data; } double &amp;operator[](size_t i) { return d_data[i]; } }; int main() { size_t len = 50000000; Data im(len); for (size_t index = 0; index != len; ++index) im[index] = static_cast&lt;double&gt;(index); double sum = 0; for (size_t index = 0; index != len; ++index) sum += im[index]; std::cout &lt;&lt; sum &lt;&lt; '\n'; } </code></pre> <p>source: <a href="http://ideone.com/UajMMz" rel="nofollow">http://ideone.com/UajMMz</a></p> <p>It is about 8x faster, but also less readable, especially when we consider more complicated structures like images with kernels.</p> <h2>Question</h2> <p>Is there a way to provide the lambda function as a template argument, such that forEach is compiled for each call, and optimized for each specific instance of the lambda function? Can the lambda function be inlined somehow, since lambda functions are typically not recursive this should be trivial, but what is the syntax?</p> <p>I found some related posts:</p> <ul> <li><a href="http://stackoverflow.com/questions/8611756/why-c-lambda-is-slower-than-ordinary-function-when-called-multiple-times">Why C++ lambda is slower than ordinary function when called multiple times?</a></li> <li><a href="http://stackoverflow.com/questions/18619035/understanding-the-overhead-of-lambda-functions-in-c11">Understanding the overhead of lambda functions in C++11</a></li> <li><a href="http://stackoverflow.com/questions/3218821/c0x-lambda-overhead">C++0x Lambda overhead</a></li> </ul> <p>But they do not give a solution in the form of a minimal working example, and they do not discuss the possibility of inlining a lambda function. The answer to my question should do that: change the Data.forEach member function and it's call such that is as fast as possible / allows for as many <strong>running time optimizations</strong> (not optimizations at run time, but at compile time that decrease runtime) as possible.</p> <h2>Regarding the suggestion of forEveR</h2> <p>Thank you for creating that fix, it's a huge improvement yet still approximately 2x as slow:</p> <ul> <li>test0.cc: <a href="http://ideone.com/hviTwx" rel="nofollow">http://ideone.com/hviTwx</a></li> <li>test1.cc: <a href="http://ideone.com/UajMMz" rel="nofollow">http://ideone.com/UajMMz</a></li> <li>test2.cc: <a href="http://ideone.com/8kR3Mw" rel="nofollow">http://ideone.com/8kR3Mw</a></li> </ul> <p>Results:</p> <pre class="lang-cpp prettyprint-override"><code>herbert@machine ~ $ g++ -std=c++11 -Wall test0.cc -o test0 herbert@machine ~ $ g++ -std=c++11 -Wall test1.cc -o test1 herbert@machine ~ $ g++ -std=c++11 -Wall test2.cc -o test2 herbert@machine ~ $ time ./test0 1.25e+15 real 0m2.563s user 0m2.541s sys 0m0.024s herbert@machine ~ $ time ./test1 1.25e+15 real 0m0.346s user 0m0.320s sys 0m0.026s herbert@machine ~ $ time ./test2 1.25e+15 real 0m0.601s user 0m0.575s sys 0m0.026s herbert@machine ~ $ </code></pre> <p>I re-ran the code with -O2, which fixes the problem. runtimes of test1 and test2 ar now very similar. Thank you @stijn and @forEveR.</p> <pre class="lang-cpp prettyprint-override"><code>herbert@machine ~ $ g++ -std=c++11 -Wall -O2 test0.cc -o test0 herbert@machine ~ $ g++ -std=c++11 -Wall -O2 test1.cc -o test1 herbert@machine ~ $ g++ -std=c++11 -Wall -O2 test2.cc -o test2 herbert@machine ~ $ time ./test0 1.25e+15 real 0m0.256s user 0m0.229s sys 0m0.028s herbert@machine ~ $ time ./test1 1.25e+15 real 0m0.111s user 0m0.078s sys 0m0.033s herbert@machine ~ $ time ./test2 1.25e+15 real 0m0.108s user 0m0.076s sys 0m0.032s herbert@machine ~ $ </code></pre>
<p>Problem is, that you use <code>std::function</code>, that actually use <code>type-erasure</code> and virtual calls. You can simply use template parameter, instead of <code>std::function</code>. Call of lambda function will be inlined, due n3376 5.1.2/5</p> <blockquote> <p>The closure type for a lambda-expression has a <strong>public inline function call operator (13.5.4)</strong> whose param- eters and return type are described by the lambda-expressionâ€™s parameter-declaration-clause and trailing- return-type respectively</p> </blockquote> <p>So, just simply write</p> <pre><code> template&lt;typename Function&gt; inline void forEach(Function f) { for (size_t index = 0; index != d_size; ++index) f(*this, index); } </code></pre> <p><a href="http://ideone.com/8kR3Mw">Live example</a></p>