Finding a sequence of 4 values in an array without loop
<p>I'm trying to find a sequence of ascending values in an array (4 values) without <code>for</code> or <code>if</code>. For example, A = [8 9 1 3 7 18 9], input will be: <code>1 3 7 18</code>. </p> <p>Any way to do it without <code>for</code>?</p>
<p><code>strfind</code> allows you to look for patterns not only in strings, but also numeric arrays. The pattern you're looking for is three consecutive positive differences:</p> <pre><code>A = [8 9 1 3 7 18 19] sequenceLength = 4; startIdx = strfind( sign(diff(A)), ones(1,sequenceLength-1)); sequences = A(bsxfun(@plus,startIdx',0:sequenceLength-1)) sequences = 1 3 7 18 3 7 18 19 </code></pre> <p>Note: <code>strfind</code> finds overlapping intervals. If you want exclusive intervals, you may want to look at <code>regexp</code>.</p>
<p>This will give you the starting indices of all such subsequences:</p> <pre><code>n = 4; indices = find(conv(double(diff(A)&gt;0), ones(1,n-1), 'valid')==n-1); </code></pre> <p>Example:</p> <pre><code>A = [8 9 1 3 7 18 9 10 11 12 5]; </code></pre> <p>produces</p> <pre><code>indices = 3 7 </code></pre> <p>So the subsequences would be <code>A(indices(1) + (0:n-1))</code>, <code>A(indices(2) + (0:n-1))</code>, etc:</p> <pre><code>&gt;&gt; A(indices(1) + (0:n-1)) ans = 1 3 7 18 &gt;&gt; A(indices(2) + (0:n-1)) ans = 9 10 11 12 </code></pre>
<p>Another solution:</p> <pre><code>A = [8 9 1 3 7 18 9 10 11 12 5]; len = 4; subseqs = hankel(A(1:len), A(len:end)); idx = all(diff(subseqs) &gt; 0); out = subseqs(:,idx); </code></pre>