Comparing arrays of different sizes without any loop
<p>The question goes like this: </p> <p>Given two arrays, <code>a</code> &amp; <code>b</code> (both with positive integers). </p> <p>A <code>special number</code> is a number which <code>a(i) == i</code> (the value equals to the index). </p> <p>How can you check if array <code>b</code> contains a value which is a <code>special number</code> of <code>a</code>. </p> <p>For example: <code>a = [9 9 3 9]</code>, <code>b = [3 4 5]</code>. Output will be <code>3</code>. If <code>b</code> or <code>a</code> are empty, output is <code>0</code>. If <code>b</code> contains several <code>special number</code>, only the smallest one will be shown.</p> <p>This is what I have managed to do by far, can't progress from here..</p> <pre><code>a = input('Please enter the array a : '); b = input('Please enter the array b : '); indexedArray = 1:length(a); c = a-indexedArray; t = find(c==0); p = find(t==b); </code></pre> <p>does not work.</p> <p><strong>BTW: Can only use these functions: . sort , isempty , all , any , find , sum , max , min , length. No loops or conditions! Allowed only to use an array. No matrix. Cannot use logical operators such as &amp;, |</strong></p> <p>Thanks!</p>
<p>I was holding off posting my solution because I <a href="http://stackoverflow.com/questions/27006489/comparing-arrays-of-different-sizes-without-any-loop/27023376?noredirect=1#comment42571940_27023376">correctly</a> suspected that this question was a homework assignment. However, since the OP has accepted <a href="http://stackoverflow.com/a/27023376/2541573">Jonas's answer</a>, I might as well post mine.</p> <h1>Code</h1> <p>A combination of <code>sum</code>, <code>length</code>, <code>any</code>, and <code>min</code> does the trick:</p> <pre><code>function out = stupidTutor(a, b) a = sum(a, 1); % if a is empty, replace it by a 1-by-0 matrix specials = a(a == 1:length(a)); % construct the vector of special numbers b = sum(b, 1); % if b is empty, replace it by a 1-by-0 matrix % some dyadic-product shenanigans A = specials' * (b == b); B = (specials == specials)' * b; ind = any(A == B, 1); temp = min(b(ind)); % temp is either a scalar, a 1-by-0 matrix, or [] out = sum(sum(temp, 2), 1); % trick to return 0 in case temp be 1-by-0 or [] </code></pre> <h1>Tests</h1> <pre><code>% a b result stupidTutor([9 9 3 9] , [3 4 5]) % 3 stupidTutor([9 9 3 9] , [9 8]) % 0 stupidTutor([9 9 9 9 5], [3 4 5 3]) % 5 stupidTutor([9 9 3 9 5], [3 4 5 3]) % 3 stupidTutor([9 9 3 9 5], [5 4 3 2 1]) % 3 stupidTutor([9 9 3 9] , []) % 0 stupidTutor([] , [3 4 5]) % 0 stupidTutor([] , []) % 0 </code></pre>
<p>Well, turns out there might be a way after all :). We make use of the fact that the numbers have to be strictly positive to be special numbers at all. </p> <pre><code>%# in case we need to handle empty inputs: replace empty input with 0 or 1, respectively. a = sum(a(:)',1); bIsEmpty = isempty(b); b = sum(b(:)',1); b = max(b,1); specialNumber = find(a==1:length(a)); maxAB = max(max(a), max(b)); %# "zeros()" bigVectorForComparisonA = (1:maxAB)*0; bigVectorForComparisonB = (1:maxAB)*0; bigVectorForComparisonA(specialNumber) = 1; bigVectorForComparisonB(b) = 1; %# instead of &amp;, we add. Find only the smallest match specialNumberInB = find(bigVectorForComparisonA + bigVectorForComparisonB == 2,1,'first'); out = sum(specialNumberInB) * ~bIsEmpty; %# sum([]) = 0 </code></pre> <p>For a slightly prettier solution that assumes up to 1 special number in <code>a</code></p> <pre><code>specialNumber = min(find(a==(1:length(a))); out = any(b==specialNumber)*sum(specialNumber); </code></pre>