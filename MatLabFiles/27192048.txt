Equivalent threshold function of OpenCV in MATLAB
<p>What is the equivalent of <code>cv2.threshold</code>and <code>cv2.inRange</code> in MATLAB?</p>
<p>Let's tackle one function at a time:</p> <h1><a href="http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#threshold" rel="nofollow"><code>cv2.threshold</code></a></h1> <p>The closest equivalent would be to use <a href="http://www.mathworks.com/help/images/ref/im2bw.html" rel="nofollow"><code>im2bw</code></a>. This thresholds an image based on an intensity level you specify. However, what's different with <code>im2bw</code> in comparison to <code>cv2.threshold</code> is that you <strong>can't</strong> specify what the output thresholded value will be. <code>im2bw</code> assumes that it is a binary 1. As such, if you want to convert this into a different value, you'd need to cast the image to <code>uint8</code> (or whatever data type your image is), then set any locations that are 1 to whichever value you wish. Therefore, assuming your image is loaded in with <a href="http://www.mathworks.com/help/matlab/ref/imread.html" rel="nofollow"><code>imread</code></a> and the image is called <code>im</code>, <code>level</code> is the threshold level you want to threshold at, and <code>maxval</code> is the final output value you want each thresholded pixel to take, you would do:</p> <pre><code>out = im2bw(im, level/255); out = uint8(out); out(out == 1) = maxval; </code></pre> <p>It's important to note that the threshold level is <strong>normalized</strong> between <code>[0,1]</code>. I divided by 255, as most images are <code>uint8</code>, and so dividing by 255 will bring the range to <code>[0,1]</code>. <code>cv2.threshold</code> also has thresholding via Otsu available. You can do this in MATLAB via <a href="http://www.mathworks.com/help/images/ref/graythresh.html" rel="nofollow"><code>graythresh</code></a>. <code>graythresh</code> will provide the optimum threshold between <code>[0,1]</code> that you can input directly into <code>im2bw</code>. Therefore:</p> <pre><code>out = im2bw(im, graythresh(im)); out = uint8(out); out(out == 1) = maxval; </code></pre> <hr> <h1><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#cv.InRange" rel="nofollow"><code>cv2.inRange</code></a></h1> <p>This functionality is not natively supported in MATLAB. What you would have to do is take each plane of your image (only one for grayscale, three for colour), and individually check to see whether or not there are pixels that are within the valid ranges. If there are, you'd set this to logical <code>true</code>. Therefore, for grayscale images, you would do something like:</p> <pre><code>minval = ...; %// Define minimum value here maxval = ...; %// Define maximum value here out = (im &gt;= minval &amp; im &lt;= maxval); </code></pre> <p>For colour images, you'd do something like:</p> <pre><code>minval = ...; %// Define three element vector here for each colour plane i.e. [0 128 128]; maxval = ...; %// Define three element vector here for each colour plane i.e. [0 128 128]; out = true(size(im,1), size(im,2)); for p = 1 : 3 out = out &amp; (im(:,:,p) &gt;= minval(p) &amp; im(:,:,p) &lt;= maxval(p)); end </code></pre> <p>What we are doing here is going plane by plane and checking to see whether each colour plane is within the range specified per element in <code>minval</code> and <code>maxval</code>. As soon as we find a pixel that is outside of the range for any colour plane, we would set this location to <code>false</code>.</p> <hr> <p>Good luck!</p>