How do I plot relations in matlab?
<p>I want to plot relations like <code>y^2=x^2(x+3)</code> in MATLAB without using <code>ezplot</code> or doing algebra to find each branch of the function.</p> <p>Does anyone know how I can do this? I usually create a <code>linspace</code> and then create a function over the <code>linspace</code>. For example</p> <pre><code>x=linspace(-pi,pi,1001); f=sin(x); plot(x,f) </code></pre> <p>Can I do something similar for the relation I have provided?</p>
<p>What you could do is use <a href="http://www.mathworks.com/help/symbolic/solve.html" rel="nofollow noreferrer"><code>solve</code></a> and allow MATLAB's symbolic solver to symbolically solve for an expression of <code>y</code> in terms of <code>x</code>. Once you do this, you can use <a href="http://www.mathworks.com/help/symbolic/subs.html" rel="nofollow noreferrer"><code>subs</code></a> to substitute values of <code>x</code> into the expression found from <code>solve</code> and plot all of these together. Bear in mind that you will need to cast the result of <code>subs</code> with <code>double</code> because you want the numerical result of the substitution. Not doing this will still leave the answer in MATLAB's symbolic format, and it is incompatible for use when you want to plot the final points on your graph.</p> <p>Also, what you'll need to do is that given equations like what you have posted above, you may have to loop over each solution, substitute your values of <code>x</code> into each, then add them to the plot. </p> <p>Something like the following. Here, you also have control over the domain as you have desired:</p> <pre><code>syms x y; eqn = solve('y^2 == x^2*(x+3)', 'y'); %// Solve for y, as an expression of x xval = linspace(-1, 1, 1000); %// Spawn a blank figure and remember stuff as we throw it in figure; hold on; %// For as many solutions as we have... for idx = 1 : numel(eqn) %// Substitute our values of x into each solution yval = double(subs(eqn(idx), xval)); %// Plot the points plot(xval, yval); end %// Add a grid grid; </code></pre> <hr> <p>Take special care of how I used <code>solve</code>. I specified <code>y</code> because I want to solve for <code>y</code>, which will give me an expression in terms of <code>x</code>. <code>x</code> is our independent variable, and so this is important. I then specify a grid of <code>x</code> points from -1 to 1 - exactly 1000 points actually. I spawn a blank figure, then for as many solutions to the equation that we have, we determine the output <code>y</code> values for each solution we have given the <code>x</code> values that I made earlier. I then plot these on a graph of these points. Note that I used <code>hold on</code> to add more points with each invocation to <code>plot</code>. If I didn't do this, the figure would refresh itself and only remember the most recent call to <code>plot</code>. You want to put all of the points on here generated from all of the solution. For some neatness, I threw a grid in.</p> <p>This is what I get:</p> <p><img src="https://i.stack.imgur.com/g66N4.png" alt="enter image description here"></p>
<p>Ok I was about to write my answer and I just saw that @rayryeng proposed a similar idea (Good job Ray!) but here it goes. The idea is also to use solve to get an expression for y, then convert the symbolic function to an anonymous function and then plot it. The code is general for any number of solutions you get from solve:</p> <pre><code>clear clc close all syms x y FunXY = y^2 == x^2*(x+3); %//Use solve to solve for y. Y = solve(FunXY,y); %// Create anonymous functions, stored in a cell array. NumSol = numel(Y); %// Number of solutions. G = cell(1,NumSol); for k = 1:NumSol G{k} = matlabFunction(Y(k)) end %// Plot the functions... figure hold on for PlotCounter = 1:NumSol fplot(G{PlotCounter},[-pi,pi]) end hold off </code></pre> <p>The result is the following:</p> <p><img src="https://i.stack.imgur.com/DX8s7.jpg" alt="enter image description here"></p>
<pre><code>n = 1000; [x y] = meshgrid(linspace(-3,3,n),linspace(-3,3,n)); z = nan(n,n); z = (y .^ 2 &lt;= x .^2 .* (x + 3) + .1); z = z &amp; (y .^ 2 &gt;= x .^2 .* (x + 3) - .1); contour(x,y,z) </code></pre> <p><img src="https://i.stack.imgur.com/8euNh.png" alt="enter image description here"></p> <p>It's probably not what you want, but I it's pretty cool!</p> <p><img src="https://i.stack.imgur.com/3mIVS.png" alt="enter image description here"></p>