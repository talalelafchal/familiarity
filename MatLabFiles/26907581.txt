MATLAB optimization: objective function with &quot;steps&quot;
<p>I am trying to find a minimum using fmincon in MATLAB, and I am facing a following problem:</p> <p><em>Optimization completed because the size of the gradient at the initial point is less than the default value of the function tolerance.</em></p> <p>My objective function's surface shows "steps", and therefore it has the same values over certain ranges of input variables (the size of the gradient is zero, if I am correct):</p> <p><img src="https://i.stack.imgur.com/7VLon.png" alt="enter image description here"></p> <p>When moving from the initial point, the solver doesn't see any changes in the objective function's value, and finishes the optimization:</p> <pre><code>Iteration Func-count f(x) Step-size optimality 0 3 581.542 0 Initial point is a local minimum. Optimization completed because the size of the gradient at the initial point is less than the default value of the function tolerance. </code></pre> <p>Is there any way make the solver move forward when the objective function keeps its value unchanged (until the objective function starts to increase)?</p> <p>Thanks for your help.</p>
<p>I post my extended comment as an answer in the hope that it will be easier for future answer seekers to find the solution:</p> <p>Probably you would get reasonable results with a non-gradient based solver, e.g. <a href="http://www.mathworks.com/discovery/genetic-algorithm.html" rel="nofollow"><code>ga</code></a>, if the evaluation of the objective function is not costly. These are not dependent on the gradient and performing well on non-smooth functions. It is also worth to read the following guide before selecting solver algorithm: <a href="http://www.mathworks.com/help/optim/ug/choosing-a-solver.html" rel="nofollow">How to choose solver</a>.</p>
<p>The answer is right there : </p> <p><code>Initial point is a local minimum</code>. </p> <p>The point you are giving as the <strong>initial point</strong> is already a <strong>local minimum</strong>. So the algorithm finds that minimum and sticks there. In order to find other <strong>local minimum</strong> or maybe the <strong>global</strong> one, change the initial points to something else far from the <strong>local minimum</strong>. In order to find the <strong>global minimum</strong> use a global optimization technique.</p>