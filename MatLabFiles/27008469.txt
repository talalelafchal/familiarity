How to find haze of an image on MATLAB?
<p>I want to compute the extent of haze of an image for each block. This is done by finding the dark channel value that is used to reflect the extent of haze. This concept is from Kaiming He's paper on a <a href="http://research.microsoft.com/en-us/um/people/jiansun/papers/dehaze_cvpr2009.pdf" rel="nofollow">Single Image Haze Removal using Dark Channel Prior</a>.</p> <p>The dark channel value for each block is defined as follows:</p> <p><img src="http://latex.codecogs.com/gif.latex?I%5E%7Bdark%7D%28x%2C%20y%29%20%3D%20%5Cmin_%7Bc%20%5Cin%20%5C%7Br%2C%20g%2C%20b%5C%7D%7D%5Cleft%28%5Cmin_%7B%28x%27%2C%20y%27%29%20%5Cin%20%5COmega%28x%2Cy%29%7D%20I%5E%7Bc%7D%28x%27%2Cy%27%29%5Cright%29" alt=""></p> <p>where <code>I^c (x',y')</code> denotes the intensity at a pixel location <code>(x',y')</code> in color channel <code>c</code> (one of Red, Green, or Blue color channel), and <code>omega(x,y)</code> denotes the neighborhood of the pixel location <code>(x',y')</code>. </p> <p>I'm not sure how to translate this equation in MATLAB?</p>
<p>If I correctly understand what this equation is asking for, you are essentially extracting pixel blocks centered at each <code>(x,y)</code> in the image, you determine the minimum value within this pixel block for the red, green, and blue channels. This results in 3 values where each value is the minimum within the pixel block for each channel. From these 3 values, you choose the minimum of these and that is the final result for a location <code>(x,y)</code> in the image.</p> <p>We can do this very easily with <a href="http://www.mathworks.com/help/images/ref/ordfilt2.html" rel="nofollow noreferrer"><code>ordfilt2</code></a>. What <code>ordfilt2</code> does is that it applies an order-statistics filter to your image. You specify a mask of which pixels needs to be analyzed in your neighbourhood, it gathers those pixels in the neighbourhood that are deemed valid and sorts their intensities. You then you choose the rank of the pixel you want in the end. A lower rank means a smaller value while a larger rank denotes a larger value. In our case, the mask would be set to all logical <code>true</code> and is the size of the neighbourhood you want to analyze. Because you want a minimum, you would choose rank 1 of the result. </p> <p>You would apply this to each red, green and blue channel, then for each spatial location, choose the minimum out of the three. Therefore, supposing your image was stored in <code>im</code>, and you wanted to apply a <code>m x n</code> neighbourhood to the image, do something like this:</p> <pre><code>%// Find minimum intensity for each location for each channel out_red = ordfilt2(im(:,:,1), 1, true(m, n)); out_green = ordfilt2(im(:,:,2), 1, true(m, n)); out_blue = ordfilt2(im(:,:,3), 1, true(m, n)); %// Create a new colour image that has these all stacked out = cat(3, out_red, out_green, out_blue); %// Find dark channel image out_dark = min(out, [], 3); </code></pre> <p><code>out_dark</code> will contain the dark channel image you desire. The key to calculating what you want is in the last two lines of code. <code>out</code> contains the minimum values for each spatial location in the red, green and blue channels and they are all <a href="http://www.mathworks.com/help/matlab/ref/cat.html" rel="nofollow noreferrer">concatenated in the third dimension to produce a 3D matrix</a>. After, I apply the <a href="http://www.mathworks.com/help/matlab/ref/min.html" rel="nofollow noreferrer"><code>min</code></a> operation and look at the third dimension to finally choose which out of the red, green and blue channels for each pixel location will give the output value.</p> <p>With an example, if I use <code>onion.png</code> which is part of MATLAB's system path, and specify a 5 x 5 neighbourhood (or <code>m = 5, n = 5</code>), this is what the original image looks like, as well as the dark channel result:</p> <p><img src="https://i.stack.imgur.com/RJuow.png" alt="enter image description here"></p> <p><img src="https://i.stack.imgur.com/Gedba.png" alt="enter image description here"></p> <hr> <h1>Sidenote</h1> <p>If you're an image processing purist, finding the minimum value for pixel neighbourhoods in a grayscale image is the same as finding the grayscale <a href="http://en.wikipedia.org/wiki/Erosion_(morphology)" rel="nofollow noreferrer">morphological erosion</a>. You can consider each red, green or blue channel to be its own grayscale image. As such, we could simply replace <code>ordfilt2</code> with <a href="http://www.mathworks.com/help/images/ref/imerode.html" rel="nofollow noreferrer"><code>imerode</code></a> and use a rectangle structuring element to generate the pixel neighbourhood you want to use to apply to your image. You can do this through <a href="http://www.mathworks.com/help/images/ref/strel.html" rel="nofollow noreferrer"><code>strel</code></a> in MATLAB and specify the <code>'rectangle'</code> flag.</p> <p>As such, the equivalent code using morphology would be:</p> <pre><code>%// Find minimum intensity for each location for each channel se = strel('rectangle', [m n]); out_red = imerode(im(:,:,1), se); out_green = imerode(im(:,:,2), se); out_blue = imerode(im(:,:,3), se); %// Create a new colour image that has these all stacked out = cat(3, out_red, out_green, out_blue); %// Find dark channel image out_dark = min(out, [], 3); </code></pre> <p>You should get the same results as using <code>ordfilt2</code>. I haven't done any tests, but I highly suspect that using <code>imerode</code> is faster than using <code>ordfilt2</code>... at least on higher resolution images. MATLAB has highly optimized morphological routines and are specifically for images, whereas <code>ordfilt2</code> is for more general 2D signals.</p>
<p>Or you can use the <strong>Visibility Metric</strong> to see how hazy an image is. It turns out someone wrote a <a href="http://www.mathworks.com/matlabcentral/fileexchange/33529-a-new-visibility-metric-for-haze-images" rel="nofollow">beautiful code</a> for it as well.The lower the metric, the higher is the haze in the image.</p> <p>This metric can also be used as a pre-processor to autmatically adjust dehaze parameters. </p>