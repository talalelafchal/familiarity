A More Efficient Way of Calculating Objective Function Value is Needed
<p>I encountered a problem where my way of calculating the objective function is not efficient enough when it comes to a huge number of data (population size). (Scroll down if you feel the explanation is too long)</p> <p>Matrix 'A' is of size nx1 where n is the number of facilities. The element in each row represents the length of the facilities respectively. For example:</p> <pre><code>A = [0.05 % 1 % Original Position 0.03 % 2 0.06 % 3 0.04 % 4 0.02]; % 5 </code></pre> <p>Matrix 'W' is an upper triangular square matrix of size n containing the flow between facilities. For example: (i.e. from facility 1 to 3 the flow is 4, same to 3 to 1)</p> <pre><code>W = [0 5 2 4 1 0 0 3 0 2 0 0 0 0 0 0 0 0 0 5 0 0 0 0 0]; </code></pre> <p>I need to find the best arrangement in a row such that the objective function value is minimized.</p> <p><img src="https://i.stack.imgur.com/2MS7p.png" alt="Objective Function">...............................................(1)</p> <p>where w_ij is the flow between facilities and B_ij is the distance between the center of 2 facilities.</p> <p>For example, the arrangement of facility is [2 4 1 5 3], so matrix A permutes to be </p> <pre><code>A = [0.03 % 2 % Permuted Position 0.04 % 4 0.05 % 1 0.02 % 5 0.06]; % 3 </code></pre> <p>the distance between center of 4th and 3rd facility, B_13 = 0.05/2 + 0.02 + 0.06/2 = 0.0750 with flow value 2 based on matrix W. </p> <hr> <hr> <p>Now, given the set of data p, a permutation matrix of m x n. Where m is the number of population and n is the number of facilities. Each row stores the arrangement of the facilities. For example:</p> <pre><code>p = [3 2 1 5 4 % can be any number of row and column. 5 4 1 2 3 % in this case m = 3 (Since it has 3 rows) 1 2 3 4 5]; </code></pre> <p>So far, this is the objective function that I can think of (also some guide from member of stack overflow). The aim of this objective function is to return their values based on equation (1). You may refer <a href="http://stackoverflow.com/a/27085618/4283034">here</a>, in order to know what it did for each iteration in for loops.</p> <pre><code>function fit_value = fit_func(p,A,W,m) % m is the number of rows fit_value = zeros(1,m); A2 = A(p); for i=1:m W2 = W(p(i,:),p(i,:)); end_pts = cumsum(A2(i,:)); start_pts = end_pts - A2(i,:); start_dist = abs(bsxfun(@minus,start_pts,start_pts')); end_dist = abs(bsxfun(@minus,end_pts,end_pts')); distance = (start_dist + end_dist)./2; fit_value(i) = sum(sum(distance .* W2)); end </code></pre> <p>However, the data are huge for the function to be called each time (where the function may be called for many times as well). It has to loop for m times in order to get the fit_value. Is there any trick instead of using the 'for' loop?</p> <hr> <hr> <hr> <p>Overall (For those who skip the explanation)</p> <pre><code>% Take this 4 Parameter A = [0.05 0.03 0.06 0.04 0.02]; W = [0 5 2 4 1 0 0 3 0 2 0 0 0 0 0 0 0 0 0 5 0 0 0 0 0]; p = [3 2 1 5 4 5 4 1 2 3 1 2 3 4 5]; m = 3; % since p have 3 rows. % Substitute into this function function fit_value = fit_func(p,A,W,m) % m is the number of rows fit_value = zeros(1,m); A2 = A(p); for i=1:m % this for loop consume the time very much W2 = W(p(i,:),p(i,:)); end_pts = cumsum(A2(i,:)); start_pts = end_pts - A2(i,:); start_dist = abs(bsxfun(@minus,start_pts,start_pts')); end_dist = abs(bsxfun(@minus,end_pts,end_pts')); distance = (start_dist + end_dist)./2; fit_value(i) = sum(sum(distance .* W2)); end % Will Return This Output fit_value = [1.100 1.1400 1.6100]; </code></pre> <p>What is the trick instead of using for loop, in order to have high efficient code?</p>