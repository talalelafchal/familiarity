Calculate Quantization error in MATLAB
<p>iI was given this solution to a problem in my course material.</p> <p><strong>Problem:</strong> </p> <p>a signal <code>x(t)</code> sampled at <code>10 sample/sec</code>. consider the first <code>10 samples</code> of <code>x(t)</code></p> <pre><code>x(t) = 0.3 cos(2*pi*t); </code></pre> <p>using a 8-bit quantiser find the quantisation error.</p> <p><strong>solution:</strong></p> <pre><code>(256 quantisation levels) t=1:10; x=(0.3)*cos(2*pi*(t-1)/10); mx=max(abs(x)); q256=mx*(1/128)*floor(128*(x/mx)); stem(q256) e256=(1/10)*sum(abs(x-q256)) Error: e256 = 9.3750e-04 </code></pre> <p>There was no explanation on this, can you explain how this was calculated in detail?</p>
<p>For the first two code lines I prefer,</p> <pre><code>Fs = 10; L = 10; t = (0 : L - 1) / Fs; x = 0.3 * cos(2 * pi * t); </code></pre> <p>where <code>Fs</code> is sampling frequency, <code>L</code> number of samples and <code>t</code> shows the time.</p> <p>Note that <code>x</code> is sinusoidal with frequency of <code>Fx = 1 Hz</code> or we can say that it's periodic with <code>Tx = 1 sec</code>.</p> <p>For <code>8-bit</code> quantization we have <code>256</code> levels. Since <code>L / Fs = [10 sample] / [10 sample/sec] = 1 sec</code> is equal to <code>Tx</code> (a whole period of <code>x</code>) we can work with positive samples.</p> <pre><code>mx = max(abs(x)); </code></pre> <p><code>mx</code> is defined because in order to use <code>floor</code> we need to scale the <code>x</code>.</p> <pre><code>q256 = mx*(1/128)*floor(128*(x/mx)); </code></pre> <p><code>mx</code> shows the maximum value for <code>x</code> so <code>x / mx</code> will take values over <code>[-1 1]</code> and <code>128*x/mx</code> over <code>[-128 128]</code> will cover all <code>256</code> levels. </p> <p>So we will quantize it with <code>floor</code> and scale it back (<code>mx*1/128</code>). </p> <pre><code>e256 = (1/L)*sum(abs(x-q256)) </code></pre> <p><code>e256</code> simply shows the mean error over 10 samples.</p> <p>Note that if <code>L / Fs &lt; Tx</code> then this quantization won't be the optimum one.</p> <p><strong>Have in mind</strong></p> <p>The answer that you are given has some problems!</p> <p>suppose <code>x = [-1 -.2 0 .7 1];</code> and we want to quantize it with <code>2</code> bits.</p> <pre><code>mx = max(abs(x)); q4 = mx * (1/2) * floor(2*(x/mx)); </code></pre> <p>Will give <code>q4 = [-1 -0.5 0 0.5 1]</code> which has <code>5</code> levels (instead of <code>2^2 = 4</code>).</p> <p>It might not be a big problem, you can delete the level <code>x=1</code> and have <code>q4 = [-1 -0.5 0 0.5 0.5]</code>, still the code needs some improvements and of course the <em>error</em> will increase.</p> <p>A simple solution is to add </p> <pre><code>[~,ind] = max(x); x(ind) = x(ind) - 1e-10; </code></pre> <p>after definition of <code>mx</code> so the maximum values of <code>x</code> will be quantized in one level lower.</p> <p>The error will increase to <code>0.0012</code>.</p>