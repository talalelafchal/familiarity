matrix into vector of columns in matlab
<p>I have a problem on specific matrix multiplication. </p> <ul> <li>There is a matrix X(M x N) and vectors b(1 x 3), a(1 x 3).</li> <li>I need to multiply each column of X by b, so I would have N squared matrices (M x 3).(see example how it should look like below)</li> <li>Then I need to multiply each of this N matrixes on transposed vector a, which will turn my N matrixes into N vectors of length M. </li> </ul> <p>Is there an elegant way to do this without loops?</p> <p>My previous code which doesn't work properly:</p> <pre><code>[n,m] = size(x); nn=3; aa = [ 0.069 0.167 0.826]; bb = [ 0.132 0.302 0.917]; a = repmat(aa,[n 1]); b = repmat(bb,[n 1]); res = ((-x'*b)*a'); </code></pre> <p>I have one idea how to do this, but i don't know how to create one row (1 x N) vector from (M x N) matrix by putting all rows, from 1 to N, of the original matrix into values of the vector. example:</p> <pre><code>A =[1 2 3; 11 22 33; 111 222 333] A = [[1; 11; 111]; [2; 22; 222]; [3; 33; 333]] </code></pre> <p>I figured out that I even can not initialize such a structure. But if there is some way to do this, I still will need <code>.*</code> operation to work as common, for example:</p> <pre><code>A = [[1; 11; 111]; [2; 22; 222]] A.*[1 3 3] result: A = [[1 3 3; 11 33 33; 111 333 333]; [2 6 6; 22 66 66; 222 666 666]] </code></pre>
<p>Allow me to rephrase what you are asking in order to suit future readers. </p> <ul> <li>(a) Step #2: This step is essentially computing the <a href="http://en.wikipedia.org/wiki/Outer_product" rel="nofollow">outer product</a> between each column of <code>X</code> with <code>b</code>. As such, for each column of <code>X</code>, where each column has <code>M</code> elements / rows, we will generate a <code>M x 3</code> matrix each time. Operating over all columns will produce <code>N</code> <code>M x 3</code> matrices. Specifically, given a column of <code>X</code> which is <code>M x 1</code> and <code>b</code> which is <code>1 x 3</code>, doing the outer product is a matrix multiplication between <code>X</code> and <code>b</code>, which thus gives us a <code>M x 3</code> matrix. We repeat this <code>N</code> times, where <code>N</code> is the amount of columns in our matrix.</li> <li>(b) Step #3: Given your <code>N</code> matrices of size <code>M x 3</code>, you wish to multiply each matrix in this result by the transpose of <code>a</code>, and so the final output will be a column vector of length <code>M</code>, and we will thus have <code>N</code> of these.</li> </ul> <hr> <h1>Step #2</h1> <p>To answer your question for Step #2: Yes it is possible without loops. I would <a href="http://www.mathworks.com/help/matlab/ref/permute.html" rel="nofollow"><code>permute</code></a> the matrix <code>X</code> such that we create a 3D matrix where the first lateral slice is the matrix <code>X</code> itself. Think of a 3D volume, but the volume only has 1 slice, and this slice is the matrix <code>X</code>. This slice is also rotated 90 degrees laterally and longitudinally. If you further need clarification, think of a thin 3D matrix, where each column of <code>X</code> makes 1 slice in the 3D matrix. Each 2D slice is composed of a single column of <code>X</code>. The reason why I need to reshape the 2D matrix into this way is so that we can easily compute the outer products. I do this through <a href="http://www.mathworks.com/help/matlab/ref/bsxfun.html" rel="nofollow"><code>bsxfun</code></a>. The outer product can essentially be computed by replicating the column from <code>M</code> you're working on to the right and replicating the <code>b</code> vector to the bottom until we create 2 matrices of the same size. Once you do this, you simply do a point-by-point multiplication. <code>bsxfun</code> will essentially replicate the <code>b</code> vector into a 3D matrix where each slice contains that replicated <code>b</code> vector and it is repeated for as many slices as we have in the matrix. For the 3D matrix of <code>X</code>, each slice will have its columns replicated to the right until we have a 3D matrix that is of a compatible size with the replicated <code>b</code> 3D matrix.</p> <p>Therefore, Step #2 can elegantly be computed by:</p> <pre><code>out = bsxfun(@times, permute(X.', [2 3 1]), b); </code></pre> <p><code>out</code> should contain a 3D matrix where each slice <code>i</code> stores the <code>M x 3</code> matrix of the resulting multiplication between column <code>i</code> of matrix <code>X</code> and <code>b</code>.</p> <hr> <h1>Step #3</h1> <p>You now wish to take each of these matrices (which are stored in <code>out</code>) and compute the multiplication with the transpose of <code>a</code>. Yes, you can do this without loops as well, but this will require a bit of manipulation. Matrix multiplication (the true definition) is only defined for 2D matrices. 3D matrices do not have such a definition. Therefore, what we will have to do is take all of our 2D slices in our 3D matrix and stack them so that they form a single 2D matrix. This 2D matrix will have each <code>M x 3</code> matrix from <code>out</code> stacked on top of each other, so that the total dimension of this matrix will be <code>NM x 3</code>. Once we do this, we can simply use this matrix and multiply this with the transpose of <code>a</code>. This will generate a <code>NM x 1</code> vector. This vector will have <strong>all</strong> of your <code>N</code> vectors of length <code>M</code> concatenated together into a single vector. To finally extract out the <code>N</code> length vectors, simply <code>reshape</code> the vector so that you get a <code>N x M</code> matrix. Now, this matrix will be stacked such that each <strong>row</strong> of the matrix contains one of the vectors you are seeking in the end. </p> <p>Therefore:</p> <pre><code>[M,N] = size(X); out2 = reshape(permute(out, [2 1 3]), [3 N*M]).'; out_vec = out2 * a.'; out_mat = reshape(out_vec, [M N]).'; </code></pre> <p>Finally, <code>out_mat</code> will contain that matrix we talked about. The first output vector is stored in <code>out_mat(1,:)</code>, the second output vector is stored in <code>out_mat(2,:)</code>, and so on and so forth.</p> <hr> <p>Hope this helps, and good luck!</p>