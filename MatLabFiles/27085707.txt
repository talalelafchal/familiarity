Cases where Morphological Opening and Closing yields the same results?
<p>I would like to know if there are any examples or cases where Opening and Closing Morphology operations on an single image produce the same results.</p> <p>As an example, let's say we have an image <code>X</code>, and we have done opening operation to produce <code>Y</code>. Similarly, we have done a closing operation on the original <code>X</code> to produce the same <code>Y</code>. I would like to know if there are examples for these type of images <code>X</code>. Programming examples in Python or MATLAB are also appreciated.</p>
<p>Yes, there are such images. One of the properties of opening (it's mentioned in <a href="https://en.wikipedia.org/wiki/Opening_(morphology)" rel="nofollow">wiki</a> article, for example) is that it is an anti-extensive operation, i.e. if Y is opening of X, then Y ⊆ X. Similarly, closing is an extensive operation (i.e. X ⊆ Y), therefore for any such image X = Y. Any image invariant to both opening and closing will satisfy your requirement (and, as I have just shown, <em>only</em> such images will).</p> <p>Concrete examples depend on structuring element used when performing erosion or dilation. For example, if it is a square n x n matrix with all elements equal to 1, then any rectangle with both height and width greater than n (and located far enough, i.e. at least n/2 pixels, from image edges) will satisfy this requirement.</p>
<p>Yes there are. As one small example, if you had a binary image where it consists of a bunch of squares that are disconnected and distinct. Provided that you specify a structuring element that is square, and choosing the structuring element so that it is smaller than the smallest square in the image, then doing either operation will give you the same results.</p> <p>If you did an opening on this image and a closing on this image, you will produce the same results. Remember, an opening is an erosion followed by a dilation where a closing is a dilation followed by an erosion. In terms of analyzing the shapes, erosion slightly shrinks the area of the image while dilation slightly enlarges it.</p> <p>By doing an erosion followed by a dilation (opening), you're shrinking the object and then growing it again. This will bring the image back to where it was before, provided that you choose the structuring element like what we talked about before. Similarly, if you did an dilation followed by an erosion (closing), you're growing the object and then shrinking it again, also bringing the image back to where it was before... following that same guideline I just talked about of course. </p> <p>If you were to choose a structuring element where it is larger than the smallest object, doing an opening will <strong>remove</strong> this object from the image, and so you won't get the original image back. Also, you need to make sure that the objects are well far away from each other, and that the size of the structuring element does not overlap any of the objects as you slide over and do the morphology operations. The reason why is because if you were to do a closing, you would join these two objects together and so that won't get you the same results either!</p> <hr> <p>Here's an example image that I generated that is binary:</p> <p><img src="https://i.stack.imgur.com/XGbZB.png" alt="enter image description here"></p> <p>To generate this image in MATLAB, you can do:</p> <pre><code>A = false(200,200); A(30:60,30:60) = true; A(90:110,90:110) = true; A(10:30, 135:155) = true; A(150:180,100:120) = true; </code></pre> <p>In Python, you can do this with <code>numpy</code>:</p> <pre><code>import numpy as np A = np.zeros((200,200), dtype='uint8') A[29:60,29:60] = 255 A[89:110,89:110] = 255 A[9:30, 134:155] = 255 A[149:180, 99:120] = 255 </code></pre> <p>The reason why I had to create the array as <code>uint8</code> in <code>numpy</code> is because when we want to show this image, I'm going to use OpenCV and it requires that the image be at least a <code>uint8</code> type.</p> <p>Now, let's choose a 5 x 5 square structuring element, and let's perform a closing and an opening with this image. We will display the results in a single figure going from left to right:</p> <pre><code>se = strel('square', 5); A_close = imclose(A, se); A_open = imopen(A, se); figure; subplot(1,3,1); imshow(A); title('Original'); subplot(1,3,2); imshow(A_close); title('Closed'); subplot(1,3,3); imshow(A_open); title('Open'); </code></pre> <p>This is the result:</p> <p><img src="https://i.stack.imgur.com/Ae9sR.png" alt="enter image description here"></p> <p>It certainly looks the same! To really show the difference, let's subtract the closed and opened result from the original image. You should get a blank image in the end if they're both equal to the original image.</p> <pre><code>figure; subplot(1,2,1); imshow(abs(double(A) - double(A_close))); subplot(1,2,2); imshow(abs(double(A) - double(A_open))); </code></pre> <p>Bear in mind that I converted the images to <code>double</code> to facilitate subtraction, and I used <code>abs</code> to ensure that negative differences are reflected. This is what I get:</p> <p><img src="https://i.stack.imgur.com/EZgGF.png" alt="enter image description here"></p> <p>As you can see, both results are totally blank, meaning they're exact copies of the original image after each result.</p> <p>The equivalent code in Python for the first part is the following:</p> <pre><code>import cv2 se = np.ones((5,5), dtype='uint8') A_close = cv2.morphologyEx(A, cv2.MORPH_CLOSE, se) A_open = cv2.morphologyEx(A, cv2.MORPH_OPEN, se) cv2.imshow('Original', A) cv2.imshow('Close', A_close) cv2.imshow('Open', A_open) cv2.waitKey(0) cv2.destroyAllWindows() </code></pre> <p>Here's what I get:</p> <p><img src="https://i.stack.imgur.com/ZVXh5.png" alt="enter image description here"></p> <p>You'll need to install the OpenCV package for this Python code. I displayed all of the images as three separate figures, then left the windows there until you choose any one of them and push a key. Once you do this, all of the windows will close. If you want to show the subtraction stuff, this is the code in Python:</p> <pre><code>A_close_diff = A - A_close A_open_diff = A - A_open cv2.imshow('Close Diff', A_close_diff) cv2.imshow('Open Diff', A_open_diff) cv2.waitKey(0) cv2.destroyAllWindows() </code></pre> <p>I didn't name the figures in MATLAB because what we're showing is obvious, but for OpenCV, you need to name the windows, and so I put names that describe what we're showing for each. I also didn't need to take the absolute value, because in <code>numpy</code>, doing arithmetic operations that result in an overflow or underflow will simply wrap around itself, while for MATLAB, the values get clipped. That's why for MATLAB, I needed to convert to <code>double</code> and take the absolute value because <code>imshow</code> doesn't display negative intensities or if we were to have a situation where we did <code>0 - 1</code>, the output would be 0 and you wouldn't be able to show that this location has a difference. With Python, doing <code>0 - 1</code> for <code>uint8</code>, will result in 255, so we can certainly see a difference here.... so there's no need to do any of this <code>abs</code> and casting stuff that we did in MATLAB. Here's what I get:</p> <p><img src="https://i.stack.imgur.com/hDnfC.png" alt="enter image description here"></p> <hr> <p>In general, you can reproduce what I did with any kind of shape and any size shape, so long as you choose a structuring element that mimics the properties of the shape that is in your image, and you choose a structuring element that is smaller than the smallest shape seen in that image. I'm sure there are many more examples that don't have to follow these specific guidelines, but this is the best example that I can think of at this moment.</p> <hr> <p>This should hopefully get you started.</p> <p>Good luck!</p>