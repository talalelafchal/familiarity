Dividing an image into N block in the width and calculating the edge points of each block Matlab
<p>Hello everyone I was trying to divide an image into N different blocks in the width after I performed this code to get its edge points:</p> <pre><code>Ioriginal = imread('sample.jpg') %read the image Igray = rgb2gray(Ioriginal) %change it to gray scale InoNoise = wiener2(Igray) %remove noise from image image = edge(InoNoise, 'prewitt') %get the edge points of the image </code></pre> <p>the result is shown in this picture: <img src="https://i.stack.imgur.com/ZvfoL.png" alt="enter image description here"></p> <p>Now what i want to do is dividing the image into N equal blocks in the <strong>width</strong> and calculate the edge points of each block</p> <p>After the division, the image should be divided this way: <img src="https://i.stack.imgur.com/oCtnt.png" alt="enter image description here"></p> <p>I really appreciate if someone can really help me doing this part</p> <p>Thank you</p>
<p>If I understand your question correctly, you want to decompose the edge detected image into <code>N</code> blocks where the height of each block is the height of the image, while the width of each block is computed such that it is of width <code>m</code>, where <code>N*m = width of image</code>. Therefore, each block's width is <code>width of image / N</code>. Bear in mind that you must choose a value of <code>N</code> such that it is evenly divisible by the width of your image. Your image has 460 columns, and so we can choose any number of blocks that is divisible by 10 for example.... so let's choose something like 10 blocks.</p> <p>The easiest way to decompose your image would be to use <a href="http://www.mathworks.com/help/matlab/ref/mat2cell.html" rel="nofollow noreferrer"><code>mat2cell</code></a>. This takes a 2D matrix and segments the matrix into pieces. Each piece would be stored in an individual element in a cell array. Therefore, you want to make sure that the height of each block is the same, and the width of each block is using that formula I gave you above. Therefore, you simply need to do this. I'm reading your example image that you posted directly from StackOverflow, but the image was actually uploaded as RGB. I converted it to binary directly so that we get an actual edge map:</p> <pre><code>N = 10; %// Declare total number of blocks im = im2bw(imread('http://i.stack.imgur.com/ZvfoL.png')); %// Read in image C = mat2cell(im, size(im,1), (size(im,2)/N)*ones(N,1)); </code></pre> <p><code>C</code> will contain your image blocks, where <code>C{idx}</code> will get you the image block located at index <code>idx</code>. If you want to make this into a 3D array, where each <strong>slice</strong> gives you the image block you want, simply use <a href="http://www.mathworks.com/help/matlab/ref/cat.html" rel="nofollow noreferrer"><code>cat</code></a> and concatenate in the third dimension like so:</p> <pre><code>C_matrix = cat(3, C{:}); </code></pre> <p>Therefore, to access the block at <code>idx</code>, simply do <code>C_matrix(:,:,idx)</code>.</p> <hr> <p>As a visual representation, let's display each block in a figure:</p> <pre><code>figure; hold on; for idx = 1 : N subplot(1,N,idx); imshow(C{idx}); %// Or imshow(C_matrix(:,:,idx)); end </code></pre> <hr> <p>This is what I get:</p> <p><img src="https://i.stack.imgur.com/GRzlt.png" alt="enter image description here"></p> <p>Basically, each block is placed in a separate figure within the window itself, which is why I'm using <code>subplot</code>. You can see that there is a white gap in between the blocks, which properly shows you each separated block within your image.</p> <hr> <p>Good luck!</p>