How to get MATLAB xlsread to read until a last row of a contiguous &lt;&lt;data-range&gt;&gt;?
<p>I want to use <code>xlsread</code> in MATLAB to read an Excel file.</p> <p>While I know which columns I want to read from, and which row I want to start reading from, the file could contain any number of rows.</p> <p><strong>Is there a way to do something like</strong>:</p> <pre><code>array = xlsread( 'filename', 'D4:F*end*' ); %% OR ANY SIMILAR SYNTAX </code></pre> <p>Where <strong><code>F*end*</code></strong> is the last row in column F?</p>
<p>In <code>xls</code> format excel files, <code>65536</code> seems to be limit of number of rows that you can use. You can use this number with <code>F</code> and that will basically tell MATLAB to search till the end of file. That's all I could gather from little digging up work on these and this trick/hack seems to work alright. </p> <p>To sum up, this seems to do the trick for <code>xls</code> files -</p> <pre><code>array = xlsread('filename', 'D4:F65536') </code></pre> <p>For <code>xlsx</code> files, the limit seems to be <code>1048576</code>, so the code would change to -</p> <pre><code>array = xlsread('filename', 'D4:F1048576') </code></pre> <hr> <p>External <a href="http://excelsemipro.com/2011/04/spreadsheet-size-in-excel-for-windows/" rel="nofollow">source</a> to confirm the limit on number of rows -</p> <blockquote> <p>Excel versions 97-2003 (Windows) have a file extension of XLS and the worksheet size is 65,536 rows and 256 columns. In Excel 2007 and 2010 the default file extension is XLSX and the worksheet size is 1,048,576 rows and 16,384 columns.</p> </blockquote>
<h2>No, But...</h2> <p>MATLAB does not have either documented or undocumented feature for doing this directly.</p> <p>The maximum one can use under direct MATLAB support is to:</p> <pre><code>___ = xlsread(filename,-1) opens an Excel window to interactively select data. Select the worksheet, drag and drop the mouse over the range you want, and click OK. This syntax is supported only on Windows systems with Excel software. </code></pre> <h2><strong>Still, how to approach the task efficiently and future-proof?</strong></h2> <p>The "blind" black-box approach would be to first test the boundary of the contiguous area, where your data is present -- use any feasible iterator, first forward-stepping by doubling a blind-test step-distance of a tested cell alike <code>aRowToTEST = ( aRowToStartFROM + aRowNumberDistanceToTEST )</code> and in case the tested cell contains a number, set <code>aLastNonEmptyROW = aRowToTEST;</code> double the <code>aRowNumberDistanceToTEST</code> and repeat.</p> <p>In case <code>aRowToTEST</code> points "behind" the format-specific maximum row number, set <code>aRowToStartFROM = aLastNonEmptyROW;</code> and reset the forward-stepping distance <code>aRowNumberDistanceToTEST = 1;</code> to continue forward-stepping iterations with a doubling-step stepping. If this again hits the limit, having the step <code>== 1</code> and yet pointing right "behind" the format-specific limit, your sheet-under-review contains data until its last row ( finishing on the format-specific "edge" ).</p> <p>But once the target cell <strong>is</strong> empty/NaN, stop the forward-stepping phase and start a standard back-stepping phase by halving the interval between a found/failed ( empty ) cell <code>aFirstEmptyROW = aRowToTEST;</code> and the last known cell at <code>aLastNonEmptyROW</code>, that contained number.</p> <p>Again, if a cell under test contained a fair value, move the <code>aLastNonEmptyROW</code>-boundary to <code>aRowToTEST</code> value, if not, move the same way <code>aFirstEmptyROW</code>-boundary.</p> <p>Finally set <code>aBackSteppingSTEP = ( aFirstEmptyROW - aLastNonEmptyROW )/2; aRowToTEST = aFirstEmptyROW - aBackSteppingSTEP;</code>.</p> <p>Iterate the above until your step is <strong><code>&lt; 1</code></strong> and thus you have iteratively found the contiguous data-area boundary.</p> <p>This is way faster and incomparably more efficient than a raw-dumb-import-whole-sheet and works until both a 64k or 1M or <em>any</em> further upper-limit of an XLS <code>rowNumber</code>.</p> <p>Having the boundary, simply <code>array = xlsread( 'filename', 'D4:F&lt;&lt;aLastNonEmptyROW&gt;&gt;' );</code></p>
<p>Yes. Try this:</p> <pre><code>FileFormat = '.xls' or '.xlsx'; % choose one % ( by default MATLAB % imports only '.xls' ) filename = strcat( 'Filename you desire', FileFormat ); array = xlsread( filename ) % This will read all % the Matrix ( by default % MATLAB will import all % numerical data from % file with this syntax ) </code></pre> <p>Then you can look to the size of the matrix to refine the search/import.</p> <pre><code>[nRows,nCols] = size( array ); </code></pre> <p>Then if the matrix you want to import just parts of the matrix, you can do this:</p> <pre><code>NewArray = xlsread( filename, strcat( 'initial cell', ':', 'ColumnLetter', num2str( nRows ) ) ); % for your case: NewArray = xlsread( filename, strcat( 'D3', ':', 'F', num2str( nRows ) ) ); </code></pre> <p>Hope this helps.</p>