Is there a way to catch an attempt to access a non existant property or method?
<p>For instance this code:</p> <pre><code>function stuff() { this.onlyMethod = function () { return something; } } // some error is thrown stuff().nonExistant(); </code></pre> <p>Is there a way to do something like PHP's <code>__call</code> as a fallback from inside the object?</p> <pre><code>function stuff() { this.onlyMethod = function () { return something; } // "catcher" function this.__call__ = function (name, params) { alert(name + " can't be called."); } } // would then raise the alert "nonExistant can't be called". stuff().nonExistant(); </code></pre> <p><strong>Maybe I'll explain a bit more what I'm doing.</strong></p> <p>The object contains another object, which has methods that should be accessible directly through this object. But those methods are different for each object, so I can't just route them, i need to be able to call them dynamically.</p> <p>I know I could just make the object inside it a property of the main object <code>stuff.obj.existant()</code>, but I'm just wondering if I could avoid it, since the main object is sort of a wrapper that just adds some functionality temporarily (and makes it easier to access the object at the same time).</p>
<p>There is a way to define a generic handler for calls on non-existant methods, but it is non-standard. Checkout the <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Object/NoSuchMethod" rel="nofollow noreferrer"><strong>noSuchMethod</strong></a> for Firefox. Will let you route calls to undefined methods dynamically. Seems like v8 is also <a href="http://dailyjs.com/2010/03/12/nosuchmethod/" rel="nofollow noreferrer">getting support</a> for it.</p> <p>To use it, define this method on any object:</p> <pre><code>var a = {}; a.__noSuchMethod__ = function(name, args) { console.log("method %s does not exist", name); }; a.doSomething(); // logs "method doSomething does not exist" </code></pre> <p>However, if you want a cross-browser method, then simple try-catch blocks if the way to go:</p> <pre><code>try { a.doSomething(); } catch(e) { // do something } </code></pre> <p>If you don't want to write try-catch throughout the code, then you could add a wrapper to the main object through which all function calls are routed.</p> <pre><code>function main() { this.call = function(name, args) { if(this[name] &amp;&amp; typeof this[name] == 'function') { this[name].call(args); } else { // handle non-existant method } }, this.a = function() { alert("a"); } } var object = new main(); object.call('a') // alerts "a" object.call('garbage') // goes into error-handling code </code></pre>
<p>You can also check if the method exists.</p> <pre><code>if(a['your_method_that_doesnt_exist']===undefined){ //method doesn't exist } </code></pre>
<p>It seems that you know your way around JS. Unfortunately, I don't know of such feature in the language, and am pretty sure that it does not exist. Your best option, in my opinion is either using a uniform interface and extend it, or extend the prototypes from which your objects inherit (then you can use instanceof before going forward with the method call) or use the somewhat cumbersome '&amp;&amp;' operator in order to avoid the access of nonexistent properties/methods:</p> <pre><code>obj.methodName &amp;&amp; obj.methodName(art1,arg2,...); </code></pre> <p>You can also extend the Object prototype with Anurag's suggestion ('call').</p>
<p>Well, it seems that with harmony (ES 6), there will be a way, and its quite more complicated if you compare it to the way other <a href="http://rosettacode.org/wiki/Respond_to_an_unknown_method_call#PHP" rel="nofollow">programing languages</a> do it, basically, it involves using the Proxy built in object, to create a wrapper on the object, and modify the way default behavior its implemented on it:</p> <pre><code>obj = new Proxy({}, { get : function(target, prop) { if(target[prop] === undefined) return function() { console.log('an otherwise undefined function!!'); }; else return target[prop]; } }); obj.f() ///'an otherwise undefined function!!' obj.l = function() {console.log(45);}; obj.l(); ///45 </code></pre> <p>Proxy will forward all not handled by handlers behavior into the normal object, so it will be like if it wheren´t there, and from proxy you can modify the target. There are also more handlers, even some to modify the prototype getting, and setters for any property access yes!.</p> <p>Has you would imagine, this isn´t supported in all browsers right now, but, in firefox you can play with proxy interface quite easy, just go ahead into the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" rel="nofollow">MDN docs</a></p> <p>It would make me more happy if the managed to add some sintactic sugar on this, but, anyway, its nice to have this kind of power in an already powerfull languaje. Have a nice day! :)</p> <p>PD: I didnt copy rosettacode js entry, I updated it.</p>