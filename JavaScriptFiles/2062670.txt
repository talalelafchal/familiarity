JavaScript Execution Order Problem
<p>The following works correctly: </p> <pre><code>alert("start"); loadData(); // takes a while alert("finished"); </code></pre> <p>loadData() is a method that inserts large amounts of data into a table in the DOM and takes a few seconds. </p> <p>This, however, does not work as expected: </p> <pre><code>document.getElementById("mydiv").style.display = "block"; loadData(); // takes a while document.getElementById("mydiv").style.display = "none"; </code></pre> <p>The data is loaded into the table without displaying mydiv until the loading is completed and then mydiv is quickly displayed and gone. </p> <p>But this works like it's supposed to: </p> <pre><code>document.getElementById("mydiv").style.display = "block"; alert("start"); loadData(); // takes a while alert("finish"); document.getElementById("mydiv").style.display = "none"; </code></pre> <p>mydiv is displayed, the alert dialog is shown, the data is loaded into the table, and then mydiv disappears, as expected. </p> <p>Anyone know why the second code section above does not work properly? </p>
<p>I dont know the exact reason, but i can think of is that LoadData is a heavy function so browser is busy evaluating that, so it holds the rendering. When u give alert in between it provides sufficient time to render div and then evaluate LoadData.</p> <p>Work Around:</p> <pre><code>function LoadData() { //Show Div here //window.setTimeout(newFunc,100); } function newFunc() { //Do data operations here //Hide Div } </code></pre>
<p>Think of javascript as inserting some interpreted code into a larger program. The larger program looks a little like this:</p> <pre><code>void eventLoop () { struct event event; while(event = getEvent()){ runJavascript(event); runBrowserCode(); if(viewHasChanged) { redrawViewRegions(); } } } </code></pre> <p>This isn't really accurate at all, but it gives you a little bit of an idea. While javascript code is running, the browser is not doing anything else: including updating the view. it hasn't got up to that bit. The browser gui does not run in a seperate asynchronous thread, in parallel to the javascript as you seem to imagine. The browser has to wait for javascript to finish before it can do anything.</p> <p>You can see the gui update when you use alerts, because, well- To display an alert you have to update the gui! so it's kind of a special case.</p>