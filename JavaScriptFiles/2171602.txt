setTimeout and anonymous function problem
<p>This is my code, SetOpacity get invoked with wrong values, why?</p> <pre><code>function SetOpacity(eID, opacity){ eID.style.opacity = opacity / 100; eID.style.filter = 'alpha(opacity=' + opacity + ')'; } function fade(eID, startOpacity, endOpacity){ var timer = 0; if (startOpacity &lt; endOpacity) { for (var i = startOpacity; i &lt;= endOpacity; i++) { setTimeout(function() {SetOpacity(eID, i);}, timer * 30); timer++; } } } </code></pre>
<p>This is a closure issue. By the time you run the function, <code>i</code> is already at <code>endOpacity</code>. This will work, by creating another closure:</p> <pre><code>function SetOpacityTimeout(eID, opacity, timer){ setTimeout(function() {SetOpacity(eID, opacity);}, timer * 30); } function fade(eID, startOpacity, endOpacity){ var timer = 0; if (startOpacity &lt; endOpacity) { for (var i = startOpacity; i &lt;= endOpacity; i++) { SetOpacityTimeout(eID,i,timer); timer++; } } } </code></pre>
<p>Kobi has the right idea on the problem. I suggest you use an interval instead, though.</p> <p>Here's an example: (Your SetOpacity function remains the same, I left it out here.)</p> <pre><code>function fade(eID, startOpacity, endOpacity){ var opacity = startOpacity; SetOpacity(eID, opacity); var interval = window.setInterval(function(){ opacity++; SetOpacity(eID, opacity); // Stop the interval when done if (opacity === endOpacity) window.clearInterval(interval); }, 30); } </code></pre>
<p>This should work:</p> <pre><code>for (var i = startOpacity; i &lt;= endOpacity; i++) { (function(opacity) { setTimeout(function() {SetOpacity(eID, opacity);}, timer * 30); })(i); timer++; } </code></pre> <p>This works as follows:</p> <ul> <li>inside loop you create anonymous function (<code>function(...){...}</code>) and immediately call it with parameter (that's why there are parenthesis around <code>function(){}</code>, so you can call it adding <code>()</code> at end and pass parameters)</li> <li>parameters passed to this anonymous function (<code>i</code> value, which is <code>opacity</code> inside function) are local to this anonymous function, so they don't change at next steps of loop, and you can safelly pass them to another anonymous function (this at <code>setTimeout</code>)</li> </ul> <p>Your original version didn't worked because:</p> <ul> <li>your function passed to <code>setTimeout</code> holds reference to variable <code>i</code> (not value of it), and it gets value when this function is called, which is not at time of adding it to <code>setTimeout</code></li> <li>the value of this variable gets changed in loop, and before you even get first <code>setTimeout</code> it gets <code>endOpacity</code> value (last value from <code>for</code> loop)</li> </ul> <p>Unfortunately JavaScript only has function scope, so it won't work if you create variable inside the loop and assign new actual value, because whenever there is some <code>var</code> inside function, those variables are created at time of function execution (and get <code>undefined</code> value by default). The only (easy) way to create new scope is to create function (may be anonymous) and create new variables inside them (parameters are variables too)</p>
<p>This is am example I used with jquery. "menuitem" is the itemclass and jquery checks the "recentlyOut" class to see if it needs to slide back up.</p> <p>The code speaks for itself. </p> <pre><code>$(".menuitem").mouseenter( function(){ $(this).addClass("over").removeClass("out").removeClass("recentlyOut"); $(this).children(".sub").slideDown(); }); $(".menuitem").mouseleave( function(){ $(this).addClass("out").addClass("recentlyOut").removeClass("over"); setTimeout(function() { var bool = $(".recentlyOut").hasClass("over"); if (!bool) { $(".recentlyOut").removeClass("recentlyOut").children(".sub").slideUp(); } } , 400); } ); </code></pre>