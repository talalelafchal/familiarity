External Javascript Timeout
<p>I have a number of tracking scripts and web services installed on my website and I noticed when one of the services goes down, it still tries to call the external javascript file hosted on a different server. In Firefox, Chrome and other new browsers, there doesn't seem to be any issues when one of the services go down. However, in IE7 and IE8, my pages don't load all the way and time out before everything is displayed. Is there any way to add a time out on these javascript calls to prevent them from breaking my pages when they go down? </p>
<p>Try adding <a href="http://www.websiteoptimization.com/speed/tweak/defer/" rel="nofollow noreferrer"><code>defer="defer"</code></a></p> <blockquote> <p>The defer attribute gives a hint to the browser that the script does not create any content so the browser can optionally defer interpreting the script. This can improve performance by delaying execution of scripts until after the body content is parsed and rendered.</p> </blockquote> <p><b>Edit</b> <br> This will prevent those scripts from running until the page loads:</p> <pre><code>function loadjs(filename) { var fileref=document.createElement('script'); fileref.setAttribute("type","text/javascript"); fileref.setAttribute("src", filename); } window.onLoad = function() { loadJs("http://path.to.js"); loadJs("http://path.to2.js"); ... } </code></pre>
<p>You can load them dynamically after page load with JS. If the JS files are on a different server, the browser will still show a "browser busy" indicator when you do that, but the original page will load.</p> <p>If you can fetch the JS from your own site, you can load it with <code>XMLHttpRequest</code> after page load (or with your favorite JS library's helpers, e.g. jQuery's <code>$.ajax(...)</code>) and then eval it. This way the fetching itself won't show the browser-busy indicator.</p> <p>To fetch the JS from your own site, you can download it from your tracking provider (which won't be officially supported but usually works) - just remember to refetch new versions every once in a while - or you can create a "forwarding" service on your own site that fetches it from the tracking provider and caches it locally for a while. This way your JS won't be in danger of staleness.</p> <p>Steve Souders has more information about <a href="http://www.stevesouders.com/blog/2009/04/27/loading-scripts-without-blocking/" rel="nofollow noreferrer">deferred loading of scripts and browser-busy indicators</a>.</p>
<p>If you need to load external scripts and you want to enforce a timeout limit, to avoid having a busy indicator running for too long, you can use setTimeout() with window.stop() and, the IE equivalent:</p> <p><a href="http://forums.devshed.com/html-programming-1/does-window-stop-work-in-ie-1311.html" rel="nofollow">http://forums.devshed.com/html-programming-1/does-window-stop-work-in-ie-1311.html</a></p> <pre><code> var abort_load = function() { if(navigator.appName == "Microsoft Internet Explorer") { window.document.execCommand('Stop'); } else { window.stop(); } }; /** * Ensure browser gives up trying to load JS after 3 seconds. */ setTimeout(abort_load, 3000); </code></pre> <p>Note that window.stop() is the equivalent of the user clicking the stop button on their browser. So typically you'd only want to call setTimeout() after page load, to ensure you don't interrupt the browser while it's still downloading images, css and so on.</p> <p>This should be combined with the suggestions made by orip, namely to load the scripts dynamically, in order to avoid the worst case of a server that never responds, resulting in a "browser busy" indicator that's active until the browser's timeout (which is often over a minute). With window.stop() in a timer, you effectively specify how long the browser can try to load the script.</p> <p>Also note that setTimeout()'s interval is not that precisely interpreted by browsers so round up in terms of how much time you want to allow to load a script.</p> <p>Also, one counter-indication to using window.stop() is if your page does things like scroll to a certain position via js. You might be willing to live with that but in any case you can make the stop() conditional on NOT having already loaded the content you expected. For example if your external JS will define a variable foo, you could do:</p> <pre><code>var abort_load = function() { if (typeof(foo) == "undefined") { if(navigator.appName == "Microsoft Internet Explorer") { window.document.execCommand('Stop'); } else { window.stop(); } } }; </code></pre> <p>This way, in the happy path case (scripts do load within timeout interval), you don't actually invoke window.stop().</p>