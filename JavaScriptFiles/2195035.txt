Javascript function called twice, how to handle this?
<p>My application is a LiveChat developed in C# and ASP.NET</p> <p>I have a Client timer which call the webservice Function RetrieveMessages() every second. Additionally, soon after the user send a message i'm call de same function RetrieveMessages().</p> <p>I have a variable that store the last message Id, so, every RetrieveMessage call retrieve only the messages that is unread.</p> <p>Sometimes the the client show the same message twice, like so:</p> <p>Ewerton (14:22:20) : Hello! Ewerton (14:22:20) : Hello!</p> <p>the duplicity occurs only in client, the DataBase table is ok, no duplications.</p> <p>I suspect tha the Timer, and the Send Message is executing a RetrieveMessage before the variable lastMessageId is updated.</p> <p>How can i synchronize the call of the RetrieveMessage() ?</p> <p>Here are some code to analise.</p> <pre><code> // ThisFunction is a callback that RetrieveMessage every time the user send's a message function SendMessageSucess(cdMsgEnviada) { //Carrega Mensagens Avalon.Services.ChatService.RetrieveMessages(CodChamado, IdLastMsg, RetrieveMessagesSucess); } </code></pre> <p>OnTImer Tick</p> <pre><code> // Every second, verify is exist new messages function timer_onTick() { //Carrega Mensagens Avalon.Services.ChatService.RetrieveMessages(CodChamado, IdLastMsg, RetrieveMessagesSucess); } </code></pre> <p>The RetrieveMessages function</p> <pre><code>function RetrieveMessagesSucess(result) { var myMsgs = new Array(); for (var i = 0; i &lt; result.length; i++) { var obj = eval('(' + result[i] + ')'); if (obj != null) myMsgs[i] = obj; } for (var j = 0; j &lt; myMsgs.length; j++) { if (myMsgs.length &gt; 0) { // Armazeno o codigo da ultima mensagem recebida IdLastMsg = myMsgs[myMsgs.length - 1].cd_chat_message; if (par) { var novoconteudo = "&lt;div style='background-color: #EFEFEF; padding: 10px;'&gt;" par = false; } else { var novoconteudo = "&lt;div style='padding: 10px;'&gt;" par = true; } if (myMsgs[j].origem_mensagem == 1) // Msg enviada pelo cliente novoconteudo = novoconteudo + "&lt;b&gt;" + myMsgs[j].solicitante + ": &lt;/b&gt;" else novoconteudo = novoconteudo + "&lt;b&gt;" + myMsgs[j].tecnico + ": &lt;/b&gt;" var objDate = eval(myMsgs[j].datahora.replace(/\/Date\((\d+)\)\//gi, "new Date($1)")); novoconteudo = novoconteudo + "(" + objDate.format("HH:MM:ss") + ") "; novoconteudo = novoconteudo + myMsgs[j].texto + "&lt;/div&gt;"; divChatHistory.append(novoconteudo); AutoScroll(); if (myMsgs[j].origem_mensagem == 2) // Msg enviada por um tecnico show_popAlert() } } // Verifico se o chat esta ativo IsChatInativo(); } </code></pre> <p>Any Ideas ?</p>
<p>Jage, your solution works fine. I do some adaptations in the RetrieveMessages Lets see the code:</p> <pre><code> function RetrieveMessagesSucess(result) { // parsin the json and storing the messages in a array var myMsgs = new Array(); for (var i = 0; i &lt; result.length; i++) { var obj = eval('(' + result[i] + ')'); if (obj != null) myMsgs[i] = obj; } for (var j = 0; j &lt; myMsgs.length; j++) { if (myMsgs.length &gt; 0) { // Verifing if the message already exists var divExiste = document.getElementById(myMsgs[j].cd_chat_message); // If not exists, put the message on the page if (divExiste == null) { // Storing the id of tha last received message. This is useful as a parameter to retrieve messages again IdLastMsg = myMsgs[myMsgs.length - 1].cd_chat_message; // Trick to a zebra style if (par) { var novoconteudo = "&lt;div id='" + myMsgs[j].cd_chat_message + "' style='background-color: #EFEFEF; padding: 10px;'&gt;" par = false; } else { var novoconteudo = "&lt;div id='" + myMsgs[j].cd_chat_message + "' style='padding: 10px;'&gt;" par = true; } // Putting the message on page if (myMsgs[j].origem_mensagem == 1) // Msg enviada pelo cliente novoconteudo = novoconteudo + "&lt;b&gt;" + myMsgs[j].solicitante + ": &lt;/b&gt;" else novoconteudo = novoconteudo + "&lt;b&gt;" + myMsgs[j].tecnico + ": &lt;/b&gt;" var objDate = eval(myMsgs[j].datahora.replace(/\/Date\((\d+)\)\//gi, "new Date($1)")); novoconteudo = novoconteudo + "(" + objDate.format("HH:MM:ss") + ") "; novoconteudo = novoconteudo + myMsgs[j].texto + "&lt;/div&gt;"; divChatHistory.append(novoconteudo); AutoScroll(); if (myMsgs[j].origem_mensagem == 2) // Msg enviada por um tecnico show_popAlert() } } } IsChatInativo(); } </code></pre> <p>Thats it guys.</p> <p>Thanks a lot!</p> <p>excuse my bad English =o)</p>
<p>try to disable your timer when you enter the tick method and re-enable it before you leave the method.</p>
<p>Set a global variable that is an object and create a new property in it whenever you add a new message to the conversation. Use your message ID in the name of the new property and set it to true or something. If each of your messages has a unique ID, then you can just verify that you haven't already processed that message before proceeding by checking for the existence of that message ID's specific property in your object. </p> <p>Might look something like:</p> <pre><code>var PROCESSED_MSGS = new Object(); </code></pre> <p>and then later...</p> <pre><code>for (var j = 0; j &lt; myMsgs.length; j++) { if (myMsgs.length &gt; 0) { thisMsgId = myMsgs[j].id; if(PROCESSED_MSGS['msg'+thisMsgId]) continue; PROCESSED_MSGS['msg'+thisMsgId] = true; //keep going.... </code></pre>