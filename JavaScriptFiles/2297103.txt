Easy way to evaluate path-like expressions in Javascript?
<p>If I have a JavaScript object such as:</p> <pre><code>var x = {foo: 42, bar: {fubar: true}} </code></pre> <p>then I can get the value <code>true</code> with <code>var flag = x.bar.fubar</code>. I'd like to be able to separate out and store the path <code>"bar.fubar"</code>, then evaluate it dynamically. Something like:</p> <pre><code>var paths = ["bar.fubar", ...]; ... var flag = evalPath( x, paths[0] ); </code></pre> <p>Obviously I could write a simple parser and evaluator for a basic path expression grammar. But under DRY principles I wonder if there's already an existing way to do something like <code>evalPath</code> built-in to JavaScript, or a small library that would do the job? I also anticipate needing array indexes in the path expression in future.</p> <p><strong>Update</strong> Just to be clear, I'm not asking for code samples - my question is whether there's existing code (built-in or library) I can re-use. Thanks to the contributors below for suggestions of code samples anyway! Note that none of them handle the array index requirement.</p>
<p>JavaScript provides <code>eval</code>, but I don't recommend it.</p>
<p>Why not try something like</p> <pre><code>function evalPath(obj, path) { var rtnValue = obj; // Split our path into an array we can iterate over var path = path.split("."); for (var i = 0, max=path.length; i &lt; max; i++) { // If setting current path to return value fails, set to null and break if (typeof (rtnValue = rtnValue[path[i]]) == "undefined") { rtnValue = null; break; } } // Return the final path value, or null if it failed return rtnValue; } </code></pre> <p>Not tested, but it should work fairly well. Like XPath, it will return null if it can't find what it's looking for.</p>
<p>like </p> <pre><code>function locate(obj, path) { var p = path.split("."), a = p.shift(); if(a in obj) return p.length ? locate(obj[a], p.join(".")) : obj[a]; return undefined; } locate(x, "bar.fubar") </code></pre> <p>this works on the right only, of course</p>
<p>You could try something like this. I can't really think of a situation where it would be appropriate to store paths this way though.</p> <pre><code>function evalPath(obj, path) { var pathLevels = path.split('.'); var result = obj; for (var i = 0; i &lt; pathLevels.length; i++) { try { result = result[pathLevels[i]]; } catch (e) { alert('Property not found:' + pathLevels[i]); } } return result; } </code></pre> <p>The <code>alert</code> is really only there for debugging purposes. You may want to return <code>null</code> or something.</p>
<p>Doing a quick search, I came across <a href="http://goessner.net/articles/JsonPath/" rel="nofollow noreferrer">JSONPath</a>. Haven't used it at all, but it looks like it might do what you want it to.</p> <p>Example usage:</p> <pre><code>var x = {foo: 42, bar: {fubar: true}} var res1 = jsonPath(x, "$.bar.fubar"); // Array containing fubar's value </code></pre>
<p>How about:</p> <pre><code>evalPath = function(obj, path) { if (path[0] === "[") { return eval("obj" + path); } else { return eval("obj." + path); } }; </code></pre> <p>This has the advantage that it works for arbitrary strings:</p> <p>evalPath([1,2,3], "[0]"); => 1</p> <p>evalPath({a:{b:7}}, "a.b"); => 7</p> <p>This, of course, only works if you really trust your input.</p>