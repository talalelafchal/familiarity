JavaScript idiom: !something &amp;&amp; function()
<p>I have been looking at the source code of <a href="http://raphaeljs.com/index.html" rel="nofollow noreferrer">raphael.js</a> and I see a lot of stuff like <code>!variable &amp;&amp; function()</code> (e.g.: <code>!svg.bottom &amp;&amp; (svg.bottom = this);</code> )</p> <p>What does that exactly do? Does it check first and execute only if not true?</p>
<p>It uses short-circuiting rules to perform the second part of the expression (which actually includes assignment) only if the first part (<code>!svg.bottom</code>) is not false. That is if svg.bottom is <code>null</code> - set it to <code>this</code>.</p>
<p>Correct. This is (ab)using short-circuit evaluation. A boolean expression is only executed as far as is needed to determine the result. In your example, if <code>svg.bottom</code> is non-null, then <code>!svg.bottom</code> is <code>false</code>, and the result of the <code>&amp;&amp;</code> is <code>false</code>, so execution of the right hand side does not happen. It's basically equivalent to <code>if(!svg.bottom)svg.bottom = this;</code></p>
<p>Javascript has many strange casting conventions. The <code>!</code> operator will cast to a boolean. If the test fails, the part after <code>&amp;&amp;</code> will not be run.</p> <p>Some examples:<br> <code>!undefined</code> is true<br> <code>!false</code> is true<br> <code>!0</code> is true <code>!1</code> is false<br> <code>!"hello"</code> is false </p>
<p>There are two handy ways of using logical operators in JS, because they are not merely boolean operators.</p> <p>With <code>&amp;&amp;</code>, you can say "if this expression is true, it's safe to evaluate the next expression". The most common usage is to check if a property is non-null before digging further inside it:</p> <pre><code>var result = myObj.person &amp;&amp; myObj.person.firstName; </code></pre> <p>If <code>myObj.person</code> is undefined, the value of <code>result</code> will be undefined also.</p> <p>With <code>||</code>, you can say "take the value of this expression if it's truthy (not null or undefined in this context), otherwise use a default":</p> <pre><code>var result = person.firstName || "Sid"; </code></pre> <p>Combining the two:</p> <pre><code>var result = (myObj.person &amp;&amp; myObj.person.firstName) || "Sid"; </code></pre> <p>A quick way to say "get the <code>firstName</code> from the <code>person</code> property of <code>myObj</code>, or use "Sid" if the <code>person</code> has no <code>firstName</code> or <code>myObj</code> has no <code>person</code>".</p> <p>The example you refer to is a bit strange though. Doing a side-effecting operation inside an expression is a bit ugly. It's usually easier to keep track of what you're program is doing if you clearly separate "read-only" expressions from variable-mutating statements.</p>
<p>When you have boolean operations, the compiler start check the one by the other, and stop when its sure for the results - for example if you ask </p> <pre><code>if(a &amp;&amp; b &amp;&amp; c) { } </code></pre> <p>if <strong>a</strong> is false, then the <strong>boolean is false</strong>, and compiler <strong>did not</strong> need to check b and c. <strong>This compiler future is used to short the writing code for some cases.</strong></p> <p>This is (for me) a bad practice that writing code.</p> <pre><code>!variable &amp;&amp; function() </code></pre> <p>instide of</p> <pre><code>if(!variable) function(); </code></pre> <p>try to minimize the size of the javascript ?</p> <p>Dificult to debug, and dificult to find what actually dose in many cases.</p> <p>See this similar code.</p> <pre><code>unsigned uCycleCheckBox(unisgned uCur) { return ((uCur &lt;= 1) ? (uCur?0:1) : (uCur==4)?2:(uCur+1)); } </code></pre> <p>is the same think... hard to understand, hard to debug, hard to change and fix in case of problems.</p> <p>For the comments on that, I suggest to read the books, Writing Solid Code, and Debbuging the deveopment process.</p> <p>Writing solid code is more important than enything else.</p>