Extend descendent object in javascript
<p>I've been learning more about javascript's prototypal inheritance. I know there is a somewhat fierce debate on whether to extend native objects and I'd like to side step that whole debate entirely in this question.</p> <p>Is it possible to extend only descendent object in javascript?</p> <p>To extend all objects I can do this:</p> <pre><code>Object.prototype.size = function(){ var length = 0; for(var i in this){ if(this.hasOwnProperty(i)){ length++; } } return this; } </code></pre> <p>But the problem is that It extends all objects. What I'd like to do is have this:</p> <pre><code>var MyNameSpace = function(){ }; MyNameSpace.Object.prototype.size = function(){ var length = 0; for(var i in this){ if(this.hasOwnProperty(i)){ length++; } } return this; } </code></pre> <p>That way I would only be extending the native objects in the scope of my global object.</p> <p>any suggestions would be great thanks</p> <p>Update:<br> In response to a few comments I'm adding more code to clarify what I'm trying to do.</p> <p>I think i may have not phrased my question correctly, or maybe my thinking is incorrect, but what i'd like to be able to do is this:</p> <pre> <code> var my = new MyNameSpace(); var my.name = {firstName : 'Hello', lastName : 'World'}; var nameCount = my.name.size(); // 2 </code> </pre> <p>the code you provided will allow me to get the size of each MyNameSpace object I create, but not the object literals that are properties of the MyNameSpace object</p>
<p>You could use "pseudo-classical" inheritance style to achieve it:</p> <pre><code>var MyNameSpace = function() { this.v1 = null; this.v2 = null; } MyNameSpace.prototype.size = function() { var length = 0; for(var i in this){ if(this.hasOwnProperty(i)){ length++; } } return this; } var my = new MyNameSpace(); // create new object based on MyNameSpace my.size(); // length would be 2 </code></pre> <p>What you define on a function object's <code>prototype</code> would be inherited by all the function objects created via <code>new</code> operator.</p> <p><strong>Updated</strong> code, according to your added requirements,</p> <pre><code>var obj = {}; var MyNameSpace = function(props) { for(var name in props) { this[name] = props[name]; } } MyNameSpace.prototype.size = function() { var length = 0; for(var i in this){ if(this.hasOwnProperty(i)){ length++; } } return this; } obj.name = new MyNameSpace({firstName : 'Hello', lastName : 'World'}); obj.name.size(); // length would be 2 </code></pre>
<p>In your code</p> <pre><code>var my = new MyNameSpace(); var my.name = {firstName : 'Hello', lastName : 'World'}; var nameCount = my.name.size(); // 2 </code></pre> <p><code>my.name</code> is obviously traversable from <code>my</code>, but the opposite is not true. That means that properties of <code>my</code> cannot be accessed from <code>my.name</code>, and <code>my</code> is nowhere to be found in the prototype chain of <code>my.name</code>. If you don't want to inherit directly from MyNameSpace you have to explicitly "hang on" whatever functions you would like to inherit.</p> <p>You could do</p> <pre><code>my.name.size = my.size; </code></pre> <p>alternatively (without having to instantiate MyNameSpace):</p> <pre><code>my.name.size = MyNameSpace.prototype.size; </code></pre> <p>if you have only few functions to "inherit". Or you could define an inherit function in MyNameSpace as follows:</p> <pre><code>MyNameSpace.prototype.addToNameSpace = function(obj) { obj.size = this.size; // obj.propertyI = this.propertyI, etc. } </code></pre> <p>Note that I don't use <code>for..in</code> here as that would add the <code>addToNameSpace</code> function as well.</p> <p>Hope this helps</p>