Got a question I don't understand, can anyone make sense of it?
<p>Question from an online resource paper:</p> <pre><code>Create javascript so that the following methods produce the output listed next to them. circle = new Circle(); console.log(circle.get_area()); // 3.141592653589793 circle.set_radius(10); console.log(circle.get_area()); // 314.1592653589793 console.log(circle); // the radius of my circle is 10 and its area is 314.1592653589793 </code></pre> <p>Can anyone understand what is being asked?</p> <p>Here is a copy of my comment below in pretty format:</p> <pre><code>function Circle() { this.pi=3.141592653589793; this.radius; } Circle.prototype={ get_area: function(){ return this.radius*this.pi; }, set_radius: function(radius){ return this.radius=radius; } }; circle=new Circle(); circle.set_radius(100); </code></pre> <p>Okay I've played around with this and kind of get the gist of what is happening, although I'm unsure as to when or why one would need to write in this technique; if someone could explain I'd perhaps have a better understanding of its uses.</p> <p>My final code is as follow: -</p> <pre><code>function Circle(r) { this.pi=Math.PI; } Circle.prototype={ get_area: function(){ return this.radius*this.pi; }, set_radius: function(radius){ return this.radius=radius; } }; var circle=new Circle(); circle.set_radius(100); Circle.prototype.toString=function(){ return 'The radius of my circle is '+circle.radius+' and it\'s area is '+this.get_area(); } console.log(circle); </code></pre> <p>I'm not entirely sure if I'm using Circle.prototype.toString=function() correctly as all it seems to do is create a string.</p>
<p>They're asking you to create a <em>constructor function</em> called <code>Circle</code> which creates objects that will have <code>get_area</code>, <code>set_radius</code>, and <code>toString</code> functions that behave in the way indicated. (<code>toString</code> is what will be used in the final statement, where you're outputting the value of the <code>circle</code> instance.) They're probably expecting you to give the objects those functions via the <code>Circle</code> prototype (see below).</p> <p><code>Circle</code> is a <em>constructor function</em> because it creates new objects (well, technically it just <em>populates</em> them; they're <em>created</em> by the <code>new</code> operator). Sometimes people call these <em>classes</em>, but they're not really classes in the genuine class-based OOP way (they're constructor functions in the genuine prototype-based OOP way used by JavaScript).</p> <p>There are a few ways to do this, but again, typically you'd have a <code>Circle</code> function that sets up the properties for an instance on <code>this</code>, and then assign functions to the <code>Circle.prototype</code>, which all objects created via <code>new Circle</code> will inherit. I'd dash off an example but my impression is that this is a learning exercise, so best left to the reader. But there are some pointers:</p> <ul> <li>Inside the constructor function, you can refer to the object created by the <code>new</code> operator using the keyword <code>this</code>.</li> <li>The constructor function <em>object</em> will have a property on it called <code>prototype</code>. If you assign properties to that prototype, they'll be inherited by instances created with your constructor function (inherited through something called the <em>prototype chain</em>). So if I have a constructor function <code>Foo</code>, I can set a property (say, <code>bar</code>) on <code>Foo.prototype</code> (<code>Foo.prototype.bar = /* whatever */;</code>) and all instances created via <code>new Foo()</code> will have a <code>bar</code> property with that value.</li> <li>Functions in JavaScript are first-class objects. You can refer to them just like you can refer to strings or numbers. If I have <code>function foo() { /* ... */ }</code>, I can set a variable <code>x</code> to refer to it (<code>var x = foo;</code>) and then call it via that variable (<code>x();</code>).</li> <li>Just like <code>x</code> can refer to a function, the <code>bar</code> property I mentioned above can refer to a function.</li> </ul> <p>Hopefully that puts you on the right track without giving the game entirely away.</p> <p>Re your comment about references for learning more about JavaScript:</p> <ul> <li>I found the book <em>JavaScript: The Definitive Guide</em> by David Flanagan (from O'Reilly) to be very good. It may be getting a bit dated, the fifth edition is now several years old.</li> <li>There are a bunch of articles from well-respected JavaScript guru Douglas Crockford at <a href="http://javascript.crockford.com" rel="nofollow noreferrer">http://javascript.crockford.com</a>, but I warn you that Crockford is terse. :-) Smart and informed, though, even if one doesn't always agree with his conclusions.</li> <li>I really don't like to refer to my blog <em>[because A) SO is not about self-promotion, and B) "anemic" doesn't half say it]</em> but there are <a href="http://blog.niftysnippets.org/2008/03/mythical-methods.html" rel="nofollow noreferrer">a couple</a> of <a href="http://blog.niftysnippets.org/2008/02/closures-are-not-complicated.html" rel="nofollow noreferrer">posts there</a> that I think <a href="http://blog.niftysnippets.org/2008/04/you-must-remember-this.html" rel="nofollow noreferrer">might help</a>.</li> </ul> <p>Re my comment below: Really I can't leave this without an example, because it's just not helpful to do so. So here's an example of a constructor function and some functions associated with it:</p> <pre><code>// A constructor function called `Person` function Person(fname, lname) { // Within the constructor, we can refer to the new instance via `this`. // Let's remember the names we were given. this.firstName = fname; this.lastName = lname; // Now, the instance that is returned from `new Person(...)` will have // those properties on it. } // Let's give the Person prototype a function that returns the person's // full name. Person.prototype.getFullName = function() { return this.firstName + " " + this.lastName; }; // Okay, let's see `Person` in action: var p = new Person("John", "Doe"); console.log(p.firstName); // "John" -- this is referencing the property we set in the constructor console.log(p.getFullName()); // "John Doe" -- this calls the function we get from the prototype // `p` has the `getFullName` function because it inherits it from the // `Person.prototype` object. // Let's see what happens if I try to output the instance itself: console.log(p); // Most like you get "[object Object]" or similar -- not useful! // In that sort of situation, JavaScript will use a function called `toString` // to get a string equivalent of the instance. (It's more complicated than that, // but you don't want me to go into the details here.) So let's give // `Person.prototype` a `toString` function that does something useful: Person.prototype.toString = function() { return this.getFullName(); }; // Note there that we're using `this` again. When a function is called through // an object property (e.g., `p.toString()`), within the function call `this` // refers to the object instance. `this` is an important and flexible concept // in JavaScript and very much unlike its counterpart in (say) Java or C++, // even though in simple situations (like this) it looks similar. // Now let's try it: console.log(p); // "John Doe", because the interpreter implicitly calls `toString` for you // "Hey, wait a minute!" I hear you saying, "You didn't make a new `p`! How did it // get the new function?!" The answer is it got it the same way it got `getFullName`: // from `Person.prototype`. The `p` instance *refers* to the `Person.prototype`, it // doesn't have a *copy* of it. So changes to `Person.prototype` show up in `p` // (unless `p` overrides them, which we aren't doing in this example). </code></pre> <p>(That example uses anonymous functions, which I'm <a href="http://blog.niftysnippets.org/2010/03/anonymouses-anonymous.html" rel="nofollow noreferrer">not a fan of</a>, but I didn't want to get into the whole discussion of named functions here.)</p> <hr> <p>(OT: Being picky, the person posing this question to you really should have declared the <code>circle</code> variable at the very beginning: <code>var circle;</code> Also, note that <code>console.log</code> may not exist in all JavaScript implementations -- it's best known from Firefox+Firebug.)</p>
<p>I guess what's being asked is implementing a <code>toString()</code> function (or whatever its equivalent in JS is) for the Circle class that will look up <code>this.get_radius()</code> and <code>this.get_area()</code> and output a nicely formatted string: "the radius of my circle..."</p>
<p>You are supposed to implement javascript functions to create a Circle object with get_area() and set_radius() functions which will allow the script as shown to run.</p>
<p>You need to write the "Circle" class in javascript so that:</p> <p>By default its area is PI (3.141592653....) or 22 / 7</p> <p>The Radius property of the circle object would be 1 initially because area of circle = PI * R * R</p> <p>Setting Radius to 10 makes the formula PI * 10 * 10 = 314.1592653....</p> <p>I guess its pretty simple that now you can write the javascript code by yourself.</p>