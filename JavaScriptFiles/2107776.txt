Implementing instance methods/variables in prototypal inheritance
<p>I've been playing around with prototypal inheritance after reading <a href="http://javascript.crockford.com/prototypal.html" rel="nofollow noreferrer">http://javascript.crockford.com/prototypal.html</a> and having a bit of a problem with understanding how I could make use of it in the way I would use classical inheritance. Namely, all functions and variables inherited by the prototype essentially become statics unless they are overwritten by the child object. Consider this snippet:</p> <pre><code>var Depot = { stockpile : [], loadAmmo : function (ammoType) { this.stockpile.push(ammoType); } }; var MissileDepot = Object.create(Depot); var GunDepot = Object.create(Depot); </code></pre> <p><code>stockpile</code> and <code>loadAmmo</code> definitely should be in the prototype, since both MissileDepot and GunDepot have them. Then we run:</p> <pre><code>MissileDepot.loadAmmo("ICBM"); MissileDepot.loadAmmo("Photon Torpedo"); alert(MissileDepot.stockpile); // outputs "ICBM,Photon Torpedo" alert(GunDepot.stockpile); // outputs "ICBM,Photon Torpedo" </code></pre> <p>This is expected because Neither <code>MissileDepot</code> nor <code>GunDepot</code> actually have <code>stockpile</code> or <code>loadAmmo</code> in their objects, so javascript looks up the inheritance chain to their common ancestor.</p> <p>Of course I could set GunDepot's stockpile manually and as expected, the interpreter no longer needs to look up the chain</p> <pre><code>GunDepot.stockpile = ["Super Nailgun", "Boomstick"]; alert(GunDepot.stockpile); // outputs "Super Nailgun,Boomstick" </code></pre> <p>But this is not what I want. If this were classical inheritance (say Java), loadAmmo would operate on MissileDepot and GunDepot's stockpile independently, as an instance method and an instance variable. <strong>I would like my prototype to declare stuff that's common to children, not shared by them.</strong></p> <p>So perhaps I'm completely misunderstanding the design principles behind prototypal inheritance, but I'm at a loss as how to achieve what I've just described. Any tips? Thanks in advance!</p>
<p>To achieve what you want, you need a cloning method. You don't want an inheritance prototype, you want a cloning prototype. Take a look at one of the Object.clone() functions already implemented, like prototypejs's one: <a href="http://api.prototypejs.org/language/object.html#clone-class_method" rel="nofollow noreferrer">http://api.prototypejs.org/language/object.html#clone-class_method</a></p> <p>If you want to stick to some kind of prototyping, you have to implement an initialize() method that will give a <em>stockpile</em> property to your newly created Depots. That is the way prototypejs Classes are defined : a cloned prototype and an initialize() method : <a href="http://prototypejs.org/learn/class-inheritance" rel="nofollow noreferrer">http://prototypejs.org/learn/class-inheritance</a></p>
<p>For the method, all works as expected. It's just the fields that you need to take care of. </p> <p>What I see a lot in YUI, is that the constructor allocates the instance varialbes. 'Classes' that inherit from a parent call the constructor of their parent. Look here: <a href="http://developer.yahoo.com/yui/docs/DataSource.js.html" rel="nofollow noreferrer">http://developer.yahoo.com/yui/docs/DataSource.js.html</a></p> <p>Example base class: </p> <pre><code>util.DataSourceBase = function(oLiveData, oConfigs) { ... this.liveData = oLiveData; ... more initialization... } </code></pre> <p>Example subclass:</p> <pre><code>util.FunctionDataSource = function(oLiveData, oConfigs) { this.dataType = DS.TYPE_JSFUNCTION; oLiveData = oLiveData || function() {}; util.FunctionDataSource.superclass.constructor.call(this, oLiveData, oConfigs); }; // FunctionDataSource extends DataSourceBase lang.extend(util.FunctionDataSource, util.DataSourceBase, { ...prototype of the subclass... }); </code></pre>
<p>Javascript provides a way to do this the way U are used to :) try this:</p> <pre><code>function Depot() { this.stockpile = [], this.loadAmmo = function (ammoType) { this.stockpile.push(ammoType); } }; var MissileDepot = new Depot(); var GunDepot = new Depot(); MissileDepot.loadAmmo("ICBM"); MissileDepot.loadAmmo("Photon Torpedo"); alert(MissileDepot.stockpile); // outputs "ICBM,Photon Torpedo" alert(GunDepot.stockpile); // outputs "" </code></pre> <p>And U can add the functions on the fly afterwards:</p> <pre><code>MissileDepot.blow = function(){alert('kaboom');} </code></pre> <p>Extending object with another object is also an option, but what You wanted is the fact, that OO programming in javascript is done by functions not objects with {} ;)</p> <p>EDIT:</p> <p>I feel bad for writing that without mentioning: The javascript "new" keyword is only for making it easier to OO veterans. Please, dig deeper into the prototypal inheritance and dynamic object creation as therein lies true magic! :)</p>
<p>That's because you're trying to make a cat meow! Douglas Crockford is good, but that script you're using essentially works by looping through your parent object and copying all of its attributes into the prototype chain--which is not what you want. When you put things in the prototype chain, they're shared by all instances of that object--ideal for member functions, not ideal for data members, since you want each object instance to have its own collection of data members.</p> <p>John Resig wrote a <a href="http://ejohn.org/blog/simple-javascript-inheritance/" rel="nofollow noreferrer">small script</a> for simulating classical inheritance. You might want to check that out.</p>
<p>The secret to instance variables in JavaScript is that they are shared across methods defined in superclasses or from included modules. The language itself doesn't provide such a feature, and it may not be possible to mesh with Prototypal inheritance because each instance will need it's own instance variable capsule, but by using discipline and convention it is fairly straightforward to implement.</p> <pre><code>// Class Depot function Depot(I) { // JavaScript instance variables I = I || {}; // Initialize default values Object.reverseMerge(I, { stockpile: [] }); return { // Public loadAmmo method loadAmmo: function(ammoType) { I.stockpile.push(ammoType); }, // Public getter for stockpile stockpile: function() { return I.stockpile; } }; } // Create a couple of Depot instances var missileDepot = Depot(); var gunDepot = Depot(); missileDepot.loadAmmo("ICBM"); missileDepot.loadAmmo("Photon Torpedo"); alert(missileDepot.stockpile()); // outputs "ICBM,Photon Torpedo" alert(gunDepot.stockpile()); // outputs "" // Class NonWeaponDepot function NonWeaponDepot(I) { I = I || {}; // Private method function nonWeapon(ammoType) { // returns true or false based on ammoType } // Make NonWeaponDepot a subclass of Depot and inherit it's methods // Note how we pass in `I` to have shared instance variables return Object.extend(Depot(I), { loadAmmo: function(ammoType) { if(nonWeapon(ammoType)) { // Here I.stockpile is the same reference an in the Depot superclass I.stockpile.push(ammoType); } } }); } var nonWeaponDepot = NonWeaponDepot(); nonWeaponDepot.loadAmmo("Nuclear Bombs"); alert(nonWeaponDepot.stockpile()); // outputs "" </code></pre> <p>And that's how to do instance variables in JavaScript. <a href="http://strd6.com/2010/09/javascript-instance-variables-do-exist/" rel="nofollow noreferrer">Another instance variable example using the same technique</a>.</p>