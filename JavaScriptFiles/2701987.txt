JavaScript function binding (this keyword) is lost after assignment
<p>this is one of most mystery feature in JavaScript, after assigning the object method to other variable, the binding (this keyword) is lost</p> <pre><code>var john = { name: 'John', greet: function(person) { alert("Hi " + person + ", my name is " + this.name); } }; john.greet("Mark"); // Hi Mark, my name is John var fx = john.greet; fx("Mark"); // Hi Mark, my name is </code></pre> <p>my question is:</p> <p>1) what is happening behind the assignment? var fx = john.greet; is this copy by value or copy by reference? fx and john.greet point to two diferent function, right?</p> <p>2) since fx is a global method, the scope chain contains only global object. what is the value of <strong><em>this</em></strong> property in Variable object? </p>
<p>As I understand it, you're only assigning that method to the variable "fx." The context of the john object doesn't come along with it.</p> <p>Off the top of my head, "this" in the context of fx will refer to the global object, which in the context of a browser is (I believe) equivalent to your window object.</p> <p>(editing to clarify global object. Sort of)</p>
<p><code>john.greet("Mark")</code> actually calls a function. When you do <code>var fx = john.greet;</code>, you're getting a reference to the function. So when you call it, <code>this</code> is not bound to <code>john</code>. What you're actually doing is <code>window.fx("Mark")</code> and so <code>this</code> is the <code>window</code> object. You were on the right track when you said that it was in the global context. In this particular instance, the global object is <code>window</code>, and so <code>fx</code> is actually <code>window.fx</code>.</p> <p>When you have a function reference you should use <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Function/call" rel="nofollow noreferrer"><code>call</code></a> or <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Function/apply" rel="nofollow noreferrer"><code>apply</code></a> if you want to set the value of <code>this</code>. Try doing this:</p> <pre><code>fx.call(john, "Mark"); </code></pre> <p>The first argument in <code>call</code> or <code>apply</code> is the value used for <code>this</code> in the context of the function call.</p> <p><strong>EDIT</strong></p> <p>Some people mentioned that the real issue here might be confusion surrounding an object literal vs. an instance of an object. You're creating an object literal which also behaves kind of like a singleton. You cannot create a new instance of that object. In this case <code>john</code> is a reference to that object literal. In that context, <code>this</code> in the function <code>greet</code> refers to the object literal itself. Hence when you call <code>john.greet("Mark")</code>, <code>this</code> is bound to <code>john</code>.</p> <p>When you grab a reference to <code>john.greet</code> just by itself and assigning it to a global variable, you're essentially doing this:</p> <pre><code>var fx = function(person) { alert("Hi " + person + ", my name is " + this.name); } </code></pre> <p>In this scenario, <code>this</code> is <code>window</code>, because <code>fx</code> is basically <code>window.fx</code> (since the global object here is <code>window</code>. Assuming this code was wrapped inside <em>another</em> function, then the global object would refer to that function. </p> <p>If you want to create multiple instances of an object, you can do something like this:</p> <pre><code>var Person = function(name) { var self = this; //maintains a reference to the instance this.name = name; this.greet = function(name) { alert("Hi " + name + ", my name is " + self.name); } } var john = new Person("John"); john.greet("Mark"); // alerts "Hi Mark, my name is John" var fx = john.greet; fx("Mark"); // also alerts "Hi Mark, my name is John" </code></pre> <p>Here, the <code>self</code> variable (which is local to the function) maintains a reference to the actual instance because you're binding it to <code>this</code> when you create the object.</p> <p>There are many best practices associated with OOP in Javascript. You can Google and find out (there are many links). I recommend reading stuff from Douglas Crockford especially.</p>
<p>1) <code>fx</code> and <code>john.greet</code> are referring to the same function object, the assignment operation for objects, works <em>by reference</em>.</p> <p>For primitive values, like <code>String</code>, <code>Number</code>, <code>Boolean</code> <code>undefined</code> or <code>null</code>, a copy of the value will be made.</p> <p>2) The <code>this</code> value refers to the global object.</p> <p>The <code>this</code> value is not a property of the <a href="http://bclary.com/2004/11/07/#a-10.1.3" rel="nofollow noreferrer">Variable Object</a> and it has nothing to do with the <em>scope chain</em>, is a special reserved word, and it is determined implicitly when a <a href="http://bclary.com/2004/11/07/#a-11.2.3" rel="nofollow noreferrer">function is called</a> (you can also set it explicitly via <code>call</code> or <code>apply</code>).</p> <p>JavaScript internally handles a <a href="http://bclary.com/2004/11/07/#a-8.7" rel="nofollow noreferrer"><code>Reference type</code></a>, which consists of two components, the <em>base object</em> and the <em>property name</em>, when a function is invoked, the <code>this</code> value is determined implicitly by getting the <em>base object</em> (by the internal <a href="http://bclary.com/2004/11/07/#a-8.7.1" rel="nofollow noreferrer"><code>GetValue</code></a> operation).</p> <p>And finally, the last case where <code>this</code> is set implicitly is when you invoke a function with the <a href="http://bclary.com/2004/11/07/#a-11.2.2" rel="nofollow noreferrer"><code>new</code></a> operator, the <code>this</code> keyword will refer to a newly created object.</p> <p>So in brief, here is how <code>this</code> works <em>implicitly</em>:</p> <p>1- When a function is called as a method (the function is invoked as member of an object):</p> <pre><code>obj.method(); // 'this' inside method will refer to obj </code></pre> <p>2- A <em>normal</em> function call:</p> <pre><code>myFunction(); // 'this' inside the function will refer to the Global object // or (function () {})(); </code></pre> <p>3- When the <code>new</code> operator is used:</p> <pre><code>var obj = new MyObj(); // 'this' will refer to a newly created object. </code></pre>
<p>Because you're only setting fx to the greet method and not the entire john object, it has no concept of it's parent and becomes globally scoped. So in essence, it's passing by value in that in only copies the method.</p> <p>Since the function is now globally scoped, "this" becomes the Window object.</p> <p>If you instead set fx to john, you get what's expected.</p> <pre><code>var john = { name: 'John', greet: function(person) { alert("Hi " + person + ", my name is " + this.name); } }; john.greet("Mark"); // Hi Mark, my name is John var fx = john; fx.greet("Mark"); // Hi Mark, my name is John </code></pre>
<p>inspired by @Vivin Paliath answer, actually I come out something new. As to me, I always try my best to make javascript programming the same way as java, especially in OOP. </p> <p>So my suggestion is to avoid using <strong>this</strong> as possible as we can , when we first do</p> <pre><code>var self = this; </code></pre> <p>we should use self instead of this in all function (prototype function, whatsoever), but if we write something like this:</p> <pre><code>function MyObject = { var self = this; }; MyObject.prototype = { method1 = function(data){ self.data = data; } } </code></pre> <p>This is not gonna work, because prototype is an object in MyObject, It can not access <strong>private</strong> member <strong>self</strong> owned by MyObject. My solution for this is simple:</p> <pre><code>function MyObject = { var self = this; MyObject.prototype.method1 = function(data){ self.data = data; }; } </code></pre> <p>This takes the advantage of prototype's efficiency and also we do not have to care about all the <strong>this</strong> issues. Though we gonna type a lot of <strong>MyObject.prototype.xxxx</strong> thing.</p> <p>If this helpful to your guys, please give me some <strong>thumb up</strong>, so I can gather 15 reputation to <strong>thumb up</strong> others, thanks.</p>