How can I return a built-in function as a object property?
<p>This code works, in some cases. If it returns <code>console.log</code> then the call to <code>p.out</code> functions just fine. </p> <pre><code>function Notice(mode) { this.debug = mode; this.out = (function() { if(mode) { if(window.console) { return console.log; } else { return alert; } } else { return Notice.doNothing; } })(mode); } var p = new Notice('1'); p.out('Kool-aid, OH YEAH!'); </code></pre> <p>However, when it returns alert (or window.alert) I get an error:</p> <pre><code>Error: uncaught exception: [Exception... "Illegal operation on WrappedNative prototype object" nsresult: "0x8057000c (NS_ERROR_XPC_BAD_OP_ON_WN_PROTO)" location: "JS frame :: http:// .. :: &lt;TOP_LEVEL&gt; :: line 22" data: no] </code></pre> <p>And as a simple test, this works:</p> <pre><code>out = (function() { return alert; })(); out('hello dolly'); </code></pre> <p>How can I get obj.out to function properly when its being set to alert?</p>
<p>Why not return an anonymous function that in return calls the build-in function?</p> <p>Something like</p> <pre><code>return function(msg) { alert(msg); } </code></pre>
<p>I suspect the problem you're having isn't because of how you're setting it, but because of the functions involved. <code>console.log</code> calls the <code>log</code> function with the context (the <code>this</code> value) set to <code>console</code>. If you do</p> <pre><code>var f = console.log; f("Hi there"); </code></pre> <p>...note that <code>log</code> is called with a <em>different context</em> (in this case, the global object, which is <code>window</code> in browsers), <code>this</code> is no longer the <code>console</code> object.</p> <p>If you do this:</p> <pre><code>var obj = {}; obj.f = console.log; obj.f(); </code></pre> <p>...then <code>log</code> will be called with <code>obj</code> as <code>this</code>.</p> <p>Some functions will care, because some functions use <code>this</code> in their implementation. Some functions won't care because they don't. It may be that <code>alert</code> didn't care because it just so happens that it's expecting <code>this</code> to be <code>window</code> -- and that's exactly what it is when you call the function raw (e.g., not via dotted notation or in the other ways that explicitly set <code>this</code>), because (again) <code>window</code> is the global object in browsers.</p> <p>As a separate note: In most implementations, the built-in functions you see are proper JavaScript function objects and have all of their features. In some implementations, though (Internet Explorer is one), they aren't proper JavaScript functions at all and they lack some of the features of proper functions, such as the <code>apply</code> and <code>call</code> properties. When in doubt, wrap.</p>
<p>The problem is that in some implementations, alert is actually a proper method of the window object. That is, alert expects <code>this</code> to be the window object. This illustrates the problem in the simplest form:</p> <pre><code>var foo = {alert : alert}; /* this fails because the value of 'this' is foo: */ foo.alert('hello'); /* but this works because we re-point 'this to the * correct object, that is the window object: */ foo.alert.call(window,'hello'); </code></pre> <p>So, a solution to your problem is to either return a function that directly call alert or bind window to alert in a closure. Either something like this:</p> <pre><code>function Notice (mode) { this.out = function(message) { if(mode) { if(window.console) { console.log(message); } else { alert(message); } } }; } </code></pre> <p>or this:</p> <pre><code>function Notice (mode) { this.out = (function() { if(mode) { if(window.console) { return console.log; } else { return function (message) {alert(message)}; } } })(); } </code></pre>