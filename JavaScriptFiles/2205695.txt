What is the modern way to structure a &quot;class&quot; in JavaScript?
<p>How to build a "class" (with properties and methods) upon which will be created a lot of instances? </p>
<p>The approach to object orientation most native to JavaScript is to use prototypal inheritance, but many other patterns exist, including pseudoclassical inheritance, which mimics the class-based inheritance pattern in languages like C and Java. Douglas Crockford has written and spoken on the subject and provides some very good explanations of each. Take a look at these articles:</p> <p><a href="http://javascript.crockford.com/prototypal.html" rel="nofollow noreferrer">Prototypal Inheritance in JavaScript</a></p> <p><a href="http://javascript.crockford.com/inheritance.html" rel="nofollow noreferrer">Classical Inheritance in JavaScript</a></p>
<p><a href="http://www.phpied.com/3-ways-to-define-a-javascript-class/" rel="nofollow noreferrer">http://www.phpied.com/3-ways-to-define-a-javascript-class/</a> </p>
<p>JavaScript does not use classes in the same way as Java, C++ or the like. </p> <p>One way to achieve your effect is to define a function in which the <em>this</em> keyword is used--accessing members roughly as you would in Java. Then, use the <em>new</em> keyword in calling this function to create an object.</p> <pre><code>function Foo(){ //vaguely like a Java constructor this.aField = 1; //define members simply by using 'this' this.aMethod = methodFunction; //assign a function as a member using 'this' } function methodFunction(){ } var foo = new Foo(); //construct an object </code></pre>
<p><a href="http://www.cristiandarie.ro/asp-ajax/JavaScriptClass.html" rel="nofollow noreferrer">Here is a basic class with explanation on how to create them.</a></p> <p>For <strong>modern way</strong>, all the nuts and bolts will be the same. Nothing fancy to about it :)</p>
<pre><code>// I like this pattern.. // class function Person(name, birthdate) { this._name = name; this._birthdate = birthdate; /* should not do this * this.getAge = function() { * } * as the method will be constructed * for each instance, better to let it * be inherited from prototype, see below */ } // class methods Person.prototype.getBirthdate = function() { return this._birthdate; } // same as above, function as a method Person.prototype.getAge = function() { var currentDate = new Date(); // age in millis return currentDate - this._birthdate; } // the get age method can be a "static" // method on the constructor function if you pass the // person object Person.getAge = function(person) { var currentDate = new Date(); // age in millis //no reference to this return currentDate - person.getBirthdate(); } // you could use it like this myPerson = new Person("Steve", new Date("1980-01-01")); // returns age in millis myPerson.getAge(); // returns age in millis Person.getAge(myPerson); </code></pre> <p>You could also use a anonymous function to simulate private and public</p> <pre><code>var PersonFactory = (function() { // private area, no one can alter // the person cache var _cache = {} // public area return { // returns a person born now getPerson: function(name) { if(_cache[name]) { return _cache[name]; } else { _cache[name] = new Person(name, new Date()); return _cache[name]; } } } })(); var p = PersonFactory.getPerson("Leif"); p.getAge(); p = PersonFactory.getPerson("Leif"); // should be the same age / obj p.getAge(); </code></pre> <p>I don't like this pattern though. The underscore warning _myVariable should be enough to keep users of your lib from using those variables / methods. I used it allot when I first discovered it because of my Java background.. It makes it difficult to work with prototype inheritance and can cause memory leaks.</p>
<p>In "modern" JavaScript, there are three popular methods for defining objects.</p> <p>The first method is the classic method and is still popular because of its simplicity; however, it is <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Inheritance#Discouraged" rel="nofollow noreferrer">discouraged by MDC</a> in favor of the second method because of the inefficiency of having to redefine each function every time an instance of the object is created.</p> <pre><code>// Constructor, methods and members all rolled up into one definition var Movie = function(name) { this.name = name; // Note that private members can be created using the closure property var _id = +(new Date()); this.getName = function() { return this.name + " " + _id; }; this.setName = function(name) { this.name = name; }; }; var m = new Movie("Beerfest"); </code></pre> <p>The second method is a variation of and can be used interchangeably with the first. It is also useful for adding new methods to existing objects via the <code>prototype</code> property. Private members and methods are not possible in this form.</p> <pre><code>// Constructor is separate from its methods var Movie = function(name) { this.name = name; } Movie.prototype.getName = function() { return name; }; Movie.prototype.setName = function(name) { this.name = name; }; var m = new Movie("Kill Bill"); </code></pre> <p>The third method is to use the <a href="http://www.yuiblog.com/blog/2007/06/12/module-pattern/" rel="nofollow noreferrer">module pattern</a>, which makes it possible to instantiate objects without having to use the <code>new</code> operator.</p> <pre><code>var Movie = function (name) { var _id = +(new Date()); var privateMethod = function() { alert(_id); }; // All methods and members defined here are public return { name: name, getName: function() { return this.name + " " + _id; }, setName: function(name) { this.name = name; } }; }; var m = Movie("Stackoverflow: the movie"); </code></pre> <p>Note that in the first and third methods, you can use private access members and methods. But be aware that <a href="http://www.zebrakick.com/blog/object-literals-vs-constructed-objects-in-javascript/" rel="nofollow noreferrer">to use <code>this</code> within private methods some must happen</a>.</p>
<p>By using an anonymous self-executing function, you can allow for public and private attributes/methods.</p> <p>This is the pattern I like the most:</p> <pre><code>(function ($, MyObject, undefined) { MyObject.publicFunction = function () { console.log("Public function"); }; var privateFunction = function () { console.log("Private function"); }; var privateNumber = 0; MyObject.sayStuff = function () { this.publicFunction(); privateFunction(); privateNumber++; console.log(privateNumber); }; // You can even nest the namespaces MyObject.nestedNamespace = MyObject.nestedNamespace || {}; MyObject.nestedNamespace.logNestedMessage = function () { console.log("Nested namespace function"); }; }(jQuery, window.MyObject = window.MyObject || {})); MyObject.sayStuff(); MyObject.sayStuff(); MyObject.nestedNamespace.logNestedMessage(); MyObject.publicFunction(); </code></pre> <p>Learned about it from the comments <a href="http://www.impressivewebs.com/my-current-javascript-design-pattern/" rel="nofollow">here</a> and <a href="http://enterprisejquery.com/2010/10/how-good-c-habits-can-encourage-bad-javascript-habits-part-1/" rel="nofollow">this article</a>.</p>