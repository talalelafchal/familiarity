closure not working
<pre><code>var Dog = function() { var _instance = 'hello world'; return function() { console.log(this._instance); } } (); //note that it is self invoking function var l = new Dog(); //#&gt; undefined </code></pre> <p>In the above case I was expecting an output of:</p> <blockquote> <p>'hello world'</p> </blockquote> <p>Why is <code>this._instance</code> not accessing the the variable which should be accessible by virtue of closure? I tested this in FF and am getting undefined.</p>
<p>Your problem is <code>this</code>. </p>
<p>Change <code>this._instance</code> to <code>_instance</code>. You may also want to wrap your self-invoking function in parentheses like <code>(function() { ... })();</code> for maximum browser compatibility.</p>
<p>You don't assign <code>_instance</code> to the object, it's just a closure variable, and should be accessed without using <code>this</code>:</p> <pre><code>var Dog = function() { var _instance = 'hello world'; return function() { console.log(_instance); } } (); //note that it is self invoking function var l = new Dog(); </code></pre> <p>I'd probably write it like so instead:</p> <pre><code>var Dog = (function() { var defaults = { name: 'Rags' }; var Dog = function (options) { // Take options as a constructor argument, this // allows you to merge it with defaults to override // options on specific instances this.setOptions(options); }; Dog.prototype = { // Common methods for Dogs here setOptions: function (options) { // Declare all variables in the beginning of the method because // JavaScript hoists variable declarations var key = null; // First assign all the defaults to this object for ( key in defaults) { this[key] = defaults[key]; } // Now override with the values in options: if (options &amp;&amp; options.hasOwnProperty) { for ( key in options ) { this[key] = options[key]; } } } }; return Dog; // Return the constructor method } ()); // wrap the self-invoked function in paranthesis to visualize that // it creates a closure var buster = new Dog({name: 'Buster'}), unnamed = new Dog(); alert(buster.name); // Alerts 'Buster' alert(unnamed.name); // Alerts 'Rags' </code></pre> <p>Note that I have not tried to compile the above code, so it might contain a few mistakes. Nothing <a href="http://www.jslint.com/" rel="nofollow noreferrer">JsLint</a> can't handle though!</p> <p>You might want to consider adding filtering to the <code>setOptions</code> method so that it doesn't assign properties you don't want, or filter out methods etc declared in the options-parameter.</p> <p>Additionally, if you use JQuery, or similar library, there are (often) utility functions for merging objects, making it trivial to write the setOptions-method:</p> <pre><code>function setOptions (options) { // I assume JQuery here // true as the first argument gives us a recursive merge var mergedOptions = $.extend(true, defaults, options); for (var key in mergedOptions ) { if(this.checkAllowedProperty(key, typeof(mergedOptions[key])) { this[key] = mergedOptions[key]; } } } /** * This method checks if propertyName is an allowed property on this object. * If dataType is supplied it also checks if propertyName is allowed for * dataType * @return true if propertyName, with type dataType, is allowed on this object, * else false */ function checkAllowedProperty (propertyName, dataType); </code></pre>
<p>As the others have said, you need to remove "this." from your function.</p> <p>The reason for the problem is down to the binding of the "this" keyword in the two function contexts. Inside the closure, "this" refers to the function that is being returned, and not to the outer function. You could resolve this by doing the following:</p> <pre><code>var Dog = function() { var _instance = 'hello world'; var that = this; //Assign "this" to "that" return function() { console.log(that._instance); //Use reference to "that" } } (); var l = new Dog(); </code></pre> <p>You could also probably do something closer with the function.apply() method, but I'll leave that to you.</p> <p>I hope that helps.</p>
<p>Perhaps you are satisfied by removing "this.", but you may be interested to learn that "this" doesn't refer to what you wanted it to anyway. What it refers to really depends on how the function is called. It does not necessarily refer to an instance of an object constructed by the function you returned, or its container function, or to any other object. By default, if you merely call the function as a normal function, "this" will refer to the global window context. </p> <p>What you must do to have "this" be bound to any specific object is to call the function as a <strong>method of that object</strong>, or of its prototype. e.g. foo.myMethod(). Another way is that you can use the apply or call method, passing in the object you want it to apply to. e.g. anyFunction.apply(foo).</p>