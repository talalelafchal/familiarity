valueOf() vs. toString() in Javascript
<p>In Javascript every object has a valueOf() and toString() method. I would have thought that the toString() method got invoked whenever a string conversion is called for, but apparently it is trumped by valueOf().</p> <p>For example, the code</p> <pre><code>var x = {toString: function() {return "foo"; }, valueOf: function() {return 42; }}; window.console.log ("x="+x); window.console.log ("x="+x.toString()); </code></pre> <p>will print</p> <pre><code>x=42 x=foo </code></pre> <p>This strikes me as backwards .. if x were a complex number, for example, I would want valueOf() to give me its magnitude, but whenever I wanted to convert to a string I would want something like "a+bi". And I wouldn't want to have to call toString() explicitly in contexts that implied a string.</p> <p>Is this just the way it is? </p>
<p>Here's a little more detail, before I get to the answer:</p> <pre><code>var x = { toString: function () { return "foo"; }, valueOf: function () { return 42; } }; alert(x); // foo "x=" + x; // "x=42" x + "=x"; // "42=x" x + "1"; // 421 x + 1; // 43 ["x=", x].join(""); // "x=foo" </code></pre> <p>The <code>toString</code> function is <em>not</em> "trumped" by <code>valueOf</code> in general. The ECMAScript standard actually answers this question pretty well. Every object has a <code>[[DefaultValue]]</code> property, which is computed on-demand. When asking for this property, the interpreter also provides a "hint" for what sort of value it expects. If the hint is <code>String</code>, then <code>toString</code> is used before <code>valueOf</code>. But, if the hint is <code>Number</code>, then <code>valueOf</code> will be used first. Note that if only one is present, or it returns a non-primitive, it will usually call the other as the second choice.</p> <p>The <code>+</code> operator always provides the hint <code>Number</code>, even if the first operand is a string value. Even though it asks <code>x</code> for its <code>Number</code> representation, since the first operand returns a string from <code>[[DefaultValue]]</code>, it does string concatenation.</p> <p>If you want to guarantee that <code>toString</code> is called for string concatenation, use an array and the <code>.join("")</code> method.</p> <p><em>(ActionScript 3.0 slightly modifies the behavior of <code>+</code>, however. If either operand is a <code>String</code>, it will treat it as a string concatenation operator and use the hint <code>String</code> when it calls <code>[[DefaultValue]]</code>. So, in AS3, this example yields "foo, x=foo, foo=x, foo1, 43, x=foo".)</em></p>
<p>The reason why ("x="+x) gives "x=value" and not "x=tostring" is the following. When evaluating "+", javascript first collects primitive values of the operands, and then decides if addition or concatenation should be applied, based on the type of each primitive.</p> <p>So, this is how you think it works</p> <pre><code>a + b: pa = ToPrimitive(a) if(pa is string) return concat(pa, ToString(b)) else return add(pa, ToNumber(b)) </code></pre> <p>and this is what actually happens</p> <pre><code>a + b: pa = ToPrimitive(a) pb = ToPrimitive(b)* if(pa is string || pb is string) return concat(ToString(pa), ToString(pb)) else return add(ToNumber(pa), ToNumber(pb)) </code></pre> <p>That is, toString is applied to the result of valueOf, not to your original object.</p> <p>For further reference, check out section 11.6.1 <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.6.1" rel="nofollow noreferrer">The Addition operator ( + )</a> in the ECMAScript Language Specification.</p> <hr> <p>*When called in string context, ToPrimitive <em>does</em> invoke toString, but this is not the case here, because '+' doesn't enforce any type context. </p>