javascript - get node reference to script tag that calls a function
<p>How might one go about obtaining a reference to the DOM script tag that called a function?</p> <p>For example:</p> <pre><code>&lt;script type="text/javascript"&gt; var globalfunc = function(){ //obtain a reference to the script block that globalfunc() was called from } &lt;/script&gt; &lt;script type="text/javascript"&gt; globalfunc(); &lt;/script&gt; </code></pre> <p>I know that I could assign an id or class to the script element and pass that through to my function to do a DOM lookup, but I think it would be more flexible and elegant to do it without such a thing. The main reason is that I may have to do some work on our site to get 3rd party ads wrangled into shape, and we don't have control over the scripts they use to load their ads.</p>
<p>Actually, you can't assign a class or id to a <code>script</code> element <em>if</em> you want to have valid markup. That said, I have used that method and yes it does work.</p> <p>Alternatively, <strong>and let the record show that I would never do this</strong>, you could do something like:</p> <pre><code>var scripts = document.getElementsByTagName("script"); for (var i=0, l=scripts.length; i&lt;l; ++i ) { if ( scripts[i].innerHTML.indexOf("globalfunc();") != -1 ) { // Found a script tag in which `globalfunc();` is executed } } </code></pre>
<p>Assuming the script tag is not deferred, when the function executes, it should be from the last script tag in the page. So something like </p> <pre><code>var scripts = document.getElementsByTagName("script"); var scriptElement = scripts[scripts.length-1]; </code></pre> <p>should get the reference.</p> <p>You should wrap the original function in your own construct to insert this code, something like:</p> <pre><code>var old_global = globalFunction; globalFunction = function () { var scripts = document.getElementsByTagName("script"); var scriptElement = scripts[scripts.length-1]; old_global.call(this,arguments); // do something after }; </code></pre> <p>This code is untested but may give you the idea.</p>
<p>Here's my solution: It will work in every browser except IE, it requires that you catch a real error (well it doesn't for Firefox, but other browsers do), and you must call it from an external script (<code>&lt;script src="..."&gt;</code>) to use it.</p> <pre><code>var getErrorScriptNode = (function () { var getErrorSource = function (error) { var loc, replacer = function (stack, matchedLoc) { loc = matchedLoc; }; if ("fileName" in error) { loc = error.fileName; } else if ("stacktrace" in error) { // Opera error.stacktrace.replace(/Line \d+ of .+ script (.*)/gm, replacer); } else if ("stack" in error) { // WebKit error.stack.replace(/at (.*)/gm, replacer); loc = loc.replace(/:\d+:\d+$/, ""); } return loc; }, anchor = document.createElement("a"); return function (error) { anchor.href = getErrorSource(error); var src = anchor.href, scripts = document.getElementsByTagName("script"); anchor.removeAttribute("href"); for (var i = 0, l = scripts.length; i &lt; l; i++) { anchor.href = scripts.item(i).src; if (anchor.href === src) { anchor.removeAttribute("href"); return scripts.item(i); } } }; }()); </code></pre> <h2>Usage</h2> <pre><code>var globalfunc = function (err) { var scriptNode = getErrorScriptNode(err); // ... }; </code></pre> <p>In an external (must be EXTERNAL) script that calls <code>globalfunc()</code>:</p> <pre><code>try { 0(); } catch (e) { var err = e; } // do stuff... globalfunc(err); </code></pre>