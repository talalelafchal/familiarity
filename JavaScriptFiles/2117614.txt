subclass.prototype = new superclass() vs. subclass = new superclass()
<p>I've been instantiating subclasses in javascript using</p> <pre><code>object = new class () </code></pre> <p>but I notice some people instantiate using</p> <pre><code>object.prototype = new class () </code></pre> <p>Question: What's the difference? To me it seems like the latter is respecting the inheritance chain more because if <code>class ()</code> has a bunch of "<code>this.variable = x</code>" statements, and object is something you want to inherit from it rather than an instance of class, you are accurately assigning those variables to object's prototype rather than to the object itself as in the former case. So in effect it's like this? </p> <pre><code>object = new class () |vs.| subclass.prototype = new superclass () </code></pre> <p><strong>However, functionally in the program both are the same?</strong></p> <p>Side question: Also I'm a bit unclear as to what the <code>new</code> operator actually does. It seems to me to do something like just create an empty object and assign it's <em>proto</em> property?</p>
<p>The difference is that when you do:</p> <pre><code>var subclass = new superclass(); </code></pre> <p>you are creating an instance of <code>superclass</code>. <code>subclass</code> is just variable. You are not creating a sub-class (ie. making <code>subclass</code> inherit <code>superclass</code>). In the latter example, assuming subclass is a function, you are saying that all new instances of subclass should inherit (ie. sub-class) <code>superclass</code>.</p> <p>So:</p> <pre><code>function superclass() {this.stuff="stuff";} function() subclass() {} subclass.prototype = new superclass(); alert(new subclass().this); // pops up "stuff" </code></pre> <p>is prototypical inheritance.</p> <p>As for the <code>new</code> operator, it is used for creating an instance of built-in objects and user defined types. A user defined type is simply a function. </p> <p><strong>Edit:</strong> When I wrote above that subclass inherits supertype using prototypical inheritance, I mean that all new instances of subclass inherit from <strong>one</strong> particular <strong>instance</strong> of superclass, not from the <code>superclass</code> type/function itself.</p>
<p>The code samples in your question reflect a couple of misunderstanding. Let's address them first:</p> <ul> <li>class is a reserved keyword in Javascript. You cannot use class as the name of any variable or function. This is not because the Javascript language makes any use of the keyword, but because it was planned for a possible future use.</li> <li>there are no real classes in Javascript. What you may have seen, is different flavors of attempts to simulate class inheritance by using the available inheritance mechanism in Javascript, which is based on prototype objects, sharing properties with linked instances</li> <li><strong>very important:</strong> the prototype property used in this inheritance mechanism is set on a <strong>function</strong>, <strong>not</strong> directly on <strong>objects</strong></li> </ul> <p>Quoting Douglas Crockford in Chapter 5, Inheritance, of <a href="http://rads.stackoverflow.com/amzn/click/0596517742" rel="nofollow noreferrer">JavaScript: The Good Parts</a>:</p> <blockquote> <p>Instead of having objects inherit directly from other objects, an unnecessary level of indirection is inserted such that objects are produced by constructor functions.</p> <p>(...)</p> <p>When a function is invoked with the constructor invocation pattern using the new prefix, this modifies the way in which the function is executed.</p> </blockquote> <p>Douglas Crockford then explains how the new operator could be implemented as a JavaScript function. This function makes use of several other functions defined in the book, so I rewrote it in a (somewhat) simpler form below:</p> <pre><code>function createNew(constructor) { // a function to explain the new operator: // var object = createNew(constructor); // is equivalent to // var object = new constructor(); // // param: constructor, a function // return: a new instance of the "constructor" kind of objects // step 1. create a new empty object instance // linked to the prototype of provided constructor var hiddenLink = function(){}; hiddenLink.prototype = constructor.prototype; var instance = new hiddenLink(); // cheap trick here: using new to implement new // step 2. apply the constructor the new instance and get the result var result = constructor.apply(object); // make this a reference to instance within constructor // step 3. check the result, and choose whether to return it or the created instance if (typeof result === 'object') { return object; } else { return instance; } } </code></pre> <p>In simple English, if you call <code>new constructor()</code>, where constructor is a function, the operator creates a new object with a link to inherit properties from the constructor, applies the constructor function to it, and returns either the value returned by the constructor, or the new object in case the constructor returned something else which is not an object.</p> <p><strong>At any time</strong>, before or after creating new instances using a custom constructor, <strong>you may modify the prototype (object) on the constructor (function)</strong>:</p> <pre><code>function constructor(){} // the most simple constructor function: does nothing var before = new constructor(); var different = new constructor(); different.answer = "So long, and thanks for all the fish"; constructor.prototype = {}; // set an empty object to the prototype property constructor.prototype.answer = 42; // create a new property on prototype object constructor.prototype.answer = Math.PI; // replace an existing property var after = new constructor(); </code></pre> <p>Through the hidden link added to all objects created using this constructor (see "cheap trick" in createNew), the properties of the prototype object can be accessed on all these instances, unless overridden by properties defined on the objects directly.</p> <pre><code>before.answer === Math.PI; // true after.answer === Math.PI; // true different.answer === "So long, and thanks for all the fish"; // true </code></pre> <p>Using this newly acquired knowledge, how would you create a new "class" of objects that inherit all the properties of arrays, together with a new method empty() to remove all elements?</p> <p><strong>First</strong>, there are no classes in Javascript, so in order to create a new "class", I have to define a new constructor function. Let's call it CustomArray, with a capital C to follow the convention that constructor functions should start with a capital.</p> <pre><code>function CustomArray(){} </code></pre> <p>I can now create custom instances:</p> <pre><code>var myArray = new CustomArray(); </code></pre> <p><strong>Second</strong>, I want instances created with CustomArray to inherit Array properties:</p> <pre><code>myArray.prototype = new Array(); // WRONG EXAMPLE: we must set CustomArray.prototype CustomArray.prototype = Array; // WRONG EXAMPLE: prototype expects an object, Array is a function CustomArray.prototype = new Array(); // OK, BUT: the simpler form [] should be used instead CustomArray.prototype = []; </code></pre> <p><strong>Third</strong>, I want all instances created with CustomArray to have the empty() method:</p> <pre><code>function empty(){ // empty this array by setting its length to 0 // function to be called in the context (this) of an array this.length = 0; } CustomArray.prototype.empty = empty; // set the function named empty to the property "empty" of the prototype </code></pre> <p><strong>Finally</strong>, I can rewrite the whole example in a more concise way:</p> <pre><code>function CustomArray(){} CustomArray.prototype = []; CustomArray.prototype.empty = function(){ this.length = 0; } </code></pre> <p>I can now create a custom array, set a couple of values and empty it:</p> <pre><code>var myArray = new CustomArray(); myArray[0] = "abc"; myArray[1] = "def"; myArray[2] = "ghi"; myArray.empty(); </code></pre> <p><strong>The issue is</strong>: the above code does not work as expected. Why? Because unlike in regular arrays, setting values in our custom array does not automagically increase the length property of the array. Likewise, calling empty() only sets the length property of our custom array to 0, it does not delete all the values within.</p> <p>Besides, we could not use the array literal syntax to initialize our custom array:</p> <pre><code>var myArray = ["abc","def","ghi"]; // this creates a regular array </code></pre> <p><strong>All in all</strong>, it is important to understand how Javascript inheritance works, but you may often find it less useful than expected and there are simpler ways to achieve the same result, for example by using builder functions instead of constructors. We can solve the problem by using a builder function customizeArray to extend regular arrays:</p> <pre><code>function customizeArray(array){ array.empty = function(){ this.length = 0; }; } var myArray = ["abc","def","ghi"]; customizeArray(myArray); myArray.empty(); </code></pre> <p>This code works as expected because myArray is a regular array in this case, extended with a new method named empty. The main advantage and drawback of this approach in comparison with using prototypes is that it modifies only the selected instance, and if you were working with lots of similar objects at the same time, setting this extra property would use more memory than setting a single shared property on a common prototype.</p> <p>To avoid that, you may be tempted to modify the Array prototype directly:</p> <pre><code>Array.prototype.empty = function(){ this.length = 0; }; var myArray = ["abc","def","ghi"]; myArray.empty(); </code></pre> <p>It works, but I would advise against it: you are attaching a custom property to every array instance, including all those created by those fancy libraries, plugins, frameworks, advertising and analytics scripts, all the code on your page. Needless to say that it may break something in a place where you cannot fix it.</p> <p><strong>Edit:</strong> Interesting post on kangax's blog as a follow-up: <a href="http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/" rel="nofollow noreferrer">"How ECMAScript 5 still does not allow to subclass an array"</a></p>
<p>Sharing a quick demo of Javascript inheritance after reading the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Details_of_the_Object_Model#More_flexible_constructors" rel="nofollow">mozilla doc</a></p> <pre><code>function Employee (name, dept) { this.name = name || ""; this.dept = dept || ""; } function Programmer (name, projs) { Employee.call(this, name, "programming"); this.projects = projs || []; } Programmer.prototype = new Employee; // demo dynamic inheritance Employee.prototype.leave = 10; var johnny = new Programmer("Johnny", ["C#","Java"]); alert("name: " + johnny.name + "\n" + "dept: " + johnny.dept + "\n" + "projects: " + johnny.projects + "\n" + "leave: " + johnny.leave); var mary = new Programmer("Mary", ["Javascript","Java"]); alert("name: " + mary.name + "\n" + "dept: " + mary.dept + "\n" + "projects: " + mary.projects + "\n" + "leave: " + mary.leave); alert("changing leave of all staff to 8"); Employee.prototype.leave = 8; alert("Johnny leave: " + johnny.leave); // 8 alert("Mary leave: " + mary.leave); // 8 alert("cannot batch move staff to another department"); Employee.prototype.dept = "sales"; alert("Johnny dept: " + johnny.dept); // programming alert("Mary dept: " + mary.dept); // programming </code></pre> <p><a href="http://jsfiddle.net/9Xr83/" rel="nofollow">Demo in jsfiddle</a> <a href="http://jsfiddle.net/9Xr83/1/" rel="nofollow">Demo with more debug in jsfiddle</a></p>