Prototyping with a function assignment in Javascript
<p>I have been trying some fundamentals in javascript and here is what I observed.</p> <p>I wrote a prototype modification method for Function object</p> <pre><code>Function.prototype.method = function(name, func) { this.prototype[name] = func; return this; } function pirates(value) { console.log("I just throw away the value!!" + value); } pirates.method("my_skill", function(){ console.log("Pirate skills"); }); new_pirate = new pirates(1234); //SUCCESS new_pirate.my_skill(); //prints "Pirate skills" var someCrappyVariable = function(){ return function() { console.log("I am going to just sit and do nothing. Really!"); } }(); **//Throws error. WHY???????? This was assigned a function, so ideally prototype should work on this too? Shouldn't it?** someCrappyVariable.method("crappyFunction", function(){ console.log("am I doomed?"); }); </code></pre> <p>Why does last assignment throws an error that someCrappyVariable is not a function, when it was assigned a function reference earlier? I am confused.</p> <p>Cheers</p>
<p>Your code should be throwing an error here:</p> <pre><code>new_pirate.method("my_skill", function(){ console.log("Pirate skills"); }); // TypeError: new_pirate.method is not a function </code></pre> <p>... since <code>method</code> is not a direct or inherited method. The object created from <code>new pirates(1234)</code> will not inherit from <code>Function</code>; it will inherit from <code>Object</code> (<em>which, ideally, shouldn't be extended with custom methods</em>).</p>
<p>If we remove the code for "new_pirate", there is still an error.</p> <p>In standard js, a prototype chain for an object can be established by assigning the prototype property of the constructor <em>before</em> it runs and creates the object. So if you call the "method" on someCrappyVariable, it will set the "name" on the "prototype" property of the created object only, which is pretty much useless.</p> <p>What you actaully want is to set someCrappyVariable.constructor.prototype[name] so all object with the same constructor can find the set method like someCrappyVariable[name] (which is created by an anonymous function in this case).</p>