Problems with javascript classes and context
<p>In the code below I want to call the method <strong>OpenNextPage</strong> through a <strong>call back</strong> called by a function from a third part API. In the first time the method is being called by an instance of a class called Corridor. After called for the first time, the method is called again through the callBack passed to the <strong>LoadPage</strong> method until no more corridors are returned by the Api function getCorridors.</p> <p>I've found some problems regarding the context of execution. The method OpenNextPage should always be executed in the same context it was in the first time (where mC is the object that holds the instance of this). But this is not happening, the OpenNextPage is being called in a different context. Any ideas?</p> <p>Cheers</p> <pre><code>function startExec() { var mC = new Corridor(); mC.OpenNextPage(); } Corridor.prototype.OpenNextPage = function() { if(this.KeepLoading == false) { if(this.KeepLoadingTimer) clearTimeout(this.KeepLoadingTimer); return 0; } this.ShowLoadingCorridorMsg(); this.LoadPage(++this.LoadedPages, this.OpenNextPage, 3 * this.ItemsPerPage); } //******************************************************************************** //Private Corridor.prototype.LoadPage = function(page, callBack, pageSize) { var ref = this; var mt = new MWsTraffic(); var city = new MCity(); city.name = cityList.getCurrentCity().name; city.state = cityList.getCurrentCity().state; var rr = new MResultRange(); //This function is defined in a sort of public API available on the partner web site. //So, as far as I know, the execution context will be changed and as of this point the 'this' will refer //to another object, that's why I have a this reference in the ref variable. This is what I think mt.getCorridors(city, rr, function(cInfo) { if (cInfo == null) { ref.KeepLoading = false; return null; } if( (cInfo.recordCount == 0) ) { ref.KeepLoading = false; return null; } var e; for (var i = 0; i &lt; cInfo.recordCount; i++) { e = cInfo.corridor[i]; ref.totalCorridorsArray.push( new corridorContents(e.codCorridor, e.nameCorridor, e.levelCongested, e.point.x, e.point.y, false) ); } if(callBack != null) { //Corridor.call(ref, callBack); callBack(); // &lt;---- here's is the problem. This callback which points to the OpenNextPage function is being executed in another context. // I want to execute it in the same context OpenNextPage was called originaly (from inside startExec mC object) } } ); } </code></pre>
<p>You should use some kind of "bind" facility. This will help you</p> <pre><code>function bind(context,fncname){ return function(){ context[fncname].apply(context,arguments); } } var openNextPage = bind(this,"OpenNextPage"); this.LoadPage(++this.LoadedPages, openNextPage, 3 * this.ItemsPerPage); </code></pre> <p>Or instead of callBack do </p> <pre><code>callBack.call(ref); </code></pre> <p>But "bind" is better, cause sometimes you want to pass callbacks to some outside functions which have no pointer to "this". So by binding them, you will always have a correct scope. </p>