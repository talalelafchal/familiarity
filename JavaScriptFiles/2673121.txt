How to check if object has any properties in JavaScript?
<p>Assuming I declare </p> <pre><code>var ad = {}; </code></pre> <p>How can I check whether this object will contain any user-defined properties?</p>
<pre><code>for(var memberName in ad) { //Member Name: memberName //Member Value: ad[memberName] } </code></pre> <p>Member means Member property, member variable, whatever you want to call it >_></p> <p>The above code will return EVERYTHING, including toString... If you only want to see if the object's prototype has been extended:</p> <pre><code>var dummyObj = {}; for(var memberName in ad) { if(typeof(dummyObj[memberName]) == typeof(ad[memberName])) continue; //note A //Member Name: memberName //Member Value: ad[memberName] } </code></pre> <p>Note A: We check to see if the dummy object's member has the same type as our testing object's member. If it is an extend, dummyobject's member type should be "undefined"</p>
<p>You can loop over the properties of your object as follows: </p> <pre><code>for(var prop in ad) { if (ad.hasOwnProperty(prop)) { // handle prop as required } } </code></pre> <p>It is important to use the <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Object/hasOwnProperty" rel="nofollow noreferrer"><code>hasOwnProperty()</code></a> method, to determine whether the object has the specified property as a direct property, and not inherited from the object's prototype chain.</p>
<pre><code>for (var hasProperties in ad) break; if (hasProperties) ... // ad has properties </code></pre> <p>If you have to be safe and check for Object prototypes (these are added by certain libraries and not there by default):</p> <pre><code>var hasProperties = false; for (var x in ad) { if (ad.hasOwnProperty(x)) { hasProperties = true; break; } } if (hasProperties) ... // ad has properties </code></pre>
<p>What about making a simple function?</p> <pre><code>function isEmptyObject(obj) { for(var prop in obj) { if (Object.prototype.hasOwnProperty.call(obj, prop)) { return false; } } return true; } isEmptyObject({}); // true isEmptyObject({foo:'bar'}); // false </code></pre> <p>The <code>hasOwnProperty</code> method call directly on the <code>Object.prototype</code> is only to add little more <em>safety</em>, imagine the following using a normal <code>obj.hasOwnProperty(...)</code> call:</p> <pre><code>isEmptyObject({hasOwnProperty:'boom'}); // false </code></pre> <hr> <p><strong>Note:</strong> <sub>(for the future)</sub> The above method relies on the <code>for...in</code> statement, and this statement iterates only over <em>enumerable</em> properties, in the currently most widely implemented ECMAScript Standard (3rd edition) the programmer doesn't have any way to create non-enumerable properties.</p> <p>However this has changed now with <a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm" rel="nofollow noreferrer">ECMAScript 5th Edition</a>, and we are able to create non-enumerable, non-writable or non-deletable properties, so the above method <strong>can fail</strong>, e.g.:</p> <pre><code>var obj = {}; Object.defineProperty(obj, 'test', { value: 'testVal', enumerable: false, writable: true, configurable: true }); isEmptyObject(obj); // true, wrong!! obj.hasOwnProperty('test'); // true, the property exist!! </code></pre> <p>An ECMAScript 5 solution to this problem would be:</p> <pre><code>function isEmptyObject(obj) { return Object.getOwnPropertyNames(obj).length === 0; } </code></pre> <p>The <code>Object.getOwnPropertyNames</code> method returns an <code>Array</code> containing the names of <em>all</em> the <em>own properties</em> of an object, <em>enumerable or not</em>, this method is being implemented now by browser vendors, it's already on the Chrome 5 Beta and the latest WebKit Nightly Builds.</p> <p><code>Object.defineProperty</code> is also available on those browsers and latest Firefox 3.7 Alpha releases.</p>
<p>When sure that the object is a user-defined one, the easiest way to determine if UDO is empty, would be the following code:</p> <pre><code>isEmpty= /*b.b Troy III p.a.e*/ function(x,p){for(p in x)return!1;return!0}; </code></pre> <p>Even though this method is (by nature) a deductive one, - it's the quickest, and fastest possible. </p> <pre><code>a={}; isEmpty(a) &gt;&gt; true a.b=1 isEmpty(a) &gt;&gt; false </code></pre> <p>p.s.: !don't use it on browser-defined objects.</p>
<p>Late answer, but some frameworks handle objects as enumerables. Therefore, <a href="http://www.bobjs.com" rel="nofollow">bob.js</a> can do it like this:</p> <pre><code>var objToTest = {}; var propertyCount = bob.collections.extend(objToTest).count(); </code></pre>
<p>With <strong>jQuery</strong> you can use:</p> <pre><code>$.isEmptyObject(obj); // Returns: Boolean </code></pre> <p>As of jQuery 1.4 this method checks both properties on the object itself and properties inherited from prototypes (in that it doesn't use hasOwnProperty).</p> <p>With <strong>ECMAScript 5th Edition</strong> in modern browsers (IE9+, FF4+, Chrome5+, Opera12+, Safari5+) you can use the built in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys">Object.keys</a> method:</p> <pre><code>var obj = { blah: 1 }; var isEmpty = !Object.keys(obj).length; </code></pre> <p>Or plain old JavaScript:</p> <pre><code>var isEmpty = function(obj) { for(var p in obj){ return false; } return true; }; </code></pre>
<p>Most recent browsers (and node.js) support Object.keys() which returns an array with all the keys in your object literal so you could do the following:</p> <pre><code>var ad = {}; Object.keys(ad).length;//this will be 0 in this case </code></pre> <p>Browser Support: Firefox 4, Chrome 5, Internet Explorer 9, Opera 12, Safari 5</p> <p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys</a></p>
<p>If you're using underscore.js then you can use the <a href="http://underscorejs.org/#isEmpty">_.isEmpty</a> function:</p> <pre><code>var obj = {}; var emptyObject = _.isEmpty(obj); </code></pre>
<p><strong>There are two ways of doing it:</strong></p> <ol> <li>propName in obj</li> <li>obj.hasOwnProperty(propName)</li> </ol> <p>However, pay attention: there is a very <strong>big</strong> difference between the two: </p> <p>The first one will return <code>true</code> if obj has a property named propName (obj.propName), however if it will not find one, it will <strong>keep</strong> looking for propName down the <code>prototype</code> tree. If it will find one there, the expression will return <code>true</code> otherwise it will return <code>false</code>.</p> <p>The second example will check <strong>only</strong> the object itself <strong>without</strong> checking its prototype(s). This is much like iterating an array.</p> <p>Example:</p> <pre><code>function Obj(){ this.a = undefined; this.b = null; this.c = false; } Obj.prototype = { d: true, e: true }; var obj = new Obj(); </code></pre> <p>And to test it:</p> <pre><code>"a" in obj // true "e" in obj // true obj.hasOwnProperty("a") // true obj.hasOwnProperty("e") // false </code></pre>
<p>If you are willing to use <a href="https://lodash.com/" rel="nofollow">lodash</a>, you can use the <code>some</code> method.</p> <pre><code>_.some(obj) // returns true or false </code></pre> <p>See this small jsbin <a href="https://jsbin.com/sizoroyuti/edit?js,console" rel="nofollow">example</a></p>
<pre><code>var hasAnyProps = false; for (var key in obj) { hasAnyProps = true; break; } // as of this line hasAnyProps will show Boolean whether or not any iterable props exist </code></pre> <p>Simple, works in every browser, and even though it's technically a loop for all keys on the object it does <strong>NOT</strong> loop through them all...either there's 0 and the loop doesn't run or there is some and it breaks after the first one (because all we're checking is if there's ANY...so why continue?)</p>
<p>You can use the following:</p> <p><strong>Double bang !! property lookup</strong></p> <pre><code>var a = !![]; // true var a = !!null; // false </code></pre> <p><strong>hasOwnProperty</strong> This is something that I used to use:</p> <pre><code>var myObject = { name: 'John', address: null }; if (myObject.hasOwnProperty('address')) { // true // do something if it exists. } </code></pre> <p>However, JavaScript decided not to protect the methodâ€™s name, so it could be tampered with. </p> <pre><code>var myObject = { hasOwnProperty: 'I will populate it myself!' }; </code></pre> <p><strong>prop in myObject</strong></p> <pre><code>var myObject = { name: 'John', address: null, developer: false }; 'developer' in myObject; // true, remember it's looking for exists, not value. </code></pre> <p><strong>typeof</strong></p> <pre><code>if (typeof myObject.name !== 'undefined') { // do something } </code></pre> <p>However, it doesn't check for null.</p> <p>I think this is the best way.</p> <p><strong>in operator</strong> </p> <pre><code>var myObject = { name: 'John', address: null }; if('name' in myObject) { console.log("Name exists in myObject"); }else{ console.log("Name does not exist in myObject"); } </code></pre> <p>result: </p> <blockquote> <p>Name exists in myObject</p> </blockquote> <p>Here is a link that goes into more detail on the in operator: <a href="https://www.nczonline.net/blog/2010/07/27/determining-if-an-object-property-exists/" rel="nofollow">Determining if an object property exists</a></p>
<p>You can use the built in <code>Object.keys</code> method to get a list of keys on an object and test its length. </p> <pre><code>var x = {}; // some code where value of x changes and than you want to check whether it is null or some object with values if(Object.keys(x).length &gt; 0){ // Your code here if x has some properties } </code></pre>