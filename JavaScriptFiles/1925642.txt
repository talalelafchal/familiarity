Javascript: Suppress &quot;Stop running this script?&quot;, or how to use setTimeout?
<p>I'm building a js library that reads binary files, including zip files. </p> <p>Because there's no direct native support for arrays of binary data, when the zip files get large, there's a lot of copying that has to go on (<a href="http://stackoverflow.com/questions/1919972/how-do-i-access-xhr-responsebody-from-javascript">See my other question</a> for details). </p> <p>This results in a "Stop Running this script?" alert. Now, I know this can happen if there's an infinite loop, but in my case, it's not an infinite loop. It's not a bug in the program. It just takes a loooooong time. </p> <p>How can I suppress this? </p>
<p>I believe this feature is specific to Firefox and/or other browsers, and it has nothing to do with the javascript language itself.</p> <p>As far as I know you (the programmer) have no way of stopping it in your visitors' browser.</p>
<p>You could divide the process into increments, then use <code>setTimeout</code> to add a small delay.</p>
<p>In IE (and maybe Firefox too), the message is based on the number of statements executed, not the running time. If you can split some of the processing into a separate function, and defer it with setTimeout, I believe that it won't count toward the limit.</p>
<p>This message is for security reason enabled, because otherwise you could simply block the users browser with a simple never ending loop. I think there no way to deactivate it.</p> <p>Think about splitting you processing into serval parts, and schedule them via <code>setTimeout</code>, this should surpress the message, because the script is now not running all the time.</p>
<p>...answering my own question, so I could post the code I used. </p> <p>The main issue was, I was reading the entire contents of a file, with a readToEnd() method, which actually reads one byte at a time. When reading a large file, it took a looooong time. The solution was to read asynchronously, and in batches. </p> <p>This is the code I used: </p> <pre><code>readToEndAsync : function(callback) { _state = ""; var slarge = ""; var s = ""; var txtrdr = this; var readBatchAsync = function() { var c = 0; var ch = txtrdr.readChar(); while(ch != null) { s += ch;c++; if(c &gt; 1024) { slarge += s; s = ""; break; } ch = txtrdr.readChar(); } if (ch!=null){ setTimeout(readBatchAsync, 2); } else { callback(slarge+s); } }; // kickoff readBatchAsync(); return null; }, </code></pre> <p>And to call it: </p> <pre><code>textReader.readToEndAsync(function(out){ say("The callback is complete"); // the content is in "out" }); </code></pre>