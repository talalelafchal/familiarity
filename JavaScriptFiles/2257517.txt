Objects's global variable
<p>The problem is with object's variable: </p> <blockquote> <p>this.timer</p> </blockquote> <p>it's not "global", so when I click the stop button the value of the variable is wrong.<br> If I declare a global variable MyObject (loke var mytimer;) and use it instead this.timer, it works.</p> <p>This is my code:</p> <pre><code>&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="content-type" content="text/html; charset=utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript" language="JavaScript"&gt; var MyObject = { init: function(){ this.timer = 0; document.getElementById("btn1").onclick = function(){ MyObject.RunIt(); }; document.getElementById("btn2").onclick = function(){ clearInterval(this.timer); }; }, RunIt: function(){ var x=0; this.timer = setInterval(function(){ x++; document.getElementById("spn").innerHTML=x; }, 1000); } }; &lt;/script&gt; &lt;style type="text/css"&gt; &lt;/style&gt; &lt;/head&gt; &lt;body onload="MyObject.init();"&gt; &lt;input type="button" id="btn1" value="Run"/&gt; &lt;input type="button" id="btn2" value="Stop"/&gt; &lt;span id="spn"&gt;&lt;/span&gt; &lt;/body&gt; &lt;/html&gt; </code></pre>
<p><strike>You can access an object through <code>this</code> only if the object was created by <code>new</code>.</p> <p>The <code>this</code> in your code refers to the <code>window</code> object.</strike> In the event handlers it refers to the respective HTML element.</p> <p><a href="http://www.quirksmode.org/js/this.html" rel="nofollow noreferrer">Read a detailled explanation.</a></p> <p><strike>Your MyObject declaration is an object, but lets say that it is not an object instance. There is a difference in JS.</strike></p> <p>Object instance example:</p> <pre><code> function MyClass() { this.timer = 0; this.RunIt = function() { var x=0; this.timer = setInterval(function(){ x++; document.getElementById("spn").innerHTML=x; }, 1000); }; var me = this; // alias to current "this" document.getElementById("btn1").onclick = function(){ // "this" refers to btn1, use me me.RunIt(); }; document.getElementById("btn2").onclick = function(){ // "this" refers to btn2, use me clearInterval(me.timer); }; } var MyObject = new MyClass(); </code></pre> <p>Note, that there are many different ways to construct objects in JavaScript.</p> <p><strong>EDIT</strong>: it contains another bug: the event handler functions will be executed as members of the HTML element. So <code>this</code> in the handlers refers to the HTML element, not to your object.</p> <p><strong>EDIT</strong>: fixed the code</p> <p><strong>EDIT</strong>: Bad day, don't listen to me ;-)</p>
<p>The problem is this: when you set "onclick" to a function call like that, there's no object reference in the call. The browser calls your function to do the "clearInterval", but "this" is not pointing to your object - in fact, it's pointing at the button element itself.</p> <p>Here's one way to work around the problem:</p> <pre><code>var self = this; document.getElementById('btn2').onclick = function() { clearInterval(self.timer); }; </code></pre> <p>I know that question-askers on Stackoverflow get annoyed sometimes when people urge them to investigate jQuery or some other modern Javascript framework, but it's simply a better way to do things.</p>
<p>This is a common problem in writing javascript code; the <strong>Scope</strong>.</p> <p>in an <strong>.onclick</strong> method on an element, the <strong>scope</strong> (this) is the element itself not the class you are in (MyObject).</p> <p>i use this/that method; like below:</p> <pre><code> init: function(){ this.timer = 0; document.getElementById("btn1").onclick = function(){ MyObject.RunIt(); }; var that = this; document.getElementById("btn2").onclick = function(){ /** Here i use 'that' instead of 'this'; because 'this' is the button element */ clearInterval(that.timer); }; }, </code></pre>