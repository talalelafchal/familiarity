How to display all methods of an object in Javascript?
<p>I want to know how to list all methods available for an object like for example:</p> <pre><code> alert(show_all_methods(Math)); </code></pre> <p>This should print: </p> <pre><code>abs, acos, asin, atan, atan2, ceil, cos, exp, floor, log, max, min, pow, random,round, sin, sqrt, tan. </code></pre>
<pre><code>var methods = []; for (var m in obj) { if (typeof obj[m] == "function") { methods.push(m); } } alert(methods.join(",")); </code></pre> <p>This way, you will get all methods that you can call on <code>obj</code>. This includes the methods that it "inherits" from its prototype (like <code>getMethods()</code> in java). If you only want to see those methods defined directly by <code>obj</code> you can check with <code>hasOwnProperty</code>:</p> <pre><code>var methods = []; for (var m in obj) { if (typeof obj[m] == "function" &amp;&amp; obj.hasOwnProperty(m)) { methods.push(m); } } alert(methods.join(",")); </code></pre>
<p>The short answer is you can't because <code>Math</code> and <code>Date</code> (off the top of my head, I'm sure there are others) are't normal objects. To see this, create a simple test script:</p> <pre><code>&lt;html&gt; &lt;body&gt; &lt;script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function() { alert("Math: " + Math); alert("Math: " + Math.sqrt); alert("Date: " + Date); alert("Array: " + Array); alert("jQuery: " + jQuery); alert("Document: " + document); alert("Document: " + document.ready); }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; </code></pre> <p>You see it presents as an object the same ways document does overall, but when you actually try and see in that object, you see that it's native code and something not exposed the same way for enumeration.</p>
<p>Most modern browser support <code>console.dir(obj)</code>, which will return all the properties of an object that it inherited through its constructor. See Mozilla's <a href="https://developer.mozilla.org/en-US/docs/Web/API/console.dir" rel="nofollow noreferrer">documentation</a> for more info and current browser support.</p> <p><code>console.dir(Math) =&gt; MathConstructor E: 2.718281828459045 LN2: 0.6931471805599453 ... tan: function tan() { [native code] } __proto__: Object </code></p>
<p>You can use <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames" rel="nofollow noreferrer"><code>Object.getOwnPropertyNames()</code></a> to get all properties that belong to an object, whether enumerable or not. For example:</p> <pre><code>console.log(Object.getOwnPropertyNames(Math)); //-&gt; ["E", "LN10", "LN2", "LOG2E", "LOG10E", "PI", ...etc ] </code></pre> <p>You can then use <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="nofollow noreferrer"><code>filter()</code></a> to obtain only the methods:</p> <pre><code>console.log(Object.getOwnPropertyNames(Math).filter(function (p) { return typeof Math[p] === 'function'; })); //-&gt; ["random", "abs", "acos", "asin", "atan", "ceil", "cos", "exp", ...etc ] </code></pre> <hr> <p>In ES3 browsers (IE 8 and lower), the properties of built-in objects aren't enumerable. Objects like <code>window</code> and <code>document</code> aren't built-in, they're defined by the browser and most likely enumerable by design.</p> <p>From <a href="http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf" rel="nofollow noreferrer">ECMA-262 Edition 3</a>:</p> <blockquote> <p><strong>Global Object</strong><br> There is a unique global object (15.1), which is created before control enters any execution context. Initially the global object has the following properties: </p> <p>• Built-in objects such as Math, String, Date, parseInt, etc. <strong>These have attributes { DontEnum }</strong>.<br> • Additional host defined properties. This may include a property whose value is the global object itself; for example, in the HTML document object model the window property of the global object is the global object itself. </p> <p>As control enters execution contexts, and as ECMAScript code is executed, additional properties may be added to the global object and the initial properties may be changed.</p> </blockquote> <p>I should point out that this means those objects aren't enumerable properties of the Global object. If you look through the rest of the specification document, you will see most of the built-in properties and methods of these objects have the <code>{ DontEnum }</code> attribute set on them.</p> <hr> <p>Update: a fellow SO user, CMS, brought an <a href="https://developer.mozilla.org/en/ECMAScript_DontEnum_attribute#JScript_DontEnum_Bug" rel="nofollow noreferrer">IE bug regarding <code>{ DontEnum }</code></a> to my attention.</p> <blockquote> <p>Instead of checking the DontEnum attribute, [Microsoft] JScript will skip over any property in any object where there is a same-named property in the object's prototype chain that has the attribute DontEnum.</p> </blockquote> <p>In short, beware when naming your object properties. If there is a built-in prototype property or method with the same name then IE will skip over it when using a <code>for...in</code> loop.</p>
<p>It's not possible with ES3 as the properties have an internal <code>DontEnum</code> attribute which prevents us from enumerating these properties. ES5, on the other hand, provides property descriptors for controlling the enumeration capabilities of properties so user-defined and native properties can use the same interface and enjoy the same capabilities, which includes being able to see non-enumerable properties programmatically.</p> <p>The <code>getOwnPropertyNames</code> function can be used to enumerate over all properties of the passed in object, including those that are non-enumerable. Then a simple <code>typeof</code> check can be employed to filter out non-functions. Unfortunately, Chrome is the only browser that it works on currently.</p> <pre><code>​function getAllMethods(object) { return Object.getOwnPropertyNames(object).filter(function(property) { return typeof object[property] == 'function'; }); } console.log(getAllMethods(Math)); </code></pre> <p>logs <code>["cos", "pow", "log", "tan", "sqrt", "ceil", "asin", "abs", "max", "exp", "atan2", "random", "round", "floor", "acos", "atan", "min", "sin"]</code> in no particular order.</p>
<p>I believe there's a simple historical reason why you can't enumerate over methods of built-in objects like Array for instance. Here's why:</p> <p>Methods are properties of the prototype-object, say Object.prototype. That means that all Object-instances will inherit those methods. That's why you can use those methods on any object. Say .toString() for instance.</p> <p>So IF methods were enumerable, and I would iterate over say {a:123} with: "for (key in {a:123}) {...}" what would happen? How many times would that loop be executed? </p> <p>It would be iterated once for the single key 'a' in our example. BUT ALSO once for every <em>enumerable</em> property of Object.prototype. So if methods were enumerable (by default), then any loop over any object would loop over all its inherited methods as well.</p>