In Javascript, what's better than try/catch for exiting an outer scope?
<p>In Javascript, I sometimes want to return a value from a scope that <em>isn't</em> the current function. It might be a block of code within the function, or it might be an enclosing function as in the following example, which uses a local function to recursively search for something. As soon as it finds a solution, the search is done and the outer function should just exit. Unfortunately, I can't think of a simpler way to do this than by hacking try/catch for the purpose:</p> <pre><code>function solve(searchSpace) { var search = function (stuff) { var solution = isItSolved(stuff); if (solution) { throw solution; } else { search(narrowThisWay(stuff)); search(narrowThatWay(stuff)); }; }; try { return search(searchSpace); } catch (solution) { return solution; }; }; </code></pre> <p>I realize one could assign the solution to a local variable and then check it before making another recursive call, but my question is specifically about transfer of control. Is there a better way than the above? Perhaps involving label/break?</p> <p>Edit: since the answers to date are variations of "ew that's bad you're not supposed to do that", let me add some necessary context. I'm hacking on an open-source compiler that targets Javascript. <em>No one is going to write this code by hand</em>, so please don't tell me "this is a bad programming technique". What I want is a better <em>code generation</em> technique. The question is whether anyone has any clever hack for exploiting Javascript to get more flexible control transfer.</p> <p>The reason assigning the result to a local variable and checking it is ruled out is because that requires understanding the code in a way that is hard for a compiler to do.</p>
<p>It seems I stand corrected on the intent of the question. If statements <em>are</em> are a useful and readable way to structure code and make it flow however you want to. There's a reason <code>goto</code> was taken out of so many languages, because you don't need it. And it seems like, based on your example code, you're using a try-catch block as a form of <code>goto</code>. If you don't want certain things to run then use if statements or equivalents:</p> <pre><code>function solve(searchSpace) { function search = function (stuff) { //|| will only return the first value if that value is truthy, subsequent values will be ignored return isItSolved(stuff) || (search(narrowThisWay(stuff)) || search(narrowThatWay(stuff))); }; return search(searchSpace); }; </code></pre> <p>I know of no way to break out of function calls like you want. You can break out of loops using <a href="http://blog.stchur.com/2007/03/09/the-javascript-goto-statement/" rel="nofollow noreferrer">labels</a>, but it doesn't seem that's much help to your situation. Other than that, I don't think JavaScript has any such ability beyond your use of exceptions</p>
<p>It looks like you're doing a fairly straightforward recursive search in your example. Why not just use "return"?</p> <pre><code>function solve(searchSpace) { var search = function (stuff) { var solution = isItSolved(stuff); if (solution) { return solution; } else { solution = search(narrowThisWay(stuff)); if (solution) { return solution; } return search(narrowThatWay(stuff)); }; }; return search(searchSpace); }; </code></pre> <p>I suppose it could be that there are other constraints you haven't mentioned, but it's in general possible to turn any control flow into a set of nested (or recursive) functions, with appropriate return values.</p>
<pre><code>function solve(stuff) { return isItSolved(stuff) || solve(narrowThisWay(stuff)) || solve(narrowThatWay(stuff)); } </code></pre> <p>Bob's way is good... exept that he uses twice the function statement (and that he uses ; after a function delaration without an assignment)... and that as we can do it that way, function solve actually is function search.</p> <p>PS : This code will epically fail if the isItSolved, narrowThisWay or narrowThatWay functions can return a value evaluated to false as a positive result. In this cas, you would have to use ? : statement in order to check if all responses are !== undefined.</p> <p>PS2: And of ourse, if these function can send an error, you have to catch it...</p>
<p>The cleanest way would be to use a continuation, but you don't have that efficiently in JS (a few <a href="http://wiki.apache.org/cocoon/RhinoWithContinuations" rel="nofollow noreferrer">JS engines</a> support continuations, but for the rest there's only <a href="http://www.google.com/search?q=continuation+passing+style+javascript" rel="nofollow noreferrer">CPS</a>, which cries out for tail calls). In C, you could use setjmp/longjmp. In Common Lisp, you could use conditions (which include the functionality of exceptions plus much more). In JS, exceptions are the only non-local control flow option you have available.</p> <p>You can programmatically <a href="http://c2.com/cgi/wiki?CpsTransformation" rel="nofollow noreferrer">transform</a> a program into another that uses CPS.</p> <pre><code>function solve(searchSpace, isItSolved, isBase, narrowThisWay, narrowThatWay) { function search(stuff, k) { solution = isItSolved(stuff); if (solution) { return solution; } else if (isBase(stuff)) { return k(); } else { return search(narrowThisWay(stuff), function() { return search(narrowThatWay(stuff), k); }); }; }; return search(searchSpace, function(val) {return val}); }; var arr=[1, 2,9,72,0,34,5,33,24,62,89,90,30,54,590,23,59,62,73]; solve(arr, function(a) {return (a.length==1 &amp;&amp; a[0] == 5) ? a[0] : false;}, function (a) {return a.length &lt; 2; }, function (a) {return a.slice(0, a.length / 2);}, function (a) {return a.slice(a.length / 2);} ); </code></pre>