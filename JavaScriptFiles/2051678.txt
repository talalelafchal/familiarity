Getting All Variables In Scope
<p>Is there a way to get all variables that are currently in scope in javascript?</p>
<p>No. "In scope" variables are determined by the "scope chain", which is not accessible programmatically.</p> <p>For detail (quite a lot of it), check out the ECMAScript (JavaScript) specification. <a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm" rel="nofollow noreferrer">Here's a link</a> to the official page where you can download the canonical spec (a PDF), and <a href="http://www.ecma-international.org/ecma-262/5.1/" rel="nofollow noreferrer">here's one</a> to the official, linkable HTML version.</p> <p><strong>Update based on your comment to Camsoft</strong></p> <p>The variables <em>in scope</em> for your event function are determined by where you define your event function, not how they call it. <strong>But</strong>, you may find useful information about what's available to your function via <code>this</code> and arguments by doing something along the lines of what KennyTM pointed out (<code>for (var propName in ____)</code>) since that will tell you what's available on various objects provided to you (<code>this</code> and arguments; if you're not sure what arguments they give you, you can find out via the <code>arguments</code> variable that's implicitly defined for every function).</p> <p>So in addition to whatever's in-scope because of where you define your function, you can find out what else is available by other means by doing:</p> <pre><code>var n, arg, name; alert("typeof this = " + typeof this); for (name in this) { alert("this[" + name + "]=" + this[name]); } for (n = 0; n &lt; arguments.length; ++n) { arg = arguments[n]; alert("typeof arguments[" + n + "] = " + typeof arg); for (name in arg) { alert("arguments[" + n + "][" + name + "]=" + arg[name]); } } </code></pre> <p>(You can expand on that to get more useful information.)</p> <p>Instead of that, though, I'd probably use a debugger like Chrome's dev tools (even if you don't normally use Chrome for development) or <a href="http://getfirebug.com/" rel="nofollow noreferrer">Firebug</a> (even if you don't normally use Firefox for development), or Dragonfly on Opera, or "F12 Developer Tools" on IE. And read through whatever JavaScript files they provide you. And beat them over the head for proper docs. :-)</p>
<p>You can't.</p> <p>Variables, identifiers of function declarations and arguments for function code, are bound as properties of the <a href="http://bclary.com/2004/11/07/#a-10.1.3" rel="nofollow noreferrer">Variable Object</a>, which is not accesible.</p> <p>See also:</p> <ul> <li><a href="http://bclary.com/2004/11/07/#a-10.1.4" rel="nofollow noreferrer">Scope Chain and Identifier Resolution</a></li> </ul>
<p>Yes and no. "No" in almost every situation. "Yes," but only in a limited manner, if you want to check the global scope. Take the following example:</p> <pre><code>var a = 1, b = 2, c = 3; for ( var i in window ) { console.log(i, typeof window[i], window[i]); } </code></pre> <p>Which outputs, <em>amongst 150+ other things</em>, the following:</p> <pre><code>getInterface function getInterface() i string i // &lt;- there it is! c number 3 b number 2 a number 1 // &lt;- and another _firebug object Object firebug=1.4.5 element=div#_firebugConsole "Firebug command line does not support '$0'" "Firebug command line does not support '$1'" _FirebugCommandLine object Object hasDuplicate boolean false </code></pre> <p>So it is possible to list some variables in the current scope, but <strong>it is not reliable, succinct, efficient, or easily accessible.</strong></p> <p>A better question is <em>why do you want to know what variables are in scope?</em></p>
<p>As everyone noticed: you can't. But you can create a obj and assign every var you declare to that obj. That way you can easily check out your vars:</p> <pre><code>var v = {}; //put everything here var f = function(a, b){//do something }; v.f = f; //make's easy to debug var a = [1,2,3]; v.a = a; var x = 'x'; v.x = x; //so on... console.log(v); //it's all there </code></pre>
<h2>The Simplest Way to Get Access to Vars in a Particular Scope</h2> <ol> <li>Open Developer Tools > Resources (in Chrome)</li> <li>Open file with a function that has access to that scope (tip cmd/ctrl+p to find file)</li> <li>Set breakpoint inside that function and run your code</li> <li>When it stops at your breakpoint, you can access the scope var through console (or scope var window) </li> </ol> <p><strong>Note:</strong> You want to do this against un-minified js.</p> <h2>The Simplest Way to Show All Non-Private Vars</h2> <ol> <li>Open Console (in Chrome)</li> <li>Type: <strong>this.window</strong></li> <li>Hit Enter</li> </ol> <p>Now you will see an object tree you can expand with all declared objects.</p>
<p>Although everyone answer "<strong>No</strong>" and I know that "No" is the right answer but if you really need to get <strong>local variables</strong> of a function there is a restricted way.</p> <p>Consider this function:</p> <pre><code>var f = function() { var x = 0; console.log(x); }; </code></pre> <p>You can convert your function to a string:</p> <pre><code>var s = f + ''; </code></pre> <p>You will get source of function as a string</p> <pre><code>'function () {\nvar x = 0;\nconsole.log(x);\n}' </code></pre> <p>Now you can use a parser like <a href="http://esprima.org/demo/parse.html">esprima</a> to parse function code and find local variable declarations.</p> <pre><code>var s = 'function () {\nvar x = 0;\nconsole.log(x);\n}'; s = s.slice(12); // to remove "function () " var esprima = require('esprima'); var result = esprima.parse(s); </code></pre> <p>and find objects with:</p> <pre><code>obj.type == "VariableDeclaration" </code></pre> <p>in the result (I have removed <code>console.log(x)</code> below):</p> <pre><code>{ "type": "Program", "body": [ { "type": "VariableDeclaration", "declarations": [ { "type": "VariableDeclarator", "id": { "type": "Identifier", "name": "x" }, "init": { "type": "Literal", "value": 0, "raw": "0" } } ], "kind": "var" } ] } </code></pre> <p>I have tested this in Chrome, Firefox and Node.</p> <p>But the <strong>problem</strong> with this method is that you just have the variables defined in the function itself. For example for this one:</p> <pre><code>var g = function() { var y = 0; var f = function() { var x = 0; console.log(x); }; } </code></pre> <p>you just have access to the <strong>x</strong> and not <strong>y</strong>. But still you can use chains of <strong>caller</strong> (arguments.callee.caller.caller.caller) in a loop to find local variables of caller functions. If you have all local variable names so you have <strong>scope variables</strong>. With the variable names you have access to values with a simple eval.</p>
<p>If you just want to inspect the variables manually to help debug, just fire up the debugger:</p> <p><code>debugger;</code></p> <p>Straight into the browser console.</p>