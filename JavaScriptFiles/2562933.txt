Confusing Javascript class declaration
<p>I have some third-party Javascript that has statements like this:</p> <pre><code>FOO = function() { ...functions() ... return { hash } }(); </code></pre> <p>It is working as designed but I'm confused by it. Can anybody define what this structure is doing? Is it just a weird way to create a class?</p>
<p>You're missing an open parens, but it is basically a way of usually hiding information within an object i.e. a way of setting up private and privelaged methods.</p> <p>For example</p> <pre><code>var foo = (function() { /* function declarations */ return { /* expose only those functions you want to expose in a returned object */ } })(); </code></pre> <p>Take a look at Papa Crockford's <strong><a href="http://www.crockford.com/javascript/private.html" rel="nofollow noreferrer">Private Members in JavaScript</a></strong>. This is basically the pattern you are seeing, but in a slightly different guise. The function declarations are wrapped in a self-invoking anonymous function - an anonymous function that is executed as soon as it's declared. Since the functions inside of it are scoped to the anonymous function, they will be unreachable after the anonymous function has executed unless they are exposed through a closure created by referencing them in the object returned from the execution of the anonymous function. </p> <p>It's generally referred to as <strong><a href="http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth" rel="nofollow noreferrer">the Module Pattern</a></strong>.</p>
<p>That's not actually a class, just an object. I'd recommend reading this: <a href="http://javascript.crockford.com/survey.html" rel="nofollow noreferrer">http://javascript.crockford.com/survey.html</a></p> <p>Because JavaScript doesn't have block scope, your choice is (mostly) to have all variable reside in global or function scope. The author of your snippet wants to declare some local variables that he doesn't want to be in the global scope, so he declares an anonymous function and executes it immediately, returning the object he was trying to create. That way all the vars will be in the function's scope.</p>
<p>Js doesn't really have classes, per se, but "prototypes". This means that no two objects are ever of the same "type" in the normal type-safe sense, and you can dynamically add members to one instance while leaving the other unmolested. (which is what they have done).</p> <p>Believe it or not, the syntax they have used is probably the most lucid, as it doesn't try to hide behind some C-style class syntax.</p> <p>Doug Crockford's Javascript: The Good Parts is a quick read, and the best introduction to OOP in js that I've come across.</p>
<p>This is a technique that uses closure. The idiom is well-known, but confusing when you first see it. <code>FOO</code> is defined as the object that the outermost function() returns. Notice the parenthesis at the end, which causes the function to evaluate and return <code>{ hash }</code>.</p> <p>The code is equivalent to</p> <pre><code>function bar() { ...functions() ... return { hash } }; FOO = bar(); </code></pre> <p>So FOO is equal to <code>{ hash }</code>. The advantage of this is that <code>hash</code>, whatever it is, has access to stuff defined inside the <code>function()</code>. Nobody else has access, so that stuff is essentially private.</p> <p>Google 'Javascript closure' to learn more.</p>
<p>The parans at the end make this the <a href="http://www.yuiblog.com/blog/2007/06/12/module-pattern/" rel="nofollow noreferrer">Module Pattern</a>, which is basically a way to have a single instance of an object(Singleton) while also using private variables and functions.</p> <p>Since there's closures <code>hash</code>, if it's itself an object or function, will have access to all variables declared within that anonymous Singleton object. </p>