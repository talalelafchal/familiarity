Still confused about JavaScript's 'this'
<p>I've been reading through quite a few articles on the 'this' keyword when using JavaScript objects and I'm still somewhat confused. I'm quite happy writing object orientated Javascript and I get around the 'this' issue by referring the full object path but I don't like the fact I still find 'this' confusing. </p> <p>I found a good answer <a href="http://stackoverflow.com/questions/2148451/help-this-is-confusing-me-in-javascript">here</a> which helped me but I'm still not 100% sure. So, onto the example. The following script is linked from test.html with <code>&lt;script src="js/test.js"&gt;&lt;/script&gt;</code></p> <pre><code>if (!nick) { var nick = {}; } nick.name= function(){ var helloA = 'Hello A'; console.log('1.',this, this.helloA); var init = function(){ var helloB = 'Hello B'; console.log('2.',this, this.helloB); } return { init: init } }(); nick.name.init(); </code></pre> <p><strong>What kind of expected to see was</strong> </p> <pre><code>1. Object {} nick.name, 'Hello A' 2. Object {} init, 'Hello B' </code></pre> <p><strong>But what I get is this?</strong></p> <pre><code>1. Window test.html, undefined 2. Object {} init, undefined </code></pre> <p>I think I understand some of what's happening there but I would mind if someone out there explains it to me.</p> <p>Also, I'm not entirely sure why the first 'console.log' is being called at all? If I remove the call to the init function <code>//nick.name.init()</code> firebug still outputs <code>1. Window test.html, undefined</code>. Why is that? Why does nick.name() get called by the window object when the html page loads? </p> <p>Many thanks</p>
<blockquote> <p>Also, I'm not entirely sure why the first 'console.log' is being called at all?</p> </blockquote> <pre><code>nick.name = function(){ // ... }(); </code></pre> <p>Here you define a function, call it immediately (hence <code>()</code>) and assign its return value (<code>{init: init}</code>) to <code>nick.name</code></p> <p>So the execution is:</p> <ol> <li>Create a variable called <code>nick</code> if there isn't one with a non-falsey value already</li> <li>Create an anonymous function thatâ€¦</li> <li>Creates a variable called <code>helloA</code> in its own scope</li> <li>Outputs data using <code>console.log</code> containing "1" (as is), <code>this</code> (the <code>window</code> because the function is executing in the global context instead of as a method), and <code>this.helloA</code> (<code>window.helloA</code>, which doesn't exist.</li> <li>Defines a function called <code>init</code></li> <li>Returns an object which gets assigned to <code>nick.name</code></li> <li>Then you call <code>nick.name.init()</code> which executes the <code>init</code> function in the context of <code>name</code>.</li> <li>This defines <code>helloB</code></li> <li>Then it <code>console.logs</code> with "2" (as is), <code>this</code> (<code>name</code>), and <code>this.helloB</code> (<code>nick.name.helloB</code> - which doesn't exist)</li> </ol> <p>So the first output you get is from <code>console.log('1.',this, this.helloA);</code></p> <p>I think your main problem is that you are confusing <code>this.foo</code> (properties on the object on which a method is being called) with variable scope (variables available to a function)</p>
<ol> <li><p><code>this</code> is defined on a per-function basis <em>when the function call is made</em>. When you call a function as <code>o.f()</code>, <code>this</code> will be <code>o</code> within the function, and when you call it as <code>f()</code>, <code>this</code> will be the global object (for browsers, this is the window). You wrote <code>nick.name = function(){...}();</code> and the right-hand part is of the form <code>f()</code>, hence the <code>Window</code>.</p></li> <li><p><code>var foo = bar;</code> defines a local variable. It may not be accessed as <code>this.foo</code> (well, except when you're at global scope, but that's silly). To define a member, you usually write <code>this.foo = bar;</code> instead.</p></li> </ol>
<p>It's much simpler if you think about <code>this</code> as a function, not as a variable. Essentially, <code>this</code> is a function which returns current "execution context", that is, the object the current function was "applied" to. For example, consider the following</p> <pre><code>function t() { console.log(this)} </code></pre> <p>this will return very different results depending upon how you call it</p> <pre><code>t() // print window bar = { func: t } bar.func() // print bar foo = { x: 123 } t.apply(foo) // print foo </code></pre>
<p>This is what your code does:</p> <ul> <li>It creates an object and assigns to the variable <code>nick</code>.</li> <li>It creates an anonymous function.</li> <li>It calls the function (in the window scope).</li> <li>It assigns the return value (an object containing the <code>init</code> property) to the <code>name</code> property of the object.</li> <li>It gets the value from the <code>init</code> property, which is a method delegate, and calls the method.</li> </ul> <p>The anonymous function does this:</p> <ul> <li>It declares a local variable named <code>helloA</code> and assigns a string to it. (Creating a local variable doesn't add it as a property to the current object.)</li> <li>It logs <code>this</code> (window) and the <code>helloA</code> property (which doesn't exist).</li> <li>It creates an anonymous function and assignes to the local variable <code>init</code>.</li> <li>It creates an object with the property <code>init</code> and the value from the local variable <code>init</code>.</li> </ul> <p>The anonymous function assigned to the <code>init</code> property does this:</p> <ul> <li>It declares a local variable named <code>helloB</code> and assigns a string to it. (Creating a local variable doesn't add it as a property to the current object.)</li> <li>It logs <code>this</code> (the object from the <code>name</code> property, not the <code>nick</code> variable), and the <code>helloB</code> property (which doesn't exist).</li> </ul>