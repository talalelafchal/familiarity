Why is __caller__ unsafe?
<p>The following seems to be a reasonable use of <code>__caller__</code>:</p> <pre><code>var foo=1; function a() { var foo=2; function b() { var foo=3; foo; // 3 this.foo; // 1, from global __caller__.foo // 2 } b(); } a(); // creates a's execution context </code></pre> <p>However, <code>__caller__</code> is not available. Why not? If the global context/variable object can be accessed using <code>this</code>, then why not <code>a</code>'s?</p>
<p>I am not really familiar with the subject, but have you tried <code>arguments.callee.caller</code>? </p> <p>See here: <a href="http://stackoverflow.com/questions/280389/javascript-how-do-you-find-the-caller-function"><strong>Javascript how do you find the caller function?</strong></a></p>
<p>In your example, you can argue that things in <code>b</code> should be able to address things in the active instance of <code>a</code>, and it seems reasonable because <code>a</code> encloses <code>b</code>. But if that weren't the case, say you define</p> <pre><code> function c() { var foo='hedgehog'; b(); } </code></pre> <p>that's something else entirely, so your argument looks like it applies to a pretty special case.</p>
<p><a href="https://developer.mozilla.org/En/Core_JavaScript_1.5_Reference/Objects/Function/Caller" rel="nofollow noreferrer">Doc says</a>:</p> <blockquote> <p>The special property __caller__, which returned the activation object of the caller thus allowing to reconstruct the stack, was removed for security reasons. </p> </blockquote> <p>And it is easy to see why this could be a security disaster in a browser where much of the UI is implemented in JavaScript. Imagine having one of your functions called by an add-on or other chrome. You could look up the call stack and read callers' (potentially sensitive) variables, or even inject JavaScript values into caller functions, potentially subverting them to do something against the user's wishes. Effectively every web page would get chrome security privileges and completely compromise the browser.</p> <p>You certainly should never have used it in real JavaScript, because it was a non-standard Mozilla-only implementation detail, not to mention incredibly ugly. It does not have the lexical behaviour you normally expect of JS.</p>