unique object identifier in javascript
<p>I need to do some experiment and I need to know some kind of unique identifier for objects in javascript, so I can see if they are the same. I don't want to use equality operators, I need something like the id() function in python. </p> <p>Does something like this exist ?</p>
<p><strong>Update</strong> My original answer below was written 6 years ago in a style befitting the times and my understanding. In response to some conversation in the comments, a more modern approach to this is as follows:</p> <pre><code>(function() { if ( typeof Object.id == "undefined" ) { var id = 0; Object.id = function(o) { if ( typeof o.__uniqueid == "undefined" ) { Object.defineProperty(o, "__uniqueid", { value: ++id, enumerable: false, // This could go either way, depending on your // interpretation of what an "id" is writable: false }); } return o.__uniqueid; }; } })(); var obj = { a: 1, b: 1 }; console.log(Object.id(obj)); console.log(Object.id([])); console.log(Object.id({})); console.log(Object.id(/./)); console.log(Object.id(function() {})); for (var k in obj) { if (obj.hasOwnProperty(k)) { console.log(k); } } // Logged keys are `a` and `b` </code></pre> <p>If you have archaic browser requirements, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#Browser_compatibility" rel="nofollow noreferrer">check here</a> for browser compatibility for <code>Object.defineProperty</code>.</p> <p>The original answer is kept below (instead of just in the change history) because I think the comparison is valuable. </p> <hr> <p>You can give the following a spin. This also gives you the option to explicitly set an object's ID in its constructor or elsewhere.</p> <pre><code>(function() { if ( typeof Object.prototype.uniqueId == "undefined" ) { var id = 0; Object.prototype.uniqueId = function() { if ( typeof this.__uniqueid == "undefined" ) { this.__uniqueid = ++id; } return this.__uniqueid; }; } })(); var obj1 = {}; var obj2 = new Object(); console.log(obj1.uniqueId()); console.log(obj2.uniqueId()); console.log([].uniqueId()); console.log({}.uniqueId()); console.log(/./.uniqueId()); console.log((function() {}).uniqueId()); </code></pre> <p>Take care to make sure that whatever member you use to internally store the unique ID doesn't collide with another automatically created member name.</p>
<p>jQuery code uses it's own <code>data()</code> method as such id.</p> <pre><code>var id = $.data(object); </code></pre> <p>At the backstage method <code>data</code> creates a very special field in <code>object</code> called <code>"jQuery" + now()</code> put there next id of a stream of unique ids like</p> <pre><code>id = elem[ expando ] = ++uuid; </code></pre> <p>I'd suggest you use the same method as John Resig obviously knows all there is about JavaScript and his method is based on all that knowledge.</p>
<p>I've used code like this, which will cause Objects to stringify with unique strings:</p> <pre><code>Object.prototype.__defineGetter__('__id__', function () { var gid = 0; return function(){ var id = gid++; this.__proto__ = { __proto__: this.__proto__, get __id__(){ return id } }; return id; } }.call() ); Object.prototype.toString = function () { return '[Object ' + this.__id__ + ']'; }; </code></pre> <p>the <code>__proto__</code> bits are to keep the <code>__id__</code> getter from showing up in the object. this has been only tested in firefox. </p>
<p>Latest browsers provide a cleaner method for extending Object.prototype. This code will make the property hidden from property enumeration (for p in o)</p> <p>For the browsers that implement defineProperty, you can implement uniqueId property like this:</p> <pre><code>(function() { var id_counter = 1; Object.defineProperty(Object.prototype, "__uniqueId", { writable: true }); Object.defineProperty(Object.prototype, "uniqueId", { get: function() { if (this.__uniqueId == undefined) this.__uniqueId = id_counter++; return this.__uniqueId; } }); }()); </code></pre> <p>For details, see <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/defineProperty">https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/defineProperty</a></p>
<p>Actually, you don't need to modify the <code>object</code> prototype and add a function there. The following should work well for your purpose.</p> <pre><code>var __next_objid=1; function objectId(obj) { if (obj==null) return null; if (obj.__obj_id==null) obj.__obj_id=__next_objid++; return obj.__obj_id; } </code></pre>
<p>For browsers implementing the <code>Object.defineProperty()</code> method, the code below generates and returns a function that you can bind to any object you own.</p> <p>This approach has the advantage of not extending <code>Object.prototype</code>.</p> <p>The code works by checking if the given object has a <code>__objectID__</code> property, and by defining it as a hidden (non-enumerable) read-only property if not.</p> <p>So it is safe against any attempt to change or redefine the read-only <code>obj.__objectID__</code> property after it has been defined, and consistently throws a nice error instead of silently fail.</p> <p>Finally, in the quite extreme case where some other code would already have defined <code>__objectID__</code> on a given object, this value would simply be returned.</p> <pre><code>var getObjectID = (function () { var id = 0; // Private ID counter return function (obj) { if(obj.hasOwnProperty("__objectID__")) { return obj.__objectID__; } else { ++id; Object.defineProperty(obj, "__objectID__", { /* * Explicitly sets these two attribute values to false, * although they are false by default. */ "configurable" : false, "enumerable" : false, /* * This closure guarantees that different objects * will not share the same id variable. */ "get" : (function (__objectID__) { return function () { return __objectID__; }; })(id), "set" : function () { throw new Error("Sorry, but 'obj.__objectID__' is read-only!"); } }); return obj.__objectID__; } }; })(); </code></pre>
<p>Notwithstanding the advice not to modify Object.prototype, this can still be really useful for testing, within a limited scope. The author of the accepted answer changed it, but is still setting <code>Object.id</code>, which doesn't make sense to me. Here's a snippet that does the job:</p> <pre><code>// Generates a unique, read-only id for an object. // The _uid is generated for the object the first time it's accessed. (function() { var id = 0; Object.defineProperty(Object.prototype, '_uid', { // The prototype getter sets up a property on the instance. Because // the new instance-prop masks this one, we know this will only ever // be called at most once for any given object. get: function () { Object.defineProperty(this, '_uid', { value: id++, writable: false, enumerable: false, }); return this._uid; }, enumerable: false, }); })(); function assert(p) { if (!p) throw Error('Not!'); } var obj = {}; assert(obj._uid == 0); assert({}._uid == 1); assert([]._uid == 2); assert(obj._uid == 0); // still </code></pre>
<p>I faced the same problem and here's the solution I implemented with ES6</p> <pre><code>code let id = 0; // This is a kind of global variable accessible for every instance class Animal { constructor(name){ this.name = name; this.id = id++; } foo(){} // Executes some cool stuff } cat = new Animal("Catty"); console.log(cat.id) // 1 </code></pre>