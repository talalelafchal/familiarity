Javascript: Retrieve Object Property Names
<p>I'm trying to write a function that needs to know the property names of an object being passed in, like so:</p> <pre><code>var data = { "key1":"value1", "key2":"value2", etc} ^ i want the string value "key1" </code></pre> <p>How do I retrieve the string "key1" from <code>data</code>? I know I can set a property dynamically like <code>data[prop]=value</code> but i want to know what <code>prop</code> is from an object passed in.</p> <p>If that doesn't make sense I suppose I could try to explain more. Thanks!</p> <p>I eventually want to do something like:</p> <pre><code>for (var i = 0; i&lt;data.length; i++) { var name = data[i].getPropertyName() &lt;--- not a real function // do stuff } </code></pre>
<pre><code>var data = { "key1":"value1", "key2":"value2"}; //etc for (var prop in data) { var propName = prop; var propVal = data[prop]; // do something with your new variables } </code></pre> <p>Yeah, it's that simple.</p>
<p>Before we look at our options, a quick note of the four key things about properties in JavaScript:</p> <ol> <li>Objects can have properties of their own, and properties they inherit from their prototype object.</li> <li>Properties can be <em>enumerable</em> or <em>non-enumerable</em>.</li> <li>Properties can have names that are <em>strings</em>, or (as of ES2015/ES6) names that are <code>Symbol</code>s.</li> <li>Properties cannot have names that are numbers, like 1. Sometimes we act like they do, as when we're dealing with arrays, but they don't. Standard arrays <a href="http://blog.niftysnippets.org/2011/01/myth-of-arrays.html" rel="nofollow noreferrer">aren't really arrays at all</a> (per the spec; JavaScript implementations are allowed to optimize when they can), and the entries in arrays are object properties whose names are strings. So <code>a = ['x', 'y', 'z']</code> defines an array with three properties whose namse are <code>"0"</code>, <code>"1"</code>, and <code>"2"</code>. When we do <code>a[0]</code> to access the first one, the number <code>0</code> is converted to a string. (In theory; again, the JavaScript implementation is allowed to optimize.)</li> </ol> <p>All of these properties can be discovered and enumerated (even the non-enumerable ones). You have several options for doing so:</p> <ul> <li>A <strong><code>for-in</code> loop</strong> (<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-for-in-and-for-of-statements" rel="nofollow noreferrer">spec</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in" rel="nofollow noreferrer">MDN</a>), with or without a <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-object.prototype.hasownproperty" rel="nofollow noreferrer"><code>hasOwnProperty</code></a> guard inside the loop to differentiate between "own" and inherited properties. (Does not include properties named with <code>Symbol</code>s.) Loops through the <em>names</em> of the properties.</li> <li><strong><code>Object.keys</code></strong> (<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-object.keys" rel="nofollow noreferrer">spec</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" rel="nofollow noreferrer">MDN</a>) (ES5+), which returns an array of the names of an object's own, enumerable properties. (Does not include properties named with <code>Symbol</code>s.)</li> <li><strong><code>Object.getOwnPropertyNames</code></strong> (<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-object.getownpropertynames" rel="nofollow noreferrer">spec</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames" rel="nofollow noreferrer">MDN</a>) (ES5+), which returns an array of the names of an object's own properties, regardless of whether they're enumerable. (Does not include properties named with <code>Symbol</code>s.)</li> <li><strong><code>Reflect.enumerate</code></strong> (<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-reflect.enumerate" rel="nofollow noreferrer">spec</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/enumerate" rel="nofollow noreferrer">MDN</a>) (ES2015+), which returns an iterator for the names of the enumerable properties of an object, including ones it inherits. (Does not include properties named with <code>Symbol</code>s.)</li> <li><strong><code>Object.getOwnPropertySymbols</code></strong> (<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-object.getownpropertysymbols" rel="nofollow noreferrer">spec</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols" rel="nofollow noreferrer">MDN</a>) (ES2015+), which returns an array of the names of an object's own properties named with <code>Symbol</code>s, regardless of whether they're enumerable. (Leaves out ones named with strings.)</li> <li><strong><code>Reflect.ownKeys</code></strong> (<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-reflect.ownkeys" rel="nofollow noreferrer">spec</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys" rel="nofollow noreferrer">MDN</a>) (ES2015+), which returns an array of the names of an object's own properties no matter how they're named (<code>Symbol</code> or string), and whether they're enumerable or not.</li> </ul> <p>As you can see, most of the operations only include properties whose names are strings, with only <code>Object.getOwnPropertySymbols</code> and <code>Reflect.ownKeys</code> giving us the ones named with <code>Symbol</code>s.</p> <p>The order of the keys is not defined (not even in ES2015) for <code>for-in</code> or <code>Object.keys</code>. In ES2015 and above, it <em>is</em> defined for the other four, by the <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys" rel="nofollow noreferrer"><code>[[OwnPropertyKeys]]</code></a> and (where applicable) <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ordinary-object-internal-methods-and-internal-slots-enumerate" rel="nofollow noreferrer"><code>[[Enumerate]]</code></a> operations. (Since ES2015 is still [as of this writing] relatively knew, it's possible not all JavaScript engines correctly implement the order yet.)</p> <p>Let's look at examples. First, some setup:</p> <pre><code>// Create an object with one "own" property (plus the ones it // inherits from Object.prototype): var proto = { one: 1 } // Create an object that uses the above as its prototype var obj = Object.create(proto); // Add a couple of enumerable properties obj.two = 2; obj.three = 3; // Add a non-enumerable property (by default, properties created // with Object.defineProperty are non-enumerable) Object.defineProperty(obj, "four", { value: 4, configurable: true, writable: true }); </code></pre> <p><em>(<code>Object.create</code> was added in ES5, but the version of it taking just one argument [as above] can easily be shimmed/polyfilled for obsolete JavaScript engines, like the one in IE8. <code>Object.defineProperty</code> was also added in ES5, and cannot be correctly shimmed/polyfilled.)</em></p> <p>Since most of the operations only involve properties named by strings, we're ignoring <code>Symbol</code>s for now.</p> <p>Once the code above runs, we have this in memory:</p> <pre> +-----------------+ Object.prototype--------------------------------+-->| toString* |-->(...a function...) | | valueOf* |-->(...a function...) | | hasOwnProperty* |-->(...a function...) | | ... | | +-----------------+ | +---------------+ | proto--------------------+-->| [[Prototype]] |--+ | | one: 1 | | +---------------+ | +---------------+ | obj-->| [[Prototype]] |--+ | two: 2 | | three: 3 | | four*: 4 | +---------------+ </pre> <p>With that setup, let's look at our options:</p> <h3><code>for-in</code></h3> <p><code>for-in</code> loops through the names of all of an object's properties (including ones it inherits from its prototype) whose names are strings (leaving out any whose names are <code>Symbol</code>s).</p> <pre><code>for (var name in obj) { // name is the name of each property, so: console.log(name + " = " + obj[name]); } </code></pre> <p>With that, we see</p> <pre> two = 2 three = 3 one = 1 </pre> <p>...or similar. The order you see the properties in is not defined, not even in ES2015.</p> <h3><code>for-in</code> with a <code>hasOwnProperty</code> guard</h3> <p>If we wanted the loop, but ignoring inherited properties, we can add a <code>hasOwnProperty</code> check:</p> <pre><code>for (var name in obj) { if (obj.hasOwnProperty(name)) { console.log(name + " = " + obj[name]); } } </code></pre> <p>With that, we see</p> <pre> two = 2 three = 3 </pre> <p>We don't see <code>one</code> because it's inherited.</p> <p>Since <code>hasOwnProperty</code> is a method on the object, in theory it could be overridden with a version that didn't return what we expect:</p> <pre><code>obj.hasOwnProperty = function() { return true; }; </code></pre> <p>...which would fool our loop above. That's not usually an issue, but if you want to guard against it, use the one from <code>Object.prototype</code> instead:</p> <pre><code>var hasOwn = Object.prototype.hasOwnProperty; for (var name in obj) { if (hasOwn.call(obj, name)) { console.log(name + " = " + obj[name]); } } </code></pre> <p>Of course, someone can assign to the <code>Object.prototype.hasOwnProperty</code> property as well, but if they do, a fair number of things are likely to break.</p> <h3><code>Object.keys</code> (ES5+, easily shimmed/polyfilled)</h3> <p><code>Object.keys</code> gives us an array of the names of the object's <em>own, enumerable</em> properties named with strings. So it doesn't include inherited properties, properties marked non-enumerable, or properties named with <code>Symbol</code>s.</p> <pre><code>var propNames = Object.keys(obj); </code></pre> <p>We can then loop over the entries in that array in any of several ways, such as <code>forEach</code>:</p> <pre><code>propNames.forEach(function(name) { console.log(name + " = " + obj[name]); }); </code></pre> <p>With our sample setup, that gives us:</p> <pre> two = 2 three = 3 </pre> <p>The order of the names in the array is not defined by the specification, not even in ES2015.</p> <h3><code>Object.getOwnPropertyNames</code> (ES5+)</h3> <p><code>Object.getOwnPropertyNames</code> returns an array of the names of the object's own properties named with strings, whether enumerable or not. It leaves out properties named with <code>Symbol</code>s.</p> <pre><code>var propNames = Object.getOwnPropertyNames(obj); propNames.forEach(function(name) { console.log(name + " = " + obj[name]); }); </code></pre> <p>With our sample setup, that gives us:</p> <pre> two = 2 three = 3 four = 4 </pre> <p>The order of the names in the array is defined by the <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys" rel="nofollow noreferrer"><code>[[OwnPropertyKeys]]</code></a> operation in the specification, which says the order is:</p> <ul> <li>The property names that qualify as <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-object-type" rel="nofollow noreferrer">integer indexes</a>, in numeric order.</li> <li>The names for other properties, in the order the property was created.</li> </ul> <p>So we get <code>two</code>, <code>three</code>, <code>four</code> because none of those fits the spec's definition of an integer index, and that's the order in which we added the properties. If we added them in a different order, or included ones that qualified as indexes, we'd get different results:</p> <pre><code>var obj2 = {}; obj2.four = 4; obj2[0] = "zero"; obj2.two = 2; obj2.three = 3; Object.getOwnPropertyNames(obj2).forEach(function(name) { console.log(name + " = " + obj2[name]); }); </code></pre> <p>Gives us:</p> <pre> 0 = zero four = 4 two = 2 three = 3 </pre> <p><code>0</code> was first because although it's a string, it fits the criteria for an integer index. Then we get <code>four</code> because it was created first, then <code>two</code>, then <code>three</code>.</p> <h3><code>Reflect.enumerate</code> (ES2015+)</h3> <p><code>Reflect.enumerate</code> uses the new <em>iterator</em> feature of ES2015. It returns an iterator that will iterate over the names of the string-named enumerable properties of the object, including inherited ones, skipping ones named with <code>Symbol</code> or that aren't enumerable. First it visits the "own" properties (in the order defined by <code>[[OwnPropertyKeys]]</code>, and then inherited properties (unless they've been hidden by "own" properties).</p> <p>We can use the new <code>for-of</code> loop to loop over them:</p> <pre><code>for (let name of Reflect.enumerate(obj)) { console.log(name + " = " + obj[name]); } </code></pre> <p>With our setup, that gives us:</p> <pre> two = 2 three = 3 one = 1 </pre> <p><code>one</code> is at the end because it's inherited, and "own" properties come first.</p> <p>Note: Again, since ES2015 is relatively new as of this writing, some JavaScript engines may not implement the <code>Reflect</code> object, or the <code>for-of</code> loop, yet.</p> <h3><code>Object.getOwnPropertySymbols</code> (ES2015+)</h3> <p><code>Object.getOwnPropertySymbols</code> returns an array of an object's own properties named with <code>Symbol</code>s, regardless of whether they're enumerable. (Leaves out ones named with strings.) We'll need a different setup to try this, since we didn't include <code>Symbol</code>-named properties in our main setup. Since inherited properties are ignored, we'll keep it simple:</p> <pre><code>var obj3 = {}; obj3[Symbol("x")] = "ecks"; obj3[1] = "one"; obj3[Symbol("y")] = "why"; obj3.z = "zee"; Object.getOwnPropertySymbols(obj3).forEach(function(symbol) { console.log(symbol.toString() + " = " + obj3[symbol]); }); </code></pre> <p>Output:</p> <pre> Symbol(x) = ecks Symbol(y) = why </pre> <p><code>z</code> wasn't listed because it has a string name, not a <code>Symbol</code> name. <code>Symbol(x)</code> was first because it was created first.</p> <p>There's a lot more to <code>Symbols</code> than shown here, but as you can see, if we give a symbol a name, we can use <code>toString</code> to get back <code>Symbol(the name here)</code> as a string. Interesting, we have to call <code>toString</code> <em>explicitly</em> (<code>thesymbol.toString()</code>) or use <code>String(theSymbol</code>); the <code>+</code> operator will not do it for us when appending a symbol to a string.</p> <h3><code>Reflect.ownKeys</code> (ES2015+)</h3> <p><code>Reflect.ownKeys</code> returns an array of an object's own properties no matter how they're named (<code>Symbol</code> or string), and whether they're enumerable or not. It ignores inherited properties:</p> <pre><code>var obj3 = {}; obj3[Symbol("x")] = "ecks"; obj3[1] = "one" obj3[Symbol("y")] = "why"; obj3.z = "zee"; Reflect.ownKeys(obj3).forEach(function(key) { console.log(key.toString() + " = " + obj3[key]); }); </code></pre> <p>Output:</p> <pre> 1 = one z = zee Symbol(x) = ecks Symbol(y) = why </pre> <p>Note the order, which is defined by <code>[[OwnPropertyKeys]]</code>: <code>1</code> was first because it's a string that qualifies as an integer index. <code>z</code> was next because it's a string-named property. Then we have the <code>Symbol</code>-named properties, in the order in which they were created.</p>
<p>Inspired by above answers I wondered how to list ALL properties of any object (both emumerable and not) up the inheritance chain. This function seems sufficient.</p> <pre><code>var allPropNames = []; function digAllPropsOut (ob){ var propNames = Object.getOwnPropertyNames(ob); propNames.forEach(function(name) { allPropNames.push(name); }); // allPropNames.push('\n'); ob = Object.getPrototypeOf(ob); if (ob) digAllPropsOut(ob); } </code></pre>