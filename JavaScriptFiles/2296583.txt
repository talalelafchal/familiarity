javascript, wait for something to be true then run action
<p>Well the title kindof says what I need. Because in Javascript timeouts asynchronous I need to know when something becomes true. I don't want busyloop.</p> <p>Came up with:</p> <pre><code>function do_when(predicate, action, timeout_step) { if (predicate()) { action(); } else { setTimeout(do_when, timeout_step, predicate, action, timeout_step); } } </code></pre> <p>Is it good Javascript or can I make better?</p>
<p>It's decent enough, if it's easy enough to read and it works just fine then it's generally good javascript.</p> <p>Performance-wise, it's generally better to call the function whenever whatever is set to true happens. So in whatever function that executes to make <code>predicate()</code> return true, you could just call <code>action()</code> at the end. But I'm sure that's what you would have done if you could, right?</p> <p>You could also look at using a callback, where you register a javascript function to a particular variable or function argument and when the function is run it executes whatever function was set to the callback variable.</p>
<p>if your predicate become true when a variable change, here is another solution:</p> <p>say we want to log 'Big brother is watching you' when value of object a become 2.</p> <pre><code>function observable (value, condition, callback){ this.value = value; this.condition = condition; this.callback = callback; } observable.prototype = { get value () { return this._value; }, set value (value) { this._value = value; if (this.condition &amp;&amp; this.callback &amp;&amp; this.condition (value)) { this.callback (value); } } }; condition = function (value) { console.log ('condition', value); return value === 2; } callback = function (value) { console.info ('Big Brother is watching you!'); } var a = new observable (0, condition, callback); console.log ('set value to 1'); a.value = 1; console.log ('set value to 2'); a.value = 2; console.log ('set value to 3'); a.value = 3; </code></pre> <p>you can try this exemple in firefox </p>
<p>Depending on what the predicate is, you might be able to fit your problem into an implementation of the <a href="http://en.wikipedia.org/wiki/Observer_pattern" rel="nofollow noreferrer">observer pattern</a>. A while back I wrote a blog post about <a href="http://blogs.claritycon.com/blogs/sean_devlin/archive/2009/08/21/creating-objects-with-observable-properties-in-javascript.aspx" rel="nofollow noreferrer">creating JavaScript objects with observable properties</a>. It really depends on what the predicate <em>is</em>, but this might get you most of the way there with code like this:</p> <pre><code>var observable = createObservable({ propToWatch: false }); observable.observe('propToWatch', function (oldValue, newValue) { alert('propToWatch has changed from ' + oldValue + ' to ' + newValue); }); observable.propToWatch(true); // alert pops </code></pre> <p>Of course, this might be overkill for your example. Since it's never listed out explicitly (n.b. I am not a very good blogger), here's the complete code needed to make this work:</p> <pre><code>var createMediator = function () { var events = {}; return { subscribe: function (eventName, callback) { events[eventName] = events[eventName] || []; events[eventName].push(callback); }, publish: function (eventName) { var i, callbacks = events[eventName], args; if (callbacks) { args = Array.prototype.slice.call(arguments, 1); for (i = 0; i &lt; callbacks.length; i++) { callbacks[i].apply(null, args); } } } }; }; var createObservable = function (properties) { var notifier = createMediator(), createObservableProperty, observable; createObservableProperty = function (propName, value) { return function (newValue) { var oldValue; if (typeof newValue !== 'undefined' &amp;&amp; value !== newValue) { oldValue = value; value = newValue; notifier.publish(propName, oldValue, value); } return value; }; }; observable = { register: function (propName, value) { this[propName] = createObservableProperty(propName, value); this.observableProperties.push(propName); }, observe: function (propName, observer) { notifier.subscribe(propName, observer); }, observableProperties: [] }; for (propName in properties) { observable.register(propName, properties[propName]); } return observable; }; </code></pre> <p>My observable objects make use internally of a small eventing framework (the createMediator function) I wrote once for a project. (<em>Before</em> realizing jQuery supported custom events. D'oh!) Again, this may or may not be overkill for your need, but I thought it was a fun hack. Enjoy!</p>