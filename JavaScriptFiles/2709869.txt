Declaring variables with this or var?
<p>What is the difference between declaring a variable with <code>this</code> or <code>var</code> ?</p> <pre><code>var foo = 'bar' </code></pre> <p>or</p> <pre><code>this.foo = 'bar' </code></pre> <p>When do you use <code>this</code> and when <code>var</code>? </p> <p>edit: is there a simple question i can ask my self when deciding if i want to use <code>var</code> or <code>this</code> </p>
<p>If you use <code>var</code>, the variable is scoped to the current function.</p> <p>If you use <code>this</code>, then you are assigning a value to a property on whatever <code>this</code> is (which is either the object the method is being called on or (if the <code>new</code> keyword has been used) the object being created.</p>
<p>If it is <a href="http://bclary.com/2004/11/07/#a-10.2.1" rel="nofollow noreferrer"><em>global code</em></a> (the code is not part of any function), then you are creating a property on the global object with the two snippets, since <code>this</code> in <a href="http://bclary.com/2004/11/07/#a-10.2.1" rel="nofollow noreferrer">global code</a> points to the global object.</p> <p>The difference in this case is that when the <code>var</code> statement is used, that property cannot be deleted, for example:</p> <pre><code>var foo = 'bar'; delete foo; // false typeof foo; // "string" this.bar = 'baz'; delete bar; // true typeof bar; "undefined" </code></pre> <p><sub>(<em>Note:</em> The above snippet will behave differently in the Firebug console, since it runs code with <em>eval</em>, and the code executed in the <em>Eval Code</em> execution context permits the deletion of identifiers created with <code>var</code>, try it <a href="http://jsbin.com/ukoya4/" rel="nofollow noreferrer">here</a>)</sub></p> <p>If the code is part of a function you should know that the <code>this</code> keyword has nothing to do with the function scope, is a reserved word that is set implicitly, depending how a function is called, for example:</p> <p><em>1</em> - When a function is called as a method (the function is invoked as member of an object):</p> <pre><code>obj.method(); // 'this' inside method will refer to obj </code></pre> <p><em>2</em> - A normal function call:</p> <pre><code>myFunction(); // 'this' inside the function will refer to the Global object // or (function () {})(); </code></pre> <p><em>3</em> - When the new operator is used:</p> <pre><code>var obj = new Constructor(); // 'this' will refer to a newly created object. </code></pre> <p>And you can even set the <code>this</code> value explicitly, using the <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Function/call" rel="nofollow noreferrer"><code>call</code></a> and <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Function/call" rel="nofollow noreferrer"><code>apply</code></a> methods, for example:</p> <pre><code>function test () { alert(this); } test.call("hello!"); //alerts hello! </code></pre> <p>You should know also that JavaScript has <strong>function scope</strong> only, and variables declared with the <code>var</code> statement will be reachable only within the same function or any inner functions defined below.</p> <p><strong>Edit:</strong> Looking the code you posted to the <a href="http://stackoverflow.com/questions/2709869/declaring-variables-with-this-or-var/2709876#2709876">@David's answer</a>, let me comment:</p> <pre><code>var test1 = 'test'; // two globals, with the difference I talk this.test2 = 'test'; // about in the beginning of this answer //... function test4(){ var test5 = 'test in function with var'; // &lt;-- test5 is locally scoped!!! this.test6 = 'test in function with this'; // global property, see below } test4(); // &lt;--- test4 will be called with `this` pointing to the global object // see #2 above, a call to an identifier that is not an property of an // object causes it alert(typeof test5); // "undefined" since it's a local variable of `test4` alert(test6); // "test in function with this" </code></pre> <p>You can't access the <code>test5</code> variable outside the function because is locally scoped, and it exists only withing the scope of that function.</p> <p><strong>Edit:</strong> In response to your comment</p> <p>For declaring variables I encourage you to always use <code>var</code>, it's what is made for.</p> <p>The concept of the <code>this</code> value, will get useful when you start working with <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Creating_New_Objects/Using_a_Constructor_Function" rel="nofollow noreferrer">constructor functions</a>, objects and methods. </p>
<pre><code>var foo = 'bar' </code></pre> <p>This will scope the <code>foo</code> variable to the function wrapping it, or the global scope.</p> <pre><code>this.foo = 'bar' </code></pre> <p>This will scope the <code>foo</code> variable to the <code>this</code> object, it exactly like doing this:</p> <pre><code>window.foo = 'bar'; </code></pre> <p>or</p> <pre><code>someObj.foo = 'bar'; </code></pre> <p>The second part of your question seems to be what is the <code>this</code> object, and that is something that is determined by what context the function is running in. <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Function/apply" rel="nofollow noreferrer">You can change what <code>this</code> is by using the apply method that all functions have</a>. You can also make the default of the <code>this</code> variable an object other than the global object, by:</p> <pre><code>someObj.foo = function(){ // 'this' is 'someObj' }; </code></pre> <p>or </p> <pre><code>function someObj(x){ this.x=x; } someObj.prototype.getX = function(){ return this.x; } var myX = (new someObj(1)).getX(); // myX == 1 </code></pre>
<p>You use <code>var</code> when you want to define a simple local variable as you would in a typical function:-</p> <pre><code>function doAdd(a, b) { var c = a + b; return c; } var result = doAdd(a, b); alert(result); </code></pre> <p>However <code>this</code> has special meaning when <code>call</code> is used on a function.</p> <pre><code>function doAdd(a, b) { this.c = a + b; } var o = new Object(); doAdd.call(o, a, b); alert(o.c); </code></pre> <p>You note the first parameter when using <code>call</code> on doAdd is the object created before. Inside that execution of doAdd <code>this</code> will refer to that object. Hence it creates a <code>c</code> property on the object.</p> <p>Typically though a function is assigned to a property of an object like this:-</p> <pre><code>function doAdd(a, b) { this.c = a + b; } var o = new Object(); o.doAdd = doAdd; </code></pre> <p>Now the function can be execute using the . notation:-</p> <pre><code>o.doAdd(a, b); alert(o.c); </code></pre> <p>Effectively <code>o.doAdd(a, b)</code> is <code>o.doAdd.call(o, a, b)</code></p>
<p>In a constructor, you can use var to simulate private members and this to simulate public members:</p> <pre><code>function Obj() { this.pub = 'public'; var priv = 'private'; } var o = new Obj(); o.pub; // 'public' o.priv; // error </code></pre>
<p>Example for <em>this</em> and <em>var</em> explained below:</p> <pre><code> function Car() { this.speed = 0; var speedUp = function() { var speed = 10; // default this.speed = this.speed + speed; // see how this and var are used }; speedUp(); } </code></pre>
<pre><code>var foo = 'bar'; // 'var can be only used inside a function </code></pre> <p>and</p> <pre><code>this.foo = 'bar' // 'this' can be used globally inside an object </code></pre>