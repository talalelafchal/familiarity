Are string literals objects or not?
<p>Trying to get my JavaSscript fundamentals strong. So the question is about string literals. Aren't they <code>Objects</code>? If your answer is 'yes' then my question is why is <code>instanceof</code> returning <code>false</code>?</p> <pre><code>&gt; var s = new String &gt; s.constructor.toString() function String() { [native code] } &gt; typeof s object &gt; s instanceof String true &gt; s instanceof Object true &gt; s instanceof Number false </code></pre> <p>So far so good.</p> <pre><code>&gt; typeof 'c' string &gt; 'c' instanceof Object false &gt; 'c' instanceof String false &gt; 'c'.length 1 &gt; 'c'.charAt(0) c &gt; 'c'.constructor.toString() function String() { [native code] } </code></pre>
<p>Great explanation of this <a href="http://stackoverflow.com/questions/203739/why-does-instanceof-return-false-for-some-literals">here</a>. Copied for reference below.</p> <hr> <p>That's because those things are <em>primitives</em>, and unless they need to be used as objects (when you are calling methods on them, for example) they remain so. The only time they "become" objects is when they need to be wrapped. If you are familiar with the concept of "boxing" in .NET, then think of it in that way.</p> <p>Here is an example - take a look at this code:</p> <pre><code>Number.prototype.times = function(func) { for(var index = 1; index &lt;= this; index++) { func(index); } }; </code></pre> <p>So, the following code will fail:</p> <pre><code>3.times(print); // assume 'print' writes to standard out </code></pre> <p>3, by itself is a primitive. That said, the following will work:</p> <pre><code>(3).times(print); // assume 'print' writes to standard out </code></pre> <p>That would display the numbers 1, 2, and 3. Because of the parenthesis, the JavaScript interpreter will temporarily wrap the primitive 3 in a Number object, call the method, and then garbage collect the object since it isn't needed any longer.</p> <p>Anyway, a full discussion of this can be found in <a href="http://oreilly.com/catalog/9780596101992/?CMP=AFC-ak_book&amp;ATT=JavaScript%3A+The+Definitive+Guide" rel="nofollow noreferrer"><strong>"JavaScript: The Definitive Guide."</strong></a></p>
<p>String literals are primitives (<a href="http://bclary.com/2004/11/07/#a-4.3.16" rel="nofollow noreferrer">String values</a>), <a href="http://bclary.com/2004/11/07/#a-4.3.18" rel="nofollow noreferrer">String objects</a> can be created with the <a href="http://bclary.com/2004/11/07/#a-15.5.2.1" rel="nofollow noreferrer">String constructor</a> in a <code>new</code> expression:</p> <pre><code>"foo" instanceof String // false new String("foo") instanceof String // true </code></pre> <p><strong>Edit:</strong> Something that seems to be confusing (by looking at the accepted answer <a href="http://stackoverflow.com/questions/203739/why-does-instanceof-return-false-for-some-literals">here</a>), is that you can still access properties defined on the <em>prototype objects</em> of primitive values, for example:</p> <pre><code>"foo".indexOf == String.prototype.indexOf // true "foo".match == String.prototype.match // true String.prototype.test = true; "foo".test // true true.toString == Boolean.prototype.toString (3).toFixed == Number.prototype.toFixed // true // etc... </code></pre> <p>The reason of that relies on the <a href="http://bclary.com/2004/11/07/#a-11.2.1" rel="nofollow noreferrer">Property Accessors</a>, the dot notation <code>.</code> and the bracket notation <code>[]</code>.</p> <p>Let's give a look to the algorithm in the ECMA-262 specification:</p> <p>The production MemberExpression : MemberExpression [ Expression ] (or MemberExpression . Identifier) is evaluated as follows:</p> <ol> <li><p>Evaluate <code>MemberExpression</code>.</p></li> <li><p>Call <code>GetValue(Result(1))</code>.</p></li> <li><p>Evaluate Expression.</p></li> <li><p>Call <code>GetValue(Result(3))</code>.</p></li> <li><p>Call <code>ToObject(Result(2))</code>.</p></li> <li><p>Call <code>ToString(Result(4))</code>.</p></li> <li><p>Return a value of type Reference whose base object is Result(5) and whose property name is <code>Result(6)</code>.</p></li> </ol> <p>In the <strong>Step 5</strong>, the <a href="http://bclary.com/2004/11/07/#a-9.9" rel="nofollow noreferrer"><code>ToObject</code></a> internal operator type-converts the MemberExpression to object, depending on it's type.</p> <p>The primitives are converted to Objects without noticing, and that's why you can access the properties defined on the prototype.</p>