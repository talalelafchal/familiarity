accessing eval'd code through setInterval/setTimeout
<p>i am wondering if i can do some cleanup routines that will auto grab timeouts / intervals. consider this:</p> <pre><code>var timeout = setInterval(function dimitar() { console.log("hi!"); }, 1000); console.log(window); </code></pre> <p>i had a look through window and can't find any reference to the function that's been passed on. the reference to timeout is there, sure enough. so where does the function 'live' here? is it launching a new instance of the js interpreter to eval/run/keep the code? how can you access it in relation to the timeout uid?</p> <p>i know i can curry the setInterval function and get it to always store the reference into an array which i can then loop through and clear, but am curious if there's a natural way of doing this</p>
<p>The function you create in your example is using a <em>named function expression</em>. The name is only available within the function. Otherwise, it behaves the same as an anonymous function: you haven't assigned it to a variable and since it's not a function declaration, it doesn't create a <code>dimitar</code> variable in the enclosing scope. The following article may be useful: <a href="http://yura.thinkweb2.com/named-function-expressions/" rel="nofollow noreferrer">http://yura.thinkweb2.com/named-function-expressions/</a></p> <p>There's no <code>eval</code>-type thing going on: you've just passed in a reference to a function into <code>window.setInterval</code>. This function cannot be retrieved afterwards unless you've assigned it to a variable previously, or it was a reference to a function defined by a function declaration.</p> <p>If you want to keep a reference to the function around, it's simply a matter of storing it in a variable first:</p> <pre><code>var dimitar = function() { console.log("hi!"); }; window.setInterval(dimitar, 1000); </code></pre>
<blockquote> <p>so where does the function 'live' here?</p> </blockquote> <p>The timeout/interval queue is an internal implementation detail that's not accessible to content JavaScript. It retains a reference to the function passed in to <code>setInterval</code>, but it's not a reference that's visible to you.</p> <p>Incidentally you should generally avoid using named inline function expressions. Although it's probably OK in this example code, IE's JScript has some serious basic bugs with them that can trip you up if you're not careful. Stick to named function statements (<code>function dimitar() { ... } ... setInterval(dimitar, 1000)</code>) or anonymous inline function expressions (<code>setInterval(function() { ... })</code>).</p> <blockquote> <p>is it launching a new instance of the js interpreter to eval/run/keep the code?</p> </blockquote> <p>No, it's the same interpreter and the queue could even be implemented in JavaScript. But the variables behind it are hidden away from the caller.</p> <blockquote> <p>how can you access it in relation to the timeout uid?</p> </blockquote> <p>The timeout ID is by design completely opaque. The only defined interface that can do anything with it is the <code>clearTimeout</code>/<code>clearInterval</code> call. There is no interface provided to get the function back from a timeout ID.</p>