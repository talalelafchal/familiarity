delcare a function?
<p>i wonder what the difference is between these two declarations:</p> <pre><code>var delay = (function() { var timer = 0; return function(callback, ms) { clearTimeout (timer); timer = setTimeout(callback, ms); }; })(); function delay { var timer = 0; return function(callback, ms) { clearTimeout (timer); timer = setTimeout(callback, ms); }; } </code></pre>
<p>In the second case you discard the returned function.</p> <p>If I understand your question right, that is if you want the second case to be</p> <pre><code>function delay() { var timer = 0; return function(callback, ms) { clearTimeout (timer); timer = setTimeout(callback, ms); }; } </code></pre> <p>then the difference is that the code stored into delay is not executed. If you call delay later, then it will be equivalent and the difference would be anonymity of the function and the value of <code>delay</code> (in the first case it's inner function, in the second - outer one).</p>
<p>The first case uses a function expression to generate an anonymous function, which is called instantly and which wraps a <code>timer</code> variable in a closure and returns another function (generated with a function expression).</p> <p><strike>The second case is a syntax error (since there is no context for a function expression and no name for a function declaration).</strike></p> <p>Since you have now edited itâ€¦</p> <p>The second case now uses a function declaration, but doesn't call the function. So it will now do what the anonymous function does (and not what the returned function does). </p>
<p>In the first case, you create then call an anonymous function. In the second, you create an anonymous function but neither call it nor save it in a variable. I'm not even sure that's legal.</p>
<p>The purpose of having a function return another function is to create a scope for variables declared outside the function without having to declare them globally. The outer function is executed immediately after it's created (by putting the parentheses after the declaration), so the inner function is returned and assigned to the variable.</p> <p>In the first example the <code>timer</code> variable is used in the inner function, so a closure is created that contains the variable. When you later use the function, it still has access to the <code>timer</code> variable although it's not inside the function itself. The outer function is executed so that it returns the inner function, and it's assigned to the <code>delay</code> variable.</p> <p>Discussing the difference between the two declarations is pointless. The second declaration only declares the outer function, but then it's neither stored nor executed so it's just thrown away.</p> <p>Edit:<br> In your updated question (if corrected by adding parentheses efter the function name in the second declaration), the second declaration is a function that returns the same result that is assigned to the variable in the first declaration. So to get the same result you have to call the function and assign the return value to a variable:</p> <pre><code>var d = delay(); </code></pre> <p>Now the <code>d</code> variable contains the same as the <code>delay</code> variable in the first example.</p>
<p>The first function declaration uses an anonymous function to create a closure over the variable <code>timer</code> and a second anonymous function to avoid polluting the global namespace with <code>timer</code>. This is a simple and handy technique to implement data hiding and <em>static variables</em> within a function in JavaScript.</p> <p>This first/outer function typically only gets used once, which is why it is never given a name, but instead is executed immediately as an anonymous function. However, the opposite is true if you needed to be able to create multiple timers for multiple events.</p> <p>Consider the following:</p> <pre><code>var delayBuilder = function() { var timer = 0; return function(callback, ms) { clearTimeout (timer); timer = setTimeout(callback, ms); }; } </code></pre> <p>Now:</p> <pre><code>var delay = (function() { var timer = 0; return function(callback, ms) { clearTimeout (timer); timer = setTimeout(callback, ms); }; })(); </code></pre> <p>is equivalent to:</p> <pre><code>var delay = delayBuilder(); </code></pre> <p>So, if you needed to have multiple delays (more than one timer running at the same time), you could do:</p> <p>var delay1 = delayBuilder(), delay2 = delayBuilder(), ... delayN = delayBuilder();</p> <pre><code>// And of course, used as: delay1(callback, ms); </code></pre> <p>More generalized, you have a function to build functions, in other words <code>funcBuilder</code> and <code>func</code> (using "func" since "function" is a reserved word).</p> <pre><code>var func = funcBuilder(configurationifany); </code></pre> <p>So, if the function builder was more complex and you wanted a single, throw-away instance of whatever function it was building, you could do</p> <pre><code>funcBuilder(configurationifany)(etc, etc); </code></pre> <p>Or in the case of the code that you posted (although this is overkill for simply wrapping <code>setTimeout</code> but just to continue the example):</p> <pre><code>delayBuilder()(callback, ms); </code></pre> <p>It really boils down to usage. If you're not going to use the function builder more than once, there's no sense in keeping it around and executing it as an anonymous function is more appropriate. If you need to build multiple instances of that function, then saving a reference to the function builder makes sense.</p>