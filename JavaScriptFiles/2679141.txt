Is there a way to check if a var is using setInterval()?
<p>For instance, I am setting an interval like</p> <pre><code>timer = setInterval(fncName, 1000); </code></pre> <p>and if i go and do</p> <pre><code>clearInterval(timer); </code></pre> <p>it does clear the interval but is there a way to check that it cleared the interval? I've tried getting the value of it while it has an interval and when it doesn't but they both just seem to be numbers.</p>
<p>The return values from <code>setTimeout</code> and <code>setInterval</code> are completely opaque values. You can't derive any meaning from them; the only use for them is to pass back to <code>clearTimeout</code> and <code>clearInterval</code>.</p> <p>There is no function to test whether a value corresponds to an active timeout/interval, sorry! If you wanted a timer whose status you could check, you'd have to create your own wrapper functions that remembered what the set/clear state was.</p>
<p>There is no direct way to do what you are looking for. Instead, you could set <code>timer</code> to false every time you call <code>clearInterval</code>:</p> <pre><code>// Start timer var timer = setInterval(fncName, 1000); // End timer clearInterval(timer); timer = false; </code></pre> <p>Now, <code>timer</code> will either be false or have a value at a given time, so you can simply check with</p> <pre><code>if (timer) ... </code></pre> <p>If you want to encapsulate this in a class, it's trivial:</p> <pre><code>function Interval(fn, time) { var timer = false; this.start = function () { if (!this.isRunning()) timer = setInterval(fn, time); }; this.stop = function () { clearInterval(timer); timer = false; }; this.isRunning = function () { return timer !== false; }; } var i = new Interval(fncName, 1000); i.start(); if (i.isRunning()) // ... i.stop(); </code></pre>
<p>You COULD override the setInterval method and add the capability to keep track of your intervals. Here is an untestet example to outline the idea. It will work on the current window only (if you have multiple, you could change this with the help of the prototype object) and this will only work if you override the functions BEFORE any functions that you care of keeping track about are registered:</p> <pre><code>var oldSetInterval = window.setInterval; var oldClearInterval = window.clearInterval; window.setInterval = function(func, time) { var id = oldSetInterval(func, time); window.intervals.push(id); return id; } window.intervals = []; window.clearInterval = function(id) { for(int i = 0; i &lt; window.setInterval.intervals; ++i) if (window.setInterval.intervals[i] == id) { window.setInterval.intervals.splice(i, 1); } oldClearInterval(id); } window.isIntervalRegistered(id) { for(int i = 0; i &lt; window.setInterval.intervals; ++i) if (window.setInterval.intervals[i] == func) return true; return false; } var i = 0; var refreshLoop = setInterval(function(){ i++; }, 250); if (isIntervalRegistered(refrshLoop)) alert('still registered'); else alert('not registered'); clearInterval(refreshLoop); if (isIntervalRegistered(refrshLoop)) alert('still registered'); else alert('not registered'); </code></pre>
<p>The solution to this problem: Create a global counter that is incremented within your code performed by setInterval. Then before you recall setInterval, test if the counter is STILL incrementing. If so, your setInterval is still active. If not, you're good to go.</p>
<p>Lots of complicated answers above, this method works just fine for me:</p> <pre><code>if (typeof timer == 'undefined') { //timer has been cleared } </code></pre>
<p>I did this like below, My problem was solved. you should set the value like "false", when you clearTimeout the timer.</p> <pre><code>var timeer=false; ---- ---- if(timeer==false) { starttimer(); } ----- ----- function starttimer() { timeer=setInterval(activefunction, 1000); } function pausetimer() { clearTimeout(timeer); timeer=false; } </code></pre>