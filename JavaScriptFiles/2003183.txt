Object and Function are quite confusing
<pre><code>Object instanceof Object true Object instanceof Function true Function instanceof Object true Function instanceof Function true </code></pre> <p>so if Function is an Object and the Object is a Function how come</p> <p><code>Function === Object</code> and <code>Function == Object</code> are false?</p> <p>I do understand that checking the instance of an object is not the same as comparison. So the question here is the fuzziness in the case where if two objects (which are actually types) are instances of each other, shouldn't the types be the same?</p> <p>Note: Object is not an instance of a Number or an Array just an instance of Function.</p>
<p>instanceof operator indicates if the first argument is of the given type. That is saying </p> <pre><code> A instanceof B </code></pre> <p>returns true if A is an instance of the type B.</p> <p>The == and === operators are comparison operators on the other hand. They compare values for equality.</p> <p>For instance, you can say jack instanceof Boy is true but would you say that jack == boy? No.</p>
<p>I think this is more due to the unique way in which objects are defined. You don't define a type in javascript, you define a constructor. But you also do not define the constructor as a constructor, it's simply a function.</p> <p>You can then refer to the types by the name of their constructor....which is just a function.</p> <pre><code>function Tiger(){ //function, or object? } function Apple(){ //function, or object? } </code></pre> <p>Both <em>could</em> be objects, or perhaps just functions. Only the way you use them will determine that. So it <em>kind of</em> makes sense that at a low level, objects are functions and functions are objects, but there is still a difference, right?</p>
<p>Everything is an <code>Object</code> in JavaScript because JavaScript is an object-oriented language. <code>Function</code> is an instance of <code>Object</code> because everything is an instance of <code>Object</code>. Simple enough. However, objects that initialize other objects (constructors) are also <code>Function</code>s in JavaScript, so it would make sense for <code>Object</code> to also be a <code>Function</code>.</p> <p>Think about this:</p> <pre><code>var obj = new Object(); </code></pre> <p><code>Object</code> in this case is used as a <code>Function</code>, is it not? So while, in theory, <code>Object</code> should be the lowest-level object in the language, JavaScript cannot function without <code>Function</code>s (pun!), so you need both to be at the same level. <code>Object</code> needs to be an instance of <code>Function</code> because it's a constructor and it needs to create more instances of itself.</p> <pre><code>function FooBar() {} </code></pre> <p>The <code>FooBar</code> class above is an instance of both <code>Object</code> and <code>Function</code>, because it's both. The same logic applies to the built-in <code>Object</code> and <code>Function</code> objects; they're instances of both.</p> <p>Phew, confusing. Did that make any sense?</p>
<p>From <a href="http://www.3site.eu/doc/#Object" rel="nofollow noreferrer">JavaScript Prototypal Inheritance</a>:</p> <blockquote> <p>Quite everything, in JavaScript, inherits from Object. We could say that Object is the super class, or better, the super constructor, of every variable and that everything is an instanceof Object. The Object constructor is a Function, but a Function is an instanceof Object. This means that these assertions are always true:</p> <p><code>(Object <a href="http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Operators:Special_Operators:instanceof_Operator" rel="nofollow noreferrer">instanceof</a> Function) === (Function instanceof Object)</code></p> <p>Above example is true because Object is a constructor, and a constructor in JavaScript is always a Function. At the same time, every Function has its own prototype, and a prototype always starts its inheritance from Object.prototype. The Function constructor, is a Function itself, and the function prototype is a function(){};</p> <p><code>(Function.prototype <a href="http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Operators:Special_Operators:instanceof_Operator" rel="nofollow noreferrer">instanceof</a> Object) <a href="http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Operators:Comparison_Operators" rel="nofollow noreferrer">===</a> (function(){} instanceof Object)</code></p> </blockquote>
<pre><code> javascript:alert([ window.navigator.userAgent, Object ].join("\n\n") ) </code></pre> <p>displays</p> <pre><code>Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.2.3) Gecko/20100423 Ubuntu/10.04 (lucid) Firefox/3.6.3 function Object() { [native code] } </code></pre> <p>reference: <a href="http://stackoverflow.com/questions/7018023/is-every-javascript-object-a-function">Is every JavaScript Object a function?</a></p>
<p>There is no such thing as classes in Javascript. The <code>instanceof</code> operator is called on functions.</p> <p><code>Object</code> is a constructor function for "Object objects" (yes, this is the official term), and <code>Function</code> is the constructor function for "Function objects".</p> <p>So, when you call <code>Function instanceof Object</code>, it returns <code>true</code> because <code>Function</code> is a function, and thus an object, etc. This does not mean that the types are the same, because Object and Function have different prototypes:</p> <pre><code>Object.prototype ^ | inherits from | instance Function.prototype &lt;------- Object, Function </code></pre>
<p><em>Suppose</em>:</p> <p><strong>&lt;---- : links to (via <code>.__proto__</code>)</strong></p> <p><strong>&lt;-- : has inherited property of (via <code>.</code>)</strong></p> <p><em>Then</em>:</p> <p><strong>Function.prototype &lt;---- {Object, Function}</strong></p> <p><strong>Object &lt;---- Function.prototype</strong></p> <p><strong>Object.prototype &lt;-- Object</strong></p> <pre><code>console.log(Object.prototype.constructor === Object); // true! </code></pre> <p><code>Object.prototype</code> does <strong>not</strong> link to anything; it doesn't have <code>__proto__</code> property.</p>