Is there an equivalent of the __noSuchMethod__ feature for properties, or a way to implement it in JS?
<p>There is a <strong>noSuchMethod</strong> feature in some javascript implementations (Rhino, SpiderMonkey)</p> <pre><code>proxy = { __noSuchMethod__: function(methodName, args){ return "The " + methodName + " method isn't implemented yet. HINT: I accept cash and beer bribes" ; }, realMethod: function(){ return "implemented" ; } } js&gt; proxy.realMethod() implemented js&gt; proxy.newIPod() The newIPod method isn't implemented yet. HINT: I accept cash and beer bribes js&gt; </code></pre> <p>I was wondering, is there was a way to do something similar for properties? I'd like to write proxy classes that can dispatch on properties as well as methods.</p>
<p>There is only one existing thing at the moment that can actually do what you want, but unfortunately is not widely implemented:</p> <ul> <li><a href="http://wiki.ecmascript.org/doku.php?id=harmony:proxies" rel="nofollow noreferrer">ECMAScript Harmony Proxies</a>.</li> </ul> <p>There are only <em>two working</em> implementations available at this time, in the latest Firefox 4 betas (it has been around since FF3.7 pre-releases) and in <a href="https://npmjs.org/package/node-proxy" rel="nofollow noreferrer">node-proxy</a> for server-side JavaScript -<a href="http://code.google.com/p/v8/issues/detail?id=633" rel="nofollow noreferrer">Chrome</a> and <a href="https://bugs.webkit.org/show_bug.cgi?id=35731" rel="nofollow noreferrer">Safari</a> are currently working on it-.</p> <p>It is one of the <a href="http://wiki.ecmascript.org/doku.php?id=harmony:proposals&amp;s=harmony" rel="nofollow noreferrer">early proposals</a> for the <a href="http://en.wikipedia.org/wiki/ECMAScript#ECMAScript_Harmony" rel="nofollow noreferrer">next version of ECMAScript</a>, it's an API that allows you to implement <em>virtualized</em> objects (proxies), where you can assign a variety of <em>traps</em> -callbacks- that are executed in different situations, you gain full control on what at this time -in ECMAScript 3/5- only host objects could do.</p> <p>To build a proxy object, you have to use the <code>Proxy.create</code> method, since you are interested in the <code>set</code> and <code>get</code> traps, I leave you a really simple example:</p> <pre><code>var p = Proxy.create({ get: function(proxy, name) { // intercepts property access return 'Hello, '+ name; }, set: function(proxy, name, value) { // intercepts property assignments alert(name +'='+ value); return true; } }); alert(p.world); // alerts 'Hello, world' p.foo = 'bar'; // alerts foo=bar </code></pre> <p>Try it out <a href="http://jsbin.com/ucupe4/edit" rel="nofollow noreferrer">here</a>.</p> <p>The Proxy API is so new that isn't even documented on the Mozilla Developer Center, but as I said, a working implementation has been included since the Firefox 3.7 pre-releases.</p> <p>The <code>Proxy</code> object is available in the global scope and the <code>create</code> method can take two arguments, a <code>handler</code> object, which is simply an object that contains properties named as the traps you want to implement, and an optional <code>proto</code> argument, that makes you able to specify an object that your proxy inherits from.</p> <p>The traps available are:</p> <pre><code>// TrapName(args) Triggered by // Fundamental traps getOwnPropertyDescriptor(name): // Object.getOwnPropertyDescriptor(proxy, name) getPropertyDescriptor(name): // Object.getPropertyDescriptor(proxy, name) [currently inexistent in ES5] defineProperty(name, propertyDescriptor): // Object.defineProperty(proxy,name,pd) getOwnPropertyNames(): // Object.getOwnPropertyNames(proxy) getPropertyNames(): // Object.getPropertyNames(proxy) delete(name): // delete proxy.name enumerate(): // for (name in proxy) fix(): // Object.{freeze|seal|preventExtensions}(proxy) // Derived traps has(name): // name in proxy hasOwn(name): // ({}).hasOwnProperty.call(proxy, name) get(receiver, name): // receiver.name set(receiver, name, val): // receiver.name = val keys(): // Object.keys(proxy) </code></pre> <p>The only resource I've seen, besides the proposal by itself is the following tutorial:</p> <ul> <li><a href="http://prog.vub.ac.be/~tvcutsem/proxies/index.html" rel="nofollow noreferrer">Harmony Proxies: Tutorial</a></li> </ul> <p><strong>Edit:</strong> More information is coming out, Brendan Eich recently gave a talk at the <a href="http://JSConf.eu" rel="nofollow noreferrer">JSConf.eu</a> Conference, you can find his slides here:</p> <ul> <li><a href="http://jsconf.eu/2010/speaker/be_proxy_objects.html" rel="nofollow noreferrer">Proxies are Awesome!</a></li> </ul>
<p>I don't believe this type of metaprogramming is possible (yet) in javascript. Instead, try using the <code>__noSuchMethod__</code> functionality to achieve the effect with property getters. Not cross-browser as it's a <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/NoSuchMethod" rel="nofollow">Mozilla extension</a>. </p> <pre><code>var proxy = { __noSuchMethod__: function(methodName, args) { if(methodName.substr(0,3)=="get") { var property = methodName.substr(3).toLowerCase(); if (property in this) { return this[property]; } } }, color: "red" }; alert(proxy.getColor()); </code></pre>
<p>There is <code>__defineGetter__</code>, <code>__defineSetter__</code>, <code>__lookupGetter__</code> and <code>__lookupSetter__</code> in addition to <code>__noSuchMethod__</code> in SpiderMonkey. </p>
<p>Here's how to get behaviour similar to __noSuchMethod__</p> <p>First of all, here's a simple object with one method:</p> <pre><code>var myObject = { existingMethod: function (param) { console.log('existing method was called', param); } } </code></pre> <p>Now create a Proxy which will catch access to properties/method and add your existing object as a first parameter.</p> <pre><code>var myObjectProxy = new Proxy(myObject, { get: function (func, name) { // if property or method exists, return it if( name in myObject ) { return myObject[name]; } // if it doesn't exists handle non-existing name however you choose return function (args) { console.log(name, args); } } }); </code></pre> <p>Now try it:</p> <pre><code>myObjectProxy.existingMethod('was called here'); myObjectProxy.nonExistingMethod('with a parameter'); </code></pre> <p>Works in Chrome/Firefox/Opera. Doesn't work in IE(but already works in Edge). Also tested on mobile Chrome.</p> <p>Creation of proxy can be automated and invisible i.e. if you use Factory pattern to build your objects. I did that to create workers which internal functions can be called directly from the main thread. Using workers can be now so simple thanks to this cool new feature called Proxy. The simplest worker implementation ever:</p> <pre><code>var testWorker = createWorker('pathTo/testWorker.js'); testWorker.aFunctionInsideWorker(params, function (result) { console.log('results from worker: ', result); }); </code></pre>