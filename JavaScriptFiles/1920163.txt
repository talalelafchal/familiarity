Invoking a function Object in Javascript
<p>I have a small question in javascript. Here is a declaration:</p> <pre><code> function answerToLifeUniverseAndEverything() { return 42; } var myLife = answerToLifeUniverseAndEverything(); </code></pre> <p>If I do <code>console.log(myLife)</code> It'll print 42, as I am just invoking the same instance of function resulting in 42 as the answer. (Basic rule on javascripts that only references of objects are passed and not the object)</p> <p>Now on the other hand if I do</p> <pre><code>var myLife = new answerToLifeUniverseAndEverything(); </code></pre> <p>Then I can't invoke the function; instead myLife becomes just an object? I understand that this is a new copy of the same function object and not a reference; but why can't I invoke the method?</p> <p>Can you please clarify the basic fundamental I am missing here?</p> <p>Cheers</p>
<p>Try:</p> <pre><code>function answerToLifeUniverseAndEverything() { return 42; } var myLife = answerToLifeUniverseAndEverything; alert(myLife()); </code></pre> <p>When you do:</p> <pre><code>var myLife = answerToLifeUniverseAndEverything(); </code></pre> <p>you're assigning the function <em>result</em> to <code>myLife</code> ie 42.</p>
<p>I think i've described the behaviour of <code>new</code> elsewhere. Basically when you do <code>new f()</code> the JS engine creates an object and passes that as <code>this</code>, then uses that object if the return value of <code>f()</code> is not an object.</p> <p>eg.</p> <pre><code>o = new f(); </code></pre> <p>is equivalent (approximately) to</p> <pre><code>temp = {}; temp2 = f.call(temp); o = typeof temp2 === "object" ? temp2 : temp; </code></pre>
<blockquote> <p>If I do <code>console.log(myLife)</code> It'll print 42, as I am just invoking the same instance of function resulting in 42 as the answer. (Basic rule on javascripts that only references of objects are passed and not the object)</p> </blockquote> <p>Not quite. This is because you're assigning the return value of <code>answerToLifeUniverseAndEverything()</code> to <code>myLife</code>. If you wanted to make a copy of the function, drop the brackets:</p> <pre><code>var myLife = answerToLifeUniverseAndEverything; console.log(myLife()); </code></pre>
<p>By prefixing the call to <code>answerToLifeUniverseAndEverything()</code> with <code>new</code> you are telling JavaScript to invoke the function as a <a href="https://developer.mozilla.org/En/Core_JavaScript_1.5_Guide/Creating_New_Objects/Using_a_Constructor_Function" rel="nofollow noreferrer"><strong>constructor function</strong></a>, similar (internally) to this:</p> <pre><code>var newInstance = {}; var obj = answerToLifeUniverseAndEverything.call(newInstance); // returs 42 if (typeof obj === 'object') { return obj } else { return newInstance; } </code></pre> <p>JavaScript proceeds to initialize the <code>this</code> variable inside the constructor function to point to a new instance of <code>answerToLifeUniverseAndEverything</code>. Unless you return a different <code>Object</code> yourself, this new instance <em>will</em> get returned, whether you like it or not.</p>
<p>When you do <code>var myLife = answerToLifeUniverseAndEverything();</code>, myLife is simply holding the return value from the function call - in this case, 42. <code>myLife</code> knows nothing about your function in that case, because the function was already called, returned, and <em>then</em> it assigned the resulting value (42) to the new variable <code>myLife</code>.</p> <p>A completely different thing happens when you do <code>var myLife = new answerToLifeUniverseAndEverything();</code> - instead, a new object is created, passed to the function as <code>this</code>, and then (assuming the function doesn't return an object itself), stored in the newly created variable. Since your function returns a number, not an object, the newly generated object is stored.</p>