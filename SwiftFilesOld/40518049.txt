Protocol extensions and generic types
So I was wondering why I can use two different types of protocol extension declarations for non-generic types, yet I can only use one for generic types: protocol ItemControllerProtocol { func deleteItem(indexPath: NSIndexPath) } extension ItemControllerProtocol { func deleteItem(indexPath: NSIndexPath) { print("ItemControllerProtocol.\(#function)") } } I can declare a protocol extension two ways like this : extension ItemControllerProtocol where Self : ItemController { func deleteItem(indexPath: NSIndexPath) { ... } } or like this: extension ItemController: ItemControllerProtocol { func deleteItem(indexPath: NSIndexPath) { ... } } at run time the calls to deleteItem() via the protocol invoke the extension method deleteItem() If I have a generic type that adopts the protocol class SectionController<T: NSManagedObject> { ... } I can declare an extension like this extension ItemControllerProtocol where Self : SectionController<Item> { func deleteItem(indexPath: NSIndexPath) { ... } } at runtime the calls to deleteItem() resolve to the deleteItem() in the default extension instead of resolving to the deleteItem() in the SectionController extension. The call will execute print("ItemControllerProtocol.\(#function)") If I instead declare the extension like the following, at run time the method call is resolved to the extension of the SectionController, not the default deleteItem() method defined in the ItemControllerProtocol default extension : extension SectionController: ItemControllerProtocol { func deleteItem(indexPath: NSIndexPath) { ... } } I am wondering why the two extensions resolve at runtime for the ItemController class but do not resolve for the SectionController class?