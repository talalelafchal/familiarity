Delete function (commit editingStyle function) cause crashing the application once the swipe delete button is pressed
Im working on a project in swift 3.0 and Im fetching data from core data on to two tableViews namely;'recurringIncomeTableView', and 'otherIncomeTableView'. However when 'commit editingStyle' function is activated (once I slide the row), I can deleted the particular row in 'recurringIncomeTableView'. But when i slide a row in 'otherIncomeTableView' and pressed delete, in the line 'let task = stores [indexPath.row]' causing the problem and the app is crashing. The code as bellow. import UIKit import CoreData class MyIncomesViewController: UIViewController, UITableViewDelegate, UITableViewDataSource { @IBOutlet weak var recurringIncomeTableView: UITableView! @IBOutlet weak var otherIncomeTableView: UITableView! //var myIncomeType : String? var stores = [UserIncome] () var other = [UserIncome] () let context = (UIApplication.shared.delegate as! AppDelegate).persistentContainer.viewContext override func viewDidLoad() { self.recurringIncomeTableView.reloadData() self.otherIncomeTableView.reloadData() } override func viewDidAppear(_ animated: Bool) { stores.removeAll() other.removeAll() let request = NSFetchRequest <NSFetchRequestResult> (entityName: "UserIncome") request.returnsObjectsAsFaults = false do { let results = try context.fetch(request) as! [UserIncome] print("Results from the fetch request are : ", request) // check data existance if results.count>0 { print("results are :", results.count) for resultGot in results { //lets check if the data is available and whether the loop is working by printing out the "name" if let incName = resultGot.incomeName { print("expence name is :", incName) //set the value to the global variable as to filter the arrays let myIncomeType = resultGot.incomeType if myIncomeType == "Recurring Income"{ stores += [resultGot] print("my recurring income array is : \(stores)") }else if myIncomeType == "Other Income"{ other += [resultGot] print("my other income array is : \(other)") } } } self.recurringIncomeTableView.reloadData() self.otherIncomeTableView.reloadData() } }catch{ print("No Data to load") } } @IBAction func addIncome(sender: UIButton) { print("Add Income Button Clicked") performSegue(withIdentifier: "ShowAddIncomeVC", sender: nil) // Do whatever you need when the button is pressed } func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int { if tableView == self.recurringIncomeTableView { print("recurringIncomeTableView count is ", stores.count) return stores.count }else { print("otherIncomeTableView count is ", other.count) return other.count } } func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell { if tableView == self.recurringIncomeTableView { let cell: RecuringIncomeTableViewCell = tableView.dequeueReusableCell(withIdentifier: "recurringIncomeCell") as! RecuringIncomeTableViewCell let store = stores [indexPath.row] cell.incomeNameLabel.text = store.incomeName cell.amountLabel.text = store.amount //cell.textLabel?.text = myExpensesArray[indexPath.row] return cell }else { let cell: OtherIncomeTableViewCell = tableView.dequeueReusableCell(withIdentifier: "otherIncomeCell") as! OtherIncomeTableViewCell let otherIncomes = other [indexPath.row] cell.incomeNameLabel.text = otherIncomes.incomeName cell.amountLabel.text = otherIncomes.amount //cell.textLabel?.text = myExpensesArray[indexPath.row] return cell } } func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) { //performSegue(withIdentifier: "editStore", sender: nil) } override func prepare(for segue: UIStoryboardSegue, sender: Any?) { if segue.identifier == "editRecurringIncome"{ let v = segue.destination as! AddIncomeViewController let indexPath = self.recurringIncomeTableView.indexPathForSelectedRow let row = indexPath?.row v.store = stores[row!] }else if segue.identifier == "editOtherIncome" { let t = segue.destination as! AddIncomeViewController let indexPath = self.otherIncomeTableView.indexPathForSelectedRow let row = indexPath?.row t.store = other [row!] } } // func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool { return true } //For remove row from tableview & object from array. func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) { let context = (UIApplication.shared.delegate as! AppDelegate).persistentContainer.viewContext if editingStyle == .delete { **let task = stores [indexPath.row]** context.delete(task) (UIApplication.shared.delegate as! AppDelegate).saveContext() do { stores = try context.fetch(UserIncome.fetchRequest()) }catch{ print("fail") } } tableView.reloadData() } }
As per your Core data fetch request code. You have to store core data object in your store array than & than you can delete that object directly form store array. You need to fetch object like this : // Initialize Fetch Request let fetchRequest = NSFetchRequest() // Create Entity Description let entityDescription = NSEntityDescription.entityForName("UserIncome", inManagedObjectContext: self.managedObjectContext) // Configure Fetch Request fetchRequest.entity = entityDescription store = try self.managedObjectContext.executeFetchRequest(fetchRequest) After getting all data you have to filter your array with your requirement and display it in tableview I have just give example how to show that data in tableview. Show your data in cell like this : var data: NSManagedObject = store[indexPath.row] as NSManagedObject Cell.textLabel?.text = data.valueForKeyPath("Name") as? String Delete your data as per your code : let task = stores [indexPath.row] context.delete(task) (UIApplication.shared.delegate as! AppDelegate).saveContext() it will help you to understand flow of core data with tableview.