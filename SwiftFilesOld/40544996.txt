How to store an array that is within an another array to a global variable that has been passed from JSON in Swift?
I have a JSON which receives an array from an API call Within that array are 3 other arrays: userDetails, userStats, communities An example of this API call is: ["communities": <__NSArrayI 0x6000002540a0>( { id = 5; name = South; }, { id = 13; name = HurraHarry; }, { id = 15; name = EnclliffeT; } ) , "userStats": { totalDraws = 3; totalLosses = 10; totalWins = 1; }, "userDetails": { id = 31; "user_email" = "steve@gmail.com"; "user_name" = "Steve Base"; }] I would like to store the array userStats in a variable that I can pass to another VC. I have a global variable var userStatsArray = [AnyObject]() in my class and the following code deals with the JSON:  let json = try JSONSerialization.jsonObject(with: data!, options: .allowFragments) as? [String:AnyObject] print (json!) if let arr = json?["communities"] as? [[String:String]] { self.communitiesArray = arr.flatMap { $0["name"]!} self.communityIdsArray = arr.flatMap { $0["id"]!} } if let dict = json?["userDetails"] as? [String:String] { self.tempPlayerId = [dict["id"]!] let characterArray = self.tempPlayerId.flatMap { String.CharacterView($0) } let newPlayerId = String(characterArray) self.playerId = newPlayerId } if let tempArray = json?["userStats"] as? [String:AnyObject]{ print ("here ", tempArray) } The print command successfully prints the userStats array with all its headers (totalWins, totalDraws, totalLosses...) - How do I store this array into my global variable var userStatsArray = [AnyObject]() so I can pass it to another VC?
Better you create one custom class like this, and declare the array with that custom class type. then you cast your userStats object to your custom class type. class userStats: NSObject { var totalDraws: NSNumber? var totalLosses: NSNumber? var totalWins: NSNumber? init(totalDraws: NSNumber?, totalLosses: NSNumber?, totalWins: NSNumber?) { self.totalDraws = totalDraws self.totalWins = totalWins self.totalLosses = totalLosses } } var userStatsArray = [userStats]() // CHANGE YOUR CODE LIKE THIS let json = try JSONSerialization.jsonObject(with: data!, options: .allowFragments) as? [String:AnyObject] print (json!) if let arr = json?["communities"] as? [[String:String]] { self.communitiesArray = arr.flatMap { $0["name"]!} self.communityIdsArray = arr.flatMap { $0["id"]!} } if let dict = json?["userDetails"] as? [String:String] { self.tempPlayerId = [dict["id"]!] let characterArray = self.tempPlayerId.flatMap { String.CharacterView($0) } let newPlayerId = String(characterArray) self.playerId = newPlayerId } if let tempArray = json?["userStats"]as? userStats { userSytatsArray.append(tempArray) }
Take a look at ObjectMapper! With that powerful framework you can create the mappable models of your data returned by the API and let it perform the whole work for you :) Declare your model classes like this: class UserInfo: Mappable { var communities : [Community]? var stats: UserStats? var details: UserDetails? required init?(map: Map) { } func mapping(map: Map) { communities <- map["communities"] stats <- map["userStats"] details <- map["userDetails"] } } class Community: Mappable { var id: Int! var name: String! required init?(map: Map) { } func mapping(map: Map) { id <- map["id"] name <- map["name"] } } class UserStats: Mappable { var totalDraws : Int! var totalLosses : Int! var totalWins : Int! required init?(map: Map) { } func mapping(map: Map) { totalDraws <- map["totalDraws"] totalLosses <- map["totalLosses"] totalWins <- map["totalWins"] } } class UserDetails: Mappable { var id : Int! var email : String! var username : String! required init?(map: Map) { } func mapping(map: Map) { id <- map["id"] email <- map["user_email"] username <- map["user_name"] } } And later just: let user = UserInfo(JSONString: JSONString)