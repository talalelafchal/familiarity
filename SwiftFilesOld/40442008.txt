NSCoding for a non-compliant object (MKMapItem)
Trying to save a MKMapItem as part of my custom class.  import UIKit import MapKit class Place: NSObject, NSCoding { var mapItem : MKMapItem! var type : Category! init(mapItem: MKMapItem, type: Category) { self.mapItem = mapItem self.type = type } // MARK: NSCoding required init?(coder decoder: NSCoder) { mapItem = decoder.decodeObject(forKey: "mapItem") as! MKMapItem? type = decoder.decodeObject(forKey: "type") as! Category? } func encode(with coder: NSCoder) { coder.encode(mapItem, forKey: "mapItem") coder.encode(type, forKey: "type") } } But this won't work because MKMapItem is not NSCoding-compliant (compiler doesn't complain though). I do understand how to encode custom classes, but can't figure out how to do it for an object already defined by iOS. I know there is one answer out there for Objective-C on this, but would really like a Swift solution. Thanks. PS I have tried to subclass MKMapItem and provide "new" initializers, even though it would take considerable code changes elsewhere. But that leads to "Cannot assign to property: 'placemark' is a get-only property". Both 'placemark' and 'isCurrentLocation' are get-only. import UIKit import MapKit class NewMapItem: MKMapItem { required init(placemark: MKPlacemark, isCurrentLocation:Bool, name: String, phoneNumber: String, url: URL, timeZone: TimeZone) { self.placemark = placemark //compiler complains "get-only" self.isCurrentLocation = isCurrentLocation //compiler complains "get-only" self.name = name self.phoneNumber = phoneNumber self.url = url self.timeZone = timeZone } // MARK: NSCoding init?(coder decoder: NSCoder) { placemark = (decoder.decodeObject(forKey: "placemark") as! MKPlacemark?)! //compiler complains "get-only" isCurrentLocation = decoder.decodeBool(forKey: "isCurrentLocation") //compiler complains "get-only" name = decoder.decodeObject(forKey: "name") as? String phoneNumber = decoder.decodeObject(forKey: "phoneNumber") as? String url = decoder.decodeObject(forKey: "url") as! URL? timeZone = decoder.decodeObject(forKey: "timeZone") as! TimeZone? } func encode(with coder: NSCoder) { coder.encode(placemark, forKey: "placemark") coder.encode(isCurrentLocation, forKey: "isCurrentLocation") coder.encode(name, forKey: "name") coder.encode(phoneNumber, forKey: "phoneNumber") coder.encode(url, forKey: "url") coder.encode(timeZone, forKey: "timeZone") } }
I have figured it out. Break down the mapItem in "func encode(with coder: NSCoder)" and build it back up again in "init?(coder decoder: NSCoder)" I did take advantage of the MKMapItem initializer with placemark.  MKMapItem(placemark: placemark!) Here is my working class: import UIKit import MapKit class Place: NSObject, NSCoding { var mapItem : MKMapItem! var type : Category! init(mapItem: MKMapItem, type: Category) { self.mapItem = mapItem self.type = type } // MARK: NSCoding required init?(coder decoder: NSCoder) { //liberate the properties of mapItem and rebuild it // let isCurrentLocation = decoder.decodeObject(forKey: "isCurrentLocation") as! Bool //don't need set already let name = decoder.decodeObject(forKey: "name") as! String? let phoneNumber = decoder.decodeObject(forKey: "phoneNumber") as! String? let url = decoder.decodeObject(forKey: "url") as! URL? let timeZone = decoder.decodeObject(forKey: "timeZone") as! TimeZone? let placemark = decoder.decodeObject(forKey: "placemark") as! MKPlacemark? self.mapItem = MKMapItem(placemark: placemark!) self.mapItem.name = name self.mapItem.url = url self.mapItem.phoneNumber = phoneNumber //self.mapItem.isCurrentLocation = isCurrentLocation //don't need this. Set already self.mapItem.timeZone = timeZone type = decoder.decodeObject(forKey: "type") as! Category? } func encode(with coder: NSCoder) { let placemark = mapItem.placemark let name = mapItem.name let phoneNumber = mapItem.phoneNumber let url = mapItem.url let timeZone = mapItem.timeZone coder.encode(name, forKey: "name") coder.encode(phoneNumber,forKey: "phoneNumber") coder.encode(url, forKey: "url") coder.encode(timeZone, forKey: "timeZone") coder.encode(type, forKey: "type") coder.encode(placemark, forKey: "placemark") } }