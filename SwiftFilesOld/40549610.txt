Comparing Two Enums for all possible cases
I have an enum with a bunch of different cases. Imagine it being like rock paper scissors. enum Play { case Rock, Paper, Scissors } Now I am making a class that will have a Play property and a method that takes another Play parameter as the "Attacker" and I need to compare all possible outcomes. The only way I can think to do it would be nested switches but that becomes a massive function with a high chance of error since my enum has much more than 3 cases. func determineEffectiveness(withAttacker attacker: Play) { switch attacker.type { case .Rock { switch self.type { case .Rock { return 0 } case .Paper { return 1 } case .Scissors { return -1 } } } case .Paper { // ...etc } } } This is an ugly brute force method but I'm struggling to come up with a better solution. UPDATE: As per usual... right after I ask the question I came up with a better solution. I am going to put that solution as an answer but I won't accept it until I get answers from others because there could be a better way.
I came up with this solution that would be much cleaner but I'm not going to accept it at first. I want to see if there is another, better method that I am not thinking of. It might be a better solution to create arrays for the possible advantages and then make an exhaustive switch in my initializer like so: var strongAgainst: [Play] var weakAgainst: [Play] init(withPlayType play: Play) { switch play { case .Rock { strongAgainst.append(Play.Scissors) weakAgainst.append(Play.Paper) break } // ...etc } } This would make my attack method simpler by letting my check if the attacking type is in the strongAgainst or weakAgainst arrays.
You could simply switch on a tuple of the Play instances to compare, using the == operator in order to determine whether they are equal, and a series of enum case pattern matches to define whether on play is more effective than another. For example: enum Play { case rock, paper, scissors enum Effectiveness { case effective, equal, notEffective } // You may want to consider not returning an Int, but instead // an enum that defines the Effectiveness of an attack (given that you // only ever return 3 values). func effectiveness(against attacker: Play) -> Effectiveness { switch (self, attacker) { // if the same case (binds self to x, and attacker to y, and then // uses the equality operator to determine whether the case should be triggered). case let (x, y) where x == y: return .equal // if self beats attacker case (.paper, .rock), (.rock, .scissors), (.scissors, .paper): return .effective // else self doesn't beat attacker default: return .notEffective } } } print(Play.paper.effectiveness(against: .rock)) // effective print(Play.scissors.effectiveness(against: .rock)) // notEffective print(Play.paper.effectiveness(against: .paper)) // equal
Seems like the Play type should provide the means of "comparing itself" to others. And in the end makes things much easier and clearer: enum Play { case rock, paper, scissors enum PlayResult { case aBeatsB, bBeatsA, tie } func beats(_ other: Play) -> Bool { switch (self, other) { case (.rock, .scissors): return true case (.scissors, .paper): return true case (.paper, .rock): return true default: // other cases are either ties or loses return false } } func resultOfGame(against other: Play) -> PlayResult { if (self.beats(other)) { return .aBeatsB } else if (other.beats(self)) { return .bBeatsA } else { return .tie } } } func printGame(_ a: Play, against b: Play) { switch a.resultOfGame(against: b) { case .aBeatsB: print("\(a) beats \(b)") case .bBeatsA: print("\(b) beats \(a)") case .tie: print("\(a) vs. \(b) is a tie") } } printGame(.rock, against: .scissors) printGame(.paper, against: .paper) outputs: rock beats scissors paper vs. paper is a tie
Rock, Paper, Scissors is a parity game. It becomes a bit clearer if you make the game more complicated, like Rock, Paper, Scissors, Spock, Lizard. If the distance is even, then the lower value wins. If the distance is odd, then the higher values wins. Here's a simple way we could build that: enum Hand: Int { enum Result { case lose, tie, win } case rock, paper, scissors, spock, lizzard func result(against: Hand) -> Result { let distance = rawValue - against.rawValue if distance == 0 { return .tie } if distance % 2 == 0 { return (rawValue < against.rawValue) ? .win : .lose } return (rawValue > against.rawValue) ? .win : .lose } } Of course this still works for R-P-S. Just drop the last two elements. Just keep in mind that the enum order is very important.