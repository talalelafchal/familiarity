Accessing shadowed swift var in extension: what should work?
I have a bunch of protocols designed to let me mock out UIKit stuff for testing, among which: public protocol HasPresentedVCType { var presentedViewController: HasPresentedVCType? { get } } I cannot give UIViewController an empty conformance to this protocol, because its presentedViewController is of type UIViewController?: extension UIViewController: HasPresentedVCType {} // Error:(32, 1) type 'UIViewController' does not conform to protocol 'HasPresentedVCType' // Note:(18, 9) protocol requires property 'presentedViewController' with type 'HasPresentedVCType?' The following extension is an attempt to shadow UIViewController's presentedViewController var and let type inference choose whichever of the two I need: extension UIViewController: HasPresentedVCType { public var presentedViewController: HasPresentedVCType? { let presented: UIViewController? = self.presentedViewController return presented } } This works if the extension is not in the same target as the original protocol, but fails if the protocol and the extension are in the same target: // Error:(33, 16) 'presentedViewController' used within its own type I can make it work within the same target by introducing a second protocol and putting the implementation in a constrained extension: public protocol _HasPresentedVCType { var presentedViewController: UIViewController? { get } } extension UIViewController: HasPresentedVCType, _HasPresentedVCType {} extension HasPresentedVCType where Self: _HasPresentedVCType { public var presentedViewController: HasPresentedVCType? { let presented: UIViewController? = self.presentedViewController return presented } } So my question: is this supposed to work at all, and if so under what circumstances? (Xcode 7.3, Swift 2.2.) And if (as I rather suspect) it's not supposed to work, is there any relatively tidy way to get a similar effect?