Swift 3 - Send make synchronous http request
I have the following code: func completeLoadAction(urlString:String) -> Int { let url = URL(string:urlString.trimmingCharacters(in: .whitespaces)) let request = URLRequest(url: url!) let task = URLSession.shared.dataTask(with: request) { data, response, error in guard let data = data, error == nil else { // check for fundamental networking error print("error=\(error)") let ac = UIAlertController(title: "Unable to complete", message: "The load has been added to the completion queue. This will be processed once there is a connection.", preferredStyle: .alert) ac.addAction(UIAlertAction(title: "OK", style: .default)) self.present(ac, animated: true) return } let httpStatus = response as? HTTPURLResponse var httpStatusCode:Int = (httpStatus?.statusCode)! let responseString = String(data: data, encoding: .utf8) print("responseString = \(responseString)") let ac = UIAlertController(title: "Completed Successfully", message: "The "+coldel+" has been completed successfully", preferredStyle: .alert) ac.addAction(UIAlertAction(title:"Continue", style: .default, handler: { action in self.performSegue(withIdentifier: "segueConfirmedLoad", sender: self) })) self.present(ac, animated: true) } task.resume() return httpStatusCode } I need to be able to call this and at the same time check the return value as it is the http status code, it will let me know if the call was successful or not. Problem is because it's in a dataTask I can't access the responses status code here var httpStatusCode:Int = (httpStatus?.statusCode)! Because the task doesn't start until Task.Resume() is called and the task is asynchronous so it will never work. Are there any ways around this?
To make it synchronous and wait you can use semaphores such as below struct Login { static func execute() -> Bool { let request = NSURLRequest.... var success = false let semaphore = DispatchSemaphore(value: 0) let task = URLSession.shared.dataTask(with: request, completionHandler: { _, response, error in if let error = error { print("Error while trying to re-authenticate the user: \(error)") } else if let response = response as? HTTPURLResponse, 300..<600 ~= response.statusCode { print("Error while trying to re-authenticate the user, statusCode: \(response.statusCode)") } else { success = true } semaphore.signal() }) task.resume() _ = semaphore.wait(timeout: DispatchTime.distantFuture) return success } }
There is always a way to use the asynchronous pattern. To make the function asynchronous add a completion block func completeLoadAction(urlString:String, completion: (Int) -> ()) { let url = URL(string:urlString.trimmingCharacters(in: .whitespaces)) let request = URLRequest(url: url!) let task = URLSession.shared.dataTask(with: request) { data, response, error in guard let data = data, error == nil else { // check for fundamental networking error print("error=\(error)") DispathQueue.main.async { let ac = UIAlertController(title: "Unable to complete", message: "The load has been added to the completion queue. This will be processed once there is a connection.", preferredStyle: .alert) ac.addAction(UIAlertAction(title: "OK", style: .default)) self.present(ac, animated: true) } completion(0) // or return an error code return } let httpStatus = response as? HTTPURLResponse var httpStatusCode:Int = (httpStatus?.statusCode)! let responseString = String(data: data, encoding: .utf8) print("responseString = \(responseString)") DispathQueue.main.async { let ac = UIAlertController(title: "Completed Successfully", message: "The "+coldel+" has been completed successfully", preferredStyle: .alert) ac.addAction(UIAlertAction(title:"Continue", style: .default, handler: { action in self.performSegue(withIdentifier: "segueConfirmedLoad", sender: self) })) self.present(ac, animated: true) } completion(httpStatusCode) } task.resume() } and call it completeLoadAction(urlString: "www.something.com") { code in print(code) }