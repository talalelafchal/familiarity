Why works not Swedish characters in arguments from the command line with NetFSMountURLSync?
I have tried my first Swift program. It is meant to be run from a shell script with arguments and mount server volumes. When I start the program from Xcode having arguments with Swedish characters in the volume name (å, ä, ö, for example), the program works as it should. If I start the program from the command line with arguments with Swedish characters in the volume name, mounting fails, it creates a folder at mount point with the correct name in the "/Volumes". Why does not the argument with Swedish characters works from the command line? Code: import Foundation import NetFS func mountShare(serverAddress: String, shareName: String, userName: String, password: String) { let fm = FileManager.default let mountPoint = "/Volumes/".appendingFormat(shareName) var isDir : ObjCBool = false if fm.fileExists(atPath: mountPoint, isDirectory: &isDir) { if isDir.boolValue { unmount(mountPoint, 0) print("Unmounted: \(mountPoint)") } } let sharePathRaw = "\(serverAddress)/\(shareName)" let sharePathWithPercentEscapes = sharePathRaw.addingPercentEncoding( withAllowedCharacters: .urlQueryAllowed) let sharePath = NSURL(string: sharePathWithPercentEscapes!) let kNAUIOptionKey = "UIOption" let kNAUIOptionNoUI = "NoUI" let mount_options = NSMutableDictionary() mount_options[kNAUIOptionKey] = kNAUIOptionNoUI NetFSMountURLSync(sharePath as CFURL!, nil, userName as CFString!, password as CFString!, mount_options, nil, nil) } let argCount = CommandLine.argc if argCount == 5 { let serverUrl = CommandLine.arguments[1] let shareName = CommandLine.arguments[2] let userName = CommandLine.arguments[3] let password = CommandLine.arguments[4] mountShare(serverAddress: "\(serverUrl)", shareName: "\(shareName)", userName: "\(userName)", password: "\(password)") } else { print("Wrong number of arguments.") } Example starting program from command line that works: mountVolume "afp://my.server.com" "myVolume" "user" "password" Example starting program from command line that not works: mountVolume "afp://my.server.com" "myVolumeÅÄÖ" "user" "password" More info: I have tried to print out all the variables for comparing values when I ran the program from Xcode alternative the command line and no difference. However, NetFSMountURLSync exit with code 2 instead of 0 on the command line.
Does it work if you first escape all the special characters in the relevant part of your connection string before passing it to NSURL's init ? let encodedShareName = shareName.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed) let sharePathRaw = "\(serverAddress)/\(encodedShareName!)"
First, you should fix how you're building the URL. Use NSURLComponents instead of concatenating and escaping/quoting strings. Create an NSURLComponents from the server URL string, then set its path property from the share name, then get a URL object using its url property. Second, you need to check the return code from NetFSMountURLSync() to get insight into why it's failing. Third, the Swedish characters in your share name can be represented in two different ways. For example, "Å" might be a single Unicode character, U+00C5 LATIN CAPITAL LETTER A WITH RING ABOVE. Encoded in UTF-8, that would be the bytes 0xC3 0x85. Or, it might be two Unicode characters: a plain A (U+0041 LATIN CAPITAL LETTER A) followed by a combining ring above character (U+030A COMBINING RING ABOVE). The UTF-8 for that sequence would be 0x41 0xCC 0x8A. The two different places in which you enter the character, Xcode's console pane vs. a Terminal window, could produce different actual characters for the same keystrokes. That would mean the URLs are not the same. The same sort of thing applies to the other Swedish characters in your share name. You can use funky techniques to get the right characters on your command line, such as using $'\x41\xCC\x8A' in bash to get the second form of "Å". It's up to the file server as to whether it treats the two paths as the same. Your program will either have to be familiar with the server in question and convert to its convention, or try various normalization strategies (e.g. using decomposedStringWithCanonicalMapping or precomposedStringWithCanonicalMapping) as fallbacks if the mount attempt fails because the share name isn't right.