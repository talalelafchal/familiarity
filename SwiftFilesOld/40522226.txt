App not asking for permission to access location, popup stays in background
I'm using the MapKit in my Swift iOS app. The thing is that I'm requesting the permission to access the user location when the app is in use, but the first time I run the app in my iPhone, it stays frozen in the splash screen, because the permission request don't popup, but then, if I press the home button, the popup appears to ask for permission. And if I accept then, the next run the app works properly, but it shouldn't work like this. So in the code, the debugger crashes here because he cannot get the permission: let initialLocation:CLLocation = CLLocation(latitude: (locationManager.location?.coordinate.latitude)!, longitude: (locationManager.location?.coordinate.longitude)!) Indicating the next issue: Thread 1: EXC_BREAKPOINT (code=1, subcode=0x1000b5d00) So, I'm already asking the permissions in the viewWillAppear method: let locationManager = CLLocationManager() // Ask for Authorisation from the User. // locationManager.requestAlwaysAuthorization() // For use in foreground locationManager.requestWhenInUseAuthorization() //locationManager.requestAlwaysAuthorization() if CLLocationManager.locationServicesEnabled() { locationManager.delegate = self //locationManager.desiredAccuracy = kCLLocationAccuracyNearestTenMeters locationManager.desiredAccuracy = kCLLocationAccuracyBest locationManager.startUpdatingLocation() mapView.showsUserLocation = true } And I also have the entry in the Info.plist: Privacy - Location When In Use Usage Description. Why is the popup not showing in the foreground but in the background? Thanks in advance for your help. Cheers EDIT: I have an splash screen with the logo before the map view. Can this be the problem? EDIT 2 in answer to @Dan Clark Ok, I've added this check in the viewDidLoad as below: EDIT 3  let locationManager = CLLocationManager() override func viewDidLoad() { super.viewDidLoad() locationManager.delegate = self print("viewdidload") if CLLocationManager.authorizationStatus() != .AuthorizedWhenInUse // Check authorization for location tracking { print("requestingautorization") locationManager.requestWhenInUseAuthorization() print("afterrequestingauthorization") // LocationManager will callbackdidChange... once user responds } else { print("startupdatinglocation") addPins(locationManager) } } But the popup requesting the authorization is not appearing :( I've got both prints before and after but the popup is not showing. I also added the function you wrote me, in the same class.  @nonobjc func locationManager(manager: CLLocationManager!, didChangeAuthorizationStatus status: CLAuthorizationStatus) { print("instatuscheck") switch status { case .AuthorizedWhenInUse: print("statusauthorized") addPins(manager) default: print("statusdefault") manager.requestWhenInUseAuthorization() // User denied access, handle as appropriate } } But I don't have it clear... this function will be called automatically when the authorization status changes? Thanks again for your help :)
The problem is that it can take a while for you to get authorized by LocationManager after you make the request. Therefore, on your first try you don't have authorization before reaching the closure after your request. I've addressed this by testing for authorization and, if I don't have it, putting in the request and then waiting for the callback to didChangeAuthorizationStatus before starting location updates. If I already do have authorization, I immediately start location updates. By the second time you run the app, you have the authorization so the delay doesn't occur and you're OK to go. To try this approach, include this section in your ViewDidLoad (I'm assuming that you don't need to run this whenever your view appears, but only when it first starts):  if CLLocationManager.authorizationStatus() != .authorizedAlways // Check authorization for location tracking { locationManager.requestAlwaysAuthorization() // LocationManager will callbackdidChange... once user responds } else { locationManager.startUpdatingLocation() } And add this delegate function to your class to be called by LocationManager once you're authorized: // If we've been authorized to use location, start the processes, otherwise abort the operation // since we can't proceed without locations @nonobjc func locationManager(manager: CLLocationManager!, didChangeAuthorizationStatus status: CLAuthorizationStatus) { switch status { case .authorizedAlways: locationManager.startUpdatingLocation() default: // User denied access, handle as appropriate } } Here's the code I use to instantiate / configure the locationManager: lazy var locationManager: CLLocationManager = { [unowned self] in var _locationManager = CLLocationManager() _locationManager.delegate = self _locationManager.desiredAccuracy = [a user setting in my app] _locationManager.allowsBackgroundLocationUpdates = true _locationManager.pausesLocationUpdatesAutomatically = false // So doesn't shut off if user stops to rest _locationManager.activityType = .fitness _locationManager.distanceFilter = Double([a user setting in my app]) return _locationManager }() This has been working for me so hopefully it will help.