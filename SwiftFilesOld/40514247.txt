Changing status in multiple levels in Spritekit
I made a game with different levels but it feels like it's too expanded. I have created the different levels with my limited knowledge and I think it could be coded more efficiently. I would like to change the enemy's status according to the current level. This is my codeâ†“  func addEnemy() { if currentLevel == 1{ let enemyGhost = SKSpriteNode(imageNamed: "enemy") enemyGhost.setScale(random(min: 1.5, max: 2.5)) enemyGhost.physicsBody = SKPhysicsBody(rectangleOf: enemyGhost.size) enemyGhost.physicsBody?.isDynamic = true enemyGhost.physicsBody?.categoryBitMask = PhysicsCategory.enemyGhost enemyGhost.physicsBody?.contactTestBitMask = PhysicsCategory.Projectile enemyGhost.physicsBody?.collisionBitMask = PhysicsCategory.None let actualY = random(min: enemyGhost.size.height/2, max: size.height - enemyGhost.size.height/2) enemyGhost.position = CGPoint(x: size.width + enemyGhost.size.width/2, y: actualY) addChild(enemyGhost) let actualDuration = random(min: CGFloat(5.0), max: CGFloat(7.0)) let actionMove = SKAction.move(to: CGPoint(x: -enemyGhost.size.width/2, y: actualY), duration: TimeInterval(actualDuration)) let actionMoveDone = SKAction.removeFromParent() let loseAction = SKAction.run() { let reveal:SKTransition = SKTransition.flipHorizontal(withDuration: 0.5) let gameOverScene = GameOverScene(size: self.size, won: false) self.view?.presentScene(gameOverScene, transition: reveal) } enemyGhost.run(SKAction.sequence([actionMove, loseAction, actionMoveDone])) } else if currentLevel == 2 { let enemyGhost = SKSpriteNode(imageNamed: "enemy") enemyGhost.setScale(random(min: 1.0, max: 1.5)) enemyGhost.physicsBody = SKPhysicsBody(rectangleOf: enemyGhost.size) enemyGhost.physicsBody?.isDynamic = true enemyGhost.physicsBody?.categoryBitMask = PhysicsCategory.enemyGhost enemyGhost.physicsBody?.contactTestBitMask = PhysicsCategory.Projectile enemyGhost.physicsBody?.collisionBitMask = PhysicsCategory.None let actualY = random(min: enemyGhost.size.height/2, max: size.height - enemyGhost.size.height/2) enemyGhost.position = CGPoint(x: size.width + enemyGhost.size.width/2, y: actualY) addChild(enemyGhost) let actualDuration = random(min: CGFloat(3.0), max: CGFloat(5.0)) let actionMove = SKAction.move(to: CGPoint(x: -enemyGhost.size.width/2, y: actualY), duration: TimeInterval(actualDuration)) let actionMoveDone = SKAction.removeFromParent() let loseAction = SKAction.run() { let reveal:SKTransition = SKTransition.flipHorizontal(withDuration: 0.5) let gameOverScene = GameOverScene(size: self.size, won: false) self.view?.presentScene(gameOverScene, transition: reveal) } enemyGhost.run(SKAction.sequence([actionMove, loseAction, actionMoveDone])) } }else if currentLevel == 3 { let enemyGhost = SKSpriteNode(imageNamed: "enemy") enemyGhost.setScale(random(min: 0.5, max: 1.0)) enemyGhost.physicsBody = SKPhysicsBody(rectangleOf: enemyGhost.size) enemyGhost.physicsBody?.isDynamic = true enemyGhost.physicsBody?.categoryBitMask = PhysicsCategory.enemyGhost enemyGhost.physicsBody?.contactTestBitMask = PhysicsCategory.Projectile enemyGhost.physicsBody?.collisionBitMask = PhysicsCategory.None let actualY = random(min: enemyGhost.size.height/2, max: size.height - enemyGhost.size.height/2) enemyGhost.position = CGPoint(x: size.width + enemyGhost.size.width/2, y: actualY) addChild(enemyGhost) let actualDuration = random(min: CGFloat(2.0), max: CGFloat(3.0)) let actionMove = SKAction.move(to: CGPoint(x: -enemyGhost.size.width/2, y: actualY), duration: TimeInterval(actualDuration)) let actionMoveDone = SKAction.removeFromParent() let loseAction = SKAction.run() { let reveal:SKTransition = SKTransition.flipHorizontal(withDuration: 0.5) let gameOverScene = GameOverScene(size: self.size, won: false) self.view?.presentScene(gameOverScene, transition: reveal) } enemyGhost.run(SKAction.sequence([actionMove, loseAction, actionMoveDone])) }
Well, I would start with creating a separate class for Enemy so that you aren't repeating so much initialization code. Then you could create an enum for EnemyType that housed variable information for enemy based on what type of enemy he was or what level he was on. Then you just create your enemy based on what type he is and the Enemy object will already no all of the necessary info. It's worth noting that your PhysicsCategory names have different case "enemyGhost" vs "Projectile". they should be the same case. struct EnemyScale { var minScale: CGFloat = 0 var maxScale: CGFloat = 0 } enum EnemyType: Int { case level1, level2, level3 var textureImage: String { switch self { case .level1: return "enemy" case .level2: return "enemy" case .level3: return "enemy" } } var scale: EnemyScale { switch self { case .level1: return EnemyScale(minScale: 1.5, maxScale: 2.5) case .level2: return EnemyScale(minScale: 1.0, maxScale: 1.5) case .level3: return EnemyScale(minScale: 0.5, maxScale: 1.0) } } } class Enemy: SKSpriteNode { init(type: EnemyType) { let enemyTexture = SKTexture(imageNamed: type.textureImage) super.init(texture: enemyTexture, color: .clear, size: enemyTexture.size()) self.setScale(random(min: type.scaleMin, max: type.scaleMax)) self.physicsBody = SKPhysicsBody(rectangleOf: self.size) self.physicsBody?.isDynamic = true self.physicsBody?.categoryBitMask = PhysicsCategory.enemyGhost self.physicsBody?.contactTestBitMask = PhysicsCategory.Projectile self.physicsBody?.collisionBitMask = PhysicsCategory.None } } func addEnemy() { if currentLevel == 1 { let enemyGhost = Enemy(type: .level1) let actualY = random(min: enemyGhost.size.height / 2, max: size.height - enemyGhost.size.height / 2) enemyGhost.position = CGPoint(x: size.width + enemyGhost.size.width / 2, y: actualY) self.addChild(enemyGhost) let actualDuration = random(min: CGFloat(5.0), max: CGFloat(7.0)) let actionMove = SKAction.move(to: CGPoint(x: -enemyGhost.size.width / 2, y: actualY), duration: TimeInterval(actualDuration)) let actionMoveDone = SKAction.removeFromParent() let loseAction = SKAction.run() { let reveal:SKTransition = SKTransition.flipHorizontal(withDuration: 0.5) let gameOverScene = GameOverScene(size: self.size, won: false) self.view?.presentScene(gameOverScene, transition: reveal) } enemyGhost.run(SKAction.sequence([actionMove, loseAction, actionMoveDone])) } else if currentLevel == 2 { let enemyGhost = Enemy(type: .level2) let actualY = random(min: enemyGhost.size.height / 2, max: size.height - enemyGhost.size.height / 2) enemyGhost.position = CGPoint(x: size.width + enemyGhost.size.width / 2, y: actualY) self.addChild(enemyGhost) let actualDuration = random(min: CGFloat(3.0), max: CGFloat(5.0)) let actionMove = SKAction.move(to: CGPoint(x: -enemyGhost.size.width / 2, y: actualY), duration: TimeInterval(actualDuration)) let actionMoveDone = SKAction.removeFromParent() let loseAction = SKAction.run() { let reveal:SKTransition = SKTransition.flipHorizontal(withDuration: 0.5) let gameOverScene = GameOverScene(size: self.size, won: false) self.view?.presentScene(gameOverScene, transition: reveal) } enemyGhost.run(SKAction.sequence([actionMove, loseAction, actionMoveDone])) } else if currentLevel == 3 { let enemyGhost = Enemy(type: .level3) let actualY = random(min: enemyGhost.size.height / 2, max: size.height - enemyGhost.size.height / 2) enemyGhost.position = CGPoint(x: size.width + enemyGhost.size.width / 2, y: actualY) self.addChild(enemyGhost) let actualDuration = random(min: CGFloat(2.0), max: CGFloat(3.0)) let actionMove = SKAction.move(to: CGPoint(x: -enemyGhost.size.width / 2, y: actualY), duration: TimeInterval(actualDuration)) let actionMoveDone = SKAction.removeFromParent() let loseAction = SKAction.run() { let reveal:SKTransition = SKTransition.flipHorizontal(withDuration: 0.5) let gameOverScene = GameOverScene(size: self.size, won: false) self.view?.presentScene(gameOverScene, transition: reveal) } enemyGhost.run(SKAction.sequence([actionMove, loseAction, actionMoveDone])) } }
Your function could be streamlined because it's full of redundant code as: func addEnemy() { let enemyGhost = SKSpriteNode(imageNamed: "enemy") enemyGhost.physicsBody = SKPhysicsBody(rectangleOf: enemyGhost.size) enemyGhost.physicsBody?.isDynamic = true enemyGhost.physicsBody?.categoryBitMask = PhysicsCategory.enemyGhost.rawValue enemyGhost.physicsBody?.contactTestBitMask = PhysicsCategory.Projectile.rawValue enemyGhost.physicsBody?.collisionBitMask = PhysicsCategory.None.rawValue let actualY = random(min: enemyGhost.size.height/2, max: size.height - enemyGhost.size.height/2) enemyGhost.position = CGPoint(x: size.width + enemyGhost.size.width/2, y: actualY) addChild(enemyGhost) var actualDuration = random(min: CGFloat(5.0), max: CGFloat(7.0)) switch currentLevel { case 1: enemyGhost.setScale(random(min: 1.5, max: 2.5)) case 2: enemyGhost.setScale(random(min: 1.0, max: 1.5)) actualDuration = random(min: CGFloat(3.0), max: CGFloat(5.0)) case 3: enemyGhost.setScale(random(min: 0.5, max: 1.0)) actualDuration = random(min: CGFloat(2.0), max: CGFloat(3.0)) default: break } let actionMove = SKAction.move(to: CGPoint(x: -enemyGhost.size.width/2, y: actualY), duration: TimeInterval(actualDuration)) let actionMoveDone = SKAction.removeFromParent() let loseAction = SKAction.run() { let reveal:SKTransition = SKTransition.flipHorizontal(withDuration: 0.5) let gameOverScene = GameOverScene(size: self.size, won: false) self.view?.presentScene(gameOverScene, transition: reveal) } enemyGhost.run(SKAction.sequence([actionMove, loseAction, actionMoveDone])) } About your enemy status remember you can use userData (docs) to store and retrieve particular properties, something like: enemyGhost.userData? = NSMutableDictionary() enemyGhost.userData = ["status":"aggressive"] print(enemyGhost.userData?["status"] ?? "none")