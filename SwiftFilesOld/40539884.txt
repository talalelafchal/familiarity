Swift static call with generic parameter inside its own class fails
Why does Test.create(TypeA.A) within class Test fail with error "cannot invoke 'create' with an argument list of type '(withType: TypeA)'" while the exact same line in class Tester succeeds? Shouldn't a static method work the same regardless of whether it is called in its own class? protocol Type {} enum TypeA: Type { case A } enum TypeB: Type { case B } class Test<T: Type> where T: Hashable { let type: T init(_ type: T) { self.type = type } static func create(_ withType: T) -> Test { return Test(withType) } func test() { _ = Test.create(TypeA.A) // <--THIS ERRORS } } class Tester { func test() { _ = Test.create(TypeA.A) // <--THIS SUCCEEDS } } Here is a more complete example that explains how the above code might be used practically (i.e. the "why bother"). Imagine that the 3 print functions would be most useful INSIDE of class Test like in the above example (which can't be done currently, hence this post). protocol Type { var isFun: Bool { get } } // Base protocol extension Type { var isFun: Bool { return true } } // Default protocol value enum TypeA: Type { case A } // An enum that just uses the default value for isFun enum TypeB: Type { // An enum that customizes the default value for isFun case B1 case B2 var isFun: Bool { switch self { case .B1: return false default: return true } } } class Test<T: Type> where T: Hashable { let type: T let myFunText: String init(_ type: T) { self.type = type if type.isFun { myFunText = "is fun" } else { myFunText = "is not fun" } } static func create(_ withType: T) -> Test { return Test(withType) } } print(Test.create(TypeA.A).myFunText) // <--prints "is fun" print(Test.create(TypeB.B1).myFunText) // <--prints "is not fun" print(Test.create(TypeB.B2).myFunText) // <--prints "is fun"