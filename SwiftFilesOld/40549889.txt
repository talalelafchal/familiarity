Updating failed while custom object update in Quickblox iOS
We are facing problem in updating custom object on Quickblox in iOS.We are having custome class profile and update user profile for location ,interests,name,time etc.We are getting this error "The resource wasn't found".Error message is rror updating user profile: Optional( Error reasons:{ errors = ( "The resource wasn't found" ); }) UserProfile.swift import UIKit class UserProfile: NSObject, NSCoding{ var object: QBCOCustomObject var userID: UInt var name: String! { didSet{ self.object.fields!["name"] = self.name } } var bio: String!{ didSet{ self.object.fields!["bio"] = self.bio } } var location: CLLocation! { didSet{ self.object.fields!["location"] = [self.location.coordinate.longitude,self.location.coordinate.latitude] } } var images = [UInt](){ didSet{ self.object.fields!["images"] = self.images } } var age: Int! { didSet{ self.object.fields!["age"] = self.age } } var matched: [UInt] { didSet{ self.object.fields!["matched"] = self.matched } } var swiped: [UInt] { didSet{ self.object.fields!["swiped"] = self.swiped } } var gender: Int = -1 { didSet{ self.object.fields!["gender"] = self.gender } } var interestedIn: Int = -1 { didSet{ self.object.fields!["interested_in"] = self.interestedIn } } var liked: Int = 0{ didSet{ if(self.liked >= AppConfig.likeLimit){ self.likeLimitLifted = NSDate(timeInterval: AppConfig.likeLimitTime, since: NSDate() as Date) self.liked = 0 self.object.fields!["liked"] = self.liked Utility.sharedInstance.uploadCurrentUser(completionBlock: nil, errorBlock: nil) }else{ self.object.fields!["liked"] = self.liked Utility.sharedInstance.uploadCurrentUser(completionBlock: nil, errorBlock: nil) } } } var likeLimitLifted: NSDate { didSet{ self.object.fields!["likeLimitLifted"] = self.likeLimitLifted } } // var category_interest: [NSMutableArray] { // didSet{ // self.object.fields!["category_interest"] = self.category_interest // } // } var updatedAt: Double let appDelegate = UIApplication.shared.delegate as! AppDelegate init(object:QBCOCustomObject){ self.object = object self.userID = object.userID self.name = object.fields!["name"] as? String ?? "" self.bio = object.fields!["bio"] as? String ?? "" //self.category_interest = object.fields!["category_interest"] as? [NSMutableArray] ?? [NSMutableArray]() if let location = object.fields!["location"] as? [Double]{ self.location = CLLocation(latitude: location[1], longitude: location[0]) }else{ self.location = CLLocation(latitude: 51.5072, longitude: 0.1275) } if let images = object.fields!["images"] as? [UInt]{ for image in images{ self.images.append(image) } } self.age = object.fields!["age"] as? Int ?? 18 self.matched = object.fields!["matched"] as? [UInt] ?? [UInt]() self.swiped = object.fields!["swiped"] as? [UInt] ?? [UInt]() self.liked = object.fields!["liked"] as? Int ?? 0 self.likeLimitLifted = NSDate.distantPast as NSDate if let dateString = object.fields!["likeLimitLifted"] as? String{ let dateFormatter = DateFormatter() dateFormatter.dateFormat = "yyyy-MM-dd HH:mm:ss Z" if let date = dateFormatter.date(from: dateString){ self.likeLimitLifted = date as NSDate } } self.updatedAt = object.updatedAt?.timeIntervalSince1970 ?? 0 super.init() if let gender = object.fields!["gender"] as? Int{ self.gender = gender }else{ self.gender = 0 self.object.fields!["gender"] = 0 } if let interestedIn = object.fields!["interested_in"] as? Int{ self.interestedIn = interestedIn }else{ self.interestedIn = 1 self.object.fields!["interested_in"] = 1 } } func encode(with aCoder: NSCoder) { aCoder.encode(self.userID, forKey: "userID") aCoder.encode(self.bio, forKey: "bio") //aCoder.encode(self.category_interest, forKey: "category_interest") aCoder.encode(self.name, forKey: "name") aCoder.encode(self.images, forKey: "images") aCoder.encode(self.age, forKey: "age") aCoder.encode(self.matched, forKey: "matched") aCoder.encode(self.swiped, forKey: "swiped") aCoder.encode(self.updatedAt, forKey: "updatedAt") aCoder.encode(self.gender, forKey: "gender") aCoder.encode(self.interestedIn, forKey: "interestedIn") aCoder.encode(self.liked, forKey: "liked") aCoder.encode(self.likeLimitLifted, forKey: "likeLimitLifted") } required init?(coder aDecoder: NSCoder) { self.object = QBCOCustomObject() self.object.className = "profile" // self.category_interest = aDecoder.decodeObject(forKey: "category_interest") as? [NSMutableArray] ?? [NSMutableArray]() self.userID = aDecoder.decodeObject(forKey: "userID") as? UInt ?? 0 self.name = aDecoder.decodeObject(forKey: "name") as? String ?? "" self.bio = aDecoder.decodeObject(forKey: "bio") as? String ?? "" self.location = CLLocation(latitude: 51.5072, longitude: 0.1275) self.images = aDecoder.decodeObject(forKey: "images") as? [UInt] ?? [UInt]() self.age = aDecoder.decodeObject(forKey: "age") as? Int ?? 18 self.matched = aDecoder.decodeObject(forKey: "matched") as? [UInt] ?? [UInt]() self.swiped = aDecoder.decodeObject(forKey: "swiped") as? [UInt] ?? [UInt]() self.updatedAt = aDecoder.decodeObject(forKey: "updatedAt") as? TimeInterval ?? 0 self.gender = aDecoder.decodeObject(forKey: "gender") as? Int ?? 0 self.interestedIn = aDecoder.decodeObject(forKey: "interestedIn") as? Int ?? 1 self.liked = aDecoder.decodeObject(forKey: "liked") as? Int ?? 0 self.likeLimitLifted = aDecoder.decodeObject(forKey: "likeLimitLifted") as? NSDate ?? NSDate.distantPast as NSDate } func getProfilePictureURL()->NSURL?{ if(self.images.count > 0){ if let urlString = QBCBlob.privateUrl(forID: self.images[0]){ return NSURL(string: urlString) } } return nil } } import UIKit class Utility: NSObject, CLLocationManagerDelegate{ static let sharedInstance = Utility() var currentUserProfile: UserProfile?{ didSet{ UserDefaults.standard.set(NSKeyedArchiver.archivedData(withRootObject: self.currentUserProfile!), forKey: "savedUserProfile") } } var locationManager: CLLocationManager var foundLocation = false var currentlyUploading = false var uploadAgain = false let appDelegate = UIApplication.shared.delegate as! AppDelegate override init(){ self.locationManager = CLLocationManager() super.init() self.locationManager.desiredAccuracy = kCLLocationAccuracyHundredMeters self.locationManager.distanceFilter = 1000 self.locationManager.delegate = self } func startUpdatingLocation(){ print("Started updating location") let status = CLLocationManager.authorizationStatus() if(status == CLAuthorizationStatus.notDetermined){ self.locationManager.requestWhenInUseAuthorization() } self.foundLocation = false self.locationManager.startUpdatingLocation() } func stopUpdatingLocation(){ print("Stopped updating location") self.locationManager.stopUpdatingLocation() } func locationManager(manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) { if(self.foundLocation || locations.count == 0 || NSDate().timeIntervalSince(locations.last!.timestamp) > 30){ return } self.foundLocation = true self.stopUpdatingLocation() self.currentUserProfile!.location = locations.last Utility.sharedInstance.uploadCurrentUser(completionBlock: { () -> Void in NotificationCenter.default.post(name: NSNotification.Name(rawValue: "com.samuelharrison.sparker.utility.userLocationUpdated"), object: nil) }, errorBlock: nil) } func locationManager(manager: CLLocationManager, didFailWithError error: NSError) { print("Error updating location: \(error.localizedDescription)") } func uploadCurrentUser(completionBlock:(()->Void)?,errorBlock:(()->Void)?){ if(Utility.sharedInstance.currentUserProfile == nil){ return } if(self.currentlyUploading){ self.uploadAgain = true return } self.uploadAgain = false self.currentlyUploading = true let obj = Utility.sharedInstance.currentUserProfile!.object print(obj.className); QBRequest.update(Utility.sharedInstance.currentUserProfile!.object, successBlock: { (response, object) -> Void in /*if(object != nil){ Utility.sharedInstance.currentUserProfile = UserProfile(object: object!) }*/ self.currentlyUploading = false if(self.uploadAgain){ self.uploadCurrentUser(completionBlock: nil, errorBlock: nil) } completionBlock?() }, errorBlock: { (response) -> Void in self.currentlyUploading = false print("Error updating user profile: \(response.error)") errorBlock?() }) } func allowedToLike()->Bool{ if(!AppConfig.shouldLimitLikes || self.appDelegate.subscriptionExpirationTimestamp > NSDate().timeIntervalSince1970 || Utility.sharedInstance.currentUserProfile!.likeLimitLifted.timeIntervalSince1970 < NSDate().timeIntervalSince1970){ return true } return false } }